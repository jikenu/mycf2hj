const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":758,\"nextId\":758,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"1#pages\",\"3\":\"1#content\",\"4\":\"1#configuration\",\"5\":\"1#layouts-and-customization\",\"6\":\"2\",\"7\":\"3\",\"8\":\"3#_1-计算机网络的各层协议及作用\",\"9\":\"3#_2-tcp和udp的区别\",\"10\":\"3#_3-udp-和-tcp-对应的应用场景是什么\",\"11\":\"3#_4-详细介绍一下-tcp-的三次握手机制\",\"12\":\"3#_5-为什么需要三次握手-而不是两次\",\"13\":\"3#_6-为什么要三次握手-而不是四次\",\"14\":\"3#_7-什么是-syn洪泛攻击-如何防范\",\"15\":\"3#_8-三次握手连接阶段-最后一次ack包丢失-会发生什么\",\"16\":\"3#_9-详细介绍一下-tcp-的四次挥手过程\",\"17\":\"3#_10-为什么连接的时候是三次握手-关闭的时候却是四次握手\",\"18\":\"3#_11-为什么客户端的-time-wait-状态必须等待-2msl\",\"19\":\"3#_12-如果已经建立了连接-但是客户端出现故障了怎么办\",\"20\":\"3#_13-time-wait-状态过多会产生什么后果-怎样处理\",\"21\":\"3#_14-time-wait-是服务器端的状态-还是客户端的状态\",\"22\":\"3#_15-tcp协议如何保证可靠性\",\"23\":\"3#_16-详细讲一下tcp的滑动窗口\",\"24\":\"3#_17-详细讲一下拥塞控制\",\"25\":\"3#巨人的肩膀\",\"26\":\"4\",\"27\":\"4#_1-http常见的状态码有哪些\",\"28\":\"4#_2-状态码301和302的区别是什么\",\"29\":\"4#_3-http-常用的请求方式\",\"30\":\"4#_4-get请求和post请求的区别\",\"31\":\"4#_5-解释一下http长连接和短连接\",\"32\":\"4#_6-http请求报文和响应报文的格式\",\"33\":\"4#_7-http1-0和http1-1的区别\",\"34\":\"4#_8-http1-1和-http2-0的区别\",\"35\":\"4#_9-http-与-https-的区别\",\"36\":\"4#_10-https-的优缺点\",\"37\":\"4#_11-讲一讲https-的原理\",\"38\":\"4#_12-在浏览器中输入www-baidu-com后执行的全部过程\",\"39\":\"4#_13-什么是-cookie-和-session\",\"40\":\"4#_14-cookie-和-session-是如何配合的呢\",\"41\":\"4#_15-cookie和session的区别\",\"42\":\"4#_16-如何考虑分布式-session-问题\",\"43\":\"4#_17-什么是ddos攻击\",\"44\":\"4#_18-什么是xss攻击\",\"45\":\"4#_19-sql注入是什么-如何避免sql注入\",\"46\":\"4#_20-负载均衡算法有哪些\",\"47\":\"4#end\",\"48\":\"4#巨人的肩膀\",\"49\":\"5\",\"50\":\"6\",\"51\":\"7\",\"52\":\"8\",\"53\":\"9\",\"54\":\"10\",\"55\":\"10#发布于-2024-04-02\",\"56\":\"10#一键生成免费订阅链接-订阅动态更新-自动添加优选域名和优选ip-cf-cdn-免费节点-任意一个节点-可通过此方法-生产订阅链接。。。视频教程\",\"57\":\"10#_1-搭建workers订阅节点\",\"58\":\"10#_2-订阅器部署\",\"59\":\"10#发布于-2023-07-21\",\"60\":\"10#win\",\"61\":\"10#代理ips\",\"62\":\"10#ip优选下载为0-可以直接使用下方域名-去-站长-或-itdog\",\"63\":\"10#发布于-2023-8-05\",\"64\":\"10#win-电脑解决方案\",\"65\":\"10#问题2解决方案\",\"66\":\"10#问题3解决方案\",\"67\":\"10#问题4解决方案\",\"68\":\"10#问题5解决方案\",\"69\":\"11\",\"70\":\"12\",\"71\":\"13\",\"72\":\"14\",\"73\":\"14#_1-mysql中myisam与innodb的区别\",\"74\":\"14#_2-事务的特性\",\"75\":\"14#_3-并发操作问题\",\"76\":\"14#_4-事务的隔离级别\",\"77\":\"14#_5-索引是什么\",\"78\":\"14#_6-索引能干什么-有什么好处\",\"79\":\"14#_7-索引的种类有哪些\",\"80\":\"14#_8-为什么-mysql-的索引要使用-b-树而不是其它树形结构-比如-b-树\",\"81\":\"14#_9-myisam和innodb实现btree索引方式的区别\",\"82\":\"14#myisam\",\"83\":\"14#innodb\",\"84\":\"14#_10-什么是最左匹配原则\",\"85\":\"14#_11-哪些列上适合创建索引-创建索引有哪些开销\",\"86\":\"14#_12-索引这么多优点-为什么不对表中的每一个列创建一个索引呢\",\"87\":\"14#_13-mysql建表的约束条件有哪些\",\"88\":\"14#_14-mysql执行查询的过程\",\"89\":\"14#_15-mysql的binlog有有几种录入格式-分别有什么区别\",\"90\":\"15\",\"91\":\"15#_1-数据库的三范式是什么\",\"92\":\"15#_2-mysql-支持哪些存储引擎\",\"93\":\"15#_3-超键、候选键、主键、外键分别是什么\",\"94\":\"15#_4-sql-约束有哪几种\",\"95\":\"15#_5-mysql-中的-varchar-和-char-有什么区别\",\"96\":\"15#_6-mysql中-in-和-exists-区别\",\"97\":\"15#_7-drop、delete与truncate的区别\",\"98\":\"15#_8-什么是存储过程-有哪些优缺点\",\"99\":\"15#_9-mysql-执行查询的过程\",\"100\":\"15#_1-什么是数据库事务\",\"101\":\"15#_2-介绍一下事务具有的四个特征\",\"102\":\"15#_3-说一下mysql-的四种隔离级别\",\"103\":\"15#_4-什么是脏读-幻读-不可重复读\",\"104\":\"15#_5-事务的实现原理\",\"105\":\"15#_6-mysql事务日志介绍下\",\"106\":\"15#redo-log\",\"107\":\"15#undo-log\",\"108\":\"15#_7-什么是mysql的-binlog\",\"109\":\"15#_8-在事务中可以混合使用存储引擎吗\",\"110\":\"15#_9-mysql中是如何实现事务隔离的\",\"111\":\"15#_10-什么是-mvcc\",\"112\":\"15#_11-mvcc-的实现原理\",\"113\":\"15#_1-为什么要加锁\",\"114\":\"15#_2-按照锁的粒度分数据库锁有哪些\",\"115\":\"15#_3-从锁的类别上分mysql都有哪些锁呢\",\"116\":\"15#_4-数据库的乐观锁和悲观锁是什么-怎么实现的\",\"117\":\"15#_5-innodb引擎的行锁是怎么实现的\",\"118\":\"15#_6-什么是死锁-怎么解决\",\"119\":\"15#_7-隔离级别与锁的关系\",\"120\":\"15#_8-优化锁方面的意见\",\"121\":\"15#_1-为什么要分库分表\",\"122\":\"15#_2-用过哪些分库分表中间件-不同的分库分表中间件都有什么优点和缺点\",\"123\":\"15#cobar\",\"124\":\"15#tddl\",\"125\":\"15#atlas\",\"126\":\"15#sharding-jdbc\",\"127\":\"15#mycat\",\"128\":\"15#_3-如何对数据库如何进行垂直拆分或水平拆分的\",\"129\":\"15#_1-什么是mysql主从同步\",\"130\":\"15#_2-mysql主从同步的目的-为什么要做主从同步\",\"131\":\"15#_3-如何实现mysql的读写分离\",\"132\":\"15#_4-mysql主从复制流程和原理\",\"133\":\"15#_5-mysql主从同步延时问题如何解决\",\"134\":\"15#_1-如何定位及优化sql语句的性能问题\",\"135\":\"15#_2-大表数据查询-怎么优化\",\"136\":\"15#_3-超大分页怎么处理\",\"137\":\"15#_4-统计过慢查询吗-对慢查询都怎么优化过\",\"138\":\"15#_5-如何优化查询过程中的数据访问\",\"139\":\"15#_6-如何优化关联查询\",\"140\":\"15#_7-数据库结构优化\",\"141\":\"15#_8-mysql数据库cpu飙升到500-的话他怎么处理\",\"142\":\"15#_9-大表怎么优化\",\"143\":\"15#参考\",\"144\":\"15#mysql\",\"145\":\"16\",\"146\":\"16#_1-索引是什么\",\"147\":\"16#_2-索引有哪些优缺点\",\"148\":\"16#_3-mysql有哪几种索引类型\",\"149\":\"16#_4-说一说索引的底层实现\",\"150\":\"16#_5-为什么索引结构默认使用b-tree-而不是b-tree-hash-二叉树-红黑树\",\"151\":\"16#_6-讲一讲聚簇索引与非聚簇索引\",\"152\":\"16#_7-非聚簇索引一定会回表查询吗\",\"153\":\"16#_8-联合索引是什么-为什么需要注意联合索引中的顺序\",\"154\":\"16#_9-讲一讲mysql的最左前缀原则\",\"155\":\"16#_10-讲一讲前缀索引\",\"156\":\"16#_11-了解索引下推吗\",\"157\":\"16#_12-怎么查看mysql语句有没有用到索引\",\"158\":\"16#_13-为什么官方建议使用自增长主键作为索引\",\"159\":\"16#_14-如何创建索引\",\"160\":\"16#_15-创建索引时需要注意什么\",\"161\":\"16#_16-建索引的原则有哪些\",\"162\":\"16#_17-使用索引查询一定能提高查询的性能吗\",\"163\":\"16#_18-什么情况下不走索引-索引失效\",\"164\":\"16#_1、使用-或者-导致索引失效\",\"165\":\"16#_2、类型不一致导致的索引失效\",\"166\":\"16#_3、函数导致的索引失效\",\"167\":\"16#_4、运算符导致的索引失效\",\"168\":\"16#_5、or引起的索引失效\",\"169\":\"16#_6、模糊搜索导致的索引失效\",\"170\":\"16#_7、not-in、not-exists导致索引失效\",\"171\":\"17\",\"172\":\"17#_1-mybatis是什么\",\"173\":\"17#_2-mybaits的优缺点\",\"174\":\"17#_3-为什么说mybatis是半自动orm映射工具-它与全自动的区别在哪里\",\"175\":\"17#_4-hibernate-和-mybatis-的区别\",\"176\":\"17#_5-jdbc编程有哪些不足之处-mybatis是如何解决这些问题的\",\"177\":\"17#_6-mybatis编程步骤是什么样的\",\"178\":\"17#_7-mybatis与hibernate有哪些不同\",\"179\":\"17#_8-mybaits-的优点\",\"180\":\"17#_9-mybatis-框架的缺点\",\"181\":\"17#_10-和-的区别\",\"182\":\"17#_11-通常一个xml映射文件-都会写一个dao接口与之对应-那么这个dao接口的工作原理是什么-dao接口里的方法、参数不同时-方法能重载吗\",\"183\":\"17#_12-在mapper中如何传递多个参数\",\"184\":\"17#_13-mybatis动态sql有什么用-执行原理是什么-有哪些动态sql\",\"185\":\"17#_14-xml映射文件中-不同的xml映射文件id是否可以重复\",\"186\":\"17#_15-mybatis实现一对一有几种方式-具体是怎么操作的\",\"187\":\"17#_16-mybatis实现一对多有几种方式-具体是怎么操作的\",\"188\":\"17#_17-mybatis的一级、二级缓存\",\"189\":\"17#_18-使用mybatis的mapper接口调用时有哪些要求\",\"190\":\"17#_19-mybatis动态sql是做什么的-都有哪些动态sql\",\"191\":\"17#_20-mybatis的xml映射文件中-不同的xml映射文件-id是否可以重复\",\"192\":\"18\",\"193\":\"18#main\",\"194\":\"18#流程解析\",\"195\":\"18#sqlsessionfactorybuilder\",\"196\":\"18#sqlsessionfactory\",\"197\":\"18#sqlsession\",\"198\":\"18#executor\",\"199\":\"18#mapperstatement-实体类\",\"200\":\"18#mapper\",\"201\":\"18#statement\",\"202\":\"18#parameter\",\"203\":\"18#resultset\",\"204\":\"18#utils包下类\",\"205\":\"18#所需实体类及mapper接口、xml文件、配置文件\",\"206\":\"19\",\"207\":\"19#rpc的概念\",\"208\":\"19#背景知识\",\"209\":\"19#duboo基本功能\",\"210\":\"19#rpc过程\",\"211\":\"19#版本迭代过程\",\"212\":\"19#目录\",\"213\":\"19#_0-一个最简单的rpc调用\",\"214\":\"19#背景知识-1\",\"215\":\"19#本节问题\",\"216\":\"19#过程\",\"217\":\"19#结果\",\"218\":\"19#总结\",\"219\":\"19#此rpc的最大痛点\",\"220\":\"19#_1-myrpc版本1\",\"221\":\"19#背景知识-2\",\"222\":\"19#本节问题-1\",\"223\":\"19#版本升级过程\",\"224\":\"19#结果-1\",\"225\":\"19#总结-1\",\"226\":\"19#存在的痛点\",\"227\":\"19#_2-myrpc-版本2\",\"228\":\"19#背景知识-3\",\"229\":\"19#本节问题-2\",\"230\":\"19#版本升级过程-1\",\"231\":\"19#结果-2\",\"232\":\"19#总结-2\",\"233\":\"19#此rpc最大的痛点\",\"234\":\"19#_3-myrpc版本3\",\"235\":\"19#背景知识-4\",\"236\":\"19#本节问题-3\",\"237\":\"19#升级过程\",\"238\":\"19#结果-3\",\"239\":\"19#总结-3\",\"240\":\"19#此rpc最大痛点\",\"241\":\"19#_4-myrpc版本4\",\"242\":\"19#背景知识-5\",\"243\":\"19#本节问题-4\",\"244\":\"19#升级过程-1\",\"245\":\"19#结果-4\",\"246\":\"19#总结-4\",\"247\":\"19#此版本最大痛点\",\"248\":\"19#_5-myrpc版本5\",\"249\":\"19#背景知识-6\",\"250\":\"19#本节问题-5\",\"251\":\"19#升级过程-2\",\"252\":\"19#结果-5\",\"253\":\"19#总结-5\",\"254\":\"19#此版本最大痛点-1\",\"255\":\"19#_6-myrpc版本6\",\"256\":\"19#背景知识-7\",\"257\":\"19#本节问题-6\",\"258\":\"19#升级过程-3\",\"259\":\"19#结果-6\",\"260\":\"19#总结-6\",\"261\":\"19#此版本最大痛点-2\",\"262\":\"20\",\"263\":\"20#_1-使用spring框架的好处是什么\",\"264\":\"20#_2-什么是-spring-ioc-容器\",\"265\":\"20#_3-什么是依赖注入-可以通过多少种方式完成依赖注入\",\"266\":\"20#_4-区分-beanfactory-和-applicationcontext\",\"267\":\"20#_5-区分构造函数注入和-setter-注入\",\"268\":\"20#_6-spring-提供了哪些配置方式\",\"269\":\"20#_7-spring-中的-bean-的作用域有哪些\",\"270\":\"20#_8-如何理解ioc和di\",\"271\":\"20#_9-将一个类声明为spring的-bean-的注解有哪些\",\"272\":\"20#_10-spring-支持几种-bean-scope\",\"273\":\"20#_11-spring-中的-bean-生命周期\",\"274\":\"20#创建过程\",\"275\":\"20#销毁过程\",\"276\":\"20#总结\",\"277\":\"20#_12-什么是-spring-的内部-bean\",\"278\":\"20#_13-什么是-spring-装配\",\"279\":\"20#_14-自动装配有什么局限\",\"280\":\"20#_15-spring中出现同名bean怎么办\",\"281\":\"20#_16-spring-怎么解决循环依赖问题\",\"282\":\"20#_17-spring-中的单例-bean-的线程安全问题\",\"283\":\"20#_18-什么是-aop\",\"284\":\"20#_19-aop-有哪些实现方式\",\"285\":\"20#_20-spring-aop-and-aspectj-aop-有什么区别\",\"286\":\"20#_21-spring-框架中用到了哪些设计模式\",\"287\":\"20#_22-spring-事务实现方式有哪些\",\"288\":\"20#_23-spring框架的事务管理有哪些优点\",\"289\":\"20#_24-spring事务定义的传播规则\",\"290\":\"20#_25-springmvc-工作原理了解吗\",\"291\":\"20#_26-简单介绍-spring-mvc-的核心组件\",\"292\":\"20#_27-controller-注解有什么用\",\"293\":\"20#_28-requestmapping-注解有什么用\",\"294\":\"20#_29-restcontroller-和-controller-有什么区别\",\"295\":\"20#_30-requestmapping-和-getmapping-注解的不同之处在哪里\",\"296\":\"20#_31-requestparam-和-pathvariable-两个注解的区别\",\"297\":\"20#_32-返回-json-格式使用什么注解\",\"298\":\"20#_33-什么是springmvc拦截器以及如何使用它\",\"299\":\"20#_34-spring-mvc-和-struts2-的异同\",\"300\":\"20#_35-rest-代表着什么\",\"301\":\"20#_36-什么是安全的-rest-操作\",\"302\":\"20#_37-rest-api-是无状态的吗\",\"303\":\"20#_38-rest安全吗-你能做什么来保护它\",\"304\":\"20#_39-为什么要用springboot\",\"305\":\"20#_40-spring-boot中如何实现对不同环境的属性配置文件的支持\",\"306\":\"20#_41-spring-boot-的核心注解是哪个-它主要由哪几个注解组成的\",\"307\":\"20#_42-你如何理解-spring-boot-中的-starters\",\"308\":\"20#_43-spring-boot-starter-的工作原理是什么\",\"309\":\"20#_44-保护-spring-boot-应用有哪些方法\",\"310\":\"20#_45-spring-、spring-boot-和-spring-cloud-的关系\",\"311\":\"20#参考\",\"312\":\"21\",\"313\":\"21#比较类-commonutils\",\"314\":\"21#redis-序列化及配置类\",\"315\":\"21#mybatisplus-分页拦截器配置类\",\"316\":\"21#jwtutils-搭配interceptor-webconfiguration\",\"317\":\"21#myinterceptor-登录拦截配置\",\"318\":\"21#mywebconfiguration-web配置类\",\"319\":\"21#全局跨域配置-globalcorsconfig\",\"320\":\"22\",\"321\":\"22#_1-apache-kafka是什么\",\"322\":\"22#_2-kafka-的设计是什么样的\",\"323\":\"22#_3-kafka-如何保证高可用\",\"324\":\"22#_4-kafka-消息是采用-pull-模式-还是-push-模式\",\"325\":\"22#_5-kafka-与传统消息系统之间的区别\",\"326\":\"22#_6-什么是消费者组\",\"327\":\"22#_7-在kafka中-zookeeper的作用是什么\",\"328\":\"22#_8-解释下kafka中位移-offset-的作用\",\"329\":\"22#_9-kafka-为什么那么快\",\"330\":\"22#_10-kafka-producer发送数据-ack为0-1-1分别是什么意思\",\"331\":\"22#_11-kafka如何保证消息不丢失\",\"332\":\"22#消费者异常导致的消息丢失\",\"333\":\"22#生产者数据传输导致的消息丢失\",\"334\":\"22#kafka-导致的消息丢失\",\"335\":\"22#_13-kafka-如何保证消息的顺序性\",\"336\":\"22#如何保证消息在-kafka-中顺序性\",\"337\":\"22#如何保证消费者处理消费的顺序性\",\"338\":\"22#_14-kafka中的isr、ar代表什么-isr的伸缩指什么\",\"339\":\"22#_15-描述下-kafka-中的领导者副本-leader-replica-和追随者副本-follower-replica-的区别\",\"340\":\"22#_16-分区leader选举策略有几种\",\"341\":\"22#_17-kafka的哪些场景中使用了零拷贝-zero-copy\",\"342\":\"22#_18-为什么kafka不支持读写分离\",\"343\":\"22#参考\",\"344\":\"23\",\"345\":\"23#为什么使用mq\",\"346\":\"23#解耦\",\"347\":\"23#异步\",\"348\":\"23#削峰\",\"349\":\"23#消息队列的缺点\",\"350\":\"23#kafka、activemq、rabbitmq、rocketmq-有什么优缺点\",\"351\":\"23#_1-rabbitmq是什么\",\"352\":\"23#_2-rabbitmq特点\",\"353\":\"23#_3-amqp是什么\",\"354\":\"23#_4-amqp的3层协议\",\"355\":\"23#_5-说说broker服务节点、queue队列、exchange交换器\",\"356\":\"23#_6-如何保证消息的可靠性\",\"357\":\"23#_7-生产者消息运转的流程\",\"358\":\"23#_8-消费者接收消息过程\",\"359\":\"23#_9-生产者如何将消息可靠投递到rabbitmq\",\"360\":\"23#_10-rabbitmq如何将消息可靠投递到消费者\",\"361\":\"23#_11-如何保证rabbitmq消息队列的高可用\",\"362\":\"23#_1-rocketmq是什么\",\"363\":\"23#_2-rocketmq由哪些角色组成-每个角色作用和特点是什么\",\"364\":\"23#_3-rocketmq消费模式有几种\",\"365\":\"23#_4-rocketmq消费消息是push还是pull\",\"366\":\"23#追问-为什么要主动拉取消息而不使用事件监听方式\",\"367\":\"23#_5-broker如何处理拉取请求的\",\"368\":\"23#_6-如何让rocketmq保证消息的顺序消费\",\"369\":\"23#_7-rocketmq如何保证消息不丢失\",\"370\":\"23#_7-rocketmq的消息堆积如何处理\",\"371\":\"23#追问-如果consumer和queue不对等-上线了多台也在短时间内无法消费完堆积的消息怎么办\",\"372\":\"23#追问-堆积时间过长消息超时了\",\"373\":\"23#追问-堆积的消息会不会进死信队列\",\"374\":\"23#_8-rocketmq为什么自研nameserver而不用zk\",\"375\":\"24\",\"376\":\"24#_1-redis是什么-简述它的优缺点\",\"377\":\"24#_2-redis为什么这么快\",\"378\":\"24#_3-redis相比memcached有哪些优势\",\"379\":\"24#_4-为什么要用-redis-做缓存\",\"380\":\"24#_5-为什么要用-redis-而不用-map-guava-做缓存\",\"381\":\"24#_6-redis的常用场景有哪些\",\"382\":\"24#_7-redis的数据类型有哪些\",\"383\":\"24#_8-redis持久化机制\",\"384\":\"24#_9-如何选择合适的持久化方式\",\"385\":\"24#_10-redis持久化数据和缓存怎么做扩容\",\"386\":\"24#_11-redis过期键的删除策略\",\"387\":\"24#_12-redis-key的过期时间和永久有效分别怎么设置\",\"388\":\"24#_13-redis内存淘汰策略\",\"389\":\"24#_14-如何保证缓存与数据库双写时的数据一致性\",\"390\":\"24#_15-先删除缓存-后更新数据库\",\"391\":\"24#答案一-延时双删\",\"392\":\"24#答案二-更新与读取操作进行异步串行化\",\"393\":\"24#_16-先更新数据库-后删除缓存\",\"394\":\"24#_17-什么是缓存击穿\",\"395\":\"24#_18-什么是缓存穿透\",\"396\":\"24#_19-什么是缓存雪崩\",\"397\":\"24#_20-什么是缓存预热\",\"398\":\"24#_21-什么是缓存降级\",\"399\":\"24#_22-redis为何选择单线程\",\"400\":\"24#_23-redis真的是单线程\",\"401\":\"24#_24-redis-6-0为何引入多线程\",\"402\":\"24#_25-redis-6-0-采用多线程后-性能的提升效果如何\",\"403\":\"24#_26-介绍下redis的线程模型\",\"404\":\"24#_27-redis-6-0-多线程的实现机制\",\"405\":\"24#_28-redis-6-0开启多线程后-是否会存在线程并发安全问题\",\"406\":\"24#_29-redis-6-0-与-memcached-多线程模型的对比\",\"407\":\"24#_30-redis事务的概念\",\"408\":\"24#_31-redis事务的三个阶段\",\"409\":\"24#_32-redis事务相关命令\",\"410\":\"24#_33-redis事务支持隔离性吗\",\"411\":\"24#_34-redis为什么不支持事务回滚\",\"412\":\"24#_35-redis事务其他实现\",\"413\":\"24#_36-redis常见使用方式有哪些\",\"414\":\"24#_37-介绍下redis单副本\",\"415\":\"24#_38-介绍下redis多副本-主从\",\"416\":\"24#_39-介绍下redis-sentinel-哨兵\",\"417\":\"24#_40-介绍下redis-cluster\",\"418\":\"24#_41-介绍下redis自研\",\"419\":\"24#_42-redis高可用方案具体怎么实施\",\"420\":\"24#_43-了解主从复制的原理吗\",\"421\":\"24#_44-由于主从延迟导致读取到过期数据怎么处理\",\"422\":\"24#_45-主从复制的过程中如果因为网络原因停止复制了会怎么样\",\"423\":\"24#_46-redis主从架构数据会丢失吗-为什么\",\"424\":\"24#_47-如何解决主从架构数据丢失的问题\",\"425\":\"24#_48-redis哨兵是怎么工作的\",\"426\":\"24#_49-故障转移时会从剩下的slave选举一个新的master-被选举为master的标准是什么\",\"427\":\"24#_50-同步配置的时候其他哨兵根据什么更新自己的配置呢\",\"428\":\"24#_51-为什么redis哨兵集群只有2个节点无法正常工作\",\"429\":\"24#_52-redis-cluster中是如何实现数据分布的-这种方式有什么优点\",\"430\":\"24#_53-redis-cluster节点间通信是什么机制\",\"431\":\"24#_54-什么是分布式锁-为什么用分布式锁\",\"432\":\"24#_55-常见的分布式锁有哪些解决方案\",\"433\":\"24#_56-redis实现分布式锁\",\"434\":\"24#分布式锁的三个核心要素\",\"435\":\"24#上述分布式锁存在的问题\",\"436\":\"24#_57-了解redlock吗\",\"437\":\"24#_58-redlock的原理\",\"438\":\"24#_59-redis如何做内存优化\",\"439\":\"24#_60-如果现在有个读超高并发的系统-用redis来抗住大部分读请求-你会怎么设计\",\"440\":\"25\",\"441\":\"25#java概述\",\"442\":\"25#java语言有哪些特点\",\"443\":\"25#java和c-有什么关系-它们有什么区别\",\"444\":\"25#jvm、jre和jdk的关系是什么\",\"445\":\"25#什么是字节码\",\"446\":\"25#采用字节码的好处是什么\",\"447\":\"25#oracle-jdk-和-openjdk-的区别是什么\",\"448\":\"25#基础语法\",\"449\":\"25#java有哪些数据类型\",\"450\":\"25#switch-是否能作用在-byte-上-是否能作用在-long-上-是否能作用在-string-上\",\"451\":\"25#访问修饰符public、private、protected、以及不写-默认-时的区别\",\"452\":\"25#break-continue-return-的区别及作用\",\"453\":\"25#关键字\",\"454\":\"25#final、finally、finalize的区别\",\"455\":\"25#为什么要用static关键字\",\"456\":\"25#static-关键字是什么意思-java中是否可以覆盖-override-一个private或者是static的方法\",\"457\":\"25#是否可以在static环境中访问非static变量\",\"458\":\"25#static静态方法能不能引用非静态资源\",\"459\":\"25#static静态方法里面能不能引用静态资源\",\"460\":\"25#非静态方法里面能不能引用静态资源\",\"461\":\"25#java静态变量、代码块、和静态方法的执行顺序是什么\",\"462\":\"25#面向对象\",\"463\":\"25#面向对象和面向过程的区别\",\"464\":\"25#讲讲面向对象三大特性\",\"465\":\"25#java语言是如何实现多态的\",\"466\":\"25#重载-overload-和重写-override-的区别是什么\",\"467\":\"25#重载的方法能否根据返回值类型进行区分\",\"468\":\"25#构造器-constructor-是否可被重写-override\",\"469\":\"25#抽象类和接口的区别是什么\",\"470\":\"25#抽象类能使用-final-修饰吗\",\"471\":\"25#java-创建对象有哪几种方式\",\"472\":\"25#什么是不可变对象-好处是什么\",\"473\":\"25#能否创建一个包含可变对象的不可变对象\",\"474\":\"25#值传递和引用传递的区别的什么-为什么说java中只有值传递\",\"475\":\"25#对象相等判断\",\"476\":\"25#和-equals-区别是什么\",\"477\":\"25#介绍下hashcode\",\"478\":\"25#为什么要有-hashcode\",\"479\":\"25#hashcode-equals-两种方法是什么关系\",\"480\":\"25#为什么重写-equals-方法必须重写-hashcode-方法\",\"481\":\"25#string-stringbuffer-stringbuilder-的区别是什么\",\"482\":\"25#string为什么要设计成不可变的\",\"483\":\"25#参考\",\"484\":\"26\",\"485\":\"26#string相关\",\"486\":\"26#字符型常量和字符串常量的区别\",\"487\":\"26#什么是字符串常量池\",\"488\":\"26#string-str-aaa-与-string-str-new-string-aaa-一样吗-new-string-aaa-创建了几个字符串对象\",\"489\":\"26#string-是最基本的数据类型吗\",\"490\":\"26#string有哪些特性\",\"491\":\"26#在使用-hashmap-的时候-用-string-做-key-有什么好处\",\"492\":\"26#包装类型\",\"493\":\"26#包装类型是什么-基本类型和包装类型有什么区别\",\"494\":\"26#解释一下自动装箱和自动拆箱\",\"495\":\"26#int-和-integer-有什么区别\",\"496\":\"26#两个new生成的integer变量的对比\",\"497\":\"26#integer变量和int变量的对比\",\"498\":\"26#非new生成的integer变量和new-integer-生成变量的对比\",\"499\":\"26#两个非new生成的integer对象的对比\",\"500\":\"26#反射\",\"501\":\"26#什么是反射\",\"502\":\"26#反射机制的优缺点有哪些\",\"503\":\"26#如何获取反射中的class对象\",\"504\":\"26#java反射api有几类\",\"505\":\"26#反射使用的步骤\",\"506\":\"26#为什么引入反射概念-反射机制的应用有哪些\",\"507\":\"26#反射机制的原理是什么\",\"508\":\"26#泛型\",\"509\":\"26#java中的泛型是什么\",\"510\":\"26#使用泛型的好处是什么\",\"511\":\"26#java泛型的原理是什么-什么是类型擦除\",\"512\":\"26#什么是泛型中的限定通配符和非限定通配符\",\"513\":\"26#list-extends-t-和list-super-t-之间有什么区别\",\"514\":\"26#可以把list-string-传递给一个接受list-object-参数的方法吗\",\"515\":\"26#array中可以用泛型吗\",\"516\":\"26#判断arraylist-string-与arraylist-integer-是否相等\",\"517\":\"26#序列化\",\"518\":\"26#java序列化与反序列化是什么\",\"519\":\"26#为什么需要序列化与反序列化\",\"520\":\"26#序列化实现的方式有哪些\",\"521\":\"26#serializable接口\",\"522\":\"26#externalizable接口\",\"523\":\"26#两种序列化的对比\",\"524\":\"26#什么是serialversionuid\",\"525\":\"26#为什么还要显示指定serialversionuid的值\",\"526\":\"26#serialversionuid什么时候修改\",\"527\":\"26#java-序列化中如果有些字段不想进行序列化-怎么办\",\"528\":\"26#静态变量会被序列化吗\",\"529\":\"26#异常\",\"530\":\"26#error-和-exception-区别是什么\",\"531\":\"26#非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么\",\"532\":\"26#throw-和-throws-的区别是什么\",\"533\":\"26#noclassdeffounderror-和-classnotfoundexception-区别\",\"534\":\"26#java常见异常有哪些\",\"535\":\"26#try-catch-finally-中哪个部分可以省略\",\"536\":\"26#try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗\",\"537\":\"26#jvm-是如何处理异常的\",\"538\":\"26#io\",\"539\":\"26#java的io-流分为几种\",\"540\":\"26#字节流如何转为字符流\",\"541\":\"26#字符流与字节流的区别\",\"542\":\"26#bio、nio、aio的区别\",\"543\":\"26#java-io都有哪些设计模式\",\"544\":\"26#参考\",\"545\":\"27\",\"546\":\"27#实现原理\",\"547\":\"27#存取\",\"548\":\"27#其他\",\"549\":\"27#jdk1-7-与-jdk1-8-中concurrenthashmap-的区别-★★★★★\",\"550\":\"27#最后\",\"551\":\"27#巨人的肩膀\",\"552\":\"28\",\"553\":\"28#_1-存储结构\",\"554\":\"28#字段结构\",\"555\":\"28#_2-索引计算\",\"556\":\"28#_3-put方法\",\"557\":\"28#扩展的问题\",\"558\":\"28#_4-扩容机制\",\"559\":\"28#jdk1-8的优化\",\"560\":\"28#_5-其他\",\"561\":\"28#最后\",\"562\":\"28#参考\",\"563\":\"29\",\"564\":\"29#多线程下扩容死循环\",\"565\":\"29#多线程的put可能导致元素的丢失\",\"566\":\"29#put和get并发时-可能导致get为null\",\"567\":\"29#巨人的肩膀\",\"568\":\"30\",\"569\":\"30#_1-常见的集合有哪些\",\"570\":\"30#_2-线程安全的集合有哪些-线程不安全的呢\",\"571\":\"30#_3-arraylist与-linkedlist-异同点\",\"572\":\"30#_4-arraylist-与-vector-区别\",\"573\":\"30#_5-说一说arraylist-的扩容机制\",\"574\":\"30#_6-array-和-arraylist-有什么区别-什么时候该应-array-而不是-arraylist-呢\",\"575\":\"30#_7-hashmap的底层数据结构是什么\",\"576\":\"30#_8-解决hash冲突的办法有哪些-hashmap用的哪种\",\"577\":\"30#_9-为什么在解决-hash-冲突的时候-不直接用红黑树-而选择先用链表-再转红黑树\",\"578\":\"30#_10-hashmap默认加载因子是多少-为什么是-0-75-不是-0-6-或者-0-8\",\"579\":\"30#_11-hashmap-中-key-的存储索引是怎么计算的\",\"580\":\"30#_12-hashmap-的put方法流程\",\"581\":\"30#_13-hashmap-的扩容方式\",\"582\":\"30#_14-一般用什么作为hashmap的key\",\"583\":\"30#_15-hashmap为什么线程不安全\",\"584\":\"30#_16-concurrenthashmap-的实现原理是什么\",\"585\":\"30#_17-concurrenthashmap-的-put-方法执行逻辑是什么\",\"586\":\"30#_18-concurrenthashmap-的-get-方法是否要加锁-为什么\",\"587\":\"30#_19-get方法不需要加锁与volatile修饰的哈希桶有关吗\",\"588\":\"30#_20-concurrenthashmap-不支持-key-或者-value-为-null-的原因\",\"589\":\"30#_21-concurrenthashmap-的并发度是多少\",\"590\":\"30#_22-concurrenthashmap-迭代器是强一致性还是弱一致性\",\"591\":\"30#_23-jdk1-7与jdk1-8-中concurrenthashmap-的区别\",\"592\":\"30#_24-concurrenthashmap-和hashtable的效率哪个更高-为什么\",\"593\":\"30#_25-说一下hashtable的锁机制\",\"594\":\"30#_26-多线程下安全的操作-map还有其他方法吗\",\"595\":\"30#_27-hashset-和-hashmap-区别\",\"596\":\"30#_28-collection框架中实现比较要怎么做\",\"597\":\"30#_29-iterator-和-listiterator-有什么区别\",\"598\":\"30#_30-讲一讲快速失败-fail-fast-和安全失败-fail-safe\",\"599\":\"30#巨人的肩膀\",\"600\":\"31\",\"601\":\"31#简介\",\"602\":\"31#原理\",\"603\":\"31#_1-aqs数据结构\",\"604\":\"31#_2-同步状态state\",\"605\":\"31#_3-线程加入等待队列\",\"606\":\"31#加入队列的时机\",\"607\":\"31#如-何加入队列\",\"608\":\"31#_4-等待队列中线程出队列时机\",\"609\":\"31#代码设计\",\"610\":\"31#独占式同步状态获取\",\"611\":\"31#独占式同步状态释放\",\"612\":\"31#共享式同步状态获取\",\"613\":\"31#共享式同步状态释放\",\"614\":\"31#疑问\",\"615\":\"31#reentrantlock\",\"616\":\"31#非公平锁\",\"617\":\"31#公平锁\",\"618\":\"31#参考\",\"619\":\"32\",\"620\":\"32#_1-线程和进程有什么区别\",\"621\":\"32#_2-创建线程的三种方式的对比\",\"622\":\"32#_3-为什么要使用多线程呢\",\"623\":\"32#_4-线程的状态流转\",\"624\":\"32#_5-什么是线程死锁-如何避免死锁\",\"625\":\"32#死锁\",\"626\":\"32#死锁必须具备以下四个条件\",\"627\":\"32#如何避免线程死锁\",\"628\":\"32#_6-常见的对比\",\"629\":\"32#runnable-vs-callable\",\"630\":\"32#shutdown-vs-shutdownnow\",\"631\":\"32#isterminated-vs-isshutdown\",\"632\":\"32#_7-sleep-方法和-wait-方法区别和共同点\",\"633\":\"32#区别\",\"634\":\"32#相同\",\"635\":\"32#_8-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法\",\"636\":\"32#_9-thread类中的yield方法有什么作用\",\"637\":\"32#_10-谈谈volatile的使用及其原理\",\"638\":\"32#_11-如何创建线程实例并运行\",\"639\":\"32#_12-线程阻塞的三种情况\",\"640\":\"32#_13-线程死亡的三种方式\",\"641\":\"32#_14-为什么我们调用start-方法时会执行run-方法-为什么我们不能直接调用run-方法\",\"642\":\"32#_15-守护线程是什么\",\"643\":\"32#_16-了解fork-join框架吗\",\"644\":\"32#_17-cas了解吗\",\"645\":\"32#_18-cas有什么缺陷\",\"646\":\"32#_19-synchronized-和-volatile-的区别是什么\",\"647\":\"32#_20-synchronized-和-lock-有什么区别\",\"648\":\"32#_21-synchronized-和-reentrantlock-区别是什么\",\"649\":\"32#_22-synchronized的用法有哪些\",\"650\":\"32#_23-synchronized的作用有哪些\",\"651\":\"32#_24-说一下-synchronized-底层实现原理\",\"652\":\"32#_25-多线程中-synchronized-锁升级的原理是什么\",\"653\":\"32#_26-synchronized-为什么是非公平锁-非公平体现在哪些地方\",\"654\":\"32#_27-jvm对synchronized的优化有哪些\",\"655\":\"32#_1-锁膨胀\",\"656\":\"32#偏向锁\",\"657\":\"32#轻量级锁\",\"658\":\"32#重量级锁\",\"659\":\"32#_2-锁消除\",\"660\":\"32#_3-锁粗化\",\"661\":\"32#_4-自旋锁与自适应自旋锁\",\"662\":\"32#_28-synchronized-锁能降级吗\",\"663\":\"32#_29-threadlocal是什么\",\"664\":\"32#_30-threadlocal的实现原理\",\"665\":\"32#_31-知道threadlocal-内存泄露问题吗\",\"666\":\"32#_32-了解reentrantlock吗\",\"667\":\"32#_33-readwritelock是什么\",\"668\":\"32#_1-为什么要用线程池\",\"669\":\"32#_2-执行execute-方法和submit-方法的区别是什么呢\",\"670\":\"32#_3-你说下线程池核心参数\",\"671\":\"32#_4-线程池执行任务的流程\",\"672\":\"32#_5-常用的java线程池有哪几种类型\",\"673\":\"32#_6-线程池常用的阻塞队列有哪些\",\"674\":\"32#_7-源码中线程池是怎么复用线程的\",\"675\":\"32#_8-如何合理配置线程池参数\",\"676\":\"32#_9-executor和executors的区别\",\"677\":\"32#_1-说一说什么是aqs\",\"678\":\"32#_2-aqs使用了哪些设计模式\",\"679\":\"32#_3-了解aqs中同步队列的数据结构吗\",\"680\":\"32#_4-了解aqs-对资源的共享方式吗\",\"681\":\"32#_5-aqs-组件了解吗\",\"682\":\"32#_1-介绍一下-atomic-原子类\",\"683\":\"32#_2-juc-包中的原子类是哪4类\",\"684\":\"32#_3-简单介绍一下-atomicinteger-类的原理\",\"685\":\"32#参考\",\"686\":\"33\",\"687\":\"33#_1-线程和进程有什么区别\",\"688\":\"33#_2-创建线程的三种方式的对比\",\"689\":\"33#_3-为什么要使用多线程呢\",\"690\":\"33#_4-线程的状态流转\",\"691\":\"33#_5-什么是线程死锁-如何避免死锁\",\"692\":\"33#死锁\",\"693\":\"33#死锁必须具备以下四个条件\",\"694\":\"33#如何避免线程死锁\",\"695\":\"33#_6-常见的对比\",\"696\":\"33#runnable-vs-callable\",\"697\":\"33#execute-vs-submit\",\"698\":\"33#shutdown-vsshutdownnow\",\"699\":\"33#isterminated-vs-isshutdown\",\"700\":\"33#_7-sleep-方法和-wait-方法区别和共同点\",\"701\":\"33#区别\",\"702\":\"33#相同\",\"703\":\"33#_8-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法\",\"704\":\"33#_9-threadlocal是什么-有什么用\",\"705\":\"33#_10-thread类中的yield方法有什么作用\",\"706\":\"33#_11-java中的fork-join框架是什么\",\"707\":\"33#_12-synchronized和reentrantlock-的区别\",\"708\":\"33#_13-谈谈volatile的使用及其原理\",\"709\":\"33#_14-synchronized-关键字和-volatile-关键字的区别\",\"710\":\"34\",\"711\":\"34#_2-1-总体设计\",\"712\":\"34#_2-2-生命周期管理\",\"713\":\"34#_2-3-任务执行机制\",\"714\":\"34#_2-4-worker线程管理\",\"715\":\"34#线程池参数设置\",\"716\":\"34#_1-常规设置\",\"717\":\"34#cpu-密集型任务\",\"718\":\"34#io-密集型任务\",\"719\":\"34#_2-线程池参数动态化\",\"720\":\"34#_3-2-1-整体设计\",\"721\":\"34#_3-2-2-参数动态化\",\"722\":\"34#面试题\",\"723\":\"34#参考\",\"724\":\"35\",\"725\":\"35#管道\",\"726\":\"35#消息队列\",\"727\":\"35#共享内存\",\"728\":\"35#信号量\",\"729\":\"35#信号\",\"730\":\"35#socket\",\"731\":\"35#总结\",\"732\":\"35#_1-等待通知机制\",\"733\":\"35#_2-join-方法\",\"734\":\"35#_3-volatile-共享内存\",\"735\":\"35#_4-管道通信\",\"736\":\"35#_5-并发工具\",\"737\":\"35#参考\",\"738\":\"36\",\"739\":\"37\",\"740\":\"39\",\"741\":\"40\",\"742\":\"41\",\"743\":\"42\",\"744\":\"43\",\"745\":\"44\",\"746\":\"45\",\"747\":\"46\",\"748\":\"47\",\"749\":\"48\",\"750\":\"49\",\"751\":\"50\",\"752\":\"51\",\"753\":\"52\",\"754\":\"53\",\"755\":\"54\",\"756\":\"55\",\"757\":\"56\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[2,10],\"2\":[1,24],\"3\":[1,28],\"4\":[1,29],\"5\":[3,28],\"6\":[1],\"7\":[1,13],\"8\":[3,56],\"9\":[3,45],\"10\":[6,18],\"11\":[5,43],\"12\":[4,54],\"13\":[4,19],\"14\":[5,67],\"15\":[5,26],\"16\":[5,64],\"17\":[4,19],\"18\":[7,49],\"19\":[4,32],\"20\":[6,53],\"21\":[6,23],\"22\":[3,52],\"23\":[3,25],\"24\":[3,43],\"25\":[1,35],\"26\":[1,6],\"27\":[3,35],\"28\":[3,25],\"29\":[4,31],\"30\":[3,18],\"31\":[3,41],\"32\":[3,70],\"33\":[5,63],\"34\":[6,37],\"35\":[6,21],\"36\":[4,32],\"37\":[4,65],\"38\":[5,58],\"39\":[6,36],\"40\":[6,34],\"41\":[3,35],\"42\":[5,49],\"43\":[3,28],\"44\":[3,16],\"45\":[4,25],\"46\":[3,18],\"47\":[1,9],\"48\":[1,29],\"49\":[2,2],\"50\":[2,2],\"51\":[1],\"52\":[2,44],\"53\":[1,35],\"54\":[2,2],\"55\":[4,7],\"56\":[11],\"57\":[2,48],\"58\":[2,48],\"59\":[4,11],\"60\":[1,52],\"61\":[1,49],\"62\":[1,63],\"63\":[4,25],\"64\":[1,25],\"65\":[1,39],\"66\":[1,8],\"67\":[1,5],\"68\":[1,31],\"69\":[2,700],\"70\":[2,1257],\"71\":[2,613],\"72\":[2,2],\"73\":[3,10],\"74\":[2,30],\"75\":[2,22],\"76\":[2,31],\"77\":[3,7],\"78\":[4,5],\"79\":[3,30],\"80\":[9,39],\"81\":[2],\"82\":[1,12],\"83\":[1,26],\"84\":[3,68],\"85\":[4,6],\"86\":[4,12],\"87\":[2,21],\"88\":[3,23],\"89\":[4,26],\"90\":[5,10],\"91\":[3,10],\"92\":[4,43],\"93\":[6,17],\"94\":[4,19],\"95\":[8,25],\"96\":[6,27],\"97\":[3,3],\"98\":[4,37],\"99\":[3,36],\"100\":[3,17],\"101\":[2,31],\"102\":[3,71],\"103\":[5,38],\"104\":[2,20],\"105\":[3,15],\"106\":[2,18],\"107\":[2,13],\"108\":[4,52],\"109\":[1,14],\"110\":[3,19],\"111\":[4,8],\"112\":[3,93],\"113\":[3,6],\"114\":[3,58],\"115\":[3,27],\"116\":[4,34],\"117\":[3,19],\"118\":[4,17],\"119\":[2,17],\"120\":[3,36],\"121\":[3,39],\"122\":[4,10],\"123\":[1,16],\"124\":[1,15],\"125\":[1,12],\"126\":[2,32],\"127\":[1,17],\"128\":[3,52],\"129\":[3,14],\"130\":[4,22],\"131\":[3,8],\"132\":[3,46],\"133\":[3,32],\"134\":[3,15],\"135\":[3,25],\"136\":[3,62],\"137\":[4,23],\"138\":[2,27],\"139\":[2,6],\"140\":[2,32],\"141\":[4,51],\"142\":[3,28],\"143\":[1],\"144\":[1,23],\"145\":[2,3],\"146\":[3,27],\"147\":[3,20],\"148\":[3,40],\"149\":[3,53],\"150\":[8,49],\"151\":[3,41],\"152\":[3,23],\"153\":[4,31],\"154\":[3,31],\"155\":[3,30],\"156\":[3,49],\"157\":[3,115],\"158\":[3,18],\"159\":[3,54],\"160\":[3,19],\"161\":[3,72],\"162\":[3,25],\"163\":[4],\"164\":[6],\"165\":[2],\"166\":[2,15],\"167\":[2,12],\"168\":[2,16],\"169\":[2,11],\"170\":[4],\"171\":[2,3],\"172\":[3,33],\"173\":[2,32],\"174\":[4,9],\"175\":[5,69],\"176\":[4,27],\"177\":[3,13],\"178\":[3,42],\"179\":[4,50],\"180\":[4,12],\"181\":[4,39],\"182\":[8,19],\"183\":[3,16],\"184\":[5,14],\"185\":[4,15],\"186\":[4,9],\"187\":[4,10],\"188\":[3,30],\"189\":[3,13],\"190\":[4,9],\"191\":[5,18],\"192\":[1,4],\"193\":[1,55],\"194\":[1,78],\"195\":[1,43],\"196\":[1,71],\"197\":[1,69],\"198\":[1,132],\"199\":[2,46],\"200\":[1,132],\"201\":[1,81],\"202\":[1,51],\"203\":[1,96],\"204\":[1,168],\"205\":[3,67],\"206\":[1,22],\"207\":[1],\"208\":[1,3],\"209\":[1,4],\"210\":[1,12],\"211\":[1],\"212\":[1,34],\"213\":[2],\"214\":[1,5],\"215\":[1,18],\"216\":[1,114],\"217\":[2],\"218\":[2,7],\"219\":[2,13],\"220\":[2],\"221\":[1,2],\"222\":[1,3],\"223\":[1,221],\"224\":[1],\"225\":[1,10],\"226\":[1,8],\"227\":[3],\"228\":[1,2],\"229\":[2,26],\"230\":[1,222],\"231\":[1,17],\"232\":[2,9],\"233\":[1,1],\"234\":[2],\"235\":[1,1],\"236\":[1,8],\"237\":[2,294],\"238\":[2],\"239\":[1,4],\"240\":[1,6],\"241\":[2],\"242\":[1,12],\"243\":[1,3],\"244\":[1,220],\"245\":[1,33],\"246\":[1,10],\"247\":[1,5],\"248\":[2],\"249\":[1,3],\"250\":[1,14],\"251\":[1,240],\"252\":[1,2],\"253\":[1,5],\"254\":[1,4],\"255\":[2,2],\"256\":[1,1],\"257\":[1,2],\"258\":[1,44],\"259\":[1,2],\"260\":[1,7],\"261\":[1,3],\"262\":[2],\"263\":[3,30],\"264\":[6,15],\"265\":[4,21],\"266\":[6,29],\"267\":[4,12],\"268\":[4,72],\"269\":[6,37],\"270\":[3,41],\"271\":[5,34],\"272\":[6,55],\"273\":[6,3],\"274\":[2,44],\"275\":[2,10],\"276\":[1,25],\"277\":[6,62],\"278\":[5,46],\"279\":[3,17],\"280\":[3,12],\"281\":[4,69],\"282\":[6,46],\"283\":[4,22],\"284\":[4,47],\"285\":[7,11],\"286\":[4,37],\"287\":[4,8],\"288\":[3,10],\"289\":[2,27],\"290\":[4,47],\"291\":[5,87],\"292\":[4,26],\"293\":[4,14],\"294\":[6,20],\"295\":[6,15],\"296\":[5,9],\"297\":[5,18],\"298\":[3,17],\"299\":[7,37],\"300\":[4,22],\"301\":[5,20],\"302\":[5,15],\"303\":[4,6],\"304\":[3,38],\"305\":[4,22],\"306\":[6,25],\"307\":[7,20],\"308\":[6,39],\"309\":[6,5],\"310\":[7,44],\"311\":[1,19],\"312\":[1,3],\"313\":[2,35],\"314\":[2,40],\"315\":[2,16],\"316\":[3,71],\"317\":[2,61],\"318\":[2,23],\"319\":[2,37],\"320\":[2],\"321\":[4,8],\"322\":[4,18],\"323\":[4,95],\"324\":[8,13],\"325\":[3,8],\"326\":[3,29],\"327\":[4,34],\"328\":[4,9],\"329\":[4,21],\"330\":[7,19],\"331\":[3,11],\"332\":[1,23],\"333\":[1,18],\"334\":[2,62],\"335\":[3,19],\"336\":[3,27],\"337\":[1,38],\"338\":[5,27],\"339\":[9,36],\"340\":[3,57],\"341\":[5,37],\"342\":[3,43],\"343\":[1,23],\"344\":[2],\"345\":[2,43],\"346\":[1,49],\"347\":[1,50],\"348\":[1,63],\"349\":[1,30],\"350\":[6,90],\"351\":[3,8],\"352\":[3,48],\"353\":[3,29],\"354\":[3,17],\"355\":[5,15],\"356\":[3,21],\"357\":[3,18],\"358\":[3,14],\"359\":[3,9],\"360\":[3,10],\"361\":[3,20],\"362\":[3,48],\"363\":[4,19],\"364\":[3,21],\"365\":[3,9],\"366\":[3,12],\"367\":[3,21],\"368\":[3,11],\"369\":[3,25],\"370\":[3,7],\"371\":[4,11],\"372\":[3,4],\"373\":[3,13],\"374\":[3,26],\"375\":[2],\"376\":[4,51],\"377\":[3,56],\"378\":[3,46],\"379\":[5,14],\"380\":[8,43],\"381\":[3,86],\"382\":[3,115],\"383\":[3,53],\"384\":[2,42],\"385\":[3,12],\"386\":[2,80],\"387\":[4,8],\"388\":[2,61],\"389\":[3,27],\"390\":[3,19],\"391\":[2,57],\"392\":[2,55],\"393\":[3,31],\"394\":[3,26],\"395\":[3,58],\"396\":[3,75],\"397\":[3,21],\"398\":[3,28],\"399\":[3,121],\"400\":[3,34],\"401\":[5,48],\"402\":[7,23],\"403\":[2,124],\"404\":[6,28],\"405\":[6,12],\"406\":[7,19],\"407\":[2,49],\"408\":[2,20],\"409\":[2,39],\"410\":[3,8],\"411\":[3,13],\"412\":[2,12],\"413\":[3,36],\"414\":[2,31],\"415\":[4,53],\"416\":[5,47],\"417\":[3,112],\"418\":[2,20],\"419\":[3,23],\"420\":[3,75],\"421\":[3,16],\"422\":[3,28],\"423\":[4,26],\"424\":[3,30],\"425\":[3,54],\"426\":[4,39],\"427\":[3,21],\"428\":[3,23],\"429\":[5,26],\"430\":[4,21],\"431\":[4,48],\"432\":[3,61],\"433\":[2],\"434\":[1,41],\"435\":[1,131],\"436\":[3,24],\"437\":[2,32],\"438\":[3,49],\"439\":[5,38],\"440\":[2,2],\"441\":[1],\"442\":[2,36],\"443\":[3,58],\"444\":[3,34],\"445\":[1,24],\"446\":[2,9],\"447\":[6,41],\"448\":[1],\"449\":[2,78],\"450\":[7,25],\"451\":[1,27],\"452\":[5,15],\"453\":[1],\"454\":[4,53],\"455\":[2,11],\"456\":[6,8],\"457\":[2,9],\"458\":[2,5],\"459\":[2,4],\"460\":[2,5],\"461\":[4,21],\"462\":[1],\"463\":[2,25],\"464\":[1,24],\"465\":[2,42],\"466\":[6,20],\"467\":[2,15],\"468\":[5,8],\"469\":[2,37],\"470\":[4,8],\"471\":[3,11],\"472\":[3,8],\"473\":[2,15],\"474\":[3,30],\"475\":[1],\"476\":[5,61],\"477\":[1,20],\"478\":[1,28],\"479\":[4,20],\"480\":[6,18],\"481\":[5,54],\"482\":[2,58],\"483\":[1,38],\"484\":[2,108],\"485\":[1],\"486\":[2,19],\"487\":[2,31],\"488\":[8,106],\"489\":[3,21],\"490\":[2,24],\"491\":[9,15],\"492\":[1],\"493\":[3,88],\"494\":[2,36],\"495\":[5,10],\"496\":[1,16],\"497\":[1,22],\"498\":[3,20],\"499\":[1,118],\"500\":[1],\"501\":[2,9],\"502\":[2,24],\"503\":[2,22],\"504\":[2,24],\"505\":[2,80],\"506\":[3,217],\"507\":[2,109],\"508\":[1],\"509\":[2,12],\"510\":[2,81],\"511\":[3,82],\"512\":[2,19],\"513\":[7,8],\"514\":[4,15],\"515\":[2,16],\"516\":[4,38],\"517\":[1],\"518\":[2,26],\"519\":[2,42],\"520\":[2,2],\"521\":[1,70],\"522\":[1,70],\"523\":[1,11],\"524\":[2,11],\"525\":[2,26],\"526\":[2,10],\"527\":[4,18],\"528\":[2,13],\"529\":[1],\"530\":[5,40],\"531\":[6,38],\"532\":[5,52],\"533\":[5,36],\"534\":[2,68],\"535\":[5,33],\"536\":[9,58],\"537\":[3,32],\"538\":[1],\"539\":[3,24],\"540\":[2,10],\"541\":[2,16],\"542\":[4,37],\"543\":[3,42],\"544\":[1,62],\"545\":[2,13],\"546\":[1,93],\"547\":[1,108],\"548\":[1,118],\"549\":[7,77],\"550\":[1,7],\"551\":[1,18],\"552\":[1,15],\"553\":[2,184],\"554\":[1,125],\"555\":[2,203],\"556\":[2,126],\"557\":[1,25],\"558\":[2,87],\"559\":[2,149],\"560\":[2,74],\"561\":[1,9],\"562\":[1,15],\"563\":[2,13],\"564\":[1,109],\"565\":[1,67],\"566\":[2,23],\"567\":[1,19],\"568\":[1,1],\"569\":[3,31],\"570\":[4,18],\"571\":[5,56],\"572\":[6,14],\"573\":[4,84],\"574\":[9,13],\"575\":[3,37],\"576\":[4,43],\"577\":[8,23],\"578\":[10,119],\"579\":[6,70],\"580\":[4,35],\"581\":[4,85],\"582\":[3,24],\"583\":[3,38],\"584\":[4,50],\"585\":[6,66],\"586\":[7,35],\"587\":[3,17],\"588\":[10,53],\"589\":[4,10],\"590\":[4,27],\"591\":[7,24],\"592\":[5,10],\"593\":[3,7],\"594\":[4,43],\"595\":[6,26],\"596\":[3,15],\"597\":[6,22],\"598\":[7,65],\"599\":[1,22],\"600\":[2,3],\"601\":[1,24],\"602\":[1,40],\"603\":[2,48],\"604\":[2,36],\"605\":[2,73],\"606\":[1,8],\"607\":[2,62],\"608\":[2,19],\"609\":[1,11],\"610\":[1,35],\"611\":[1,41],\"612\":[1,74],\"613\":[1,20],\"614\":[1,40],\"615\":[1,34],\"616\":[1,76],\"617\":[1,110],\"618\":[1,35],\"619\":[1,2],\"620\":[3,47],\"621\":[3,47],\"622\":[3,46],\"623\":[2,75],\"624\":[4],\"625\":[1,5],\"626\":[2,11],\"627\":[2,32],\"628\":[2],\"629\":[3,24],\"630\":[4,15],\"631\":[4,8],\"632\":[6],\"633\":[1,39],\"634\":[1,2],\"635\":[7,29],\"636\":[3,6],\"637\":[2,29],\"638\":[3,42],\"639\":[2,56],\"640\":[2,19],\"641\":[6,8],\"642\":[3,6],\"643\":[4,27],\"644\":[3,60],\"645\":[3,38],\"646\":[6,49],\"647\":[6,20],\"648\":[6,91],\"649\":[3,31],\"650\":[3,20],\"651\":[5,39],\"652\":[5,34],\"653\":[1,25],\"654\":[3,9],\"655\":[1,9],\"656\":[1,20],\"657\":[1,7],\"658\":[1,7],\"659\":[1,9],\"660\":[1,5],\"661\":[1,46],\"662\":[1,19],\"663\":[3,18],\"664\":[2,18],\"665\":[4,29],\"666\":[3,12],\"667\":[3,23],\"668\":[3,18],\"669\":[5,19],\"670\":[3,34],\"671\":[3,13],\"672\":[3,60],\"673\":[3,63],\"674\":[3,9],\"675\":[3,53],\"676\":[3,16],\"677\":[3,40],\"678\":[3,33],\"679\":[3,9],\"680\":[4,35],\"681\":[4,42],\"682\":[4,30],\"683\":[4,36],\"684\":[4,38],\"685\":[1,34],\"686\":[1,2],\"687\":[3,47],\"688\":[3,47],\"689\":[3,46],\"690\":[2,75],\"691\":[4],\"692\":[1,5],\"693\":[2,11],\"694\":[2,32],\"695\":[2],\"696\":[3,24],\"697\":[4,23],\"698\":[3,15],\"699\":[4,8],\"700\":[6],\"701\":[1,39],\"702\":[1,2],\"703\":[7,29],\"704\":[4,13],\"705\":[3,6],\"706\":[4,8],\"707\":[3,91],\"708\":[2,31],\"709\":[5,15],\"710\":[1,2],\"711\":[3,45],\"712\":[2,45],\"713\":[3,67],\"714\":[3,139],\"715\":[1],\"716\":[2,5],\"717\":[1,41],\"718\":[1,33],\"719\":[2,11],\"720\":[1,80],\"721\":[2,52],\"722\":[1,19],\"723\":[1,32],\"724\":[1,2],\"725\":[1,14],\"726\":[1,45],\"727\":[1,27],\"728\":[1,41],\"729\":[1,57],\"730\":[1,9],\"731\":[1,122],\"732\":[2,32],\"733\":[3,10],\"734\":[3],\"735\":[2],\"736\":[2,3],\"737\":[1,11],\"738\":[1,3],\"739\":[1],\"740\":[1],\"741\":[1],\"742\":[1],\"743\":[1],\"744\":[1],\"745\":[1],\"746\":[1],\"747\":[1],\"748\":[1],\"749\":[1],\"750\":[1],\"751\":[1],\"752\":[1],\"753\":[1],\"754\":[1],\"755\":[1],\"756\":[1],\"757\":[1]},\"averageFieldLength\":[2.8680738786279707,38.52495491593452],\"storedFields\":{\"0\":{\"h\":\"功能项目主页\"},\"1\":{\"h\":\"Get Started\",\"t\":[\"This is a normal page, which contains VuePress basics.\"]},\"2\":{\"h\":\"Pages\",\"t\":[\"You can add markdown files in your vuepress directory, every markdown file will be converted to a page in your site.\",\"See routing for more details.\"]},\"3\":{\"h\":\"Content\",\"t\":[\"Every markdown file will be rendered to HTML, then converted to a Vue SFC.\",\"VuePress support basic markdown syntax and some extensions, you can also use Vue features in it.\"]},\"4\":{\"h\":\"Configuration\",\"t\":[\"VuePress use a .vuepress/config.js(or .ts) file as site configuration, you can use it to config your site.\",\"For client side configuration, you can create .vuepress/client.js(or .ts).\",\"Meanwhile, you can also add configuration per page with frontmatter.\"]},\"5\":{\"h\":\"Layouts and customization\",\"t\":[\"Here are common configuration controlling layout of @vuepress/theme-default:\",\"navbar\",\"sidebar\",\"Check default theme docs for full reference.\",\"You can add extra style with .vuepress/styles/index.scss file.\"]},\"6\":{\"h\":\"\"},\"7\":{\"h\":\"计算机网络上\",\"t\":[\"计算机网络上\",\"因公众号开通较晚，无留言功能，想要交流的小伙伴可加我个人微信：coolsen666\",\"互联网公司的面试中，计算机网络可以说是必考题目。计算机网络知识点也非常多，库森特将面试题分为多期，今天先来看下第一期。\",\"老规矩，先收藏再看~\",\"看下本期的目录吧\"]},\"8\":{\"h\":\"1. 计算机网络的各层协议及作用？\",\"t\":[\"计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。\",\"OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。\",\"TCP/IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP只有最上面三层，最下面一层没有什么具体内容，TCP/IP参考模型没有真正描述这一层的实现。\",\"五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。\",\"七层网络体系结构各层的主要功能：\",\"应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。\",\"表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。\",\"会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。\",\"运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：\",\"TCP：提供面向连接的、可靠的数据传输服务；\",\"UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。\",\"网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。\",\"数据链路层：数据链路层通常简称为链路层。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。\",\"物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。\"]},\"9\":{\"h\":\"2. TCP和UDP的区别？\",\"t\":[\"对比如下：\",\"UDP\",\"TCP\",\"是否连接\",\"无连接\",\"面向连接\",\"是否可靠\",\"不可靠传输，不使用流量控制和拥塞控制\",\"可靠传输，使用流量控制和拥塞控制\",\"是否有序\",\"无序\",\"有序，消息在传输过程中可能会乱序，TCP 会重新排序\",\"传输速度\",\"快\",\"慢\",\"连接对象个数\",\"支持一对一，一对多，多对一和多对多交互通信\",\"只能是一对一通信\",\"传输方式\",\"面向报文\",\"面向字节流\",\"首部开销\",\"首部开销小，仅8字节\",\"首部最小20字节，最大60字节\",\"适用场景\",\"适用于实时应用（IP电话、视频会议、直播等）\",\"适用于要求可靠传输的应用，例如文件传输\",\"总结：\",\"TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。\"]},\"10\":{\"h\":\"3. UDP 和 TCP 对应的应用场景是什么？\",\"t\":[\"TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：\",\"FTP文件传输\",\"HTTP / HTTPS\",\"UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：\",\"包总量较少的通信，如 DNS 、SNMP等\",\"视频、音频等多媒体通信\",\"广播通信\"]},\"11\":{\"h\":\"4. 详细介绍一下 TCP 的三次握手机制？\",\"t\":[\"图片来自：https://juejin.cn/post/6844904005315854343\",\"三次握手机制：\",\"第一次握手：客户端请求建立连接，向服务端发送一个同步报文（SYN=1），同时选择一个随机数 seq = x 作为初始序列号，并进入SYN_SENT状态，等待服务器确认。\",\"第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为初始序列号，此时服务器进入SYN_RECV状态。\",\"第三次握手：客户端收到服务端的确认后，向服务端发送一个确认报文（ACK=1），确认号为 ack = y + 1，序列号为 seq = x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。\",\"理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。\"]},\"12\":{\"h\":\"5. 为什么需要三次握手，而不是两次？\",\"t\":[\"主要有三个原因：\",\"防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。\",\"在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。\",\"客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。\",\"此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。\",\"三次握手才能让双方均确认自己和对方的发送和接收能力都正常。\",\"第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；\",\"第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；\",\"第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；\",\"可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。\",\"告知对方自己的初始序号值，并确认收到对方的初始序号值。\",\"TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。\"]},\"13\":{\"h\":\"6. 为什么要三次握手，而不是四次？\",\"t\":[\"因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。\",\"第一次握手：服务端确认“自己收、客户端发”报文功能正常。\",\"第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。\",\"第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。\"]},\"14\":{\"h\":\"7. 什么是 SYN洪泛攻击？如何防范？\",\"t\":[\"SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。\",\"原理：\",\"在三次握手过程中，服务器发送 [SYN/ACK] 包（第二个包）之后、收到客户端的 [ACK] 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV（等待客户端响应）状态。如果接收到客户端的 [ACK]，则 TCP 连接成功，如果未接受到，则会不断重发请求直至成功。\",\"SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 [SYN] 包，服务器回复 [SYN/ACK] 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。\",\"这些伪造的 [SYN] 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。\",\"检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。\",\"防范：\",\"通过防火墙、路由器等过滤网关防护。\",\"通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。\",\"SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。\"]},\"15\":{\"h\":\"8. 三次握手连接阶段，最后一次ACK包丢失，会发生什么？\",\"t\":[\"服务端：\",\"第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。\",\"如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。\",\"客户端：\",\"客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。\"]},\"16\":{\"h\":\"9. 详细介绍一下 TCP 的四次挥手过程？\",\"t\":[\"图片来源：https://juejin.im/post/5ddd1f30e51d4532c42c5abe\",\"第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。\",\"序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1\",\"确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1\",\"第二次挥手：服务端收到连接释放报文后，立即发出确认报文（ACK=1），序列号 seq = k，确认号 ack = u + 1。\",\"这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。\",\"第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认。\",\"序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。\",\"确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据\",\"第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文（ACK=1），序列号 seq = u + 1，确认号为 ack = w + 1。\",\"此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。而服务端只要收到客户端发出的确认，就立即进入 CLOSED 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。\"]},\"17\":{\"h\":\"10. 为什么连接的时候是三次握手，关闭的时候却是四次握手？\",\"t\":[\"服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.\",\"接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的ACK和FIN一般都会分开发送，从而导致多了一次，因此一共需要四次挥手。\"]},\"18\":{\"h\":\"11. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？\",\"t\":[\"主要有两个原因：\",\"确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。\",\"第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN/ACK 报文的确认，就无法正常断开连接。\",\"MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。\",\"如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。\",\"防止已失效的连接请求报文段出现在之后的连接中。\",\"TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。\"]},\"19\":{\"h\":\"12. 如果已经建立了连接，但是客户端出现故障了怎么办？\",\"t\":[\"或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。\",\"简而言之，通过定时器 + 超时重试机制，尝试获取确认，直到最后会自动断开连接。\",\"具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。\"]},\"20\":{\"h\":\"13. TIME-WAIT 状态过多会产生什么后果？怎样处理？\",\"t\":[\"从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。\",\"从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。\",\"解决办法：\",\"服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于 TIME_WAIT状态），也请继续并重用它。\",\"调整系统内核参数，修改/etc/sysctl.conf文件，即修改net.ipv4.tcp_tw_reuse 和 tcp_timestamps\",\"net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 \",\"强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。\"]},\"21\":{\"h\":\"14. TIME_WAIT 是服务器端的状态?还是客户端的状态?\",\"t\":[\"TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。\",\"TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。\"]},\"22\":{\"h\":\"15. TCP协议如何保证可靠性？\",\"t\":[\"TCP主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和 流量控制等方法实现了可靠性传输。\",\"检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。\",\"序列号/确认应答：\",\"序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。\",\"TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。\",\"滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。\",\"超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。\",\"拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。\",\"流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。\"]},\"23\":{\"h\":\"16. 详细讲一下TCP的滑动窗口？\",\"t\":[\"在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。\",\"为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。\",\"从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。\",\"滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。\",\"可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。\"]},\"24\":{\"h\":\"17. 详细讲一下拥塞控制？\",\"t\":[\"TCP 一共使用了四种算法来实现拥塞控制：\",\"慢开始 (slow-start)；\",\"拥塞避免 (congestion avoidance)；\",\"快速重传 (fast retransmit)；\",\"快速恢复 (fast recovery)。\",\"发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwndssthresh时，改用拥塞避免算法。\",\"**慢开始：**不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。\",\"**拥塞避免：**拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。\",\"快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\",\"快恢复：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。\"]},\"25\":{\"h\":\"巨人的肩膀\",\"t\":[\"https://segmentfault.com/a/1190000021815671\",\"https://juejin.cn/post/6844904005315854343\",\"https://www.nowcoder.com/discuss/568071\",\"https://blog.csdn.net/yrx420909/article/details/104483455\",\"https://www.cnblogs.com/xiaolincoding/p/12638546.html\",\"https://imageslr.com/2020/07/07/tcp-shake-wave.html\",\"https://cloud.tencent.com/developer/article/1537628\"]},\"26\":{\"h\":\"计算机网络下\",\"t\":[\"计算机网络下\",\"计算机网络面试题第二期来了，话不多说，先收藏再看吧~\",\"看下本期的目录：\"]},\"27\":{\"h\":\"1. HTTP常见的状态码有哪些？\",\"t\":[\"常见状态码：\",\"200：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\",\"301 ： (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。\",\"302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\",\"400 ：客户端请求有语法错误，不能被服务器所理解。\",\"403 ：服务器收到请求，但是拒绝提供服务。\",\"404 ：(未找到) 服务器找不到请求的网页。\",\"500： (服务器内部错误) 服务器遇到错误，无法完成请求。\",\"状态码开头代表类型：\"]},\"28\":{\"h\":\"2. 状态码301和302的区别是什么？\",\"t\":[\"共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。 不同点：301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。\",\"补充，重定向原因：\",\"网站调整（如改变网页目录结构）；\",\"网页被移到一个新地址；\",\"网页扩展名改变(如应用需要把.php改成.Html或.shtml)。\"]},\"29\":{\"h\":\"3. HTTP 常用的请求方式？\",\"t\":[\"方法\",\"作用\",\"GET\",\"获取资源\",\"POST\",\"传输实体主体\",\"PUT\",\"上传文件\",\"DELETE\",\"删除文件\",\"HEAD\",\"和GET方法类似，但只返回报文首部，不返回报文实体主体部分\",\"PATCH\",\"对资源进行部分修改\",\"OPTIONS\",\"查询指定的URL支持的方法\",\"CONNECT\",\"要求用隧道协议连接代理\",\"TRACE\",\"服务器会将通信路径返回给客户端\",\"为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。\",\"PUT：上传文件，向服务器添加数据，可以看作增\",\"DELETE：删除文件\",\"POST：传输数据，向服务器提交数据，对服务器数据进行更新。\",\"GET：获取资源，查询服务器资源\"]},\"30\":{\"h\":\"4. GET请求和POST请求的区别？\",\"t\":[\"使用上的区别：\",\"GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。\",\"GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。\",\"POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。\",\"本质区别\",\"GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。\",\"幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。\"]},\"31\":{\"h\":\"5. 解释一下HTTP长连接和短连接？\",\"t\":[\"在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。\",\"但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive\",\"在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。\",\"HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。\"]},\"32\":{\"h\":\"6. HTTP请求报文和响应报文的格式？\",\"t\":[\"请求报文格式：\",\"请求行（请求方法+URI协议+版本）\",\"请求头部\",\"空行\",\"请求主体\",\"GET/sample.jspHTTP/1.1 请求行 Accept:image/gif.image/jpeg, 请求头部 Accept-Language:zh-cn Connection:Keep-Alive Host:localhost User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) Accept-Encoding:gzip,deflate username=jinqiao&password=1234 请求主体 \",\"响应报文：\",\"状态行（版本+状态码+原因短语）\",\"响应首部\",\"空行\",\"响应主体\",\"HTTP/1.1 200 OK Server:Apache Tomcat/5.0.12 Date:Mon,6Oct2003 13:23:42 GMT Content-Length:112 <html> <head> <title>HTTP响应示例<title> </head> <body> Hello HTTP! </body> </html> \"]},\"33\":{\"h\":\"7. HTTP1.0和HTTP1.1的区别?\",\"t\":[\"长连接：HTTP 1.1支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\",\"缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。\",\"带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\",\"错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\",\"Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。\"]},\"34\":{\"h\":\"8. HTTP1.1和 HTTP2.0的区别？\",\"t\":[\"HTTP2.0相比HTTP1.1支持的特性：\",\"新的二进制格式：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\",\"多路复用，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\",\"头部压缩，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\",\"服务端推送：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。\"]},\"35\":{\"h\":\"9. HTTP 与 HTTPS 的区别？\",\"t\":[\"HTTP\",\"HTTPS\",\"端口\",\"80\",\"443\",\"安全性\",\"无加密，安全性较差\",\"有加密机制，安全性较高\",\"资源消耗\",\"较少\",\"由于加密处理，资源消耗更多\",\"是否需要证书\",\"不需要\",\"需要\",\"协议\",\"运行在TCP协议之上\",\"运行在SSL协议之上，SSL运行在TCP协议之上\"]},\"36\":{\"h\":\"10. HTTPS 的优缺点?\",\"t\":[\"优点：\",\"安全性：\",\"使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\",\"HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。\",\"HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\",\"SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。\",\"缺点：\",\"在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。\",\"HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。\",\"在现有的证书机制下，中间人攻击依然有可能发生。\",\"HTTPS 需要更多的服务器资源，也会导致成本的升高。\"]},\"37\":{\"h\":\"11. 讲一讲HTTPS 的原理？\",\"t\":[\"图片来源：https://segmentfault.com/a/1190000021494676\",\"加密流程按图中的序号分为：\",\"客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。\",\"采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。\",\"服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。\",\"客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。\",\"如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。\",\"客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。\",\"服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。\",\"服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。\",\"双方使用对称加密愉快地传输所有数据。\"]},\"38\":{\"h\":\"12. 在浏览器中输入www.baidu.com后执行的全部过程？\",\"t\":[\"域名解析（域名 www.baidu.com 变为 ip 地址）。\",\"浏览器搜索自己的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的hosts文件（维护一张域名与IP的对应表）。\",\"若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即本地 dns 服务器（递归查询），本地域名服务器查询自己的dns缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。\",\"发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。\",\"建立 tcp 连接后发起 http 请求。\",\"服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。\",\"浏览器解析 html 代码，并请求 html 中的资源。\",\"浏览器对页面进行渲染，并呈现给用户。\",\"附一张形象的图片：\"]},\"39\":{\"h\":\"13. 什么是 Cookie 和 Session ?\",\"t\":[\"什么是 Cookie\",\"HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\",\"Cookie 主要用于以下三个方面：\",\"会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\",\"个性化设置（如用户自定义设置、主题等）\",\"浏览器行为跟踪（如跟踪分析用户行为等）\",\"什么是 Session\",\"Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。\"]},\"40\":{\"h\":\"14. Cookie 和 Session 是如何配合的呢？\",\"t\":[\"用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。\",\"当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。\",\"根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\"]},\"41\":{\"h\":\"15. Cookie和Session的区别？\",\"t\":[\"作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。\",\"存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。\",\"有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。\",\"隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。\",\"存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。\"]},\"42\":{\"h\":\"16. 如何考虑分布式 Session 问题？\",\"t\":[\"在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。\",\"分布式 Session 一般会有以下几种解决方案：\",\"客户端存储：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息\",\"Nginx ip_hash 策略：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。\",\"Session 复制：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。\",\"共享 Session：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。\",\"建议采用共享 Session的方案。\"]},\"43\":{\"h\":\"17. 什么是DDos攻击？\",\"t\":[\"DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：\",\"客户端向服务端发送请求链接数据包。\",\"服务端向客户端发送确认数据包。\",\"客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认\",\"DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。\",\"DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：\",\"减少SYN timeout时间。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。\",\"限制同时打开的SYN半连接数目。\"]},\"44\":{\"h\":\"18. 什么是XSS攻击？\",\"t\":[\"XSS也称 cross-site scripting，跨站脚本。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入带有＜script＞标签的代码，导致恶意代码的执行。\",\"预防措施有：\",\"前端：过滤。\",\"后端：转义，比如go自带的处理器就具有转义功能。\"]},\"45\":{\"h\":\"19. SQL注入是什么，如何避免SQL注入？\",\"t\":[\"SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。\",\"SQL注入的原理主要有以下 4 点\",\"恶意拼接查询\",\"利用注释执行非法命令\",\"传入非法参数\",\"添加额外条件\",\"避免SQL注入的一些方法：\",\"限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。\",\"对进入数据库的特殊字符（’”\\\\尖括号&*;等）转义处理。\",\"提供参数化查询接口，不要直接使用原生SQL。\"]},\"46\":{\"h\":\"20. 负载均衡算法有哪些？\",\"t\":[\"多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。\",\"轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。\",\"随机法：随机获取一台，和轮询类似。\",\"哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。\",\"加权轮询：根据服务器性能不同加权。\"]},\"47\":{\"h\":\"End\",\"t\":[\"更文不易，点赞鼓励下呗~我将持续输出干货，与你共同成长～\",\"还有，秋招求职交流群持续开放，扫码加我，备注秋招，拉你进群。\"]},\"48\":{\"h\":\"巨人的肩膀\",\"t\":[\"https://juejin.cn/post/6844903890840715271\",\"https://www.justdojava.com/2019/11/03/Network_interview_question/\",\"https://juejin.cn/post/6844903489596833800\",\"https://segmentfault.com/a/1190000021494676\",\"https://jiangren.work/2020/02/16/\",\"https://www.cnblogs.com/ityouknow/p/10856177.html\",\"https://juejin.cn/post/6844903575684907016\"]},\"49\":{\"h\":\"PDF 八股一\",\"t\":[\"面经 PDF\"]},\"50\":{\"h\":\"PDF 八股二\",\"t\":[\"面经 PDF\"]},\"51\":{\"h\":\"\"},\"52\":{\"h\":\"fofa 语句\",\"t\":[\"fofa日志\",\"HK: 阿里: 45102 HK Limit 4760 ZEN-ECN 21859 Google 396982 腾讯 132203 微软 8075\",\"示例： 美国 server==\\\"cloudflare\\\" && port==\\\"80\\\" && header=\\\"Forbidden\\\" && country==\\\"US\\\" && asn!=\\\"13335\\\" && asn!=\\\"209242\\\"\",\"自制： 1、server==\\\"cloudflare\\\" && asn==\\\"45102\\\" && region==\\\"HK\\\" && asn!=\\\"13335\\\" && asn!=\\\"209242\\\" && port==\\\"80\\\" 2、server==\\\"cloudflare\\\" && port==\\\"80\\\" && header=\\\"Forbidden\\\" && country==\\\"HK\\\" && asn!=\\\"13335\\\" && asn!=\\\"209242\\\"\",\"附： 1、-- region==\\\"HK\\\" 和 city==\\\"Hong Kong\\\" 相同 2、-- asn!=\\\"132585\\\" 该asn香港节点 非常多 且都不可用 -1\"]},\"53\":{\"h\":\"Pages1\",\"t\":[\"pages 部署日志\",\"pages1 log： from ED 直连订阅：https://vless.mycf2hj2.dynv6.net/sub/9afa0f97-643e-4c22-8156-dfa49bfcd88b 订阅器https://sub.xf.free.hr/auto?host=vless.mycf2hj1.dynv6.net&uuid=9afa0f97-643e-4c22-8156-dfa49bfcd88b\",\"其中，订阅器https://sub.xf.free.hr/auto?host=vless.mycf2hj1.dynv6.netuuid=9afa0f97-643e-4c22-8156-dfa49bfcd88b == hel3的 https://pre.mycf2hj.top/bestip/9afa0f97-643e-4c22-8156-dfa49bfcd88b 可不使用自定义域\"]},\"54\":{\"h\":\"1、一键生成免费订阅链接\",\"t\":[\"Cloudflare 博主文章\"]},\"55\":{\"h\":\"发布于 2024-04-02\",\"t\":[\"源： https://www.tweek.top/archives/1712021855314\"]},\"56\":{\"h\":\"一键生成免费订阅链接，订阅动态更新，自动添加优选域名和优选IP,CF CDN 免费节点，任意一个节点,可通过此方法，生产订阅链接。。。视频教程：\"},\"57\":{\"h\":\"1，搭建workers订阅节点\",\"t\":[\"代码地址：https://raw.githubusercontent.com/dockkkk/CF-WORKERS/main/worker.js\",\"推荐订阅器\",\"cm.godns.onflashdrive.app 天城大佬\",\"3k.fxxk.dedyn.io 3K大佬\",\"vmess.fxxk.dedyn.io CM大佬\",\"vless.fxxk.dedyn.io CM大佬\",\"变量：\",\"SUB=订阅器\",\"UUID=UUID\",\"PROXYIP=推荐几个\",\"proxyip.fxxk.dedyn.io\",\"IP落地区域: 美国 维护频率: 12小时/次\",\"proxyip.sg.fxxk.dedyn.io\",\"IP落地区域: 新加坡 维护频率: 12小时/次\",\"proxyip.jp.fxxk.dedyn.io\",\"IP落地区域: 日本 维护频率: 12小时/次\",\"proxyip.hk.fxxk.dedyn.io\",\"IP落地区域: 香港 维护频率: 12小时/次\",\"proxyip.aliyun.fxxk.dedyn.io\",\"IP落地区域: 阿里云 维护频率: 4小时/次\",\"proxyip.oracle.fxxk.dedyn.io \",\"IP落地区域: 甲骨文 维护频率: 4小时/次\",\"proxyip.digitalocean.fxxk.dedyn.io\",\"IP落地区域: 数码海 维护频率: 4小时/次\"]},\"58\":{\"h\":\"2,订阅器部署\",\"t\":[\"代码地址：https://raw.githubusercontent.com/dockkkk/CF-WORKERS/main/dingyue.js\",\"优选域名推荐\",\"cfip.xxxxxxxx.tk:2096\",\"cdn.kaiche.tk:2096\",\"c.xf.free.hr:2087\",\"cf.090227.xyz:443\",\"sp.rweek.top:443\",\"hk.rweek.top:2052\",\"推荐api地址\",\"https://raw.githubusercontent.com/ymyuuu/IPDB/main/bestcf.txt\",\"变量自动：\",\"UUID=UUID\",\"HOST=伪装域名\",\"PATH=路径\",\"TOKEN=订阅入口\",\"手动填写：https://生成器地址/sub?host=伪装域名&uuid=你的UUID&path=路径\"]},\"59\":{\"h\":\"发布于 2023-07-21\",\"t\":[\"源： https://jdssl.top/index.php/2023/07/21/2023vpn/\"]},\"60\":{\"h\":\"\",\"t\":[\"v2rayN 最新版下载地址>>\",\"cloudflare网站链接>>\",\"临时邮箱：https://www.linshiyouxiang.net/\",\"部署代码：https://github.com/leilei223/edgetunnel/blob/main/src/worker-vless.js\",\"uuid生成：https://1024tools.com/uuid\",\"免费域名注册：https://www.dynadot.com/register-your-free-link-domain\",\"付费域名注册：www.namesilo.com（付费域名注册和解析点击查看这个视频>>跳转到4分17秒处）\",\"workers win专用ip优选：下载地址>>\",\"ip查看：https://whatismyipaddress.com/\",\"cf ip优选；https://stock.hostmonit.com/CloudFlareYes\",\"网络测速：https://www.speedtest.net/result/14952074175\",\"openclash转换订阅网址：https://sub-web.netlify.app/\"]},\"61\":{\"h\":\"\",\"t\":[\"cdn-all.xn--b6gac.eu.org cdn.xn--b6gac.eu.org cdn-b100.xn--b6gac.eu.org edgetunnel.anycast.eu.org cdn.anycast.eu.org \",\"1.有域名（有tls加密，443端口)，推荐！ Custom Domains查看——添加自定义域——填1个二级域名 点击自定义域，在二级域名后加/UUID，就能看到VLESS节点URL和Clash-meta配置 在v2rayN导入URL，地址栏改为优选ip\",\"2.无域名（没tls加密，80或者2052端口） 进去worker.dev，加上/uuid就能看到VLESS节点URL和Clash-meta配置。v2ray,shadowrocket等客户端要去掉tls加密，端口改为80或者2052，地址修为优选 ip\",\"无法优选ip 可以使用这个（youxuan.jdssl.link）域名在v2ray 填优选ip处填写，把端口改为：80 并把下面的tls关闭。\",\"cloudflare颁发证书网站\"]},\"62\":{\"h\":\"\",\"t\":[\"挑选下方任意一个域名，然后粘贴，ping检测后，看地图上自己所属省份是否能使用，若颜色是绿色和黄色，说明这个域名可以使用，若你的省份为红色，则无法使用，换另一个域名测试，如果ping后是绿色或黄色，可以直接使用下方域名，或者使用解析出来的ip 作为优选ip到v2rayn中替换使用。\",\"gamer.com.tw steamdb.info toy-people.com silkbook.com cdn.anycast.eu.org icook.hk shopify.com www.visa.com.tw time.is japan.com www.hugedomains.com www.visa.com.sg www.whoer.net www.visa.com.hk malaysia.com www.visa.co.jp www.ipget.net icook.tw www.visa.com www.gov.ua www.udacity.com www.shopify.com www.whatismyip.com singapore.com www.visakorea.com www.csgo.com russia.com ip.sb www.4chan.org www.glassdoor.com xn--b6gac.eu.org www.digitalocean.com www.udemy.com cdn-all.xn--b6gac.eu.org dnschecker.org tasteatlas.com toy-people.com pixiv.net comicabc.com icook.tw gamer.com.tw steamdb.info toy-people.com silkbook.com \"]},\"63\":{\"h\":\"发布于 2023-.8-05\",\"t\":[\"源 https://jdssl.top/index.php/2023/08/05/problem/\",\"问题1：无法运行bat后缀文件问题\",\"问题2：IP优选，特定国家ip段，ip跳动问题\",\"问题3：无法免费注册link域名\",\"问题4：新版 vless 众多TLS节点无法使用。\",\"问题5：vless节点怎么在clash当中分流使用？\"]},\"64\":{\"h\":\"*\",\"t\":[\"./CloudflareST -url https://jp.cloudflarest.link -tl 200 -sl 3 -dn 10 \",\"win 32位 优选ip 下载：https://jdssl.lanzouw.com/iWdrN14wmola\",\"win64位 ip&域名优选打包：点击下载>> \"]},\"65\":{\"h\":\"\",\"t\":[\"临时邮箱：https://www.linshiyouxiang.net/\",\"fofa：https://fofa.info/\",\"美国地区cf反代ip查询代码：\",\"server==\\\"cloudflare\\\" && port==\\\"80\\\" && header=\\\"Forbidden\\\" && country==\\\"US\\\" && asn!=\\\"13335\\\" && asn!=\\\"209242\\\" \",\"需要其他地区可更改以上代码的“US” 的国家简写\",\"比如德国：简写”DE” 代码如下：\",\"server==\\\"cloudflare\\\" && port==\\\"80\\\" && header=\\\"Forbidden\\\" && country==\\\"DE\\\" && asn!=\\\"13335\\\" && asn!=\\\"209242\\\" \",\"国家简写网站查询：http://m.news.xixik.com/content/6bb1b9873c71c353/\",\"美国，法国，德国ip段可直接导入ip.txt，点击下载>>\"]},\"66\":{\"h\":\"\",\"t\":[\"无法注册或已经不免费，可以去其他网站注册便宜的域名，\",\"提供一个便宜域名注册网站：www.namesilo.com\",\"（付费域名注册和解析点击查看这个视频>>跳转到4分17秒处）\"]},\"67\":{\"h\":\"\",\"t\":[\"使用域名用tls，可参考这个视频>>的11:56处查看，来使域名使用tls节点。\"]},\"68\":{\"h\":\"\",\"t\":[\"clash meta版本下载地址：https://github.com/zzzgydi/clash-verge/releases/tag/v1.3.5\",\"win版本：https://github.com/zzzgydi/clash-verge/releases/download/v1.3.5/Clash.Verge_1.3.5_x64-setup.exe\",\"mac版本：https://github.com/zzzgydi/clash-verge/releases/download/v1.3.5/Clash.Verge_1.3.5_x64.dmg\",\"轻量代码编辑器下载：https://www.sublimetext.com/3\",\"sublimetext汉化高亮win这里下载：https://jdssl.lanzouw.com/iloSz14mra9e\",\"clash yaml配置文件：https://jdssl.lanzouw.com/iyJDV14ueruh\"]},\"69\":{\"h\":\"hel2  code\",\"t\":[\"hel2 代码日志 yonggekkk/Cloudflare-workers-pages-vless\",\"from yonggekkk/Cloudflare-workers-pages-vless\",\"//注： yonggekkk/Cloudflare-workers-pages-vless 的脚本 2024.05.02日更新 解决10011 需要删除worker重新创建 //注： https://hel2.2961819202.workers.dev/9afa0f97-643e-4c22-8156-dfa49bfcd88b // <!--GAMFC-->version base on commit 43fad05dcdae3b723c53c226f8181fc5bd47223e, time is 2023-06-22 15:20:02 UTC<!--GAMFC-END-->. // @ts-ignore import { connect } from 'cloudflare:sockets'; // How to generate your own UUID: // [Windows] Press \\\"Win + R\\\", input cmd and run: Powershell -NoExit -Command \\\"[guid]::NewGuid()\\\" let userID = '9afa0f97-643e-4c22-8156-dfa49bfcd88b'; const proxyIPs = [\\\"workers.cloudflare.cyou\\\"]; let proxyIP = proxyIPs[Math.floor(Math.random() * proxyIPs.length)]; if (!isValidUUID(userID)) { throw new Error('uuid is not valid'); } export default { /** * @param {import(\\\"@cloudflare/workers-types\\\").Request} request * @param {{UUID: string, PROXYIP: string, DNS_RESOLVER_URL: string, NODE_ID: int, API_HOST: string, API_TOKEN: string}} env * @param {import(\\\"@cloudflare/workers-types\\\").ExecutionContext} ctx * @returns {Promise<Response>} */ async fetch(request, env, ctx) { try { userID = env.UUID || userID; proxyIP = env.PROXYIP || proxyIP; const upgradeHeader = request.headers.get('Upgrade'); if (!upgradeHeader || upgradeHeader !== 'websocket') { const url = new URL(request.url); switch (url.pathname) { case '/cf': return new Response(JSON.stringify(request.cf, null, 4), { status: 200, headers: { \\\"Content-Type\\\": \\\"application/json;charset=utf-8\\\", }, }); case `/${userID}`: { const vlessConfig = getVLESSConfig(userID, request.headers.get('Host')); return new Response(`${vlessConfig}`, { status: 200, headers: { \\\"Content-Type\\\": \\\"text/plain;charset=utf-8\\\", } }); } default: // return new Response('Not found', { status: 404 }); // For any other path, reverse proxy to 'ramdom website' and return the original response, caching it in the process const randomHostname = cn_hostnames[Math.floor(Math.random() * cn_hostnames.length)]; const newHeaders = new Headers(request.headers); newHeaders.set('cf-connecting-ip', '1.2.3.4'); newHeaders.set('x-forwarded-for', '1.2.3.4'); newHeaders.set('x-real-ip', '1.2.3.4'); newHeaders.set('referer', 'https://www.google.com/search?q=edtunnel'); // Use fetch to proxy the request to 15 different domains const proxyUrl = 'https://' + randomHostname + url.pathname + url.search; let modifiedRequest = new Request(proxyUrl, { method: request.method, headers: newHeaders, body: request.body, redirect: 'manual', }); const proxyResponse = await fetch(modifiedRequest, { redirect: 'manual' }); // Check for 302 or 301 redirect status and return an error response if ([301, 302].includes(proxyResponse.status)) { return new Response(`Redirects to ${randomHostname} are not allowed.`, { status: 403, statusText: 'Forbidden', }); } // Return the response from the proxy server return proxyResponse; } } else { return await vlessOverWSHandler(request); } } catch (err) { /** @type {Error} */ let e = err; return new Response(e.toString()); } }, }; /** * * @param {import(\\\"@cloudflare/workers-types\\\").Request} request */ async function vlessOverWSHandler(request) { /** @type {import(\\\"@cloudflare/workers-types\\\").WebSocket[]} */ // @ts-ignore const webSocketPair = new WebSocketPair(); const [client, webSocket] = Object.values(webSocketPair); webSocket.accept(); let address = ''; let portWithRandomLog = ''; const log = (/** @type {string} */ info, /** @type {string | undefined} */ event) => { console.log(`[${address}:${portWithRandomLog}] ${info}`, event || ''); }; const earlyDataHeader = request.headers.get('sec-websocket-protocol') || ''; const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log); /** @type {{ value: import(\\\"@cloudflare/workers-types\\\").Socket | null}}*/ let remoteSocketWapper = { value: null, }; let udpStreamWrite = null; let isDns = false; // ws --> remote readableWebSocketStream.pipeTo(new WritableStream({ async write(chunk, controller) { if (isDns && udpStreamWrite) { return udpStreamWrite(chunk); } if (remoteSocketWapper.value) { const writer = remoteSocketWapper.value.writable.getWriter() await writer.write(chunk); writer.releaseLock(); return; } const { hasError, message, portRemote = 443, addressRemote = '', rawDataIndex, vlessVersion = new Uint8Array([0, 0]), isUDP, } = await processVlessHeader(chunk, userID); address = addressRemote; portWithRandomLog = `${portRemote}--${Math.random()} ${isUDP ? 'udp ' : 'tcp ' } `; if (hasError) { // controller.error(message); throw new Error(message); // cf seems has bug, controller.error will not end stream // webSocket.close(1000, message); return; } // if UDP but port not DNS port, close it if (isUDP) { if (portRemote === 53) { isDns = true; } else { // controller.error('UDP proxy only enable for DNS which is port 53'); throw new Error('UDP proxy only enable for DNS which is port 53'); // cf seems has bug, controller.error will not end stream return; } } // [\\\"version\\\", \\\"附加信息长度 N\\\"] const vlessResponseHeader = new Uint8Array([vlessVersion[0], 0]); const rawClientData = chunk.slice(rawDataIndex); // TODO: support udp here when cf runtime has udp support if (isDns) { const { write } = await handleUDPOutBound(webSocket, vlessResponseHeader, log); udpStreamWrite = write; udpStreamWrite(rawClientData); return; } handleTCPOutBound(remoteSocketWapper, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log); }, close() { log(`readableWebSocketStream is close`); }, abort(reason) { log(`readableWebSocketStream is abort`, JSON.stringify(reason)); }, })).catch((err) => { log('readableWebSocketStream pipeTo error', err); }); return new Response(null, { status: 101, // @ts-ignore webSocket: client, }); } /** * Checks if a given UUID is present in the API response. * @param {string} targetUuid The UUID to search for. * @returns {Promise<boolean>} A Promise that resolves to true if the UUID is present in the API response, false otherwise. */ async function checkUuidInApiResponse(targetUuid) { // Check if any of the environment variables are empty try { const apiResponse = await getApiResponse(); if (!apiResponse) { return false; } const isUuidInResponse = apiResponse.users.some(user => user.uuid === targetUuid); return isUuidInResponse; } catch (error) { console.error('Error:', error); return false; } } /** * Handles outbound TCP connections. * * @param {any} remoteSocket * @param {string} addressRemote The remote address to connect to. * @param {number} portRemote The remote port to connect to. * @param {Uint8Array} rawClientData The raw client data to write. * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocket The WebSocket to pass the remote socket to. * @param {Uint8Array} vlessResponseHeader The VLESS response header. * @param {function} log The logging function. * @returns {Promise<void>} The remote socket. */ async function handleTCPOutBound(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log,) { async function connectAndWrite(address, port) { /** @type {import(\\\"@cloudflare/workers-types\\\").Socket} */ const tcpSocket = connect({ hostname: address, port: port, }); remoteSocket.value = tcpSocket; log(`connected to ${address}:${port}`); const writer = tcpSocket.writable.getWriter(); await writer.write(rawClientData); // first write, nomal is tls client hello writer.releaseLock(); return tcpSocket; } // if the cf connect tcp socket have no incoming data, we retry to redirect ip async function retry() { const tcpSocket = await connectAndWrite(proxyIP || addressRemote, portRemote) // no matter retry success or not, close websocket tcpSocket.closed.catch(error => { console.log('retry tcpSocket closed error', error); }).finally(() => { safeCloseWebSocket(webSocket); }) remoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, null, log); } const tcpSocket = await connectAndWrite(addressRemote, portRemote); // when remoteSocket is ready, pass to websocket // remote--> ws remoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, retry, log); } /** * * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocketServer * @param {string} earlyDataHeader for ws 0rtt * @param {(info: string)=> void} log for ws 0rtt */ function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) { let readableStreamCancel = false; const stream = new ReadableStream({ start(controller) { webSocketServer.addEventListener('message', (event) => { if (readableStreamCancel) { return; } const message = event.data; controller.enqueue(message); }); // The event means that the client closed the client -> server stream. // However, the server -> client stream is still open until you call close() on the server side. // The WebSocket protocol says that a separate close message must be sent in each direction to fully close the socket. webSocketServer.addEventListener('close', () => { // client send close, need close server // if stream is cancel, skip controller.close safeCloseWebSocket(webSocketServer); if (readableStreamCancel) { return; } controller.close(); } ); webSocketServer.addEventListener('error', (err) => { log('webSocketServer has error'); controller.error(err); } ); // for ws 0rtt const { earlyData, error } = base64ToArrayBuffer(earlyDataHeader); if (error) { controller.error(error); } else if (earlyData) { controller.enqueue(earlyData); } }, pull(controller) { // if ws can stop read if stream is full, we can implement backpressure // https://streams.spec.whatwg.org/#example-rs-push-backpressure }, cancel(reason) { // 1. pipe WritableStream has error, this cancel will called, so ws handle server close into here // 2. if readableStream is cancel, all controller.close/enqueue need skip, // 3. but from testing controller.error still work even if readableStream is cancel if (readableStreamCancel) { return; } log(`ReadableStream was canceled, due to ${reason}`) readableStreamCancel = true; safeCloseWebSocket(webSocketServer); } }); return stream; } // https://xtls.github.io/development/protocols/vless.html // https://github.com/zizifn/excalidraw-backup/blob/main/v2ray-protocol.excalidraw /** * * @param { ArrayBuffer} vlessBuffer * @param {string} userID * @returns */ async function processVlessHeader( vlessBuffer, userID ) { if (vlessBuffer.byteLength < 24) { return { hasError: true, message: 'invalid data', }; } const version = new Uint8Array(vlessBuffer.slice(0, 1)); let isValidUser = false; let isUDP = false; const slicedBuffer = new Uint8Array(vlessBuffer.slice(1, 17)); const slicedBufferString = stringify(slicedBuffer); const uuids = userID.includes(',') ? userID.split(\\\",\\\") : [userID]; const checkUuidInApi = await checkUuidInApiResponse(slicedBufferString); isValidUser = uuids.some(userUuid => checkUuidInApi || slicedBufferString === userUuid.trim()); console.log(`checkUuidInApi: ${await checkUuidInApiResponse(slicedBufferString)}, userID: ${slicedBufferString}`); if (!isValidUser) { return { hasError: true, message: 'invalid user', }; } const optLength = new Uint8Array(vlessBuffer.slice(17, 18))[0]; //skip opt for now const command = new Uint8Array( vlessBuffer.slice(18 + optLength, 18 + optLength + 1) )[0]; // 0x01 TCP // 0x02 UDP // 0x03 MUX if (command === 1) { } else if (command === 2) { isUDP = true; } else { return { hasError: true, message: `command ${command} is not support, command 01-tcp,02-udp,03-mux`, }; } const portIndex = 18 + optLength + 1; const portBuffer = vlessBuffer.slice(portIndex, portIndex + 2); // port is big-Endian in raw data etc 80 == 0x005d const portRemote = new DataView(portBuffer).getUint16(0); let addressIndex = portIndex + 2; const addressBuffer = new Uint8Array( vlessBuffer.slice(addressIndex, addressIndex + 1) ); // 1--> ipv4 addressLength =4 // 2--> domain name addressLength=addressBuffer[1] // 3--> ipv6 addressLength =16 const addressType = addressBuffer[0]; let addressLength = 0; let addressValueIndex = addressIndex + 1; let addressValue = ''; switch (addressType) { case 1: addressLength = 4; addressValue = new Uint8Array( vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength) ).join('.'); break; case 2: addressLength = new Uint8Array( vlessBuffer.slice(addressValueIndex, addressValueIndex + 1) )[0]; addressValueIndex += 1; addressValue = new TextDecoder().decode( vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength) ); break; case 3: addressLength = 16; const dataView = new DataView( vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength) ); // 2001:0db8:85a3:0000:0000:8a2e:0370:7334 const ipv6 = []; for (let i = 0; i < 8; i++) { ipv6.push(dataView.getUint16(i * 2).toString(16)); } addressValue = ipv6.join(':'); // seems no need add [] for ipv6 break; default: return { hasError: true, message: `invild addressType is ${addressType}`, }; } if (!addressValue) { return { hasError: true, message: `addressValue is empty, addressType is ${addressType}`, }; } return { hasError: false, addressRemote: addressValue, addressType, portRemote, rawDataIndex: addressValueIndex + addressLength, vlessVersion: version, isUDP, }; } /** * * @param {import(\\\"@cloudflare/workers-types\\\").Socket} remoteSocket * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocket * @param {ArrayBuffer} vlessResponseHeader * @param {(() => Promise<void>) | null} retry * @param {*} log */ async function remoteSocketToWS(remoteSocket, webSocket, vlessResponseHeader, retry, log) { // remote--> ws let remoteChunkCount = 0; let chunks = []; /** @type {ArrayBuffer | null} */ let vlessHeader = vlessResponseHeader; let hasIncomingData = false; // check if remoteSocket has incoming data await remoteSocket.readable .pipeTo( new WritableStream({ start() { }, /** * * @param {Uint8Array} chunk * @param {*} controller */ async write(chunk, controller) { hasIncomingData = true; // remoteChunkCount++; if (webSocket.readyState !== WS_READY_STATE_OPEN) { controller.error( 'webSocket.readyState is not open, maybe close' ); } if (vlessHeader) { webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer()); vlessHeader = null; } else { // seems no need rate limit this, CF seems fix this??.. // if (remoteChunkCount > 20000) { // // cf one package is 4096 byte(4kb), 4096 * 20000 = 80M // await delay(1); // } webSocket.send(chunk); } }, close() { log(`remoteConnection!.readable is close with hasIncomingData is ${hasIncomingData}`); // safeCloseWebSocket(webSocket); // no need server close websocket frist for some case will casue HTTP ERR_CONTENT_LENGTH_MISMATCH issue, client will send close event anyway. }, abort(reason) { console.error(`remoteConnection!.readable abort`, reason); }, }) ) .catch((error) => { console.error( `remoteSocketToWS has exception `, error.stack || error ); safeCloseWebSocket(webSocket); }); // seems is cf connect socket have error, // 1. Socket.closed will have error // 2. Socket.readable will be close without any data coming if (hasIncomingData === false && retry) { log(`retry`) retry(); } } /** * * @param {string} base64Str * @returns */ function base64ToArrayBuffer(base64Str) { if (!base64Str) { return { error: null }; } try { // go use modified Base64 for URL rfc4648 which js atob not support base64Str = base64Str.replace(/-/g, '+').replace(/_/g, '/'); const decode = atob(base64Str); const arryBuffer = Uint8Array.from(decode, (c) => c.charCodeAt(0)); return { earlyData: arryBuffer.buffer, error: null }; } catch (error) { return { error }; } } /** * This is not real UUID validation * @param {string} uuid */ function isValidUUID(uuid) { const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i; return uuidRegex.test(uuid); } const WS_READY_STATE_OPEN = 1; const WS_READY_STATE_CLOSING = 2; /** * Normally, WebSocket will not has exceptions when close. * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} socket */ function safeCloseWebSocket(socket) { try { if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) { socket.close(); } } catch (error) { console.error('safeCloseWebSocket error', error); } } const byteToHex = []; for (let i = 0; i < 256; ++i) { byteToHex.push((i + 256).toString(16).slice(1)); } function unsafeStringify(arr, offset = 0) { return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \\\"-\\\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \\\"-\\\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \\\"-\\\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \\\"-\\\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); } function stringify(arr, offset = 0) { const uuid = unsafeStringify(arr, offset); if (!isValidUUID(uuid)) { throw TypeError(\\\"Stringified UUID is invalid\\\"); } return uuid; } /** * * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocket * @param {ArrayBuffer} vlessResponseHeader * @param {(string)=> void} log */ async function handleUDPOutBound(webSocket, vlessResponseHeader, log) { let isVlessHeaderSent = false; const transformStream = new TransformStream({ start(controller) { }, transform(chunk, controller) { // udp message 2 byte is the the length of udp data // TODO: this should have bug, beacsue maybe udp chunk can be in two websocket message for (let index = 0; index < chunk.byteLength;) { const lengthBuffer = chunk.slice(index, index + 2); const udpPakcetLength = new DataView(lengthBuffer).getUint16(0); const udpData = new Uint8Array( chunk.slice(index + 2, index + 2 + udpPakcetLength) ); index = index + 2 + udpPakcetLength; controller.enqueue(udpData); } }, flush(controller) { } }); // only handle dns udp for now transformStream.readable.pipeTo(new WritableStream({ async write(chunk) { const resp = await fetch(dohURL, // dns server url { method: 'POST', headers: { 'content-type': 'application/dns-message', }, body: chunk, }) const dnsQueryResult = await resp.arrayBuffer(); const udpSize = dnsQueryResult.byteLength; // console.log([...new Uint8Array(dnsQueryResult)].map((x) => x.toString(16))); const udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]); if (webSocket.readyState === WS_READY_STATE_OPEN) { log(`doh success and dns message length is ${udpSize}`); if (isVlessHeaderSent) { webSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer()); } else { webSocket.send(await new Blob([vlessResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer()); isVlessHeaderSent = true; } } } })).catch((error) => { log('dns udp has error' + error) }); const writer = transformStream.writable.getWriter(); return { /** * * @param {Uint8Array} chunk */ write(chunk) { writer.write(chunk); } }; } /** * * @param {string} userID * @param {string | null} hostName * @returns {string} */ function getVLESSConfig(userID, hostName) { const wvlessws = `vless://${userID}\\\\u0040www.visa.com.sg:8880?encryption=none&security=none&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}`; const pvlesswstls = `vless://${userID}\\\\u0040www.visa.com.sg:8443?encryption=none&security=tls&type=ws&host=${hostName}&sni=${hostName}&fp=random&path=%2F%3Fed%3D2048#${hostName}`; if (hostName.includes('pages.dev')) { return ` ==========================配置详解============================== ################################################################ CF-pages-vless+ws+tls节点，分享链接如下： ${pvlesswstls} --------------------------------------------------------------- 注意：如果 ${hostName} 在本地网络打不开（中国移动用户注意） 客户端选项的伪装域名(host)必须改为你在CF解析完成的自定义域名 --------------------------------------------------------------- 客户端必要文明参数如下： 客户端地址(address)：自定义的域名 或者 优选域名 或者 优选IP（反代IP必须与反代端口对应） 端口(port)：6个https端口可任意选择(443、8443、2053、2083、2087、2096) 用户ID(uuid)：${userID} 传输协议(network)：ws 或者 websocket 伪装域名(host)：${hostName} 路径(path)：/?ed=2048 传输安全(TLS)：开启 跳过证书验证(allowlnsecure)：false ################################################################ `; } else if (hostName.includes('workers.dev')) { return ` ==========================配置详解============================== ################################################################ 一、CF-workers-vless+ws节点，分享链接如下： ${wvlessws} --------------------------------------------------------------- 注意：当前节点无需使用CF解析完成的域名，客户端选项的TLS选项必须关闭 --------------------------------------------------------------- 客户端必要文明参数如下： 客户端地址(address)：自定义的域名 或者 优选域名 或者 优选IP（反代IP必须与反代端口对应） 端口(port)：7个http端口可任意选择(80、8080、8880、2052、2082、2086、2095) 用户ID(uuid)：${userID} 传输协议(network)：ws 或者 websocket 伪装域名(host)：${hostName} 路径(path)：/?ed=2048 ################################################################ ################################################################ 查看CF-workers-vless+ws+tls节点配置信息，请在浏览器地址栏输入：你设置的自定义域名/你设置的UUID 防止小白过多的操作失误，必须设置自定义域名后才能使用Workers方式的TLS模式，否则，建议只使用vless+ws节点即可 提示：使用pages方式部署，联通、电信用户大概率可以直接使用TLS模式，无需设置自定义域名 pages方式部署可参考此视频教程：https://youtu.be/McdRoLZeTqg ################################################################ `; } else { return ` ==========================配置详解============================== =====使用自定义域名查看配置，请确认使用的是workers还是pages===== ################################################################ 一、CF-workers-vless+ws节点，分享链接如下： ${wvlessws} --------------------------------------------------------------- 注意：当前节点无需使用CF解析完成的域名，客户端选项的TLS选项必须关闭 --------------------------------------------------------------- 客户端必要文明参数如下： 客户端地址(address)：自定义的域名 或者 优选域名 或者 优选IP（反代IP必须与反代端口对应） 端口(port)：7个http端口可任意选择(80、8080、8880、2052、2082、2086、2095) 用户ID(uuid)：${userID} 传输协议(network)：ws 或者 websocket 伪装域名(host)：${hostName} 路径(path)：/?ed=2048 ################################################################ ################################################################ 二、CF-workers-vless+ws+tls 或者 CF-pages-vless+ws+tls节点，分享链接如下： ${pvlesswstls} --------------------------------------------------------------- 注意：客户端选项的伪装域名(host)必须改为你在CF解析完成的自定义域名 --------------------------------------------------------------- 客户端必要文明参数如下： 客户端地址(address)：自定义的域名 或者 优选域名 或者 优选IP（反代IP必须与反代端口对应） 端口(port)：6个https端口可任意选择(443、8443、2053、2083、2087、2096) 用户ID(uuid)：${userID} 传输协议(network)：ws 或者 websocket 伪装域名(host)：${hostName} 路径(path)：/?ed=2048 传输安全(TLS)：开启 跳过证书验证(allowlnsecure)：false ################################################################ `; } } const cn_hostnames = [ '' ]; \"]},\"70\":{\"h\":\"hel3 code\",\"t\":[\"hel3 代码日志 3Kmfi6HP/EDtunnel\",\"from 3Kmfi6HP/EDtunnel\",\"//注：3Kmfi6HP/EDtunnel 的脚本 2024.05.02日更新 解决10011 需要删除worker重新创建 //注： https://hel3.2961819202.workers.dev/9afa0f97-643e-4c22-8156-dfa49bfcd88b 替换自定义域： //注： https://pre.mycf2hj.top/9afa0f97-643e-4c22-8156-dfa49bfcd88b 界面挑选 //注： 此 代码 订阅器 疑似可替换？ 大概第75行 // @ts-ignore import { connect } from 'cloudflare:sockets'; // How to generate your own UUID: // [Windows] Press \\\"Win + R\\\", input cmd and run: Powershell -NoExit -Command \\\"[guid]::NewGuid()\\\" let userID = '9afa0f97-643e-4c22-8156-dfa49bfcd88b'; const พร็อกซีไอพีs = ['cdn.xn--b6gac.eu.org', 'cdn-all.xn--b6gac.eu.org', 'workers.cloudflare.cyou']; // if you want to use ipv6 or single พร็อกซีไอพี, please add comment at this line and remove comment at the next line let พร็อกซีไอพี = พร็อกซีไอพีs[Math.floor(Math.random() * พร็อกซีไอพีs.length)]; // use single พร็อกซีไอพี instead of random // let พร็อกซีไอพี = 'cdn.xn--b6gac.eu.org'; // ipv6 พร็อกซีไอพี example remove comment to use // let พร็อกซีไอพี = \\\"[2a01:4f8:c2c:123f:64:5:6810:c55a]\\\" let dohURL = 'https://sky.rethinkdns.com/1:-Pf_____9_8A_AMAIgE8kMABVDDmKOHTAKg='; // https://cloudflare-dns.com/dns-query or https://dns.google/dns-query if (!isValidUUID(userID)) { throw new Error('uuid is invalid'); } export default { /** * @param {import(\\\"@cloudflare/workers-types\\\").Request} request * @param {{UUID: string, พร็อกซีไอพี: string, DNS_RESOLVER_URL: string, NODE_ID: int, API_HOST: string, API_TOKEN: string}} env * @param {import(\\\"@cloudflare/workers-types\\\").ExecutionContext} ctx * @returns {Promise<Response>} */ async fetch(request, env, ctx) { // uuid_validator(request); try { userID = env.UUID || userID; พร็อกซีไอพี = env.พร็อกซีไอพี || พร็อกซีไอพี; dohURL = env.DNS_RESOLVER_URL || dohURL; let userID_Path = userID; if (userID.includes(',')) { userID_Path = userID.split(',')[0]; } const upgradeHeader = request.headers.get('Upgrade'); if (!upgradeHeader || upgradeHeader !== 'websocket') { const url = new URL(request.url); switch (url.pathname) { case `/cf`: { return new Response(JSON.stringify(request.cf, null, 4), { status: 200, headers: { \\\"Content-Type\\\": \\\"application/json;charset=utf-8\\\", }, }); } case `/${userID_Path}`: { const วเลสConfig = getวเลสConfig(userID, request.headers.get('Host')); return new Response(`${วเลสConfig}`, { status: 200, headers: { \\\"Content-Type\\\": \\\"text/html; charset=utf-8\\\", } }); }; case `/sub/${userID_Path}`: { const url = new URL(request.url); const searchParams = url.searchParams; const วเลสSubConfig = สร้างวเลสSub(userID, request.headers.get('Host')); // Construct and return response object return new Response(btoa(วเลสSubConfig), { status: 200, headers: { \\\"Content-Type\\\": \\\"text/plain;charset=utf-8\\\", } }); }; case `/bestip/${userID_Path}`: { const headers = request.headers; const url = `https://sub.xf.free.hr/auto?host=${request.headers.get('Host')}&uuid=${userID}&path=/`; const bestSubConfig = await fetch(url, { headers: headers }); return bestSubConfig; }; default: // return new Response('Not found', { status: 404 }); // For any other path, reverse proxy to 'ramdom website' and return the original response, caching it in the process const randomHostname = cn_hostnames[Math.floor(Math.random() * cn_hostnames.length)]; const newHeaders = new Headers(request.headers); newHeaders.set('cf-connecting-ip', '1.2.3.4'); newHeaders.set('x-forwarded-for', '1.2.3.4'); newHeaders.set('x-real-ip', '1.2.3.4'); newHeaders.set('referer', 'https://www.google.com/search?q=edtunnel'); // Use fetch to proxy the request to 15 different domains const proxyUrl = 'https://' + randomHostname + url.pathname + url.search; let modifiedRequest = new Request(proxyUrl, { method: request.method, headers: newHeaders, body: request.body, redirect: 'manual', }); const proxyResponse = await fetch(modifiedRequest, { redirect: 'manual' }); // Check for 302 or 301 redirect status and return an error response if ([301, 302].includes(proxyResponse.status)) { return new Response(`Redirects to ${randomHostname} are not allowed.`, { status: 403, statusText: 'Forbidden', }); } // Return the response from the proxy server return proxyResponse; } } else { return await วเลสOverWSHandler(request); } } catch (err) { /** @type {Error} */ let e = err; return new Response(e.toString()); } }, }; export async function uuid_validator(request) { const hostname = request.headers.get('Host'); const currentDate = new Date(); const subdomain = hostname.split('.')[0]; const year = currentDate.getFullYear(); const month = String(currentDate.getMonth() + 1).padStart(2, '0'); const day = String(currentDate.getDate()).padStart(2, '0'); const formattedDate = `${year}-${month}-${day}`; // const daliy_sub = formattedDate + subdomain const hashHex = await hashHex_f(subdomain); // subdomain string contains timestamps utc and uuid string TODO. console.log(hashHex, subdomain, formattedDate); } export async function hashHex_f(string) { const encoder = new TextEncoder(); const data = encoder.encode(string); const hashBuffer = await crypto.subtle.digest('SHA-256', data); const hashArray = Array.from(new Uint8Array(hashBuffer)); const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join(''); return hashHex; } /** * Handles วเลส over WebSocket requests by creating a WebSocket pair, accepting the WebSocket connection, and processing the วเลส header. * @param {import(\\\"@cloudflare/workers-types\\\").Request} request The incoming request object. * @returns {Promise<Response>} A Promise that resolves to a WebSocket response object. */ async function วเลสOverWSHandler(request) { const webSocketPair = new WebSocketPair(); const [client, webSocket] = Object.values(webSocketPair); webSocket.accept(); let address = ''; let portWithRandomLog = ''; let currentDate = new Date(); const log = (/** @type {string} */ info, /** @type {string | undefined} */ event) => { console.log(`[${currentDate} ${address}:${portWithRandomLog}] ${info}`, event || ''); }; const earlyDataHeader = request.headers.get('sec-websocket-protocol') || ''; const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log); /** @type {{ value: import(\\\"@cloudflare/workers-types\\\").Socket | null}}*/ let remoteSocketWapper = { value: null, }; let udpStreamWrite = null; let isDns = false; // ws --> remote readableWebSocketStream.pipeTo(new WritableStream({ async write(chunk, controller) { if (isDns && udpStreamWrite) { return udpStreamWrite(chunk); } if (remoteSocketWapper.value) { const writer = remoteSocketWapper.value.writable.getWriter() await writer.write(chunk); writer.releaseLock(); return; } const { hasError, message, portRemote = 443, addressRemote = '', rawDataIndex, วเลสVersion = new Uint8Array([0, 0]), isUDP, } = processวเลสHeader(chunk, userID); address = addressRemote; portWithRandomLog = `${portRemote} ${isUDP ? 'udp' : 'tcp'} `; if (hasError) { // controller.error(message); throw new Error(message); // cf seems has bug, controller.error will not end stream } // If UDP and not DNS port, close it if (isUDP && portRemote !== 53) { throw new Error('UDP proxy only enabled for DNS which is port 53'); // cf seems has bug, controller.error will not end stream } if (isUDP && portRemote === 53) { isDns = true; } // [\\\"version\\\", \\\"附加信息长度 N\\\"] const วเลสResponseHeader = new Uint8Array([วเลสVersion[0], 0]); const rawClientData = chunk.slice(rawDataIndex); // TODO: support udp here when cf runtime has udp support if (isDns) { const { write } = await handleUDPOutBound(webSocket, วเลสResponseHeader, log); udpStreamWrite = write; udpStreamWrite(rawClientData); return; } handleTCPOutBound(remoteSocketWapper, addressRemote, portRemote, rawClientData, webSocket, วเลสResponseHeader, log); }, close() { log(`readableWebSocketStream is close`); }, abort(reason) { log(`readableWebSocketStream is abort`, JSON.stringify(reason)); }, })).catch((err) => { log('readableWebSocketStream pipeTo error', err); }); return new Response(null, { status: 101, webSocket: client, }); } /** * Handles outbound TCP connections. * * @param {any} remoteSocket * @param {string} addressRemote The remote address to connect to. * @param {number} portRemote The remote port to connect to. * @param {Uint8Array} rawClientData The raw client data to write. * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocket The WebSocket to pass the remote socket to. * @param {Uint8Array} วเลสResponseHeader The วเลส response header. * @param {function} log The logging function. * @returns {Promise<void>} The remote socket. */ async function handleTCPOutBound(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, วเลสResponseHeader, log,) { /** * Connects to a given address and port and writes data to the socket. * @param {string} address The address to connect to. * @param {number} port The port to connect to. * @returns {Promise<import(\\\"@cloudflare/workers-types\\\").Socket>} A Promise that resolves to the connected socket. */ async function connectAndWrite(address, port) { /** @type {import(\\\"@cloudflare/workers-types\\\").Socket} */ const tcpSocket = connect({ hostname: address, port: port, }); remoteSocket.value = tcpSocket; log(`connected to ${address}:${port}`); const writer = tcpSocket.writable.getWriter(); await writer.write(rawClientData); // first write, nomal is tls client hello writer.releaseLock(); return tcpSocket; } /** * Retries connecting to the remote address and port if the Cloudflare socket has no incoming data. * @returns {Promise<void>} A Promise that resolves when the retry is complete. */ async function retry() { const tcpSocket = await connectAndWrite(พร็อกซีไอพี || addressRemote, portRemote) tcpSocket.closed.catch(error => { console.log('retry tcpSocket closed error', error); }).finally(() => { safeCloseWebSocket(webSocket); }) remoteSocketToWS(tcpSocket, webSocket, วเลสResponseHeader, null, log); } const tcpSocket = await connectAndWrite(addressRemote, portRemote); // when remoteSocket is ready, pass to websocket // remote--> ws remoteSocketToWS(tcpSocket, webSocket, วเลสResponseHeader, retry, log); } /** * Creates a readable stream from a WebSocket server, allowing for data to be read from the WebSocket. * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocketServer The WebSocket server to create the readable stream from. * @param {string} earlyDataHeader The header containing early data for WebSocket 0-RTT. * @param {(info: string)=> void} log The logging function. * @returns {ReadableStream} A readable stream that can be used to read data from the WebSocket. */ function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) { let readableStreamCancel = false; const stream = new ReadableStream({ start(controller) { webSocketServer.addEventListener('message', (event) => { const message = event.data; controller.enqueue(message); }); webSocketServer.addEventListener('close', () => { safeCloseWebSocket(webSocketServer); controller.close(); }); webSocketServer.addEventListener('error', (err) => { log('webSocketServer has error'); controller.error(err); }); const { earlyData, error } = base64ToArrayBuffer(earlyDataHeader); if (error) { controller.error(error); } else if (earlyData) { controller.enqueue(earlyData); } }, pull(controller) { // if ws can stop read if stream is full, we can implement backpressure // https://streams.spec.whatwg.org/#example-rs-push-backpressure }, cancel(reason) { log(`ReadableStream was canceled, due to ${reason}`) readableStreamCancel = true; safeCloseWebSocket(webSocketServer); } }); return stream; } // https://xtls.github.io/development/protocols/วเลส.html // https://github.com/zizifn/excalidraw-backup/blob/main/v2ray-protocol.excalidraw /** * Processes the วเลส header buffer and returns an object with the relevant information. * @param {ArrayBuffer} วเลสBuffer The วเลส header buffer to process. * @param {string} userID The user ID to validate against the UUID in the วเลส header. * @returns {{ * hasError: boolean, * message?: string, * addressRemote?: string, * addressType?: number, * portRemote?: number, * rawDataIndex?: number, * วเลสVersion?: Uint8Array, * isUDP?: boolean * }} An object with the relevant information extracted from the วเลส header buffer. */ function processวเลสHeader(วเลสBuffer, userID) { if (วเลสBuffer.byteLength < 24) { return { hasError: true, message: 'invalid data', }; } const version = new Uint8Array(วเลสBuffer.slice(0, 1)); let isValidUser = false; let isUDP = false; const slicedBuffer = new Uint8Array(วเลสBuffer.slice(1, 17)); const slicedBufferString = stringify(slicedBuffer); // check if userID is valid uuid or uuids split by , and contains userID in it otherwise return error message to console const uuids = userID.includes(',') ? userID.split(\\\",\\\") : [userID]; // uuid_validator(hostName, slicedBufferString); // isValidUser = uuids.some(userUuid => slicedBufferString === userUuid.trim()); isValidUser = uuids.some(userUuid => slicedBufferString === userUuid.trim()) || uuids.length === 1 && slicedBufferString === uuids[0].trim(); console.log(`userID: ${slicedBufferString}`); if (!isValidUser) { return { hasError: true, message: 'invalid user', }; } const optLength = new Uint8Array(วเลสBuffer.slice(17, 18))[0]; //skip opt for now const command = new Uint8Array( วเลสBuffer.slice(18 + optLength, 18 + optLength + 1) )[0]; // 0x01 TCP // 0x02 UDP // 0x03 MUX if (command === 1) { isUDP = false; } else if (command === 2) { isUDP = true; } else { return { hasError: true, message: `command ${command} is not support, command 01-tcp,02-udp,03-mux`, }; } const portIndex = 18 + optLength + 1; const portBuffer = วเลสBuffer.slice(portIndex, portIndex + 2); // port is big-Endian in raw data etc 80 == 0x005d const portRemote = new DataView(portBuffer).getUint16(0); let addressIndex = portIndex + 2; const addressBuffer = new Uint8Array( วเลสBuffer.slice(addressIndex, addressIndex + 1) ); // 1--> ipv4 addressLength =4 // 2--> domain name addressLength=addressBuffer[1] // 3--> ipv6 addressLength =16 const addressType = addressBuffer[0]; let addressLength = 0; let addressValueIndex = addressIndex + 1; let addressValue = ''; switch (addressType) { case 1: addressLength = 4; addressValue = new Uint8Array( วเลสBuffer.slice(addressValueIndex, addressValueIndex + addressLength) ).join('.'); break; case 2: addressLength = new Uint8Array( วเลสBuffer.slice(addressValueIndex, addressValueIndex + 1) )[0]; addressValueIndex += 1; addressValue = new TextDecoder().decode( วเลสBuffer.slice(addressValueIndex, addressValueIndex + addressLength) ); break; case 3: addressLength = 16; const dataView = new DataView( วเลสBuffer.slice(addressValueIndex, addressValueIndex + addressLength) ); // 2001:0db8:85a3:0000:0000:8a2e:0370:7334 const ipv6 = []; for (let i = 0; i < 8; i++) { ipv6.push(dataView.getUint16(i * 2).toString(16)); } addressValue = ipv6.join(':'); // seems no need add [] for ipv6 break; default: return { hasError: true, message: `invild addressType is ${addressType}`, }; } if (!addressValue) { return { hasError: true, message: `addressValue is empty, addressType is ${addressType}`, }; } return { hasError: false, addressRemote: addressValue, addressType, portRemote, rawDataIndex: addressValueIndex + addressLength, วเลสVersion: version, isUDP, }; } /** * Converts a remote socket to a WebSocket connection. * @param {import(\\\"@cloudflare/workers-types\\\").Socket} remoteSocket The remote socket to convert. * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocket The WebSocket to connect to. * @param {ArrayBuffer | null} วเลสResponseHeader The วเลส response header. * @param {(() => Promise<void>) | null} retry The function to retry the connection if it fails. * @param {(info: string) => void} log The logging function. * @returns {Promise<void>} A Promise that resolves when the conversion is complete. */ async function remoteSocketToWS(remoteSocket, webSocket, วเลสResponseHeader, retry, log) { // remote--> ws let remoteChunkCount = 0; let chunks = []; /** @type {ArrayBuffer | null} */ let วเลสHeader = วเลสResponseHeader; let hasIncomingData = false; // check if remoteSocket has incoming data await remoteSocket.readable .pipeTo( new WritableStream({ start() { }, /** * * @param {Uint8Array} chunk * @param {*} controller */ async write(chunk, controller) { hasIncomingData = true; remoteChunkCount++; if (webSocket.readyState !== WS_READY_STATE_OPEN) { controller.error( 'webSocket.readyState is not open, maybe close' ); } if (วเลสHeader) { webSocket.send(await new Blob([วเลสHeader, chunk]).arrayBuffer()); วเลสHeader = null; } else { // console.log(`remoteSocketToWS send chunk ${chunk.byteLength}`); // seems no need rate limit this, CF seems fix this??.. // if (remoteChunkCount > 20000) { // // cf one package is 4096 byte(4kb), 4096 * 20000 = 80M // await delay(1); // } webSocket.send(chunk); } }, close() { log(`remoteConnection!.readable is close with hasIncomingData is ${hasIncomingData}`); // safeCloseWebSocket(webSocket); // no need server close websocket frist for some case will casue HTTP ERR_CONTENT_LENGTH_MISMATCH issue, client will send close event anyway. }, abort(reason) { console.error(`remoteConnection!.readable abort`, reason); }, }) ) .catch((error) => { console.error( `remoteSocketToWS has exception `, error.stack || error ); safeCloseWebSocket(webSocket); }); // seems is cf connect socket have error, // 1. Socket.closed will have error // 2. Socket.readable will be close without any data coming if (hasIncomingData === false && retry) { log(`retry`) retry(); } } /** * Decodes a base64 string into an ArrayBuffer. * @param {string} base64Str The base64 string to decode. * @returns {{earlyData: ArrayBuffer|null, error: Error|null}} An object containing the decoded ArrayBuffer or null if there was an error, and any error that occurred during decoding or null if there was no error. */ function base64ToArrayBuffer(base64Str) { if (!base64Str) { return { earlyData: null, error: null }; } try { // go use modified Base64 for URL rfc4648 which js atob not support base64Str = base64Str.replace(/-/g, '+').replace(/_/g, '/'); const decode = atob(base64Str); const arryBuffer = Uint8Array.from(decode, (c) => c.charCodeAt(0)); return { earlyData: arryBuffer.buffer, error: null }; } catch (error) { return { earlyData: null, error }; } } /** * Checks if a given string is a valid UUID. * Note: This is not a real UUID validation. * @param {string} uuid The string to validate as a UUID. * @returns {boolean} True if the string is a valid UUID, false otherwise. */ function isValidUUID(uuid) { const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i; return uuidRegex.test(uuid); } const WS_READY_STATE_OPEN = 1; const WS_READY_STATE_CLOSING = 2; /** * Closes a WebSocket connection safely without throwing exceptions. * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} socket The WebSocket connection to close. */ function safeCloseWebSocket(socket) { try { if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) { socket.close(); } } catch (error) { console.error('safeCloseWebSocket error', error); } } const byteToHex = []; for (let i = 0; i < 256; ++i) { byteToHex.push((i + 256).toString(16).slice(1)); } function unsafeStringify(arr, offset = 0) { return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \\\"-\\\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \\\"-\\\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \\\"-\\\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \\\"-\\\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); } function stringify(arr, offset = 0) { const uuid = unsafeStringify(arr, offset); if (!isValidUUID(uuid)) { throw TypeError(\\\"Stringified UUID is invalid\\\"); } return uuid; } /** * Handles outbound UDP traffic by transforming the data into DNS queries and sending them over a WebSocket connection. * @param {import(\\\"@cloudflare/workers-types\\\").WebSocket} webSocket The WebSocket connection to send the DNS queries over. * @param {ArrayBuffer} วเลสResponseHeader The วเลส response header. * @param {(string) => void} log The logging function. * @returns {{write: (chunk: Uint8Array) => void}} An object with a write method that accepts a Uint8Array chunk to write to the transform stream. */ async function handleUDPOutBound(webSocket, วเลสResponseHeader, log) { let isวเลสHeaderSent = false; const transformStream = new TransformStream({ start(controller) { }, transform(chunk, controller) { // udp message 2 byte is the the length of udp data // TODO: this should have bug, beacsue maybe udp chunk can be in two websocket message for (let index = 0; index < chunk.byteLength;) { const lengthBuffer = chunk.slice(index, index + 2); const udpPakcetLength = new DataView(lengthBuffer).getUint16(0); const udpData = new Uint8Array( chunk.slice(index + 2, index + 2 + udpPakcetLength) ); index = index + 2 + udpPakcetLength; controller.enqueue(udpData); } }, flush(controller) { } }); // only handle dns udp for now transformStream.readable.pipeTo(new WritableStream({ async write(chunk) { const resp = await fetch(dohURL, // dns server url { method: 'POST', headers: { 'content-type': 'application/dns-message', }, body: chunk, }) const dnsQueryResult = await resp.arrayBuffer(); const udpSize = dnsQueryResult.byteLength; // console.log([...new Uint8Array(dnsQueryResult)].map((x) => x.toString(16))); const udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]); if (webSocket.readyState === WS_READY_STATE_OPEN) { log(`doh success and dns message length is ${udpSize}`); if (isวเลสHeaderSent) { webSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer()); } else { webSocket.send(await new Blob([วเลสResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer()); isวเลสHeaderSent = true; } } } })).catch((error) => { log('dns udp has error' + error) }); const writer = transformStream.writable.getWriter(); return { /** * * @param {Uint8Array} chunk */ write(chunk) { writer.write(chunk); } }; } const at = 'QA=='; const pt = 'dmxlc3M='; const ed = 'RUR0dW5uZWw='; /** * * @param {string} userID - single or comma separated userIDs * @param {string | null} hostName * @returns {string} */ function getวเลสConfig(userIDs, hostName) { const commonUrlPart = `:443?encryption=none&security=tls&sni=${hostName}&fp=randomized&type=ws&host=${hostName}&path=%2F%3Fed%3D2048#${hostName}`; const hashSeparator = \\\"################################################################\\\"; // Split the userIDs into an array const userIDArray = userIDs.split(\\\",\\\"); // Prepare output string for each userID const output = userIDArray.map((userID) => { const วเลสMain = atob(pt) + '://' + userID + atob(at) + hostName + commonUrlPart; const วเลสSec = atob(pt) + '://' + userID + atob(at) + พร็อกซีไอพี + commonUrlPart; return `<h2>UUID: ${userID}</h2>${hashSeparator}\\\\nv2ray default ip --------------------------------------------------------------- ${วเลสMain} <button onclick='copyToClipboard(\\\"${วเลสMain}\\\")'><i class=\\\"fa fa-clipboard\\\"></i> Copy วเลสMain</button> --------------------------------------------------------------- v2ray with bestip --------------------------------------------------------------- ${วเลสSec} <button onclick='copyToClipboard(\\\"${วเลสSec}\\\")'><i class=\\\"fa fa-clipboard\\\"></i> Copy วเลสSec</button> ---------------------------------------------------------------`; }).join('\\\\n'); const sublink = `https://${hostName}/sub/${userIDArray[0]}?format=clash` const subbestip = `https://${hostName}/bestip/${userIDArray[0]}`; const clash_link = `https://api.v1.mk/sub?target=clash&url=${encodeURIComponent(sublink)}&insert=false&emoji=true&list=false&tfo=false&scv=true&fdn=false&sort=false&new_name=true`; // Prepare header string const header = ` <p align='center'><img src='https://cloudflare-ipfs.com/ipfs/bafybeigd6i5aavwpr6wvnwuyayklq3omonggta4x2q7kpmgafj357nkcky' alt='图片描述' style='margin-bottom: -50px;'> <b style='font-size: 15px;'>Welcome! This function generates configuration for วเลส protocol. If you found this useful, please check our GitHub project for more:</b> <b style='font-size: 15px;'>欢迎！这是生成 วเลส 协议的配置。如果您发现这个项目很好用，请查看我们的 GitHub 项目给我一个star：</b> <a href='https://github.com/3Kmfi6HP/EDtunnel' target='_blank'>EDtunnel - https://github.com/3Kmfi6HP/EDtunnel</a> <iframe src='https://ghbtns.com/github-btn.html?user=USERNAME&repo=REPOSITORY&type=star&count=true&size=large' frameborder='0' scrolling='0' width='170' height='30' title='GitHub'></iframe> <a href='//${hostName}/sub/${userIDArray[0]}' target='_blank'>วเลส 节点订阅连接</a> <a href='clash://install-config?url=${encodeURIComponent(`https://${hostName}/sub/${userIDArray[0]}?format=clash`)}}' target='_blank'>Clash for Windows 节点订阅连接</a> <a href='${clash_link}' target='_blank'>Clash 节点订阅连接</a> <a href='${subbestip}' target='_blank'>优选IP自动节点订阅</a> <a href='clash://install-config?url=${encodeURIComponent(subbestip)}' target='_blank'>Clash优选IP自动</a> <a href='sing-box://import-remote-profile?url=${encodeURIComponent(subbestip)}' target='_blank'>singbox优选IP自动</a> <a href='sn://subscription?url=${encodeURIComponent(subbestip)}' target='_blank'>nekobox优选IP自动</a> <a href='v2rayng://install-config?url=${encodeURIComponent(subbestip)}' target='_blank'>v2rayNG优选IP自动</a></p>`; // HTML Head with CSS and FontAwesome library const htmlHead = ` <head> <title>EDtunnel: วเลส configuration</title> <meta name='description' content='This is a tool for generating วเลส protocol configurations. Give us a star on GitHub https://github.com/3Kmfi6HP/EDtunnel if you found it useful!'> <meta name='keywords' content='EDtunnel, cloudflare pages, cloudflare worker, severless'> <meta name='viewport' content='width=device-width, initial-scale=1'> <meta property='og:site_name' content='EDtunnel: วเลส configuration' /> <meta property='og:type' content='website' /> <meta property='og:title' content='EDtunnel - วเลส configuration and subscribe output' /> <meta property='og:description' content='Use cloudflare pages and worker severless to implement วเลส protocol' /> <meta property='og:url' content='https://${hostName}/' /> <meta property='og:image' content='https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${encodeURIComponent(`วเลส://${userIDs.split(\\\",\\\")[0]}@${hostName}${commonUrlPart}`)}' /> <meta name='twitter:card' content='summary_large_image' /> <meta name='twitter:title' content='EDtunnel - วเลส configuration and subscribe output' /> <meta name='twitter:description' content='Use cloudflare pages and worker severless to implement วเลส protocol' /> <meta name='twitter:url' content='https://${hostName}/' /> <meta name='twitter:image' content='https://cloudflare-ipfs.com/ipfs/bafybeigd6i5aavwpr6wvnwuyayklq3omonggta4x2q7kpmgafj357nkcky' /> <meta property='og:image:width' content='1500' /> <meta property='og:image:height' content='1500' /> <style> body { font-family: Arial, sans-serif; background-color: #f0f0f0; color: #333; padding: 10px; } a { color: #1a0dab; text-decoration: none; } img { max-width: 100%; height: auto; } pre { white-space: pre-wrap; word-wrap: break-word; background-color: #fff; border: 1px solid #ddd; padding: 15px; margin: 10px 0; } /* Dark mode */ @media (prefers-color-scheme: dark) { body { background-color: #333; color: #f0f0f0; } a { color: #9db4ff; } pre { background-color: #282a36; border-color: #6272a4; } } </style> <!-- Add FontAwesome library --> <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css'> </head> `; // Join output with newlines, wrap inside <html> and <body> return ` <html> ${htmlHead} <body> <pre style='background-color: transparent; border: none;'>${header}</pre> <pre>${output}</pre> </body> <script> function copyToClipboard(text) { navigator.clipboard.writeText(text) .then(() => { alert(\\\"Copied to clipboard\\\"); }) .catch((err) => { console.error(\\\"Failed to copy to clipboard:\\\", err); }); } </script> </html>`; } const เซ็ตพอร์ตHttp = new Set([80, 8080, 8880, 2052, 2086, 2095, 2082]); const เซ็ตพอร์ตHttps = new Set([443, 8443, 2053, 2096, 2087, 2083]); function สร้างวเลสSub(ไอดีผู้ใช้_เส้นทาง, ชื่อโฮสต์) { const อาร์เรย์ไอดีผู้ใช้ = ไอดีผู้ใช้_เส้นทาง.includes(',') ? ไอดีผู้ใช้_เส้นทาง.split(',') : [ไอดีผู้ใช้_เส้นทาง]; const ส่วนUrlทั่วไปHttp = `?encryption=none&security=none&fp=random&type=ws&host=${ชื่อโฮสต์}&path=%2F%3Fed%3D2048#`; const ส่วนUrlทั่วไปHttps = `?encryption=none&security=tls&sni=${ชื่อโฮสต์}&fp=random&type=ws&host=${ชื่อโฮสต์}&path=%2F%3Fed%3D2048#`; const ผลลัพธ์ = อาร์เรย์ไอดีผู้ใช้.flatMap((ไอดีผู้ใช้) => { const การกำหนดค่าHttp = Array.from(เซ็ตพอร์ตHttp).flatMap((พอร์ต) => { if (!ชื่อโฮสต์.includes('pages.dev')) { const ส่วนUrl = `${ชื่อโฮสต์}-HTTP-${พอร์ต}`; const วเลสหลักHttp = atob(pt) + '://' + ไอดีผู้ใช้ + atob(at) + ชื่อโฮสต์ + ':' + พอร์ต + ส่วนUrlทั่วไปHttp + ส่วนUrl; return พร็อกซีไอพีs.flatMap((พร็อกซีไอพี) => { const วเลสรองHttp = atob(pt) + '://' + ไอดีผู้ใช้ + atob(at) + พร็อกซีไอพี + ':' + พอร์ต + ส่วนUrlทั่วไปHttp + ส่วนUrl + '-' + พร็อกซีไอพี + '-' + atob(ed); return [วเลสหลักHttp, วเลสรองHttp]; }); } return []; }); const การกำหนดค่าHttps = Array.from(เซ็ตพอร์ตHttps).flatMap((พอร์ต) => { const ส่วนUrl = `${ชื่อโฮสต์}-HTTPS-${พอร์ต}`; const วเลสหลักHttps = atob(pt) + '://' + ไอดีผู้ใช้ + atob(at) + ชื่อโฮสต์ + ':' + พอร์ต + ส่วนUrlทั่วไปHttps + ส่วนUrl; return พร็อกซีไอพีs.flatMap((พร็อกซีไอพี) => { const วเลสรองHttps = atob(pt) + '://' + ไอดีผู้ใช้ + atob(at) + พร็อกซีไอพี + ':' + พอร์ต + ส่วนUrlทั่วไปHttps + ส่วนUrl + '-' + พร็อกซีไอพี + '-' + atob(ed); return [วเลสหลักHttps, วเลสรองHttps]; }); }); return [...การกำหนดค่าHttp, ...การกำหนดค่าHttps]; }); return ผลลัพธ์.join('\\\\n'); } const cn_hostnames = [ 'weibo.com', // Weibo - A popular social media platform 'www.baidu.com', // Baidu - The largest search engine in China 'www.qq.com', // QQ - A widely used instant messaging platform 'www.taobao.com', // Taobao - An e-commerce website owned by Alibaba Group 'www.jd.com', // JD.com - One of the largest online retailers in China 'www.sina.com.cn', // Sina - A Chinese online media company 'www.sohu.com', // Sohu - A Chinese internet service provider 'www.tmall.com', // Tmall - An online retail platform owned by Alibaba Group 'www.163.com', // NetEase Mail - One of the major email providers in China 'www.zhihu.com', // Zhihu - A popular question-and-answer website 'www.youku.com', // Youku - A Chinese video sharing platform 'www.xinhuanet.com', // Xinhua News Agency - Official news agency of China 'www.douban.com', // Douban - A Chinese social networking service 'www.meituan.com', // Meituan - A Chinese group buying website for local services 'www.toutiao.com', // Toutiao - A news and information content platform 'www.ifeng.com', // iFeng - A popular news website in China 'www.autohome.com.cn', // Autohome - A leading Chinese automobile online platform 'www.360.cn', // 360 - A Chinese internet security company 'www.douyin.com', // Douyin - A Chinese short video platform 'www.kuaidi100.com', // Kuaidi100 - A Chinese express delivery tracking service 'www.wechat.com', // WeChat - A popular messaging and social media app 'www.csdn.net', // CSDN - A Chinese technology community website 'www.imgo.tv', // ImgoTV - A Chinese live streaming platform 'www.aliyun.com', // Alibaba Cloud - A Chinese cloud computing company 'www.eyny.com', // Eyny - A Chinese multimedia resource-sharing website 'www.mgtv.com', // MGTV - A Chinese online video platform 'www.xunlei.com', // Xunlei - A Chinese download manager and torrent client 'www.hao123.com', // Hao123 - A Chinese web directory service 'www.bilibili.com', // Bilibili - A Chinese video sharing and streaming platform 'www.youth.cn', // Youth.cn - A China Youth Daily news portal 'www.hupu.com', // Hupu - A Chinese sports community and forum 'www.youzu.com', // Youzu Interactive - A Chinese game developer and publisher 'www.panda.tv', // Panda TV - A Chinese live streaming platform 'www.tudou.com', // Tudou - A Chinese video-sharing website 'www.zol.com.cn', // ZOL - A Chinese electronics and gadgets website 'www.toutiao.io', // Toutiao - A news and information app 'www.tiktok.com', // TikTok - A Chinese short-form video app 'www.netease.com', // NetEase - A Chinese internet technology company 'www.cnki.net', // CNKI - China National Knowledge Infrastructure, an information aggregator 'www.zhibo8.cc', // Zhibo8 - A website providing live sports streams 'www.zhangzishi.cc', // Zhangzishi - Personal website of Zhang Zishi, a public intellectual in China 'www.xueqiu.com', // Xueqiu - A Chinese online social platform for investors and traders 'www.qqgongyi.com', // QQ Gongyi - Tencent's charitable foundation platform 'www.ximalaya.com', // Ximalaya - A Chinese online audio platform 'www.dianping.com', // Dianping - A Chinese online platform for finding and reviewing local businesses 'www.suning.com', // Suning - A leading Chinese online retailer 'www.zhaopin.com', // Zhaopin - A Chinese job recruitment platform 'www.jianshu.com', // Jianshu - A Chinese online writing platform 'www.mafengwo.cn', // Mafengwo - A Chinese travel information sharing platform 'www.51cto.com', // 51CTO - A Chinese IT technical community website 'www.qidian.com', // Qidian - A Chinese web novel platform 'www.ctrip.com', // Ctrip - A Chinese travel services provider 'www.pconline.com.cn', // PConline - A Chinese technology news and review website 'www.cnzz.com', // CNZZ - A Chinese web analytics service provider 'www.telegraph.co.uk', // The Telegraph - A British newspaper website 'www.ynet.com', // Ynet - A Chinese news portal 'www.ted.com', // TED - A platform for ideas worth spreading 'www.renren.com', // Renren - A Chinese social networking service 'www.pptv.com', // PPTV - A Chinese online video streaming platform 'www.liepin.com', // Liepin - A Chinese online recruitment website 'www.881903.com', // 881903 - A Hong Kong radio station website 'www.aipai.com', // Aipai - A Chinese online video sharing platform 'www.ttpaihang.com', // Ttpaihang - A Chinese celebrity popularity ranking website 'www.quyaoya.com', // Quyaoya - A Chinese online ticketing platform 'www.91.com', // 91.com - A Chinese software download website 'www.dianyou.cn', // Dianyou - A Chinese game information website 'www.tmtpost.com', // TMTPost - A Chinese technology media platform 'www.douban.com', // Douban - A Chinese social networking service 'www.guancha.cn', // Guancha - A Chinese news and commentary website 'www.so.com', // So.com - A Chinese search engine 'www.58.com', // 58.com - A Chinese classified advertising website 'www.cnblogs.com', // Cnblogs - A Chinese technology blog community 'www.cntv.cn', // CCTV - China Central Television official website 'www.secoo.com', // Secoo - A Chinese luxury e-commerce platform ]; \"]},\"71\":{\"h\":\"hel4 code\",\"t\":[\"hel4 代码日志 cmliu/WorkerVless2sub\",\"from cmliu/WorkerVless2sub\",\"//注： cmliu/WorkerVless2sub 的脚本 2024.05.02日更新 无10011错误 无uuid项 //注： https://hel4.2961819202.workers.dev/auto 直接出现vless节点码， 可绑定自定义域 // 部署完成后在网址后面加上这个，获取订阅器默认节点，/auto let mytoken= ['auto'];//快速订阅访问入口, 留空则不启动快速订阅 // 设置优选地址，不带端口号默认443，TLS订阅生成 let addresses = [ 'icook.tw:2053#官方优选域名', 'cloudflare.cfgo.cc#优选官方线路', 'sp.rweek.top:80#从hel2copy的优选线路', 'ali.055500.xyz:80#从hel2copy的优选线路', ]; // 设置优选地址api接口 let addressesapi = [ 'https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesapi.txt', //可参考内容格式 自行搭建。 //'https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesipv6api.txt', //IPv6优选内容格式 自行搭建。 ]; // 设置优选地址，不带端口号默认80，noTLS订阅生成 let addressesnotls = [ 'www.visa.com.sg#官方优选域名', 'www.wto.org:8080#官方优选域名', 'www.who.int:8880#官方优选域名', ]; // 设置优选noTLS地址api接口 let addressesnotlsapi = [ 'https://raw.githubusercontent.com/cmliu/CFcdnVmess2sub/main/addressesapi.txt', //可参考内容格式 自行搭建。 ]; let DLS = 8;//速度下限 let addressescsv = [ //'https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressescsv.csv', //iptest测速结果文件。 ]; let subconverter = \\\"apiurl.v1.mk\\\"; //在线订阅转换后端，目前使用肥羊的订阅转换功能。支持自建psub 可自行搭建https://github.com/bulianglin/psub let subconfig = \\\"https://raw.githubusercontent.com/cmliu/ACL4SSR/main/Clash/config/ACL4SSR_Online_Full_MultiMode.ini\\\"; //订阅转换配置文件 let noTLS = false; //改为 true , 将不做域名判断 始终返回noTLS节点 let link = ''; let edgetunnel = 'ed'; let RproxyIP = 'false'; let proxyIPs = [ 'proxyip.aliyun.fxxk.dedyn.io', 'proxyip.multacom.fxxk.dedyn.io', 'proxyip.vultr.fxxk.dedyn.io', ]; let CMproxyIPs = [ //{ proxyIP: \\\"proxyip.fxxk.dedyn.io\\\", type: \\\"HK\\\" }, ]; let BotToken =''; let ChatID =''; let proxyhosts = [//本地代理域名池 //'ppfv2tl9veojd-maillazy.pages.dev', ]; let proxyhostsURL = 'https://raw.githubusercontent.com/cmliu/CFcdnVmess2sub/main/proxyhosts';//在线代理域名池URL let EndPS = '';//节点名备注内容 let FileName = 'WorkerVless2sub'; let SUBUpdateTime = 6; let total = 99;//PB //let timestamp = now; let timestamp = 4102329600000;//2099-12-31 const regex = /^(\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}|\\\\[.*\\\\]):?(\\\\d+)?#?(.*)?$/; async function sendMessage(type, ip, add_data = \\\"\\\") { if ( BotToken !== '' && ChatID !== ''){ let msg = \\\"\\\"; const response = await fetch(`http://ip-api.com/json/${ip}?lang=zh-CN`); if (response.status == 200) { const ipInfo = await response.json(); msg = `${type}\\\\nIP: ${ip}\\\\n国家: ${ipInfo.country}\\\\n<tg-spoiler>城市: ${ipInfo.city}\\\\n组织: ${ipInfo.org}\\\\nASN: ${ipInfo.as}\\\\n${add_data}`; } else { msg = `${type}\\\\nIP: ${ip}\\\\n<tg-spoiler>${add_data}`; } let url = \\\"https://api.telegram.org/bot\\\"+ BotToken +\\\"/sendMessage?chat_id=\\\" + ChatID + \\\"&parse_mode=HTML&text=\\\" + encodeURIComponent(msg); return fetch(url, { method: 'get', headers: { 'Accept': 'text/html,application/xhtml+xml,application/xml;', 'Accept-Encoding': 'gzip, deflate, br', 'User-Agent': 'Mozilla/5.0 Chrome/90.0.4430.72' } }); } } let MamaJustKilledAMan = ['telegram','twitter','miaoko']; async function getAddressesapi(api) { if (!api || api.length === 0) { return []; } let newapi = \\\"\\\"; // 创建一个AbortController对象，用于控制fetch请求的取消 const controller = new AbortController(); const timeout = setTimeout(() => { controller.abort(); // 取消所有请求 }, 2000); // 2秒后触发 try { // 使用Promise.allSettled等待所有API请求完成，无论成功或失败 // 对api数组进行遍历，对每个API地址发起fetch请求 const responses = await Promise.allSettled(api.map(apiUrl => fetch(apiUrl, { method: 'get', headers: { 'Accept': 'text/html,application/xhtml+xml,application/xml;', 'User-Agent': 'cmliu/WorkerVless2sub' }, signal: controller.signal // 将AbortController的信号量添加到fetch请求中，以便于需要时可以取消请求 }).then(response => response.ok ? response.text() : Promise.reject()))); // 遍历所有响应 for (const response of responses) { // 检查响应状态是否为'fulfilled'，即请求成功完成 if (response.status === 'fulfilled') { // 获取响应的内容 const content = await response.value; newapi += content + '\\\\n'; } } } catch (error) { console.error(error); } finally { // 无论成功或失败，最后都清除设置的超时定时器 clearTimeout(timeout); } const newAddressesapi = await ADD(newapi); // 返回处理后的结果 return newAddressesapi; } async function getAddressescsv(tls) { if (!addressescsv || addressescsv.length === 0) { return []; } let newAddressescsv = []; for (const csvUrl of addressescsv) { try { const response = await fetch(csvUrl); if (!response.ok) { console.error('获取CSV地址时出错:', response.status, response.statusText); continue; } const text = await response.text();// 使用正确的字符编码解析文本内容 let lines; if (text.includes('\\\\r\\\\n')){ lines = text.split('\\\\r\\\\n'); } else { lines = text.split('\\\\n'); } // 检查CSV头部是否包含必需字段 const header = lines[0].split(','); const tlsIndex = header.indexOf('TLS'); const speedIndex = header.length - 1; // 最后一个字段 const ipAddressIndex = 0;// IP地址在 CSV 头部的位置 const portIndex = 1;// 端口在 CSV 头部的位置 const dataCenterIndex = tlsIndex + 1; // 数据中心是 TLS 的后一个字段 if (tlsIndex === -1) { console.error('CSV文件缺少必需的字段'); continue; } // 从第二行开始遍历CSV行 for (let i = 1; i < lines.length; i++) { const columns = lines[i].split(','); // 检查TLS是否为\\\"TRUE\\\"且速度大于DLS if (columns[tlsIndex].toUpperCase() === tls && parseFloat(columns[speedIndex]) > DLS) { const ipAddress = columns[ipAddressIndex]; const port = columns[portIndex]; const dataCenter = columns[dataCenterIndex]; const formattedAddress = `${ipAddress}:${port}#${dataCenter}`; newAddressescsv.push(formattedAddress); } } } catch (error) { console.error('获取CSV地址时出错:', error); continue; } } return newAddressescsv; } async function ADD(envadd) { var addtext = envadd.replace(/[ |\\\"'\\\\r\\\\n]+/g, ',').replace(/,+/g, ','); // 将空格、双引号、单引号和换行符替换为逗号 //console.log(addtext); if (addtext.charAt(0) == ',') addtext = addtext.slice(1); if (addtext.charAt(addtext.length -1) == ',') addtext = addtext.slice(0, addtext.length - 1); const add = addtext.split(','); //console.log(add); return add ; } async function nginx() { const text = ` <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href=\\\"http://nginx.org/\\\">nginx.org</a>.<br/> Commercial support is available at <a href=\\\"http://nginx.com/\\\">nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html> ` return text ; } let protocol; export default { async fetch (request, env) { if (env.TOKEN) mytoken = await ADD(env.TOKEN); //mytoken = env.TOKEN.split(',') || mytoken; BotToken = env.TGTOKEN || BotToken; ChatID = env.TGID || ChatID; subconverter = env.SUBAPI || subconverter; subconfig = env.SUBCONFIG || subconfig; FileName = env.SUBNAME || FileName; EndPS = env.PS || EndPS; const userAgentHeader = request.headers.get('User-Agent'); const userAgent = userAgentHeader ? userAgentHeader.toLowerCase() : \\\"null\\\"; const url = new URL(request.url); const format = url.searchParams.get('format') ? url.searchParams.get('format').toLowerCase() : \\\"null\\\"; let host = \\\"\\\"; let uuid = \\\"\\\"; let path = \\\"\\\"; let sni = \\\"\\\"; let UD = Math.floor(((timestamp - Date.now())/timestamp * 99 * 1099511627776 * 1024)/2); if (env.UA) MamaJustKilledAMan = MamaJustKilledAMan.concat(await ADD(env.UA)); total = total * 1099511627776 * 1024; let expire= Math.floor(timestamp / 1000) ; link = env.LINK || link; const links = await ADD(link); link = links.join('\\\\n'); if (env.ADD) addresses = await ADD(env.ADD); if (env.ADDAPI) addressesapi = await ADD(env.ADDAPI); if (env.ADDNOTLS) addressesnotls = await ADD(env.ADDNOTLS); if (env.ADDNOTLSAPI) addressesnotlsapi = await ADD(env.ADDNOTLSAPI); if (env.ADDCSV) addressescsv = await ADD(env.ADDCSV); DLS = env.DLS || DLS; /* console.log(` addresses: ${addresses} addressesapi: ${addressesapi} addressesnotls: ${addressesnotls} addressesnotlsapi: ${addressesnotlsapi} addressescsv: ${addressescsv} DLS: ${DLS} `); */ if (env.PROXYIP) proxyIPs = await ADD(env.PROXYIP); //console.log(proxyIPs); if (mytoken.length > 0 && mytoken.some(token => url.pathname.includes(token))) { host = \\\"null\\\"; if (env.HOST) { const hosts = await ADD(env.HOST); host = hosts[Math.floor(Math.random() * hosts.length)]; } uuid = env.UUID || \\\"null\\\"; path = env.PATH || \\\"/?ed=2560\\\"; sni = env.SNI || host; edgetunnel = env.ED || edgetunnel; RproxyIP = env.RPROXYIP || RproxyIP; if (host == \\\"null\\\" || uuid == \\\"null\\\" ){ let 空字段; if (host == \\\"null\\\" && uuid == \\\"null\\\") 空字段 = \\\"HOST/UUID\\\"; else if (host == \\\"null\\\") 空字段 = \\\"HOST\\\"; else if (uuid == \\\"null\\\") 空字段 = \\\"UUID\\\"; EndPS += ` 订阅器内置节点 ${空字段} 未设置！！！`; } const hasSos = url.searchParams.has('sos'); if (hasSos) { const hy2Url = \\\"https://hy2sub.pages.dev\\\"; try { const subconverterResponse = await fetch(hy2Url); if (!subconverterResponse.ok) { throw new Error(`Error fetching lzUrl: ${subconverterResponse.status} ${subconverterResponse.statusText}`); } const base64Text = await subconverterResponse.text(); link += '\\\\n' + atob(base64Text); // 进行 Base64 解码 } catch (error) { // 错误处理 } } await sendMessage(\\\"#获取订阅\\\", request.headers.get('CF-Connecting-IP'), `UA: ${userAgentHeader}</tg-spoiler>\\\\n域名: ${url.hostname}\\\\n<tg-spoiler>入口: ${url.pathname + url.search}</tg-spoiler>`); } else { host = url.searchParams.get('host'); uuid = url.searchParams.get('uuid'); path = url.searchParams.get('path'); sni = url.searchParams.get('sni') || host; edgetunnel = url.searchParams.get('edgetunnel') || edgetunnel; RproxyIP = url.searchParams.get('proxyip') || RproxyIP; if (!url.pathname.includes(\\\"/sub\\\")) { //首页改成一个nginx伪装页 return new Response(await nginx(), { headers: { 'Content-Type': 'text/html; charset=UTF-8', }, }); } if (!host || !uuid) { const responseText = ` 缺少必填参数：host 和 uuid Missing required parameters: host and uuid پارامترهای ضروری وارد نشده: هاست و یوآی‌دی ${url.origin}/sub?host=[your host]&uuid=[your uuid]&path=[your path] https://github.com/cmliu/WorkerVless2sub `; return new Response(responseText, { status: 400, headers: { 'content-type': 'text/plain; charset=utf-8' }, }); } if (!path || path.trim() === '') { path = '/?ed=2560'; } else { // 如果第一个字符不是斜杠，则在前面添加一个斜杠 path = (path[0] === '/') ? path : '/' + path; } } noTLS = host.toLowerCase().includes('notls') || host.toLowerCase().includes('worker') || host.toLowerCase().includes('trycloudflare') || noTLS; if(env.NOTLS == 'true')noTLS = true; if (!userAgent.includes('subconverter') && MamaJustKilledAMan.some(PutAGunAgainstHisHeadPulledMyTriggerNowHesDead => userAgent.includes(PutAGunAgainstHisHeadPulledMyTriggerNowHesDead)) && MamaJustKilledAMan.length > 0) { //首页改成一个nginx伪装页 return new Response(await nginx(), { headers: { 'Content-Type': 'text/html; charset=UTF-8', }, }); } else if ( (userAgent.includes('clash') || (format === 'clash' && !userAgent.includes('subconverter')) ) && !userAgent.includes('nekobox') && !userAgent.includes('cf-workers-sub')) { const subconverterUrl = `https://${subconverter}/sub?target=clash&url=${encodeURIComponent(request.url)}&insert=false&config=${encodeURIComponent(subconfig)}&emoji=true&list=false&tfo=false&scv=true&fdn=false&sort=false&new_name=true`; try { const subconverterResponse = await fetch(subconverterUrl); if (!subconverterResponse.ok) { throw new Error(`Error fetching subconverterUrl: ${subconverterResponse.status} ${subconverterResponse.statusText}`); } const subconverterContent = await subconverterResponse.text(); return new Response(subconverterContent, { headers: { \\\"Content-Disposition\\\": `attachment; filename*=utf-8''${encodeURIComponent(FileName)}; filename=${FileName}`, \\\"content-type\\\": \\\"text/plain; charset=utf-8\\\", \\\"Profile-Update-Interval\\\": `${SUBUpdateTime}`, \\\"Subscription-Userinfo\\\": `upload=${UD}; download=${UD}; total=${total}; expire=${expire}`, }, }); } catch (error) { return new Response(`Error: ${error.message}`, { status: 500, headers: { 'content-type': 'text/plain; charset=utf-8' }, }); } } else if ( (userAgent.includes('sing-box') || userAgent.includes('singbox') || (format === 'singbox' && !userAgent.includes('subconverter')) ) && !userAgent.includes('cf-workers-sub')){ const subconverterUrl = `https://${subconverter}/sub?target=singbox&url=${encodeURIComponent(request.url)}&insert=false&config=${encodeURIComponent(subconfig)}&emoji=true&list=false&tfo=false&scv=true&fdn=false&sort=false&new_name=true`; try { const subconverterResponse = await fetch(subconverterUrl); if (!subconverterResponse.ok) { throw new Error(`Error fetching subconverterUrl: ${subconverterResponse.status} ${subconverterResponse.statusText}`); } const subconverterContent = await subconverterResponse.text(); return new Response(subconverterContent, { headers: { \\\"Content-Disposition\\\": `attachment; filename*=utf-8''${encodeURIComponent(FileName)}; filename=${FileName}`, \\\"content-type\\\": \\\"text/plain; charset=utf-8\\\", \\\"Profile-Update-Interval\\\": `${SUBUpdateTime}`, \\\"Subscription-Userinfo\\\": `upload=${UD}; download=${UD}; total=${total}; expire=${expire}`, }, }); } catch (error) { return new Response(`Error: ${error.message}`, { status: 500, headers: { 'content-type': 'text/plain; charset=utf-8' }, }); } } else { if(host.includes('workers.dev') || host.includes('pages.dev')) { if (proxyhostsURL) { try { const response = await fetch(proxyhostsURL); if (!response.ok) { console.error('获取地址时出错:', response.status, response.statusText); return; // 如果有错误，直接返回 } const text = await response.text(); const lines = text.split('\\\\n'); // 过滤掉空行或只包含空白字符的行 const nonEmptyLines = lines.filter(line => line.trim() !== ''); proxyhosts = proxyhosts.concat(nonEmptyLines); } catch (error) { console.error('获取地址时出错:', error); } } // 使用Set对象去重 proxyhosts = [...new Set(proxyhosts)]; } const newAddressesapi = await getAddressesapi(addressesapi); const newAddressescsv = await getAddressescsv('TRUE'); addresses = addresses.concat(newAddressesapi); addresses = addresses.concat(newAddressescsv); // 使用Set对象去重 const uniqueAddresses = [...new Set(addresses)]; let notlsresponseBody; if(noTLS == true){ const newAddressesnotlsapi = await getAddressesapi(addressesnotlsapi); const newAddressesnotlscsv = await getAddressescsv('FALSE'); addressesnotls = addressesnotls.concat(newAddressesnotlsapi); addressesnotls = addressesnotls.concat(newAddressesnotlscsv); const uniqueAddressesnotls = [...new Set(addressesnotls)]; notlsresponseBody = uniqueAddressesnotls.map(address => { let port = \\\"80\\\"; let addressid = address; const match = addressid.match(regex); if (!match) { if (address.includes(':') && address.includes('#')) { const parts = address.split(':'); address = parts[0]; const subParts = parts[1].split('#'); port = subParts[0]; addressid = subParts[1]; } else if (address.includes(':')) { const parts = address.split(':'); address = parts[0]; port = parts[1]; } else if (address.includes('#')) { const parts = address.split('#'); address = parts[0]; addressid = parts[1]; } if (addressid.includes(':')) { addressid = addressid.split(':')[0]; } } else { address = match[1]; port = match[2] || port; addressid = match[3] || address; } //console.log(address, port, addressid); if (edgetunnel.trim() === 'cmliu' && RproxyIP.trim() === 'true') { // 将addressid转换为小写 let lowerAddressid = addressid.toLowerCase(); // 初始化找到的proxyIP为null let foundProxyIP = null; // 遍历CMproxyIPs数组查找匹配项 for (let item of CMproxyIPs) { if (lowerAddressid.includes(item.type.toLowerCase())) { foundProxyIP = item.proxyIP; break; // 找到匹配项，跳出循环 } } if (foundProxyIP) { // 如果找到匹配的proxyIP，赋值给path path = `/proxyIP=${foundProxyIP}`; } else { // 如果没有找到匹配项，随机选择一个proxyIP const randomProxyIP = proxyIPs[Math.floor(Math.random() * proxyIPs.length)]; path = `/proxyIP=${randomProxyIP}`; } } const vlessLink = `vless://${uuid}@${address}:${port}?encryption=none&security=&type=ws&host=${host}&path=${encodeURIComponent(path)}#${encodeURIComponent(addressid + EndPS)}`; return vlessLink; }).join('\\\\n'); } const responseBody = uniqueAddresses.map(address => { let port = \\\"443\\\"; let addressid = address; const match = addressid.match(regex); if (!match) { if (address.includes(':') && address.includes('#')) { const parts = address.split(':'); address = parts[0]; const subParts = parts[1].split('#'); port = subParts[0]; addressid = subParts[1]; } else if (address.includes(':')) { const parts = address.split(':'); address = parts[0]; port = parts[1]; } else if (address.includes('#')) { const parts = address.split('#'); address = parts[0]; addressid = parts[1]; } if (addressid.includes(':')) { addressid = addressid.split(':')[0]; } } else { address = match[1]; port = match[2] || port; addressid = match[3] || address; } //console.log(address, port, addressid); if (edgetunnel.trim() === 'cmliu' && RproxyIP.trim() === 'true') { // 将addressid转换为小写 let lowerAddressid = addressid.toLowerCase(); // 初始化找到的proxyIP为null let foundProxyIP = null; // 遍历CMproxyIPs数组查找匹配项 for (let item of CMproxyIPs) { if (lowerAddressid.includes(item.type.toLowerCase())) { foundProxyIP = item.proxyIP; break; // 找到匹配项，跳出循环 } } if (foundProxyIP) { // 如果找到匹配的proxyIP，赋值给path path = `/proxyIP=${foundProxyIP}`; } else { // 如果没有找到匹配项，随机选择一个proxyIP const randomProxyIP = proxyIPs[Math.floor(Math.random() * proxyIPs.length)]; path = `/proxyIP=${randomProxyIP}`; } } let 伪装域名 = host ; let 最终路径 = path ; let 节点备注 = EndPS ; if(proxyhosts && (host.includes('.workers.dev') || host.includes('pages.dev'))) { 最终路径 = `/${host}${path}`; 伪装域名 = proxyhosts[Math.floor(Math.random() * proxyhosts.length)]; 节点备注 = `${EndPS} 已启用临时域名中转服务，请尽快绑定自定义域！`; sni = 伪装域名; } const vlessLink = `vless://${uuid}@${address}:${port}?encryption=none&security=tls&sni=${sni}&fp=random&type=ws&host=${伪装域名}&path=${encodeURIComponent(最终路径)}#${encodeURIComponent(addressid + 节点备注)}`; return vlessLink; }).join('\\\\n'); let combinedContent = responseBody; // 合并内容 if (link) { combinedContent += '\\\\n' + link; console.log(\\\"link: \\\" + link) } if (notlsresponseBody) { combinedContent += '\\\\n' + notlsresponseBody; console.log(\\\"notlsresponseBody: \\\" + notlsresponseBody); } const base64Response = btoa(combinedContent); // 重新进行 Base64 编码 const response = new Response(base64Response, { headers: { //\\\"Content-Disposition\\\": `attachment; filename*=utf-8''${encodeURIComponent(FileName)}; filename=${FileName}`, \\\"content-type\\\": \\\"text/plain; charset=utf-8\\\", \\\"Profile-Update-Interval\\\": `${SUBUpdateTime}`, \\\"Subscription-Userinfo\\\": `upload=${UD}; download=${UD}; total=${total}; expire=${expire}`, }, }); return response; } } }; \"]},\"72\":{\"h\":\"Mysql 基础\",\"t\":[\"Mysql 基础\"]},\"73\":{\"h\":\"1. MySQL中myisam与innodb的区别?\",\"t\":[\"InnoDB支持事物，而MyISAM不支持事物\",\"InnoDB支持行级锁，而MyISAM支持表级锁\",\"InnoDB支持MVCC, 而MyISAM不支持\",\"InnoDB支持外键，而MyISAM不支持\",\"InnoDB不支持全文索引，而MyISAM支持。\"]},\"74\":{\"h\":\"2. 事务的特性\",\"t\":[\"原子性：是指事务包含所有操作要么全部成功，要么全部失败回滚。\",\"一致性：指事务必须使数据库从一个一致性状态变换成另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。\",\"隔离性：是当多个用户并发访问数据库时，比如操作同一张表时，数据表为每个用户开启的事务，不能被其他事务所干扰，多个并发事务之间要相互隔离。\",\"持久性：持久性是指一个事务一旦被提交，那么对数据库中的数据的改变就是永久的，即便是在数据库系统遇到故障的性况下也不会丢失提交事务的操作。\"]},\"75\":{\"h\":\"3. 并发操作问题\",\"t\":[\"脏读：脏读是指在一个事务处理过程中读取到了另外一个未提交事务中的数据。\",\"不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。\",\"虚读(幻读)：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。 比如两个事务操作，A 事务查询状态为 1 的记录时，这时 B 事务插入了一条状态为 1 的记录，A 事务再次查询返回的结果不一样。\"]},\"76\":{\"h\":\"4. 事务的隔离级别\",\"t\":[\"Serializable(串行化)：可避免脏读、不可重复读、幻读。（就是串行化读数据）\",\"Repeatable read(可重复读)：可避免脏读、不可重复读的发生。\",\"Read committed(读已提交)：可避免脏读的发生。\",\"Read uncommitted(读未提交)：最低级别，任何情况都无法保证。\",\"在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。##\"]},\"77\":{\"h\":\"5. 索引是什么？\",\"t\":[\"索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。\",\"索引是帮助MySQL高效获取数据的数据结构。\"]},\"78\":{\"h\":\"6. 索引能干什么?有什么好处？\",\"t\":[\"当表中的数据量越来越大时，索引对于性能的影响愈发重要。索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。\"]},\"79\":{\"h\":\"7. 索引的种类有哪些？\",\"t\":[\"1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，\",\"2、从应用层次来分：普通索引，唯一索引，复合索引\",\"3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。\",\"平时讲的索引类型一般是指在应用层次的划分。\",\"普通索引：即一个索引只包含单个列，一个表可以有多个单列索引\",\"复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并\",\"唯一索引：索引列的值必须唯一，但允许有空值\"]},\"80\":{\"h\":\"8. 为什么 MySQL 的索引要使用 B+树而不是其它树形结构?比如 B 树？\",\"t\":[\"B-tree：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；\",\"Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。\",\"二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。\",\"红黑树：树的高度随着数据量增加而增加，IO代价高。\",\"不使用平衡二叉树的原因如下：\",\"最大原因：深度太大(因为一个节点最多只有2个子节点)，一次查询需要的I/O复杂度为O(lgN),而b+tree只需要O(log_mN),而其出度m非常大，其深度一般不会超过4 平衡二叉树逻辑上很近的父子节点，物理上可能很远，无法充分发挥磁盘顺序读和预读的高效特性。\"]},\"81\":{\"h\":\"9. MyISAM和InnoDB实现BTree索引方式的区别\"},\"82\":{\"h\":\"MyISAM\",\"t\":[\"B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。 索引文件和数据文件是分离的\"]},\"83\":{\"h\":\"InnoDB\",\"t\":[\"InnoDB 的 B+Tree 索引分为主索引（聚集索引）和辅助索引(非聚集索引)。一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树。\",\"辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。\",\"就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。\"]},\"84\":{\"h\":\"10. 什么是最左匹配原则？\",\"t\":[\"最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。 例如：b = 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a = 1 and b = 2,就可以，因为优化器会自动调整a,b的顺序。再比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。\",\"最左匹配原则的原理\",\"MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引.最左匹配原则都是针对联合索引来说的\",\"我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。 例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。\",\"同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。\",\"优点：最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。\"]},\"85\":{\"h\":\"11. 哪些列上适合创建索引？创建索引有哪些开销？\",\"t\":[\"经常需要作为条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（数据页的分裂与合并），对性能造成影响\"]},\"86\":{\"h\":\"12. 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？\",\"t\":[\"当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。\",\"索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。\",\"创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。\"]},\"87\":{\"h\":\"13. ？\",\"t\":[\"主键约束（Primay Key Coustraint） 唯一性，非空性\",\"唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个\",\"检查约束 (Check Counstraint) 对该列数据的范围、格式的限制\",\"默认约束 (Default Counstraint) 该数据的默认值\",\"外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列\"]},\"88\":{\"h\":\"14. MySQL执行查询的过程？\",\"t\":[\"客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配\",\"查缓存。（当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）\",\"语法分析（SQL语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。\",\"优化。是否使用索引，生成执行计划。\",\"交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。\"]},\"89\":{\"h\":\"15. MySQL的binlog有有几种录入格式?分别有什么区别?\",\"t\":[\"有三种格式,statement,row和mixed.\",\"statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.\",\"row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大。\",\"mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row. 此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.\"]},\"90\":{\"h\":\"基础、锁、事务、分库分表、优化\",\"t\":[\"Mysql 基础、锁、事务、分库分表、优化\",\"permalink: /interview/Mysql/MySQL基础、锁、事务、分库分表、优化/\"]},\"91\":{\"h\":\"1. 数据库的三范式是什么？\",\"t\":[\"第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。\",\"第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。\",\"第三范式：任何非主属性不依赖于其它非主属性。\"]},\"92\":{\"h\":\"2. MySQL 支持哪些存储引擎?\",\"t\":[\"MySQL 支持多种存储引擎,比如 InnoDB,MyISAM,Memory,Archive 等等.在大多数的情况下,直接选择使用 InnoDB 引擎都是最合适的,InnoDB 也是 MySQL 的默认存储引擎。\",\"MyISAM 和 InnoDB 的区别有哪些：\",\"InnoDB 支持事务，MyISAM 不支持\",\"InnoDB 支持外键，而 MyISAM 不支持\",\"InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。\",\"Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；\",\"InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。\",\"MyISAM 采用表级锁(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。\"]},\"93\":{\"h\":\"3. 超键、候选键、主键、外键分别是什么？\",\"t\":[\"超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。\",\"候选键：是最小超键，即没有冗余元素的超键。\",\"主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。\",\"外键：在一个表中存在的另一个表的主键称此表的外键。\"]},\"94\":{\"h\":\"4. SQL 约束有哪几种？\",\"t\":[\"NOT NULL: 用于控制字段的内容一定不能为空（NULL）。\",\"UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。\",\"PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。\",\"FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。\",\"CHECK: 用于控制字段的值范围。\"]},\"95\":{\"h\":\"5. MySQL 中的 varchar 和 char 有什么区别？\",\"t\":[\"char 是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.\",\"在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码,则应该使用 char。\"]},\"96\":{\"h\":\"6. MySQL中 in 和 exists 区别\",\"t\":[\"MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。\",\"如果查询的两个表大小相当，那么用in和exists差别不大。 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。 not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。\"]},\"97\":{\"h\":\"7. drop、delete与truncate的区别\",\"t\":[\"三者都表示删除，但是三者有一些差别：\"]},\"98\":{\"h\":\"8. 什么是存储过程？有哪些优缺点？\",\"t\":[\"存储过程是一些预编译的 SQL 语句。\",\"1、更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。\",\"2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全\",\"但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好。\"]},\"99\":{\"h\":\"9. MySQL 执行查询的过程\",\"t\":[\"客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配\",\"查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）\",\"语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。\",\"优化。是否使用索引，生成执行计划。\",\"交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。\",\"更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。\"]},\"100\":{\"h\":\"1. 什么是数据库事务？\",\"t\":[\"事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。\",\"事务最经典也经常被拿出来说例子就是转账了。\",\"假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\"]},\"101\":{\"h\":\"2. 介绍一下事务具有的四个特征\",\"t\":[\"事务就是一组原子性的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。\",\"原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做\",\"一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。\",\"隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的//操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。\",\"持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。\"]},\"102\":{\"h\":\"3. 说一下MySQL 的四种隔离级别\",\"t\":[\"Read Uncommitted（读取未提交内容）\",\"在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。\",\"Read Committed（读取提交内容）\",\"这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓 的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。\",\"Repeatable Read（可重读）\",\"这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。\",\"Serializable（可串行化）\",\"通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。\",\"MySQL 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别\",\"事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。\",\"因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。\",\"InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。\"]},\"103\":{\"h\":\"4. 什么是脏读？幻读？不可重复读？\",\"t\":[\"1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据\",\"2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。\",\"3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\",\"不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。\"]},\"104\":{\"h\":\"5. 事务的实现原理\",\"t\":[\"事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。\",\"每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。\",\"每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。\"]},\"105\":{\"h\":\"6. MySQL事务日志介绍下？\",\"t\":[\"innodb 事务日志包括 redo log 和 undo log。\",\"undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。\",\"事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。\"]},\"106\":{\"h\":\"redo log\",\"t\":[\"redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。\"]},\"107\":{\"h\":\"undo log\",\"t\":[\"undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。\"]},\"108\":{\"h\":\"7. 什么是MySQL的 binlog？\",\"t\":[\"MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。\",\"MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。\",\"binlog 有三种格式，各有优缺点：\",\"statement： 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。\",\"row： 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。\",\"mixed： 混合模式，根据语句来选用是 statement 还是 row 模式。\"]},\"109\":{\"h\":\"\",\"t\":[\"尽量不要在同一个事务中使用多种存储引擎，MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。\",\"如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表）,在正常提交的情况下不会有什么问题。\",\"但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。\"]},\"110\":{\"h\":\"9. MySQL中是如何实现事务隔离的?\",\"t\":[\"读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。\",\"MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。\",\"详细原理看这篇文章：https://haicoder.net/note/MySQL-interview/MySQL-interview-MySQL-trans-level.html\"]},\"111\":{\"h\":\"10. 什么是 MVCC？\",\"t\":[\"MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。\"]},\"112\":{\"h\":\"11. MVCC 的实现原理\",\"t\":[\"对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：\",\"ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。\",\"事务 ID：记录最后一次修改该记录的事务 ID。\",\"回滚指针：指向这条记录的上一个版本。\",\"我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：\",\"如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b=666 where a=1 时，大致步骤如下：\",\"数据库会先对满足 a=1 的行加排他锁；\",\"然后将原记录复制到 undo 表空间中；\",\"修改 b 字段的值为 666，修改事务 ID 为 2；\",\"并通过隐藏的回滚指针指向 undo log 中的历史记录；\",\"事务提交，释放前面对满足 a=1 的行所加的排他锁。\",\"在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是来自 undolog 中。\",\"因此可以总结出 MVCC 实现的原理大致是：\",\"InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。\",\"MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。\"]},\"113\":{\"h\":\"1. 为什么要加锁?\",\"t\":[\"当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。\",\"保证多用户环境下保证数据库完整性和一致性。\"]},\"114\":{\"h\":\"2. 按照锁的粒度分数据库锁有哪些？\",\"t\":[\"在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。\",\"行级锁\",\"行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。\",\"开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\",\"表级锁\",\"表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。\",\"开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。\",\"页级锁\",\"页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁\",\"开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般\",\"MyISAM和InnoDB存储引擎使用的锁：\",\"MyISAM采用表级锁(table-level locking)。\",\"InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁\"]},\"115\":{\"h\":\"3. 从锁的类别上分MySQL都有哪些锁呢？\",\"t\":[\"从锁的类别上来讲，有共享锁和排他锁。\",\"共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\",\"排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\",\"用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。\",\"锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。\",\"他们的加锁开销从大到小，并发能力也是从大到小。\"]},\"116\":{\"h\":\"4. 数据库的乐观锁和悲观锁是什么？怎么实现的？\",\"t\":[\"数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。\",\"悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制\",\"乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。\",\"两种锁的使用场景\",\"从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。\",\"但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。\"]},\"117\":{\"h\":\"5. InnoDB引擎的行锁是怎么实现的？\",\"t\":[\"InnoDB是基于索引来完成行锁\",\"例: select * from tab_with_index where id = 1 for update;\",\"for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起\"]},\"118\":{\"h\":\"6. 什么是死锁？怎么解决？\",\"t\":[\"死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。\",\"常见的解决死锁的方法\",\"1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。\",\"2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\",\"3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；\",\"如果业务处理不好可以用分布式事务锁或者使用乐观锁\"]},\"119\":{\"h\":\"7. 隔离级别与锁的关系\",\"t\":[\"在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突\",\"在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；\",\"在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。\",\"SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。\"]},\"120\":{\"h\":\"8. 优化锁方面的意见？\",\"t\":[\"使用较低的隔离级别\",\"设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突\",\"选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。列如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁\",\"不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。\",\"尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响\",\"不要申请超过实际需要的锁级别\",\"数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别\",\"对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。\"]},\"121\":{\"h\":\"1. 为什么要分库分表？\",\"t\":[\"分表\",\"比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。\",\"分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。\",\"分库\",\"分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。\",\"这就是所谓的分库分表。\"]},\"122\":{\"h\":\"2. 用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？\",\"t\":[\"这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。\",\"比较常见的包括：\",\"cobar\",\"TDDL\",\"atlas\",\"sharding-jdbc\",\"mycat\"]},\"123\":{\"h\":\"cobar\",\"t\":[\"阿里 b2b 团队开发和开源的，属于 proxy 层方案。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。\"]},\"124\":{\"h\":\"TDDL\",\"t\":[\"淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。\"]},\"125\":{\"h\":\"atlas\",\"t\":[\"360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。\"]},\"126\":{\"h\":\"sharding-jdbc\",\"t\":[\"当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。\"]},\"127\":{\"h\":\"mycat\",\"t\":[\"基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。\"]},\"128\":{\"h\":\"3. 如何对数据库如何进行垂直拆分或水平拆分的？\",\"t\":[\"水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。\",\"垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。\",\"两种分库分表的方式：\",\"一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。\",\"或者是按照某个字段hash一下均匀分散，这个较为常用。\",\"range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。\",\"hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表\"]},\"129\":{\"h\":\"1. 什么是MySQL主从同步？\",\"t\":[\"主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。\",\"因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。\"]},\"130\":{\"h\":\"2. MySQL主从同步的目的？为什么要做主从同步？\",\"t\":[\"通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。\",\"提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据\",\"在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能\",\"数据备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全\"]},\"131\":{\"h\":\"3. 如何实现MySQL的读写分离？\",\"t\":[\"其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。\"]},\"132\":{\"h\":\"4. MySQL主从复制流程和原理？\",\"t\":[\"基本原理流程，是3个线程以及之间的关联\",\"主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；\",\"从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；\",\"从：sql执行线程——执行relay log中的语句；\",\"复制过程如下：\",\"Binary log：主数据库的二进制日志\",\"Relay log：从服务器的中继日志\",\"第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。\",\"第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。\",\"第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。\"]},\"133\":{\"h\":\"5. MySQL主从同步延时问题如何解决？\",\"t\":[\"MySQL 实际上在有两个同步机制，一个是半同步复制，用来 解决主库数据丢失问题；一个是并行复制，用来 解决主从同步延时问题。\",\"半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。\",\"并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。\"]},\"134\":{\"h\":\"1. 如何定位及优化SQL语句的性能问题？\",\"t\":[\"对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。\",\"而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。 \"]},\"135\":{\"h\":\"2. 大表数据查询，怎么优化\",\"t\":[\"优化shema、sql语句+索引；\",\"第二加缓存，memcached, redis；\",\"主从复制，读写分离；\",\"垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；\",\"水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；\"]},\"136\":{\"h\":\"3. 超大分页怎么处理?\",\"t\":[\"数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10 这种查询其实也是有可以优化的余地的. 这条语句需要 load1000000 数据然后基本上全部丢弃,只取 10 条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也 load 了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快。\",\"解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.\",\"在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.\",\"【推荐】利用延迟关联或者子查询优化超多分页场景。\",\"说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。\",\"正例：先快速定位需要获取的id段，然后再关联：\",\"SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id\"]},\"137\":{\"h\":\"4. 统计过慢查询吗？对慢查询都怎么优化过？\",\"t\":[\"在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。\",\"慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？\",\"所以优化也是针对这三个方向来的，\",\"首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。\",\"分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。\",\"如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。\"]},\"138\":{\"h\":\"5. 如何优化查询过程中的数据访问\",\"t\":[\"访问数据太多导致查询性能下降\",\"确定应用程序是否在检索大量超过需要的数据，可能是太多行或列\",\"确认MySQL服务器是否在分析大量不必要的数据行\",\"查询不需要的数据。解决办法：使用limit解决\",\"多表关联返回全部列。解决办法：指定列名\",\"总是返回全部列。解决办法：避免使用SELECT *\",\"重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存\",\"是否在扫描额外的记录。解决办法： 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化： 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。\",\"改变数据库和表的结构，修改数据表范式\",\"重写SQL语句，让优化器可以以更优的方式执行查询。\"]},\"139\":{\"h\":\"6. 如何优化关联查询\",\"t\":[\"确定ON或者USING子句中是否有索引。\",\"确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。\"]},\"140\":{\"h\":\"7. 数据库结构优化\",\"t\":[\"一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。\",\"需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。\",\"将字段很多的表分解成多个表\",\"对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。\",\"因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。\",\"增加中间表\",\"对于需要经常联合查询的表，可以建立中间表以提高查询效率。\",\"通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。\",\"增加冗余字段\",\"设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。\",\"表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。\",\"注意：\",\"冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。\"]},\"141\":{\"h\":\"8. MySQL数据库cpu飙升到500%的话他怎么处理？\",\"t\":[\"当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 MySQLd 占用导致的，如果不是，找出占用高的进程，并进行相关处理。\",\"如果是 MySQLd 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。\",\"一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。\",\"也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。\"]},\"142\":{\"h\":\"9. 大表怎么优化？\",\"t\":[\"类似的问题：某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\",\"当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\",\"限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；\",\"读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；\",\"缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑；\",\"通过分库分表的方式进行优化，主要有垂直分表和水平分表。\"]},\"143\":{\"h\":\"参考\"},\"144\":{\"h\":\"MySQL\",\"t\":[\"https://blog.csdn.net/ThinkWon/article/details/104778621\",\"https://haicoder.net/note/mysql-interview/mysql-interview-mysql-binlog.html\",\"https://www.modb.pro/db/40241\",\"https://www.jianshu.com/p/05da0fc0950e\",\"https://blog.csdn.net/ThinkWon/article/details/104778621\"]},\"145\":{\"h\":\"Mysql 索引\",\"t\":[\"Mysql 进阶 索引连环18问\"]},\"146\":{\"h\":\"1. 索引是什么？\",\"t\":[\"permalink: /interview/Mysql/MySQL索引连环18问！/\",\"索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。\",\"索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。\",\"MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。\"]},\"147\":{\"h\":\"2. 索引有哪些优缺点？\",\"t\":[\"索引的优点\",\"可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\",\"通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。\",\"索引的缺点\",\"时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；\",\"空间方面：索引需要占物理空间。\"]},\"148\":{\"h\":\"3. MySQL有哪几种索引类型？\",\"t\":[\"1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，\",\"2、从应用层次来分：普通索引，唯一索引，复合索引。\",\"普通索引：即一个索引只包含单个列，一个表可以有多个单列索引\",\"唯一索引：索引列的值必须唯一，但允许有空值\",\"复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并\",\"聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。\",\"非聚簇索引： 不是聚簇索引，就是非聚簇索引\",\"3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。\"]},\"149\":{\"h\":\"4. 说一说索引的底层实现？\",\"t\":[\"Hash索引\",\"基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。\",\"图片来源：https://www.javazhiyin.com/40232.html\",\"B-Tree索引（MySQL使用B+Tree）\",\"B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。\",\"B+Tree索引\",\"是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。\",\"B+tree性质：\",\"n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。\",\"所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。\",\"所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。\",\"B+ 树中，数据对象的插入和删除仅在叶节点上进行。\",\"B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。\"]},\"150\":{\"h\":\"5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？\",\"t\":[\"B-tree： 从两个方面来回答\",\"B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。\",\"由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。\",\"Hash：\",\"虽然可以快速定位，但是没有顺序，IO复杂度高；\",\"基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；\",\"适合等值查询，如=、in()、<=>，不支持范围查询 ；\",\"因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序 ；\",\"Hash索引在查询等值时非常快 ；\",\"因为Hash索引始终索引的所有列的全部内容，所以不支持部分索引列的匹配查找 ；\",\"如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。\",\"二叉树： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。\",\"红黑树： 树的高度随着数据量增加而增加，IO代价高。\"]},\"151\":{\"h\":\"6. 讲一讲聚簇索引与非聚簇索引？\",\"t\":[\"在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。\",\"而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。\",\"聚簇索引与非聚簇索引的区别：\",\"非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）\",\"对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。\",\"通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可\",\"注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。\"]},\"152\":{\"h\":\"7. 非聚簇索引一定会回表查询吗？\",\"t\":[\"不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为\\\"覆盖索引\\\"。\",\"举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select score from student where score > 90的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。\"]},\"153\":{\"h\":\"8. 联合索引是什么？为什么需要注意联合索引中的顺序？\",\"t\":[\"MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。\",\"具体原因为:\",\"MySQL使用索引时需要索引有序，假设现在建立了\\\"name，age，school\\\"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。\",\"当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。\"]},\"154\":{\"h\":\"9. 讲一讲MySQL的最左前缀原则?\",\"t\":[\"最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\",\"=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。\"]},\"155\":{\"h\":\"10. 讲一讲前缀索引？\",\"t\":[\"因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。\",\"流程是：\",\"先计算完整列的选择性 : select count(distinct col_1)/count(1) from table_1 \",\"再计算不同前缀长度的选择性 :select count(distinct left(col_1,4))/count(1) from table_1 \",\"找到最优长度之后，创建前缀索引 : create index idx_front on table_1 (col_1(4))\"]},\"156\":{\"h\":\"11. 了解索引下推吗？\",\"t\":[\"MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。\",\"有了索引下推优化，可以在减少回表次数\",\"在InnoDB中只针对二级索引有效\",\"官方文档中给的例子和解释如下：\",\"在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;\",\"如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件\",\"如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。\"]},\"157\":{\"h\":\"12. 怎么查看MySQL语句有没有用到索引？\",\"t\":[\"通过explain，如以下例子：\",\"EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';\",\"id\",\"select_type\",\"table\",\"partitions\",\"type\",\"possible_keys\",\"key\",\"key_len\",\"ref\",\"filtered\",\"rows\",\"Extra\",\"1\",\"SIMPLE\",\"titles\",\"null\",\"const\",\"PRIMARY\",\"PRIMARY\",\"59\",\"const,const,const\",\"10\",\"1\",\"id：在⼀个⼤的查询语句中每个SELECT关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = 'egon1');第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。\",\"select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。\",\"table：每个查询对应的表名 。\",\"type：type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。\",\"通常来说, 不同的 type 类型的性能关系如下: ALL < index < range ~ index_merge < ref < eq_ref < const < systemALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的. 而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\",\"possible_key：查询中可能用到的索引*(可以把用不到的删掉，降低优化器的优化时间)* 。\",\"key：此字段是 MySQL 在当前查询时所真正使用到的索引。\",\"filtered：查询器预测满足下一次查询条件的百分比 。\",\"rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数. 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。\",\"extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。\"]},\"158\":{\"h\":\"13. 为什么官方建议使用自增长主键作为索引？\",\"t\":[\"结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。\",\"插入连续的数据：\",\"图片来自：https://www.javazhiyin.com/40232.html\",\"插入非连续的数据：\"]},\"159\":{\"h\":\"14. 如何创建索引？\",\"t\":[\"创建索引有三种方式。\",\"1、 在执行CREATE TABLE时创建索引\",\"CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) ); \",\"2、 使用ALTER TABLE命令去增加索引。\",\"ALTER TABLE table_name ADD INDEX index_name (column_list); \",\"ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。\",\"其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。\",\"索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。 3、 使用CREATE INDEX命令创建。\",\"CREATE INDEX index_name ON table_name (column_list); \"]},\"160\":{\"h\":\"15. 创建索引时需要注意什么？\",\"t\":[\"非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；\",\"取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；\",\"索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。\"]},\"161\":{\"h\":\"16. 建索引的原则有哪些？\",\"t\":[\"1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\",\"2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。\",\"3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。\",\"4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。\",\"5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。\"]},\"162\":{\"h\":\"17. 使用索引查询一定能提高查询的性能吗？\",\"t\":[\"通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。\",\"索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:\",\"基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。\",\"基于非唯一性索引的检索。\"]},\"163\":{\"h\":\"18. 什么情况下不走索引（索引失效）？\"},\"164\":{\"h\":\"1、使用!= 或者 <> 导致索引失效\"},\"165\":{\"h\":\"2、类型不一致导致的索引失效\"},\"166\":{\"h\":\"3、函数导致的索引失效\",\"t\":[\"如：\",\"SELECT * FROM `user` WHERE DATE(create_time) = '2020-09-03'; \",\"如果使用函数在索引列，这是不走索引的。\"]},\"167\":{\"h\":\"4、运算符导致的索引失效\",\"t\":[\"SELECT * FROM `user` WHERE age - 1 = 20; \",\"如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。\"]},\"168\":{\"h\":\"5、OR引起的索引失效\",\"t\":[\"SELECT * FROM `user` WHERE `name` = '张三' OR height = '175'; \",\"OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。\"]},\"169\":{\"h\":\"6、模糊搜索导致的索引失效\",\"t\":[\"SELECT * FROM `user` WHERE `name` LIKE '%冰'; \",\"当%放在匹配字段前是不走索引的，放在后面才会走索引。\"]},\"170\":{\"h\":\"7、NOT IN、NOT EXISTS导致索引失效\"},\"171\":{\"h\":\"Mybatis 基础\",\"t\":[\"Mybatis 详解 基础\"]},\"172\":{\"h\":\"1. MyBatis是什么？\",\"t\":[\"Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，加载驱动、创建连接、创建statement等繁杂的过程，开发者开发时只需要关注如何编写SQL语句，可以严格控制sql执行性能，灵活度高。\",\"作为一个半ORM框架，MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\",\"通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。\",\"由于MyBatis专注于SQL本身，灵活度高，所以比较适合对性能的要求很高，或者需求变化较多的项目，如互联网项目。\"]},\"173\":{\"h\":\"2. Mybaits的优缺点\",\"t\":[\"优点：\",\"基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。\",\"与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；\",\"很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。\",\"能够与Spring很好的集成；\",\"提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。\",\"缺点：\",\"SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。\",\"SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。\"]},\"174\":{\"h\":\"3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\",\"t\":[\"Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。\",\"而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。\"]},\"175\":{\"h\":\"4. Hibernate 和 MyBatis 的区别\",\"t\":[\"相同点：都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。\",\"不同点\",\"1、映射关系\",\"MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单。\",\"Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂。\",\"2、 SQL优化和移植性\",\"Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。 MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。\",\"3、开发难易程度和学习成本\",\"Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统\",\"MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统\",\"总结\",\"MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，\",\"Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。\"]},\"176\":{\"h\":\"5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？\",\"t\":[\"1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。\",\"解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。\",\"2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。\",\"解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。\",\"3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。\",\"解决： Mybatis自动将java对象映射至sql语句。\",\"4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。\",\"解决：Mybatis自动将sql执行结果映射至java对象。\"]},\"177\":{\"h\":\"6. MyBatis编程步骤是什么样的？\",\"t\":[\"1、创建SqlSessionFactory 2、通过SqlSessionFactory创建SqlSession 3、 通过sqlsession执行数据库操作 4、 调用session.commit()提交事务 5、 调用session.close()关闭会话\"]},\"178\":{\"h\":\"7. MyBatis与Hibernate有哪些不同？\",\"t\":[\"1、Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要 程序员自己编写 Sql 语句。\",\"2、Mybatis 直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高，非常 适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需 求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数据库无关性， 如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。\",\"3、Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的 软件，如果用 hibernate 开发可以节省很多代码，提高效率\"]},\"179\":{\"h\":\"8. Mybaits 的优点：\",\"t\":[\"1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。\",\"2、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；\",\"3、很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。\",\"4、能够与 Spring 很好的集成； 5、提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护\"]},\"180\":{\"h\":\"9. MyBatis 框架的缺点：\",\"t\":[\"1、SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。\",\"2、SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。\"]},\"181\":{\"h\":\"10. #{}和${}的区别？\",\"t\":[\"#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。\",\"Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。\",\"Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译\",\"变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’\",\"#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入\",\"#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外\"]},\"182\":{\"h\":\"11. 通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？\",\"t\":[\"Dao接口即Mapper接口。接口的全限名就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名的拼接字符串作为key值，可唯一定位一个MapperStatement。\",\"Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。\",\"Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。\"]},\"183\":{\"h\":\"12. 在Mapper中如何传递多个参数？\",\"t\":[\"1、若Dao层函数有多个参数，那么其对应的xml中，#{0}代表接收的是Dao层中的第一个参数，#{1}代表Dao中的第二个参数，以此类推。\",\"2、使用@Param注解：在Dao层的参数中前加@Param注解,注解内的参数名为传递到Mapper中的参数名。\",\"3、多个参数封装成Map，以HashMap的形式传递到Mapper中。\"]},\"184\":{\"h\":\"13. Mybatis动态sql有什么用？执行原理是什么？有哪些动态sql？\",\"t\":[\"Mybatis动态sql可以在xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值完成逻辑判断，并动态拼接sql的功能。\",\"Mybatis提供了9种动态sql标签：trim、where、set、foreach、if、choose、when、otherwise、bind\"]},\"185\":{\"h\":\"14. xml映射文件中，不同的xml映射文件id是否可以重复？\",\"t\":[\"不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；\",\"原因是namespace+id是作为Map<String,MapperStatement>的key使用的，如果没有namespace，就剩下id，那么id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也不同。\"]},\"186\":{\"h\":\"15. Mybatis实现一对一有几种方式？具体是怎么操作的？\",\"t\":[\"有联合查询和嵌套查询两种方式。\",\"联合查询是几个表联合查询，通过在resultMap里面配置association节点配置一对一的类就可以完成；\",\"嵌套查询是先查一个表，根据这个表里面的结果的外键id，再去另外一个表里面查询数据，也是通过association配置，但另外一个表的查询是通过select配置的。\"]},\"187\":{\"h\":\"16. Mybatis实现一对多有几种方式？具体是怎么操作的？\",\"t\":[\"有联合查询和嵌套查询两种方式。\",\"联合查询是几个表联合查询，只查询一次，通过在resultMap里面的collection节点配置一对多的类就可以完成；\",\"嵌套查询是先查一个表，根据这个表里面的结果的外键id，再去另外一个表里面查询数据，也是通过collection，但另外一个表的查询是通过select配置的。\"]},\"188\":{\"h\":\"17. Mybatis的一级、二级缓存\",\"t\":[\"1、 一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。 2、 二级缓存与一级缓存机制相同，默认也是采用PerpetualCache，HashMap存储，不同在于其存储作用域为Mapper（namespace），并且可自定义存储源，如Ehcache。默认打不开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口（可用来保存对象的状态），可在它的映射文件中配置。\",\"对于缓存数据更新机制，当某一个作用域（一级缓存Session/二级缓存Namespace）进行了增/删/改操作后，默认该作用域下所有select中的缓存将被clear。\"]},\"189\":{\"h\":\"18. 使用MyBatis的Mapper接口调用时有哪些要求？\",\"t\":[\"1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同； 2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType类型相同； 3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同； 4、Mapper.xml文件中的namespace即是mapper接口的类路径。\"]},\"190\":{\"h\":\"19. Mybatis动态sql是做什么的？都有哪些动态sql？\",\"t\":[\"Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。\",\"其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。\"]},\"191\":{\"h\":\"20. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\",\"t\":[\"不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。\",\"原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。\"]},\"192\":{\"h\":\"ORM框架\",\"t\":[\"手写简易mini-mybatis总结\",\"手写简易mini-mybatis总结，从Main入口往下：\"]},\"193\":{\"h\":\"Main\",\"t\":[\"public class Main { public static void main(String[] args) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(\\\"/conf.properties\\\"); SqlSession sqlSession = sqlSessionFactory.opSession(); BookMapper bookMapper = sqlSession.getMapper(BookMapper.class); Book book = bookMapper.selectOne(1); System.out.println(book); List<Book> books = bookMapper.selectList(); System.out.println(books); } } \",\"main中为创建流程：\",\"SqlSessionFactoryBuilder： build方法创建SqlSessionFactory对象\",\"SqlSessionFactory：opSession方法创建sqlSession对象，这里的SqlSessionFactory和SqlSession都是接口，有实现类(Deafult··)\",\"Mapper： sqlsession调getMapper方法创建mapper对象 (Class(T) type 作mapper类型 = ··mapper.clsss)\",\"最后调用 mapper接口中的方法 (在对应xml文件中创建namespace:接口名 ， id:方法名 写sql语句 及返回类型)\"]},\"194\":{\"h\":\"流程解析\",\"t\":[\"SqlSessionFactoryBuilder().build(\\\"/conf.properties\\\")：\",\"通过build重载，创建了SqlSessionFactory，并且new Configuration() 传递下去\",\"qlSessionFactory.opSession() [有实现类]：\",\"loadMappersInfo(configuration) 调用XMLUtil添加mapperStatememt 和 mapper 都add到了configuration中\",\"openSession(confi...) 返回了 new DefaultSqlSession(configuration)\",\"addMapper步骤解析\",\"/* addMapper实际上是向MapperRegister类中添加MapperProxyFactory MapperProxyFactory类中维护着Map<Class<?>, MapperProxyFactory<?>> 哈希表 getMapper时需注意(看getMapper方法)： 先通过type创建factory对象，调factory对象的newInstance方法时传入sqlSession sqlSession 在mapperProxy中有两个调用 取出mapperStatement、调用selectOne/List...方法 在mapperProxy中执行selectOne/List...方法后会回到sqlSession中： sqlSession的CRUD方法会调用executor执行后续sql操作(具体看executor中的7步骤) */ // Configuration.class protected final MapperRegister mapperRegister = new MapperRegister(); public void addMapper(Class<?> type) { mapperRegister.addMapper(type); } // MapperRegister.class private final Map<Class<?>, MapperProxyFactory<?>> mappers = new HashMap<>(); public <T> void addMapper(Class<T> type) { mappers.put(type, new MapperProxyFactory<T>(type)); } public <T> T getMapper(Class<T> type, SqlSession sqlSession) { MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) mappers.get(type); return mapperProxyFactory.newInstance(sqlSession); } \",\"sqlSession.getMapper(BookMapper.class) [有实现类]：\",\"构造方法： 接收configuration，new Executor(configuration)\",\"getMapper(Class《T》 type)：从configuration中拿出mapper 生成 **Mapper\"]},\"195\":{\"h\":\"SqlSessionFactoryBuilder\",\"t\":[\"public class SqlSessionFactoryBuilder { public SqlSessionFactory build(String fileName) { InputStream stream = SqlSessionFactory.class.getResourceAsStream(fileName); System.out.println(\\\"stream: \\\"+stream); return build(stream); } public SqlSessionFactory build(InputStream stream) { try { Configuration.PROPS.load(stream); } catch (IOException e) { e.printStackTrace(); } return new DefaultSqlSessionFactory(new Configuration()); } } \",\"框架入口，build方法重载\",\"build(String fileName)方法：加载stream流，交给重载方法创建SqlSessionFactory对象；\",\".class.getResourceAsStream(fileName)：加载类路径(target/classes)下的文件 class调用就是类路径\",\"build(InputStream stream)：Configuration.PROPS.load(stream)加载配置文件，只能加载InputStream流，加载后才可以调用getProperties(String key)方法读取配置文件；返回DefaultSqlSessionFactory(new Configuration()) 是SqlSessionFactory的实现类\"]},\"196\":{\"h\":\"SqlSessionFactory\",\"t\":[\"接口：\",\"public interface SqlSessionFactory { public SqlSession opSession(); } \",\"实现类：\",\"public class DefaultSqlSessionFactory implements SqlSessionFactory { private final Configuration configuration; public DefaultSqlSessionFactory(Configuration configuration) { this.configuration = configuration; String dir = Configuration.getProperty(Constant.MAPPER_LOCATION).replaceAll(\\\"\\\\\\\\.\\\", \\\"/\\\"); // 我这里似乎不需要replace loadMappersInfo(dir); } @Override public SqlSession opSession() { return new DefaultSqlSession(configuration); } private void loadMappersInfo(String dirName) { URL url = DefaultSqlSessionFactory.class.getClassLoader().getResource(dirName); File mapperFile = new File(url.getFile()); if (mapperFile.isDirectory()) { File[] mappers = mapperFile.listFiles(); System.out.println(mappers[1].getName()); if (CommonUtils.isNotEmpty(mappers)) { for (File file : mappers) { System.out.println(\\\"currentFile: \\\" + file.getName()); if (file.isDirectory()) { System.out.println(\\\"isDir\\\"); loadMappersInfo(dirName + \\\"/\\\" + file.getName()); } else if (file.getName().endsWith(Constant.MAPPER_FILE_SUFFIX)){ System.out.println(\\\"addMapper\\\"); XmlUtil.readMapperXml(file, configuration); } } } } } } \",\"构造方法：Configuration.getProperty(Constant.MAPPER_LOCATION) 得到xml文件路径\",\"loadMappersInfo(String dirName)方法： 获取dirName下文件名，如果为路径则递归loadMappersInfo(dirName + \\\"/\\\" + file.getName())，如果为文件，检测是否以xml后缀结尾，是则调用XmlUtil.readMapperXml(file, configuration)，这里会解析xml配置并执行Configuration中的addMapper\",\"opSession()： 返回的同样是sqlSession的default实现类\"]},\"197\":{\"h\":\"SqlSession\",\"t\":[\"接口：\",\"public interface SqlSession { <T> T getMapper(Class<T> paramClass); Configuration getConfiguration(); <T> T selectOne(String statementId, Object parameter); <E> List<E> selectList(String statementId, Object parameter); void update(String statementId, Object parameter); void insert(String statementId, Object parameter); } \",\"实现类：\",\"public class DefaultSqlSession implements SqlSession { private final Configuration configuration; private final Executor executor; public DefaultSqlSession(Configuration configuration) { this.configuration = configuration; this.executor = new SimpleExecutor(configuration); } @Override public <T> T getMapper(Class<T> type) { return configuration.getMapper(type, this); } @Override public Configuration getConfiguration() { return configuration; } @Override public <T> T selectOne(String statementId, Object parameter) { List<T> list = selectList(statementId, parameter); return CommonUtils.isNotEmpty(list) ? list.get(0) : null; } @Override public <E> List<E> selectList(String statementId, Object parameter) { MapperStatement statement = configuration.getMapperStatement(statementId); return executor.doQuery(statement, parameter); } @Override public void update(String statementId, Object parameter) { MapperStatement statement = configuration.getMapperStatement(statementId); executor.doUpdate(statement, parameter); } @Override public void insert(String statementId, Object parameter) { //TODO } } \",\"sqlSession类通常持有配置类对象configuration和执行器对象executor，内部实现getMapper方法和CRUD方法\",\"构造方法：new SimpleExecutor(configuration) 为executor的default实现类\",\"getMapper方法：从configuration中通过Class(T) type获取mapper对象，因为在sqlSessionFactory的loadMapperInfo中调用的XmlUtils内已经调用过addMapper和addStatement，这里get的statementId为接口+方法名\",\"CRUD方法：configuration.getMapperStatement(statementId)根据statementId获取MapperStatement对象，内有namespace、sqlId、sqlType、resultType等属性；parameter参数交给executor调用参数处理方法处理\",\"这里selectOne方法是特殊的SelectList方法，所以调用selecctList方法执行\"]},\"198\":{\"h\":\"Executor\",\"t\":[\"接口：\",\"public interface Executor { <E> List<E> doQuery(MapperStatement statement, Object parameter); void doUpdate(MapperStatement statement, Object parameter); } \",\"实现类：\",\"public class SimpleExecutor implements Executor{ private static Connection connection; private Configuration configuration; static { initConnection(); } public SimpleExecutor(Configuration configuration) { this.configuration = configuration; } @Override public <E> List<E> doQuery(MapperStatement statement, Object parameter) { try { // 1. 获取连接 Connection connection = getConnection(); // 2. 获取config中的mapperStatement, 内含有sql信息 MapperStatement mapperStatement = configuration.getMapperStatement(statement.getSqlId()); // 3. 实例化StatementHandler对象 StatementHandler statementHandler = new SimpleStatementHandler(mapperStatement); // 4. 通过StatementHandler和connection获取PreparedStatement PreparedStatement preparedStatement = statementHandler.prepare(connection); // 5. 实例化ParameterHandler，将SQL语句中？参数化 ParameterHandler parameterHandler = new DefaultParameterHandler(parameter); parameterHandler.setParameters(preparedStatement); //6. 执行SQL，得到结果集ResultSet ResultSet resultSet = statementHandler.query(preparedStatement); //7. 实例化ResultSetHandler，通过反射将ResultSet中结果设置到目标resultType对象中 ResultSetHandler resultSetHandler = new DefaultResultSetHandler(mapperStatement); return resultSetHandler.handleResultSets(resultSet); } catch (Exception e) { e.printStackTrace(); } return null; } @Override public void doUpdate(MapperStatement statement, Object parameter) { //TODO 未实现 } private static void initConnection() { String driver = Configuration.getProperty(Constant.DB_DRIVER_CONF); String url = Configuration.getProperty(Constant.DB_URL_CONF); String username = Configuration.getProperty(Constant.DB_USERNAME_CONF); String password = Configuration.getProperty(Constant.db_PASSWORD); try { Class.forName(driver); connection = DriverManager.getConnection(url,username,password); System.out.println(\\\"connection 建立\\\"); } catch (SQLException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } } private Connection getConnection() throws SQLException { if (connection != null) { return connection; } else { throw new SQLException(\\\"connection为空\\\"); } } } \",\"initConnection中：xml标签解析中已经load过properties，这里getProperties将值取出用以连接jdbc，连接上的connection对象为成员变量，每次执行do***方法时调getConnect取出\",\"doQuery中：\",\"按注释中的7步走\",\"MapperStatement：configuration.getMapperStatement(statement.getSqlId())按标签id(方法名)取出sql信息，封装为MapperStatement对象\",\"StatementHaldler：处理sql语句，将语句中的#{}替换成 '?' ，返回PreparedStatememnt对象，PreparedStatememnt是java.sql中的对象，接收sql语句作为参数，执行CRUD操作；\",\"ParameterHandler：将已经封装sql语句的PreparedStatememnt传入，解析参数再次封装PreparedStatememnt\",\"ResultSetHandler： PreparedStatememnt执行qeuery返回ResultType对象，此类根据该对象利用反射获取成员变量列表并赋值，最后返回封装好的数据对象List\"]},\"199\":{\"h\":\"MapperStatement 实体类\",\"t\":[\"如code中注释，不详解\",\"public final class MapperStatement { // 接口名 private String namespace; // 接口名 + 方法名 private String sqlId; // sql语句 private String sql; // xml中的resultType private String resultType; // xml中 select标签？ update标签、 insert标签？ private Constant.SqlType sqlType; public String getNamespace() { return namespace; } public void setNamespace(String namespace) { this.namespace = namespace; } public String getSqlId() { return sqlId; } public void setSqlId(String sqlId) { this.sqlId = sqlId; } public String getSql() { return sql; } public void setSql(String sql) { this.sql = sql; } public String getResultType() { return resultType; } public void setResultType(String resultType) { this.resultType = resultType; } public Constant.SqlType getSqlType() { return sqlType; } public void setSqlType(Constant.SqlType sqlType) { this.sqlType = sqlType; } @Override public String toString() { return \\\"MapperStatement{\\\" + \\\"namespace='\\\" + namespace + '\\\\'' + \\\", sqlId='\\\" + sqlId + '\\\\'' + \\\", sql='\\\" + sql + '\\\\'' + \\\", resultType='\\\" + resultType + '\\\\'' + \\\", sqlType=\\\" + sqlType + '}'; } } \"]},\"200\":{\"h\":\"Mapper\",\"t\":[\"该类无接口\",\"注册类：\",\"public class MapperRegister { // **Mapper.class 作key 对应factory类为value private final Map<Class<?>, MapperProxyFactory<?>> mappers = new HashMap<>(); public <T> void addMapper(Class<T> type) { mappers.put(type, new MapperProxyFactory<T>(type)); } public <T> T getMapper(Class<T> type, SqlSession sqlSession) { MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) mappers.get(type); return mapperProxyFactory.newInstance(sqlSession); } } \",\"Mapper注册类：维护着一个(Class，MapperProxyFactory)的哈希表，注册mapper时调用传入**Mapper.class作为key，创建一个mapperProxyFactory作为值，需要时调用getMapper取出。\",\"工厂类：\",\"public class MapperProxyFactory<T> { // **Mapper.class 作 类型 private final Class<T> mapperInterface; public MapperProxyFactory(Class<T> mapperInterface) { this.mapperInterface = mapperInterface; } public T newInstance(SqlSession sqlSession) { MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface); return newInstance(mapperProxy); } protected T newInstance(MapperProxy<T> mapperProxy) { return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]{mapperInterface}, mapperProxy); } } \",\"成员变量mapperInterface：在注册类的哈希表中维护着值\",\"newInstance(SqlSession sqlSession)： 根据传入的sqlSession和mapper成员变量创建一个MapperProxy对象，将对象交给重载的方法去进行代理。\",\"newInstance(MapperProxy《T》 mapperProxy)：实现代理，参数值解析为 (···Mapper.class，Class[]{···Mapper}，mapperProxy)\",\"代理类：\",\"public class MapperProxy<T> implements InvocationHandler, Serializable { private static final long serializeUid = -17524833145151L; private final SqlSession sqlSession; private final Class<T> mapperInterface; public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface) { this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (Object.class.equals(method.getDeclaringClass())) { return method.invoke(this, args); } return execute(method, args); } private Object execute(Method method, Object[] args) { String statementId = this.mapperInterface.getName() + \\\".\\\" + method.getName(); // 根据接口名+方法名获取对应 mapperStatement对象 MapperStatement statement = this.sqlSession.getConfiguration().getMapperStatement(statementId); Object result = null; switch (statement.getSqlType()) { case SELECT: { Class<?> returnType = method.getReturnType(); //检查方法 method 的返回类型 returnType 是否可以被 Collection 类或其子类所赋值 // 即检查返回类型是否为集合 if (Collection.class.isAssignableFrom(returnType)) { result = sqlSession.selectList(statementId, args); } else { result = sqlSession.selectOne(statementId, args); } break; } case UPDATE: { sqlSession.update(statementId, args); break; } default: //TODO insert delete 方法待实现 break; } return result; } } \",\"此类返回了查询的返回结果，需实现序列化接口； 传入sqlSession与mapperInferface，实现代理方法\",\"继承InvocationHandler，实现invoke方法，在被MapperProxyFactory代理时调用\",\"execute(Method method, Object[] args)： 创建被代理方法的具体实现；通过mapperInterface拿到sqlId、再通过ssqlId拿到statement具体sql信息、取sqlType与枚举类定义中的类型比较，确定要执行的流程、最后返回结果\"]},\"201\":{\"h\":\"Statement\",\"t\":[\"接口：\",\"public interface StatementHandler { PreparedStatement prepare(Connection paramConnection) throws SQLException; ResultSet query(PreparedStatement preparedStatement) throws SQLException; void update(PreparedStatement preparedStatement) throws SQLException; } \",\"实现类：\",\"public class SimpleStatementHandler implements StatementHandler{ /** #{}正则匹配 */ private static final Pattern param_pattern = Pattern.compile(\\\"#\\\\\\\\{([^\\\\\\\\{\\\\\\\\}]*)\\\\\\\\}\\\"); private final MapperStatement mapperStatement; public SimpleStatementHandler(MapperStatement mapperStatement) { this.mapperStatement = mapperStatement; } @Override public PreparedStatement prepare(Connection paramConnection) throws SQLException { String originalSql = mapperStatement.getSql(); if (CommonUtils.isNotEmpty(originalSql)) { // 替换#{}，预处理，防止SQL注入 return paramConnection.prepareStatement(parseSymbol(originalSql)); } else { throw new SQLException(\\\"original sql is null\\\"); } } @Override public ResultSet query(PreparedStatement preparedStatement) throws SQLException { return preparedStatement.executeQuery(); } @Override public void update(PreparedStatement preparedStatement) throws SQLException { preparedStatement.executeUpdate(); } /** * 将SQL语句中的#{}替换为？，源码中是在SqlSourceBuilder类中解析的 * * @param originalSql * @return */ private static String parseSymbol(String originalSql) { originalSql = originalSql.trim(); Matcher matcher = param_pattern.matcher(originalSql); return matcher.replaceAll(\\\"?\\\"); } } \",\"成员变量：\",\"Pattern：java.util.regex的正则匹配类，用以替换#{}为 '?'\",\"MapperStatement：paramConnection.prepareStatement(parseSymbol(originalSql))，connection对象的prepareStatement方法创建PreparedStatement对象执行sql语句，需要用到的sql语句参数，从这里取\",\"prepare方法：传入connection对象，创建PreparedStatement对象执行后续CRUD\",\"query、update等自定义方法：传入PreparedStatement对象，通过它执行sql语句，并返回ResultSet对象\",\"parseSymbol方法：传入sql语句，消除两边空格，替换#{} 为 '?'\"]},\"202\":{\"h\":\"Parameter\",\"t\":[\"接口：\",\"public interface ParameterHandler { void setParameters(PreparedStatement paramPreparedStatement); } \",\"实现类：\",\"public class DefaultParameterHandler implements ParameterHandler{ private Object parameter; public DefaultParameterHandler(Object parameter) { this.parameter = parameter; } @Override public void setParameters(PreparedStatement paramPreparedStatement) { try { if (parameter != null) { //parameter.getClass().isArray() 这个判断只有1个参数也为true if (parameter.getClass().isArray()) { // 强转为数组类型 Object[] parames = (Object[]) parameter; for (int i = 0; i < parames.length; i++) { // 设置第几个参数，索引从1开始 paramPreparedStatement.setObject(i + 1, parames[i]); } } } } catch (SQLException e) { e.printStackTrace(); } } } \",\"注意：\",\"该类与其他类不耦合，只为PreparedStatement设置参数，也无返回值；接收Object parameter作为参数，parameter.getClass().isArray() 此判断中即使参数只有一个也为true，Object[] parames = (Object[]) parameter 强转数组获取参数列表，paramPreparedStatement.setObject(i + 1, parames[i])，设置第几个参数，方法默认索引从1开始\"]},\"203\":{\"h\":\"ResultSet\",\"t\":[\"接口：\",\"public interface ResultSetHandler { <E> List<E> handleResultSets(ResultSet resultSet); } \",\"实体类：\",\"public class DefaultResultSetHandler implements ResultSetHandler{ private final MapperStatement mapperStatement; public DefaultResultSetHandler(MapperStatement mapperStatement) { this.mapperStatement = mapperStatement; } @Override public <E> List<E> handleResultSets(ResultSet resultSet) { try { List<E> result = new ArrayList<>(); if (result == null) { return null; } while (resultSet.next()) { // 通过反射实例化返回类 解析xml设置mapperStatement时 标签的resultType即为目标类路径 Class<?> entrtyClass = Class.forName(mapperStatement.getResultType()); // 获取实体类 泛型 E entry = (E) entrtyClass.newInstance(); // 获取成员变量列表 Field[] fields = entry.getClass().getDeclaredFields(); for (Field field : fields) { // 设置访问权限，为true则表示对象应该允许访问，即使它是私有的或者受保护的 // 为false则正常进行权限检测 field.setAccessible(true); Class<?> fieldType = field.getType(); if (String.class.equals(fieldType)) { field.set(entry, resultSet.getString(field.getName())); } else if (Integer.class.equals(fieldType)) { field.set(entry, resultSet.getInt(field.getName())); } else { // 其他类型未一一实现 field.set(entry, resultSet.getObject(field.getName())); } } result.add(entry); } return result; } catch (SQLException e) { throw new RuntimeException(e); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } } \",\"该类也与其他类不耦合，创建实现类，解析字段封装结果类后，返回结果类的List对象\",\"成员变量：mapperStatement，内有sql信息，这里是为了取里面的mapperStatement.getResultType()返回类型， 类型为xml解析时标签的的resultType，即为返回类的路径\",\"List(E) handleResultSets(ResultSet resultSet)：\",\"entry.getClass().getDeclaredFields()： 获取成员变量列表\",\"Class<?> fieldType = field.getType()：遍历成员变量列表，获取每个变量类型\",\"String/Integer.class.equals(fieldType)：根据变量类型，设置变量值 field.set(entry, resultSet.getString(field.getName()))\",\"将填充好变量值的类添加到结果集中，继续resultSet.next() 遍历下一条数据\"]},\"204\":{\"h\":\"Utils包下类\",\"t\":[\"Constant:\",\"public interface Constant { /** * UTF-8编码 */ String CHARSET_UTF8 = \\\"UTF-8\\\"; /******** 在properties文件中配置信息 **************/ String MAPPER_LOCATION = \\\"mapper.location\\\"; String DB_DRIVER_CONF = \\\"db.driver\\\"; String DB_URL_CONF = \\\"db.url\\\"; String DB_USERNAME_CONF = \\\"db.username\\\"; String db_PASSWORD = \\\"db.password\\\"; /************ mapper xml ****************/ /** * mapper文件后缀 */ String MAPPER_FILE_SUFFIX = \\\".xml\\\"; String XML_ROOT_LABEL = \\\"mapper\\\"; String XML_ELEMENT_ID = \\\"id\\\"; String XML_SELECT_NAMESPACE = \\\"namespace\\\"; String XML_SELECT_RESULTTYPE = \\\"resultType\\\"; /** * SQL类型枚举，如select、insert、update */ public enum SqlType { SELECT(\\\"select\\\"), INSERT(\\\"insert\\\"), UPDATE(\\\"update\\\"), DEFAULT(\\\"default\\\"); private String value; private SqlType(String value) { this.value = value; } public String value() { return this.value; } } } \",\"XMLUtil:\",\"public final class XmlUtil { /** * readMapperXml * * @param fileName * @param configuration * @see */ public static void readMapperXml(File fileName, Configuration configuration) { try { // 创建一个读取器 SAXReader saxReader = new SAXReader(); saxReader.setEncoding(Constant.CHARSET_UTF8); // 读取文件内容 Document document = saxReader.read(fileName); // 获取xml中的根元素 Element rootElement = document.getRootElement(); // 不是beans根元素的，文件不对 if (!Constant.XML_ROOT_LABEL.equals(rootElement.getName())) { System.err.println(\\\"mapper xml文件根元素不是mapper\\\"); return; } // 获取 根标签的属性 :namespace String namespace = rootElement.attributeValue(Constant.XML_SELECT_NAMESPACE); List<MapperStatement> statements = new ArrayList<>(); for (Iterator iterator = rootElement.elementIterator(); iterator.hasNext(); ) { // 获取mapper根标签下的 每个子标签 Element element = (Element) iterator.next(); // 获取子标签名 String eleName = element.getName(); MapperStatement statement = new MapperStatement(); // 子标签名 与sqlType枚举类比对， 确认是select、update等四种标签的哪种 if (Constant.SqlType.SELECT.value().equals(eleName)) { String resultType = element.attributeValue(Constant.XML_SELECT_RESULTTYPE); // 根据获得的标签属性为 mapperStatement 对象赋值 statement.setResultType(resultType); statement.setSqlType(Constant.SqlType.SELECT); } else if (Constant.SqlType.UPDATE.value().equals(eleName)) { statement.setSqlType(Constant.SqlType.UPDATE); } else { // 其他标签自己实现 System.err.println(\\\"不支持此xml标签解析:\\\" + eleName); statement.setSqlType(Constant.SqlType.DEFAULT); } //设置SQL的唯一ID String sqlId = namespace + \\\".\\\" + element.attributeValue(Constant.XML_ELEMENT_ID); statement.setSqlId(sqlId); statement.setNamespace(namespace); statement.setSql(CommonUtils.stringTrim(element.getStringValue())); statements.add(statement); configuration.addMapperStatement(sqlId, statement); //这里其实是在MapperRegistry中生产一个mapper对应的代理工厂 System.out.println(\\\"namespace \\\"+namespace); configuration.addMapper(Class.forName(namespace)); } } catch (Exception e) { e.printStackTrace(); } } } \",\"CommonUtil:\",\"public class CommonUtils { public static boolean isNotEmpty(String src) { return src != null && src.trim().length() > 0; } /** * list/set is not empty * * @param collection * @return */ public static boolean isNotEmpty(Collection<?> collection) { return collection != null && !collection.isEmpty(); } /** * map is not empty * * @param map * @return */ public static boolean isNotEmpty(Map<?, ?> map) { return map != null && !map.isEmpty(); } /** * 数组不为空 * * @param arr * @return * @see */ public static boolean isNotEmpty(Object[] arr) { return arr != null && arr.length > 0; } /** * 对字符串去空白符和换行符等 * * @return */ public static String stringTrim(String src) { return (null != src) ? src.trim() : null; } } \"]},\"205\":{\"h\":\"所需实体类及mapper接口、xml文件、配置文件\",\"t\":[\"Book：\",\"public class Book { private Integer id; private String type; private String name; private String description; // 省略构造方法、Getter、Setter、toString方法 } \",\"BookMapper：\",\"public interface BookMapper { Book selectOne(Integer id); List<Book> selectList(); int update(Integer id); } \",\"BookMapper.xml：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <mapper namespace=\\\"com.minibatis.mapper.BookMapper\\\"> <select id=\\\"selectOne\\\" resultType=\\\"com.minibatis.mapper.Book\\\"> select * from book where id = #{id} </select> <select id=\\\"selectList\\\" resultType=\\\"com.minibatis.mapper.Book\\\"> select * from book </select> <update id=\\\"update\\\"> update book set description = \\\"update方法\\\" where id = #{id} </update> </mapper> \",\"conf.properties\",\"mapper.location=com.minibatis.mapper db.driver=com.mysql.cj.jdbc.Driver db.url=jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf8 db.username=root db.password=root \"]},\"206\":{\"h\":\"MyRPCFromZero\",\"t\":[\"从零开始，手写一个RPC，跟随着这篇文档以及数个迭代版本的代码，由简陋到逐渐完备，让所有人都能看懂并且写出一个RPC框架。\",\"本文档与代码都是本人第一次手写RPC的心路历程，会有理解的偏差与代码上的不完善，但更是由于这样，有着与新手对同样问题的疑惑，也许会使新手更容易理解这样做的缘故是啥。\",\"另外期待与你的合作：代码，帮助文档甚至rpc框架功能的完备\",\"学习建议：\",\"一定要实际上手敲代码\",\"每一版本都有着对应独立的代码与文档，结合来看\",\"每一版本前有一个背景知识，建议先掌握其相关概念再上手代码\",\"每一个版本都有着要解决的问题与此版本的最大痛点，带着问题去写代码，并且与上个版本的代码进行比较差异\"]},\"207\":{\"h\":\"RPC的概念\"},\"208\":{\"h\":\"背景知识\",\"t\":[\"RPC的基本概念，核心功能\",\"常见的RPC框架\"]},\"209\":{\"h\":\"Duboo基本功能\",\"t\":[\"远程通讯\",\"基于接口方法的透明远程过程调用\",\"负载均衡\",\"服务注册中心\"]},\"210\":{\"h\":\"RPC过程\",\"t\":[\"client 调用远程方法-> request序列化 -> 协议编码 -> 网络传输-> 服务端 -> 反序列化request -> 调用本地方法得到response -> 序列化 ->编码->…..\"]},\"211\":{\"h\":\"版本迭代过程\"},\"212\":{\"h\":\"目录\",\"t\":[\"从0开始的RPC的迭代过程：\",\"version0版本：以不到百行的代码完成一个RPC例子\",\"version1版本：完善通用消息格式（request，response），客户端的动态代理完成对request消息格式的封装\",\"version2版本：支持服务端暴露多个服务接口， 服务端程序抽象化，规范化\",\"version3版本：使用高性能网络框架netty的实现网络通信，以及客户端代码的重构\",\"version4版本：自定义消息格式，支持多种序列化方式（java原生， json…）\",\"version5版本: 服务器注册与发现的实现，zookeeper作为注册中心\",\"version6版本: 负载均衡的策略的实现\",\"version7版本: 客户端缓存服务地址列表, zookeeper监听服务提供者状态，更新客户端缓存**（待实现）**\",\"version8版本： 跨语言的RPC通信（protobuf）（待实现）\"]},\"213\":{\"h\":\"0.一个最简单的RPC调用\"},\"214\":{\"h\":\"\",\"t\":[\"java基础\",\"java socket编程入门\",\"项目使用maven搭建，暂时只引入了lombok包\"]},\"215\":{\"h\":\"本节问题\",\"t\":[\"什么是RPC，怎么完成一个RPC?\",\"一个RPC最最最简单的过程是客户端调用服务端的的一个方法, 服务端返回执行方法的返回值给客服端。接下来我会以一个从数据库里取数据的例子来进行一次模拟RPC过程的一个完整流程。\",\"假定有以下这样一个服务：\",\"服务端：\",\"有一个User表\",\"UserServiceImpl 实现了UserService接口\",\"UserService里暂时只有一个功能: getUserByUserId(Integer id)\",\"客户端：\",\"​ 传一个Id给服务端，服务端查询到User对象返回给客户端\"]},\"216\":{\"h\":\"过程\",\"t\":[\"首先我们得有User对象，这是客户端与服务端都已知的，客户端需要得到这个pojo对象数据，服务端需要操作这个对象\",\"@Builder @Data @NoArgsConstructor @AllArgsConstructor public class User implements Serializable { // 客户端和服务端共有的 private Integer id; private String userName; private Boolean sex; } \",\"定义客户端需要调用，服务端需要提供的服务接口\",\"public interface UserService { // 客户端通过这个接口调用服务端的实现类 User getUserByUserId(Integer id); } \",\"服务端需要实现Service接口的功能\",\"public class UserServiceImpl implements UserService { @Override public User getUserByUserId(Integer id) { System.out.println(\\\"客户端查询了\\\"+id+\\\"的用户\\\"); // 模拟从数据库中取用户的行为 Random random = new Random(); User user = User.builder().userName(UUID.randomUUID().toString()) .id(id) .sex(random.nextBoolean()).build(); return user; } } \",\"客户端建立Socket连接，传输Id给服务端，得到返回的User对象\",\"public class RPCClient { public static void main(String[] args) { try { // 建立Socket连接 Socket socket = new Socket(\\\"127.0.0.1\\\", 8899); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); // 传给服务器id objectOutputStream.writeInt(new Random().nextInt()); objectOutputStream.flush(); // 服务器查询数据，返回对应的对象 User user = (User) objectInputStream.readObject(); System.out.println(\\\"服务端返回的User:\\\"+user); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); System.out.println(\\\"客户端启动失败\\\"); } } } \",\"服务端以BIO的方式监听Socket，如有数据，调用对应服务的实现类执行任务，将结果返回给客户端\",\"public class RPCServer { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); try { ServerSocket serverSocket = new ServerSocket(8899); System.out.println(\\\"服务端启动了\\\"); // BIO的方式监听Socket while (true){ Socket socket = serverSocket.accept(); // 开启一个线程去处理 new Thread(()->{ try { ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); // 读取客户端传过来的id Integer id = ois.readInt(); User userByUserId = userService.getUserByUserId(id); // 写入User对象给客户端 oos.writeObject(userByUserId); oos.flush(); } catch (IOException e){ e.printStackTrace(); System.out.println(\\\"从IO中读取数据错误\\\"); } }).start(); } } catch (IOException e) { e.printStackTrace(); System.out.println(\\\"服务器启动失败\\\"); } } } \"]},\"217\":{\"h\":\"结果：\"},\"218\":{\"h\":\"总结：\",\"t\":[\"这个例子以不到百行的代码，实现了客户端与服务端的一个远程过程调用，非常适合上手，当然它是及其不完善的，甚至连消息格式都没有统一，我们将在接下来的版本更新中逐渐完善它。\"]},\"219\":{\"h\":\"此RPC的最大痛点：\",\"t\":[\"只能调用服务端Service唯一确定的方法，如果有两个方法需要调用呢?（Reuest需要抽象）\",\"返回值只支持User对象，如果需要传一个字符串或者一个Dog，String对象呢（Response需要抽象）\",\"客户端不够通用，host，port， 与调用的方法都特定（需要抽象）\"]},\"220\":{\"h\":\"1.MyRPC版本1\"},\"221\":{\"h\":\"背景知识\",\"t\":[\"反射\",\"动态代理\"]},\"222\":{\"h\":\"本节问题\",\"t\":[\"如何使客户端请求远程方法支持多种?\",\"如何使服务端返回值的类型多样?\"]},\"223\":{\"h\":\"版本升级过程\",\"t\":[\"更新1：定义了一个通用的Request的对象（消息格式）\",\"/** * 在上个例子中，我们的Request仅仅只发送了一个id参数过去，这显然是不合理的， * 因为服务端不会只有一个服务一个方法，因此只传递参数不会知道调用那个方法 * 因此一个RPC请求中，client发送应该是需要调用的Service接口名，方法名，参数，参数类型 * 这样服务端就能根据这些信息根据反射调用相应的方法 * 还是使用java自带的序列化方式 */ @Data @Builder public class RPCRequest implements Serializable { // 服务类名，客户端只知道接口名，在服务端中用接口名指向实现类 private String interfaceName; // 方法名 private String methodName; // 参数列表 private Object[] params; // 参数类型 private Class<?>[] paramsTypes; } \",\"更新2： 定义了一个通用的Response的对象（消息格式）\",\"/** * 上个例子中response传输的是User对象，显然在一个应用中我们不可能只传输一种类型的数据 * 由此我们将传输对象抽象成为Object * Rpc需要经过网络传输，有可能失败，类似于http，引入状态码和状态信息表示服务调用成功还是失败 */ @Data @Builder public class RPCResponse implements Serializable { // 状态信息 private int code; private String message; // 具体数据 private Object data; public static RPCResponse success(Object data) { return RPCResponse.builder().code(200).data(data).build(); } public static RPCResponse fail() { return RPCResponse.builder().code(500).message(\\\"服务器发生错误\\\").build(); } } \",\"因此在网络传输过程都是request与response格式的数据了，客户端与服务器端就要负责封装与解析以上结构数据\",\"更新3： 服务端接受request请求，并调用request中的对应的方法\",\"public interface UserService { // 客户端通过这个接口调用服务端的实现类 User getUserByUserId(Integer id); // 给这个服务增加一个功能 Integer insertUserId(User user); } \",\"服务端的实现类UserServiceImpl要实现增加的功能\",\"@Override public Integer insertUserId(User user) { System.out.println(\\\"插入数据成功：\\\"+user); return 1; } \",\"服务端接受解析reuqest与封装发送response对象\",\"public class RPCServer { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); try { ServerSocket serverSocket = new ServerSocket(8899); System.out.println(\\\"服务端启动了\\\"); // BIO的方式监听Socket while (true){ Socket socket = serverSocket.accept(); // 开启一个线程去处理，这个类负责的功能太复杂，以后代码重构中，这部分功能要分离出来 new Thread(()->{ try { ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); // 读取客户端传过来的request RPCRequest request = (RPCRequest) ois.readObject(); // 反射调用对应方法 Method method = userService.getClass().getMethod(request.getMethodName(), request.getParamsTypes()); Object invoke = method.invoke(userService, request.getParams()); // 封装，写入response对象 oos.writeObject(RPCResponse.success(invoke)); oos.flush(); }catch (IOException | ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e){ e.printStackTrace(); System.out.println(\\\"从IO中读取数据错误\\\"); } }).start(); } } catch (IOException e) { e.printStackTrace(); System.out.println(\\\"服务器启动失败\\\"); } } } \",\"更新4： 客户端根据不同的Service进行动态代理：\",\"代理对象增强的公共行为：把不同的Service方法封装成统一的Request对象格式，并且建立与Server的通信\",\"底层的通信\",\"public class IOClient { // 这里负责底层与服务端的通信，发送的Request，接受的是Response对象 // 客户端发起一次请求调用，Socket建立连接，发起请求Request，得到响应Response // 这里的request是封装好的（上层进行封装），不同的service需要进行不同的封装， 客户端只知道Service接口，需要一层动态代理根据反射封装不同的Service public static RPCResponse sendRequest(String host, int port, RPCRequest request){ try { Socket socket = new Socket(host, port); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); System.out.println(request); objectOutputStream.writeObject(request); objectOutputStream.flush(); RPCResponse response = (RPCResponse) objectInputStream.readObject(); return response; } catch (IOException | ClassNotFoundException e) { System.out.println(); return null; } } } \",\"动态代理封装request对象\",\"@AllArgsConstructor public class ClientProxy implements InvocationHandler { // 传入参数Service接口的class对象，反射封装成一个request private String host; private int port; // jdk 动态代理， 每一次代理对象调用方法，会经过此方法增强（反射获取request对象，socket发送至客户端） @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // request的构建，使用了lombok中的builder，代码简洁 RPCRequest request = RPCRequest.builder().interfaceName(method.getDeclaringClass().getName()) .methodName(method.getName()) .params(args).paramsTypes(method.getParameterTypes()).build(); // 数据传输 RPCResponse response = IOClient.sendRequest(host, port, request); //System.out.println(response); return response.getData(); } <T>T getProxy(Class<T> clazz){ Object o = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{clazz}, this); return (T)o; } } \",\"客户端调用不同的方法\",\"public class RPCClient { public static void main(String[] args) { ClientProxy clientProxy = new ClientProxy(\\\"127.0.0.1\\\", 8899); UserService proxy = clientProxy.getProxy(UserService.class); // 服务的方法1 User userByUserId = proxy.getUserByUserId(10); System.out.println(\\\"从服务端得到的user为：\\\" + userByUserId); // 服务的方法2 User user = User.builder().userName(\\\"张三\\\").id(100).sex(true).build(); Integer integer = proxy.insertUserId(user); System.out.println(\\\"向服务端插入数据：\\\"+integer); } } \"]},\"224\":{\"h\":\"结果\"},\"225\":{\"h\":\"总结\",\"t\":[\"定义更加通用的消息格式：Request 与Response格式， 从此可能调用不同的方法，与返回各种类型的数据。\",\"使用了动态代理进行不同服务方法的Request的封装，\",\"客户端更加松耦合，不再与特定的Service，host，port绑定\"]},\"226\":{\"h\":\"存在的痛点\",\"t\":[\"服务端我们直接绑定的是UserService服务，如果还有其它服务接口暴露呢?（多个服务的注册）\",\"服务端以BIO的方式性能是否太低，\",\"服务端功能太复杂：监听，处理。需要松耦合\"]},\"227\":{\"h\":\"2.MyRPC 版本2\"},\"228\":{\"h\":\"背景知识\",\"t\":[\"代码解耦\",\"线程池\"]},\"229\":{\"h\":\"本节问题：\",\"t\":[\"如果一个服务端要提供多个服务的接口， 例如新增一个BlogService，怎么处理?\",\"// 自然的想到用一个Map来保存，<interfaceName, xxxServiceImpl> UserService userService = new UserServiceImpl(); BlogService blogService = new BlogServiceImpl(); Map<String, Object>.put(\\\"***.userService\\\", userService); Map<String, Object>.put(\\\"***.blogService\\\", blogService); // 此时来了一个request，我们就能从map中取出对应的服务 Object service = map.get(request.getInterfaceName()) \"]},\"230\":{\"h\":\"版本升级过程\",\"t\":[\"更新前的工作： 更新一个新的服务接口样例和pojo类\",\"// 新的服务接口 public interface BlogService { Blog getBlogById(Integer id); } // 服务端新的服务接口实现类 public class BlogServiceImpl implements BlogService { @Override public Blog getBlogById(Integer id) { Blog blog = Blog.builder().id(id).title(\\\"我的博客\\\").useId(22).build(); System.out.println(\\\"客户端查询了\\\"+id+\\\"博客\\\"); return blog; } } // pojo类 @Data @Builder @NoArgsConstructor @AllArgsConstructor public class Blog implements Serializable { private Integer id; private Integer useId; private String title; } \",\"更新1： HashMap<String, Object> 添加多个服务的实现类\",\"public class TestServer { public static void main(String[] args) { UserService userService = new UserServiceImpl(); BlogService blogService = new BlogServiceImpl(); Map<String, Object> serviceProvide = new HashMap<>(); // 暴露两个服务接口， 即在RPCServer中加一个HashMap serviceProvide.put(\\\"com.ganghuan.myRPCVersion2.service.UserService\\\",userService); serviceProvide.put(\\\"com.ganghuan.myRPCVersion2.service.BlogService\\\",blogService); RPCServer RPCServer = new SimpleRPCRPCServer(serviceProvide); RPCServer.start(8899); } } // 这里先不去讨论实现其中的细节，因为这里还应该进行优化，我们先去把服务端代码松耦合，再回过来讨论 \",\"更新2： 服务端代码重构\",\"抽象RPCServer，开放封闭原则\",\"// 把RPCServer抽象成接口，以后的服务端实现这个接口即可 public interface RPCServer { void start(int port); void stop(); } \",\"RPCService简单版本的实现\",\"/** * 这个实现类代表着java原始的BIO监听模式，来一个任务，就new一个线程去处理 * 处理任务的工作见WorkThread中 */ public class SimpleRPCRPCServer implements RPCServer { // 存着服务接口名-> service对象的map private Map<String, Object> serviceProvide; public SimpleRPCRPCServer(Map<String,Object> serviceProvide){ this.serviceProvide = serviceProvide; } public void start(int port) { try { ServerSocket serverSocket = new ServerSocket(port); System.out.println(\\\"服务端启动了\\\"); // BIO的方式监听Socket while (true){ Socket socket = serverSocket.accept(); // 开启一个新线程去处理 new Thread(new WorkThread(socket,serviceProvide)).start(); } } catch (IOException e) { e.printStackTrace(); System.out.println(\\\"服务器启动失败\\\"); } } public void stop(){ } } \",\"为了加强性能，我们还提供了线程池版的实现\",\"public class ThreadPoolRPCRPCServer implements RPCServer { private final ThreadPoolExecutor threadPool; private Map<String, Object> serviceProvide; public ThreadPoolRPCRPCServer(Map<String, Object> serviceProvide){ threadPool = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), 1000, 60, TimeUnit.SECONDS, new ArrayBlockingQueue<>(100)); this.serviceProvide = serviceProvide; } public ThreadPoolRPCRPCServer(Map<String, Object> serviceProvide, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue){ threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); this.serviceProvide = serviceProvide; } @Override public void start(int port) { System.out.println(\\\"服务端启动了\\\"); try { ServerSocket serverSocket = new ServerSocket(port); while(true){ Socket socket = serverSocket.accept(); threadPool.execute(new WorkThread(socket,serviceProvide)); } } catch (IOException e) { e.printStackTrace(); } } @Override public void stop() { } } \",\"工作任务类，从服务端代码分离出来，简化服务端代码，单一职责原则\",\"/** * 这里负责解析得到的request请求，执行服务方法，返回给客户端 * 1. 从request得到interfaceName 2. 根据interfaceName在serviceProvide Map中获取服务端的实现类 * 3. 从request中得到方法名，参数， 利用反射执行服务中的方法 4. 得到结果，封装成response，写入socket */ @AllArgsConstructor public class WorkThread implements Runnable{ private Socket socket; private Map<String, Object> serviceProvide; @Override public void run() { try { ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); // 读取客户端传过来的request RPCRequest request = (RPCRequest) ois.readObject(); // 反射调用服务方法获得返回值 RPCResponse response = getResponse(request); //写入到客户端 oos.writeObject(response); oos.flush(); }catch (IOException | ClassNotFoundException e){ e.printStackTrace(); System.out.println(\\\"从IO中读取数据错误\\\"); } } private RPCResponse getResponse(RPCRequest request){ // 得到服务名 String interfaceName = request.getInterfaceName(); // 得到服务端相应服务实现类 Object service = serviceProvide.get(interfaceName); // 反射调用方法 Method method = null; try { method = service.getClass().getMethod(request.getMethodName(), request.getParamsTypes()); Object invoke = method.invoke(service, request.getParams()); return RPCResponse.success(invoke); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); System.out.println(\\\"方法执行错误\\\"); return RPCResponse.fail(); } } } \",\"服务端代码第一次重构完毕。\",\"更新3： 服务暴露类，这里回到了更新1**，我们发现服务接口名是我们**直接手写的，这里其实可以利用class对象自动得到\",\"/** * 之前这里使用Map简单实现的 * 存放服务接口名与服务端对应的实现类 * 服务启动时要暴露其相关的实现类0 * 根据request中的interface调用服务端中相关实现类 */ public class ServiceProvider { /** * 一个实现类可能实现多个接口 */ private Map<String, Object> interfaceProvider; public ServiceProvider(){ this.interfaceProvider = new HashMap<>(); } public void provideServiceInterface(Object service){ String serviceName = service.getClass().getName(); Class<?>[] interfaces = service.getClass().getInterfaces(); for(Class clazz : interfaces){ interfaceProvider.put(clazz.getName(),service); } } public Object getService(String interfaceName){ return interfaceProvider.get(interfaceName); } } \",\"前面服务端的代码中有Sevicerprovide 这个HashMap的地方需要改成ServiProvider，比如\",\"public class TestServer { public static void main(String[] args) { UserService userService = new UserServiceImpl(); BlogService blogService = new BlogServiceImpl(); // Map<String, Object> serviceProvide = new HashMap<>(); // serviceProvide.put(\\\"com.ganghuan.myRPCVersion2.service.UserService\\\",userService); // serviceProvide.put(\\\"com.ganghuan.myRPCVersion2.service.BlogService\\\",blogService); ServiceProvider serviceProvider = new ServiceProvider(); serviceProvider.provideServiceInterface(userService); serviceProvider.provideServiceInterface(blogService); RPCServer RPCServer = new SimpleRPCRPCServer(serviceProvider); RPCServer.start(8899); } } \"]},\"231\":{\"h\":\"结果\",\"t\":[\"// 客户中添加新的测试用例 BlogService blogService = rpcClientProxy.getProxy(BlogService.class); Blog blogById = blogService.getBlogById(10000); System.out.println(\\\"从服务端得到的blog为：\\\" + blogById); \"]},\"232\":{\"h\":\"总结：\",\"t\":[\"在一版本中，我们重构了服务端的代码，代码更加简洁，\",\"添加线程池版的服务端的实现，性能应该会有所提升（未测）\",\"并且服务端终于能够提供不同服务了， 功能更加完善，不再鸡肋\"]},\"233\":{\"h\":\"此RPC最大的痛点\",\"t\":[\"传统的BIO与线程池网络传输性能低\"]},\"234\":{\"h\":\"3.MyRPC版本3\"},\"235\":{\"h\":\"背景知识\",\"t\":[\"netty高性能网络框架的使用\"]},\"236\":{\"h\":\"本节问题\",\"t\":[\"如何提升这个rpc的性能? 可以从两个方面入手，网络传输从BIO到NIO，序列化要减少字节流长度，提高序列化反序列化效率\",\"知名的rpc框架：dubbo， grpc都是使用netty底层进行通信的\"]},\"237\":{\"h\":\"升级过程：\",\"t\":[\"前提： maven pom.xml文件引入netty\",\"<dependency> <groupId>io.netty</groupId> <artifactId>netty-all</artifactId> <version>4.1.51.Final</version> </dependency> \",\"升级1： 重构客户端代码\",\"客户端的代码太乱了， 我们先进行代码重构，才有利于后面使用netty的方式实现客户端，使之不同方式网络连接的客户端有着同样的结构，同样的api\",\"假如我们现在已经有了两个客户端：SimpleRPCClient(使用java BIO的方式)， NettyRPCClient（使用netty进行网络传输），那么它们两者的共性是啥?发送请求与得到response是共性， 而建立连接与发送请求的方式是不同点。\",\"// 共性抽取出来 public interface RPCClient { RPCResponse sendRequest(RPCRequest response); } // SimpleRPCClient实现这个接口，不同的网络方式有着不同的实现 @AllArgsConstructor public class SimpleRPCClient implements RPCClient{ private String host; private int port; // 客户端发起一次请求调用，Socket建立连接，发起请求Request，得到响应Response // 这里的request是封装好的，不同的service需要进行不同的封装， 客户端只知道Service接口，需要一层动态代理根据反射封装不同的Service public RPCResponse sendRequest(RPCRequest request) { try { // 发起一次Socket连接请求 Socket socket = new Socket(host, port); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); System.out.println(request); objectOutputStream.writeObject(request); objectOutputStream.flush(); RPCResponse response = (RPCResponse) objectInputStream.readObject(); //System.out.println(response.getData()); return response; } catch (IOException | ClassNotFoundException e) { System.out.println(); return null; } } } \",\"而RPCClientProxy类中需要加入一个RPCClient类变量即可， 传入不同的client(simple,netty), 即可调用公共的接口sendRequest发送请求，所以客户端代码结构很清晰了:\",\"RPCClient: 不同的网络连接，网络传输方式的客户端分别实现这个接口\",\"XXXRPCClient: 具体实现类\",\"RPCClientProxy： 动态代理Service类，封装不同的Service请求为Request对象，并且持有一个RPCClient对象，负责与服务端的通信，\",\"由此，客户端代码重构完毕，结构更为清晰，一个使用用例为：\",\"// 构建一个使用java Socket传输的客户端 SimpleRPCClient simpleRPCClient = new SimpleRPCClient(\\\"127.0.0.1\\\", 8899); // 把这个客户端传入代理客户端 RPCClientProxy rpcClientProxy = new RPCClientProxy(simpleRPCClient); // 代理客户端根据不同的服务，获得一个代理类， 并且这个代理类的方法以或者增强（封装数据，发送请求） UserService userService = rpcClientProxy.getProxy(UserService.class); // 调用方法 User userByUserId = userService.getUserByUserId(10); \",\"升级2： 使用netty方式传输数据：实现NettyRPCServer， NettyRPCCLient，这里建议先学习下netty的启动代码\",\"netty 服务端的实现\",\"/** * 实现RPCServer接口，负责监听与发送数据 */ @AllArgsConstructor public class NettyRPCServer implements RPCServer { private ServiceProvider serviceProvider; @Override public void start(int port) { // netty 服务线程组boss负责建立连接， work负责具体的请求 NioEventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workGroup = new NioEventLoopGroup(); System.out.printf(\\\"Netty服务端启动了...\\\"); try { // 启动netty服务器 ServerBootstrap serverBootstrap = new ServerBootstrap(); // 初始化 serverBootstrap.group(bossGroup,workGroup).channel(NioServerSocketChannel.class) .childHandler(new NettyServerInitializer(serviceProvider)); // 同步阻塞 ChannelFuture channelFuture = serverBootstrap.bind(port).sync(); // 死循环监听 channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { e.printStackTrace(); } finally { bossGroup.shutdownGracefully(); workGroup.shutdownGracefully(); } } @Override public void stop() { } } \",\"netty server初始化类\",\"/** * 初始化，主要负责序列化的编码解码， 需要解决netty的粘包问题 */ @AllArgsConstructor public class NettyServerInitializer extends ChannelInitializer<SocketChannel> { private ServiceProvider serviceProvider; @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); // 消息格式 [长度][消息体], 解决粘包问题 pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4)); // 计算当前待发送消息的长度，写入到前4个字节中 pipeline.addLast(new LengthFieldPrepender(4)); // 这里使用的还是java 序列化方式， netty的自带的解码编码支持传输这种结构 pipeline.addLast(new ObjectEncoder()); pipeline.addLast(new ObjectDecoder(new ClassResolver() { @Override public Class<?> resolve(String className) throws ClassNotFoundException { return Class.forName(className); } })); pipeline.addLast(new NettyRPCServerHandler(serviceProvider)); } } \",\"netty server具体的handler\",\"/** * 因为是服务器端，我们知道接受到请求格式是RPCRequest * Object类型也行，强制转型就行 */ @AllArgsConstructor public class NettyRPCServerHandler extends SimpleChannelInboundHandler<RPCRequest> { private ServiceProvider serviceProvider; @Override protected void channelRead0(ChannelHandlerContext ctx, RPCRequest msg) throws Exception { //System.out.println(msg); RPCResponse response = getResponse(msg); ctx.writeAndFlush(response); ctx.close(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } RPCResponse getResponse(RPCRequest request) { // 得到服务名 String interfaceName = request.getInterfaceName(); // 得到服务端相应服务实现类 Object service = serviceProvider.getService(interfaceName); // 反射调用方法 Method method = null; try { method = service.getClass().getMethod(request.getMethodName(), request.getParamsTypes()); Object invoke = method.invoke(service, request.getParams()); return RPCResponse.success(invoke); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); System.out.println(\\\"方法执行错误\\\"); return RPCResponse.fail(); } } } \",\"客户端netty的实现\",\"/** * 实现RPCClient接口 */ public class NettyRPCClient implements RPCClient { private static final Bootstrap bootstrap; private static final EventLoopGroup eventLoopGroup; private String host; private int port; public NettyRPCClient(String host, int port) { this.host = host; this.port = port; } // netty客户端初始化，重复使用 static { eventLoopGroup = new NioEventLoopGroup(); bootstrap = new Bootstrap(); bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class) .handler(new NettyClientInitializer()); } /** * 这里需要操作一下，因为netty的传输都是异步的，你发送request，会立刻返回， 而不是想要的相应的response */ @Override public RPCResponse sendRequest(RPCRequest request) { try { ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); Channel channel = channelFuture.channel(); // 发送数据 channel.writeAndFlush(request); channel.closeFuture().sync(); // 阻塞的获得结果，通过给channel设计别名，获取特定名字下的channel中的内容（这个在hanlder中设置） // AttributeKey是，线程隔离的，不会由线程安全问题。 // 实际上不应通过阻塞，可通过回调函数 AttributeKey<RPCResponse> key = AttributeKey.valueOf(\\\"RPCResponse\\\"); RPCResponse response = channel.attr(key).get(); System.out.println(response); return response; } catch (InterruptedException e) { e.printStackTrace(); } return null; } } \",\"初始化： 与服务端一致，就不贴代码了\",\"ClientHandler设计：\",\"public class NettyClientHandler extends SimpleChannelInboundHandler<RPCResponse> { @Override protected void channelRead0(ChannelHandlerContext ctx, RPCResponse msg) throws Exception { // 接收到response, 给channel设计别名，让sendRequest里读取response AttributeKey<RPCResponse> key = AttributeKey.valueOf(\\\"RPCResponse\\\"); ctx.channel().attr(key).set(msg); ctx.channel().close(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } } \"]},\"238\":{\"h\":\"结果：\"},\"239\":{\"h\":\"总结\",\"t\":[\"此版本我们完成了客户端的重构，使之能够支持多种版本客户端的扩展（实现RPCClient接口）\",\"并且使用netty实现了客户端与服务端的通信\"]},\"240\":{\"h\":\"此RPC最大痛点\",\"t\":[\"java自带序列化方式（Java序列化写入不仅是完整的类名，也包含整个类的定义，包含所有被引用的类），不够通用，不够高效\"]},\"241\":{\"h\":\"4.MyRPC版本4\"},\"242\":{\"h\":\"背景知识\",\"t\":[\"各种序列化方式以及比较，（Java原生序列化， json，protobuf，kryo..）参考博客\",\"自定义协议\",\"java IO 了解\",\"TCP粘包问题，解决方式\"]},\"243\":{\"h\":\"本节问题\",\"t\":[\"如何设计并完成自己的协议?\",\"答：自己实现encode与decode\"]},\"244\":{\"h\":\"升级过程\",\"t\":[\"在前面的RPC版本中， 我们都是使用的java自带的序列化的方式，事实上使用这种方式性能是很低的（序列化后的字节数组， 解码编码速度），而且在netty服务端，我们使用的是netty自带的编码器，简单的传输了一个 消息长度（4个字节）| 序列化后的数据 格式的数据。 在这里我们要自定义我们的传输格式和编解码。\",\"下面是我的初步对我的自定义格式的设计了， 先读取消息类型（Requst， Response， ping， pong）， 序列化方式（原生， json，kryo， protobuf..）， 加上消息长度：防止粘包， 再根据长度读取data\",\"消息类型（2Byte）\",\"序列化方式 2Byte\",\"消息长度 4Byte\",\"序列化后的Data….\",\"序列化后的Data…\",\"序列化后的Data….\",\"前提处理： maven pom文件中引入fastjson包， RPCResponse中需要加入DataType字段，因为其它序列化方式（json）无法得到Data的类型，\",\"升级1： 自定义编解码器\",\"序列化器的接口：\",\"public interface Serializer { // 把对象序列化成字节数组 byte[] serialize(Object obj); // 从字节数组反序列化成消息, 使用java自带序列化方式不用messageType也能得到相应的对象（序列化字节数组里包含类信息） // 其它方式需指定消息格式，再根据message转化成相应的对象 Object deserialize(byte[] bytes, int messageType); // 返回使用的序列器，是哪个 // 0：java自带序列化方式, 1: json序列化方式 int getType(); // 根据序号取出序列化器，暂时有两种实现方式，需要其它方式，实现这个接口即可 static Serializer getSerializerByCode(int code){ switch (code){ case 0: return new ObjectSerializer(); case 1: return new JsonSerializer(); default: return null; } } } \",\"encode类\",\"/** * 依次按照自定义的消息格式写入，传入的数据为request或者response * 需要持有一个serialize器，负责将传入的对象序列化成字节数组 */ @AllArgsConstructor public class MyEncode extends MessageToByteEncoder { private Serializer serializer; @Override protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception { System.out.println(msg.getClass()); // 写入消息类型 if(msg instanceof RPCRequest){ out.writeShort(MessageType.REQUEST.getCode()); } else if(msg instanceof RPCResponse){ out.writeShort(MessageType.RESPONSE.getCode()); } // 写入序列化方式 out.writeShort(serializer.getType()); // 得到序列化数组 byte[] serialize = serializer.serialize(msg); // 写入长度 out.writeInt(serialize.length); // 写入序列化字节数组 out.writeBytes(serialize); } } \",\"decode类\",\"/** * 按照自定义的消息格式解码数据 */ @AllArgsConstructor public class MyDecode extends ByteToMessageDecoder { @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception { // 1. 读取消息类型 short messageType = in.readShort(); // 现在还只支持request与response请求 if(messageType != MessageType.REQUEST.getCode() && messageType != MessageType.RESPONSE.getCode()){ System.out.println(\\\"暂不支持此种数据\\\"); return; } // 2. 读取序列化的类型 short serializerType = in.readShort(); // 根据类型得到相应的序列化器 Serializer serializer = Serializer.getSerializerByCode(serializerType); if(serializer == null)throw new RuntimeException(\\\"不存在对应的序列化器\\\"); // 3. 读取数据序列化后的字节长度 int length = in.readInt(); // 4. 读取序列化数组 byte[] bytes = new byte[length]; in.readBytes(bytes); // 用对应的序列化器解码字节数组 Object deserialize = serializer.deserialize(bytes, messageType); out.add(deserialize); } } \",\"升级2： 支持不同的序列化器\",\"Java 原生序列化\",\"public class ObjectSerializer implements Serializer{ // 利用java IO 对象 -> 字节数组 @Override public byte[] serialize(Object obj) { byte[] bytes = null; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try { ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(obj); oos.flush(); bytes = bos.toByteArray(); oos.close(); bos.close(); } catch (IOException e) { e.printStackTrace(); } return bytes; } // 字节数组 -> 对象 @Override public Object deserialize(byte[] bytes, int messageType) { Object obj = null; ByteArrayInputStream bis = new ByteArrayInputStream(bytes); try { ObjectInputStream ois = new ObjectInputStream(bis); obj = ois.readObject(); ois.close(); bis.close(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } return obj; } // 0 代表java原生序列化器 @Override public int getType() { return 0; } } \",\"Json序列化器\",\"/** * 由于json序列化的方式是通过把对象转化成字符串，丢失了Data对象的类信息，所以deserialize需要 * 了解对象对象的类信息，根据类信息把JsonObject -> 对应的对象 */ public class JsonSerializer implements Serializer{ @Override public byte[] serialize(Object obj) { byte[] bytes = JSONObject.toJSONBytes(obj); return bytes; } @Override public Object deserialize(byte[] bytes, int messageType) { Object obj = null; // 传输的消息分为request与response switch (messageType){ case 0: RPCRequest request = JSON.parseObject(bytes, RPCRequest.class); Object[] objects = new Object[request.getParams().length]; // 把json字串转化成对应的对象， fastjson可以读出基本数据类型，不用转化 for(int i = 0; i < objects.length; i++){ Class<?> paramsType = request.getParamsTypes()[i]; if (!paramsType.isAssignableFrom(request.getParams()[i].getClass())){ objects[i] = JSONObject.toJavaObject((JSONObject) request.getParams()[i],request.getParamsTypes()[i]); }else{ objects[i] = request.getParams()[i]; } } request.setParams(objects); obj = request; break; case 1: RPCResponse response = JSON.parseObject(bytes, RPCResponse.class); Class<?> dataType = response.getDataType(); if(! dataType.isAssignableFrom(response.getData().getClass())){ response.setData(JSONObject.toJavaObject((JSONObject) response.getData(),dataType)); } obj = response; break; default: System.out.println(\\\"暂时不支持此种消息\\\"); throw new RuntimeException(); } return obj; } // 1 代表着json序列化方式 @Override public int getType() { return 1; } } \"]},\"245\":{\"h\":\"结果\",\"t\":[\"在netty初始化类（客户端，服务器端）中添加解码器中使用自己定义的解码器：\",\"public class NettyClientInitializer extends ChannelInitializer<SocketChannel> { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); // 使用自定义的编解码器 pipeline.addLast(new MyDecode()); // 编码需要传入序列化器，这里是json，还支持ObjectSerializer，也可以自己实现其他的 pipeline.addLast(new MyEncode(new JsonSerializer())); pipeline.addLast(new NettyClientHandler()); } } \",\"成功启动!\"]},\"246\":{\"h\":\"总结\",\"t\":[\"在这版本中，我们自己定义的消息格式，使之支持多种消息类型，序列化方式，使用消息头加长度的方式解决粘包问题\",\"并且，实现了ObjectSerializer与JsonSerializer两种序列化器，也可以轻松扩展为其它序列化方式（实现Serialize接口）。\"]},\"247\":{\"h\":\"此版本最大痛点\",\"t\":[\"服务端与客户端通信的host与port预先就必须知道的，每一个客户端都必须知道对应服务的ip与端口号， 并且如果服务挂了或者换地址了，就很麻烦。扩展性也不强\"]},\"248\":{\"h\":\"5.MyRPC版本5\"},\"249\":{\"h\":\"背景知识\",\"t\":[\"zookeeper安装， 基本概念\",\"了解curator开源zookeeper客户端中的使用\"]},\"250\":{\"h\":\"本节问题\",\"t\":[\"如何设计一个注册中心\",\"注册中心（如zookeeper）的地址是固定的（为了高可用一般是集群，我们看做黑盒即可）， 服务端上线时，在注册中心注册自己的服务与对应的地址，而客户端调用服务时，去注册中心根据服务名找到对应的服务端地址。\",\"zookeeper我们可以近似看作一个树形目录文件系统，是一个分布式协调应用，其它注册中心有EureKa， Nacos等\"]},\"251\":{\"h\":\"升级过程\",\"t\":[\"前提\",\"下载解压Zookeeper [地址]（https://zookeeper.apache.org/releases.html）\",\"学习一个zookeeper启动的例子 官方例子\",\"zoo.cfg 修改dataDir为一个存在目录\",\"windows启动命令: bin/zkServer.cmd\",\"java项目中引入Curator客户端，\",\"<!--这个jar包应该依赖log4j,不引入log4j会有控制台会有warn，但不影响正常使用--> <dependency> <groupId>org.apache.curator</groupId> <artifactId>curator-recipes</artifactId> <version>5.1.0</version> </dependency> \",\"更新1 ： 引入zookeeper作为注册中心\",\"启动本地zookeeper服务端，默认端口2181。zookeeper客户端测试如下：\",\"先定义服务注册接口\",\"// 服务注册接口，两大基本功能，注册：保存服务与地址。 查询：根据服务名查找地址 public interface ServiceRegister { void register(String serviceName, InetSocketAddress serverAddress); InetSocketAddress serviceDiscovery(String serviceName); } \",\"zookeeper服务注册接口的实现类\",\"public class ZkServiceRegister implements ServiceRegister{ // curator 提供的zookeeper客户端 private CuratorFramework client; // zookeeper根路径节点 private static final String ROOT_PATH = \\\"MyRPC\\\"; // 这里负责zookeeper客户端的初始化，并与zookeeper服务端建立连接 public ZkServiceRegister(){ // 指数时间重试 RetryPolicy policy = new ExponentialBackoffRetry(1000, 3); // zookeeper的地址固定，不管是服务提供者还是，消费者都要与之建立连接 // sessionTimeoutMs 与 zoo.cfg中的tickTime 有关系， // zk还会根据minSessionTimeout与maxSessionTimeout两个参数重新调整最后的超时值。默认分别为tickTime 的2倍和20倍 // 使用心跳监听状态 this.client = CuratorFrameworkFactory.builder().connectString(\\\"127.0.0.1:2181\\\") .sessionTimeoutMs(40000).retryPolicy(policy).namespace(ROOT_PATH).build(); this.client.start(); System.out.println(\\\"zookeeper 连接成功\\\"); } @Override public void register(String serviceName, InetSocketAddress serverAddress){ try { // serviceName创建成永久节点，服务提供者下线时，不删服务名，只删地址 if(client.checkExists().forPath(\\\"/\\\" + serviceName) == null){ client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(\\\"/\\\" + serviceName); } // 路径地址，一个/代表一个节点 String path = \\\"/\\\" + serviceName +\\\"/\\\"+ getServiceAddress(serverAddress); // 临时节点，服务器下线就删除节点 client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path); } catch (Exception e) { System.out.println(\\\"此服务已存在\\\"); } } // 根据服务名返回地址 @Override public InetSocketAddress serviceDiscovery(String serviceName) { try { List<String> strings = client.getChildren().forPath(\\\"/\\\" + serviceName); // 这里默认用的第一个，后面加负载均衡 String string = strings.get(0); return parseAddress(string); } catch (Exception e) { e.printStackTrace(); } return null; } // 地址 -> XXX.XXX.XXX.XXX:port 字符串 private String getServiceAddress(InetSocketAddress serverAddress) { return serverAddress.getHostName() + \\\":\\\" + serverAddress.getPort(); } // 字符串解析为地址 private InetSocketAddress parseAddress(String address) { String[] result = address.split(\\\":\\\"); return new InetSocketAddress(result[0], Integer.parseInt(result[1])); } } \",\"更新2： 更新客户端得到服务器的方式， 服务端暴露服务时，注册到注册中心\",\"首先new client不需要传入host与name， 而在发送request时，从注册中心获得\",\"// 不需传host，port RPCClient rpcClient = new NettyRPCClient(); \",\"客户端的改造\",\"public class SimpleRPCClient implements RPCClient { private String host; private int port; private ServiceRegister serviceRegister; public SimpleRPCClient() { // 初始化注册中心，建立连接 this.serviceRegister = new ZkServiceRegister(); } // 客户端发起一次请求调用，Socket建立连接，发起请求Request，得到响应Response // 这里的request是封装好的，不同的service需要进行不同的封装， 客户端只知道Service接口，需要一层动态代理根据反射封装不同的Service public RPCResponse sendRequest(RPCRequest request) { // 从注册中心获取host，port InetSocketAddress address = serviceRegister.serviceDiscovery(request.getInterfaceName()); host = address.getHostName(); port = address.getPort(); try { Socket socket = new Socket(host, port); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); System.out.println(request); objectOutputStream.writeObject(request); objectOutputStream.flush(); RPCResponse response = (RPCResponse) objectInputStream.readObject(); //System.out.println(response.getData()); return response; } catch (IOException | ClassNotFoundException e) { System.out.println(); return null; } } } \",\"服务端的改造：服务端反而需要把自己的ip，端口给注册中心\",\"ServiceProvider serviceProvider = new ServiceProvider(\\\"127.0.0.1\\\", 8899); \",\"在服务暴露类加入注册的功能\",\"public class ServiceProvider { /** * 一个实现类可能实现多个服务接口， */ private Map<String, Object> interfaceProvider; private ServiceRegister serviceRegister; private String host; private int port; public ServiceProvider(String host, int port){ // 需要传入服务端自身的服务的网络地址 this.host = host; this.port = port; this.interfaceProvider = new HashMap<>(); this.serviceRegister = new ZkServiceRegister(); } public void provideServiceInterface(Object service){ Class<?>[] interfaces = service.getClass().getInterfaces(); for(Class clazz : interfaces){ // 本机的映射表 interfaceProvider.put(clazz.getName(),service); // 在注册中心注册服务 serviceRegister.register(clazz.getName(),new InetSocketAddress(host,port)); } } public Object getService(String interfaceName){ return interfaceProvider.get(interfaceName); } } \"]},\"252\":{\"h\":\"结果\",\"t\":[\"成功运行！\"]},\"253\":{\"h\":\"总结\",\"t\":[\"此版本中我们加入了注册中心，终于一个完整的RPC框架三个角色都有了：服务提供者，服务消费者，注册中心\"]},\"254\":{\"h\":\"此版本最大痛点\",\"t\":[\"根据服务名查询地址时，我们返回的总是第一个IP，导致这个提供者压力巨大，而其它提供者调用不到\"]},\"255\":{\"h\":\"6.MyRPC版本6\",\"t\":[\"我们的RPC总体框架已经有了，接下来就是一些修修补补已经扩展功能的模块了\"]},\"256\":{\"h\":\"背景知识\",\"t\":[\"负载均衡\"]},\"257\":{\"h\":\"本节问题\",\"t\":[\"如果一个服务有多个提供者支持，如何分散服务提供者的压力\"]},\"258\":{\"h\":\"升级过程\",\"t\":[\"负载均衡接口\",\"/** * 给服务器地址列表，根据不同的负载均衡策略选择一个 */ public interface LoadBalance { String balance(List<String> addressList); } \",\"两种实现方式\",\"/** * 随机负载均衡 */ public class RandomLoadBalance implements LoadBalance{ @Override public String balance(List<String> addressList) { Random random = new Random(); int choose = random.nextInt(addressList.size()); System.out.println(\\\"负载均衡选择了\\\" + choose + \\\"服务器\\\"); return addressList.get(choose); } } \",\"/** * 轮询负载均衡 */ public class RoundLoadBalance implements LoadBalance{ private int choose = -1; @Override public String balance(List<String> addressList) { choose++; choose = choose%addressList.size(); return addressList.get(choose); } } \",\"在服务发现方法中使用负载均衡\",\"List<String> strings = client.getChildren().forPath(\\\"/\\\" + serviceName); \"]},\"259\":{\"h\":\"结果\",\"t\":[\"我们开启两台服务提供者\",\"可以看出负载均衡策略已经成功\"]},\"260\":{\"h\":\"总结\",\"t\":[\"这一版本中，我们实现负载均衡的两种策略：随机与轮询。\",\"在这一版本下，一个完整功能的RPC已经出现，当然还有许多性能上与代码质量上的工作需要完成。\"]},\"261\":{\"h\":\"此版本最大痛点\",\"t\":[\"客户端每次发起请求都要先与zookeeper进行通信得到地址，效率低下。\"]},\"262\":{\"h\":\"Spring框架 概述\"},\"263\":{\"h\":\"1. 使用Spring框架的好处是什么？\",\"t\":[\"**轻量：**Spring 是轻量的，基本的版本大约2MB\",\"**控制反转：**Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们\",\"**面向切面的编程(AOP)：**Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开\",\"**容器：**Spring 包含并管理应用中对象的生命周期和配置\",\"**MVC框架：**Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品\",\"**事务管理：**Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）\",\"**异常处理：**Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。\"]},\"264\":{\"h\":\"2. 什么是 Spring IOC 容器？\",\"t\":[\"Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。\"]},\"265\":{\"h\":\"3. 什么是依赖注入？可以通过多少种方式完成依赖注入？\",\"t\":[\"在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。\",\"通常，依赖注入可以通过三种方式完成，即：\",\"构造函数注入\",\"setter 注入\",\"接口注入\",\"在 Spring Framework 中，仅使用构造函数和 setter 注入。\"]},\"266\":{\"h\":\"4. 区分 BeanFactory 和 ApplicationContext？\",\"t\":[\"BeanFactory\",\"ApplicationContext\",\"它使用懒加载\",\"它使用即时加载\",\"它使用语法显式提供资源对象\",\"它自己创建和管理资源对象\",\"不支持国际化\",\"支持国际化\",\"不支持基于依赖的注解\",\"支持基于依赖的注解\",\"BeanFactory和ApplicationContext的优缺点分析：\",\"BeanFactory的优缺点：\",\"优点：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势；\",\"缺点：运行速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过Bean工厂创建的Bean生命周期会简单一些。\",\"ApplicationContext的优缺点：\",\"优点：所有的Bean在启动的时候都进行了加载，系统运行的速度快；在系统启动的时候，可以发现系统中的配置问题。\",\"缺点：把费时的操作放到系统启动中完成，所有的对象都可以预加载，缺点就是内存占用较大。\"]},\"267\":{\"h\":\"5. 区分构造函数注入和 setter 注入\",\"t\":[\"构造函数注入\",\"setter 注入\",\"没有部分注入\",\"有部分注入\",\"不会覆盖 setter 属性\",\"会覆盖 setter 属性\",\"任意修改都会创建一个新实例\",\"任意修改不会创建一个新实例\",\"适用于设置很多属性\",\"适用于设置少量属性\"]},\"268\":{\"h\":\"6. spring 提供了哪些配置方式？\",\"t\":[\"基于 xml 配置\",\"bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：\",\"<bean id=\\\"studentbean\\\" class=\\\"org.edureka.firstSpring.StudentBean\\\"> <property name=\\\"name\\\" value=\\\"Edureka\\\"></property> </bean> \",\"基于注解配置\",\"您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：\",\"<beans> <context:annotation-config/> <!-- bean definitions go here --> </beans> \",\"基于 Java API 配置\",\"Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。\",\"@Bean 注解扮演与 <bean /> 元素相同的角色。\",\"@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。\",\"例如：\",\"@Configuration public class StudentConfig { @Bean public StudentBean myStudent() { return new StudentBean(); } } \"]},\"269\":{\"h\":\"7. Spring 中的 bean 的作用域有哪些?\",\"t\":[\"singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。\",\"prototype : 每次请求都会创建一个新的 bean 实例。\",\"request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。\",\"session : ：在一个HTTP Session中，一个Bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。\",\"global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话\"]},\"270\":{\"h\":\"8. 如何理解IoC和DI？\",\"t\":[\"IOC就是控制反转，通俗的说就是我们不用自己创建实例对象，这些都交给Spring的bean工厂帮我们创建管理。这也是Spring的核心思想，通过面向接口编程的方式来是实现对业务组件的动态依赖。这就意味着IOC是Spring针对解决程序耦合而存在的。在实际应用中，Spring通过配置文件（xml或者properties）指定需要实例化的java类（类名的完整字符串），包括这些java类的一组初始化值，通过加载读取配置文件，用Spring提供的方法（getBean()）就可以获取到我们想要的根据指定配置进行初始化的实例对象。\",\"优点：IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。\",\"DI：DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\"]},\"271\":{\"h\":\"9. 将一个类声明为Spring的 bean 的注解有哪些?\",\"t\":[\"我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：\",\"@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。 8 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。\",\"@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。\",\"@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。\"]},\"272\":{\"h\":\"10. spring 支持几种 bean scope？\",\"t\":[\"Spring bean 支持 5 种 scope：\",\"Singleton - 每个 Spring IoC 容器仅有一个单实例。\",\"Prototype - 每次请求都会产生一个新的实例。\",\"Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。\",\"Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。\",\"Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。\",\"仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。\"]},\"273\":{\"h\":\"11. Spring 中的 bean 生命周期?\",\"t\":[\"Bean的生命周期是由容器来管理的。主要在创建和销毁两个时期。\"]},\"274\":{\"h\":\"创建过程：\",\"t\":[\"1，实例化bean对象，以及设置bean属性； 2，如果通过Aware接口声明了依赖关系，则会注入Bean对容器基础设施层面的依赖，Aware接口是为了感知到自身的一些属性。容器管理的Bean一般不需要知道容器的状态和直接使用容器。但是在某些情况下是需要在Bean中对IOC容器进行操作的。这时候需要在bean中设置对容器的感知。SpringIOC容器也提供了该功能，它是通过特定的Aware接口来完成的。 比如BeanNameAware接口，可以知道自己在容器中的名字。 如果这个Bean已经实现了BeanFactoryAware接口，可以用这个方式来获取其它Bean。 （如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。 如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。 如果Bean实现了BeanFactoryAware接口，调用setBeanFactory()方法，传入BeanFactory对象的实例。） 3，紧接着会调用BeanPostProcess的前置初始化方法postProcessBeforeInitialization，主要作用是在Spring完成实例化之后，初始化之前，对Spring容器实例化的Bean添加自定义的处理逻辑。有点类似于AOP。 4，如果实现了BeanFactoryPostProcessor接口的afterPropertiesSet方法，做一些属性被设定后的自定义的事情。 5，调用Bean自身定义的init方法，去做一些初始化相关的工作。 6，调用BeanPostProcess的后置初始化方法，postProcessAfterInitialization去做一些bean初始化之后的自定义工作。 7，完成以上创建之后就可以在应用里使用这个Bean了。\"]},\"275\":{\"h\":\"销毁过程：\",\"t\":[\"当Bean不再用到，便要销毁 1，若实现了DisposableBean接口，则会调用destroy方法； 2，若配置了destry-method属性，则会调用其配置的销毁方法；\"]},\"276\":{\"h\":\"总结\",\"t\":[\"主要把握创建过程和销毁过程这两个大的方面； 创建过程：首先实例化Bean，并设置Bean的属性，根据其实现的Aware接口（主要是BeanFactoryAware接口，BeanFactoryAware，ApplicationContextAware）设置依赖信息， 接下来调用BeanPostProcess的postProcessBeforeInitialization方法，完成initial前的自定义逻辑；afterPropertiesSet方法做一些属性被设定后的自定义的事情;调用Bean自身定义的init方法，去做一些初始化相关的工作;然后再调用postProcessAfterInitialization去做一些bean初始化之后的自定义工作。这四个方法的调用有点类似AOP。 此时，Bean初始化完成，可以使用这个Bean了。 销毁过程：如果实现了DisposableBean的destroy方法，则调用它，如果实现了自定义的销毁方法，则调用之。\"]},\"277\":{\"h\":\"12. 什么是 spring 的内部 bean？\",\"t\":[\"只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg> 中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。\",\"例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。\",\"Student.java\",\"public class Student { private Person person; //Setters and Getters } public class Person { private String name; private String address; //Setters and Getters } \",\"bean.xml\",\"<bean id=“StudentBean\\\" class=\\\"com.edureka.Student\\\"> <property name=\\\"person\\\"> <!--This is inner bean --> <bean class=\\\"com.edureka.Person\\\"> <property name=\\\"name\\\" value=“Scott\\\"></property> <property name=\\\"address\\\" value=“Bangalore\\\"></property> </bean> </property> </bean> \"]},\"278\":{\"h\":\"13. 什么是 spring 装配？\",\"t\":[\"当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。\",\"Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。\",\"自动装配的不同模式：\",\"no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。\",\"byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。\",\"byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。\",\"构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。\",\"autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。\"]},\"279\":{\"h\":\"14. 自动装配有什么局限？\",\"t\":[\"覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。\",\"基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。\",\"令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。\"]},\"280\":{\"h\":\"15. Spring中出现同名bean怎么办？\",\"t\":[\"同一个配置文件内同名的Bean，以最上面定义的为准\",\"不同配置文件中存在同名Bean，后解析的配置文件会覆盖先解析的配置文件\",\"同文件中ComponentScan和@Bean出现同名Bean。同文件下@Bean的会生效，@ComponentScan扫描进来不会生效。通过@ComponentScan扫描进来的优先级是最低的，原因就是它扫描进来的Bean定义是最先被注册的~\"]},\"281\":{\"h\":\"16. Spring 怎么解决循环依赖问题？\",\"t\":[\"spring对循环依赖的处理有三种情况： ①构造器的循环依赖：这种依赖spring是处理不了的，直 接抛出BeanCurrentlylnCreationException异常。 ②单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。 ③非单例循环依赖：无法处理。\",\"下面分析单例模式下的setter循环依赖如何解决\",\"Spring的单例对象的初始化主要分为三步： \",\"（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象\",\"（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充\",\"（3）initializeBean：调用spring xml中的init 方法。\",\"从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二部。也就是构造器循环依赖和field循环依赖。\",\"举例：A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了\",\"初始化的第一步（createBeanINstance实例化），并且将自己提前曝光到singletonFactories中。\",\"此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过\",\"ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。\",\"此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。\"]},\"282\":{\"h\":\"17. Spring 中的单例 bean 的线程安全问题？\",\"t\":[\"当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对单例状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全.\",\"无状态bean和有状态bean\",\"有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。\",\"无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。\",\"在spring中无状态的Bean适合用不变模式，就是单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，适合用Prototype原型模式。 Spring使用ThreadLocal解决线程安全问题。如果你的Bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全 。\"]},\"283\":{\"h\":\"18. 什么是 AOP？\",\"t\":[\"AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角. 在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)\"]},\"284\":{\"h\":\"19. AOP 有哪些实现方式？\",\"t\":[\"实现 AOP 的技术，主要分为两大类：\",\"静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强； \",\"编译时编织（特殊编译器实现）\",\"类加载时编织（特殊的类加载器实现）。\",\"动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。 \",\"JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。\",\"CGLIB动态代理： 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB （ Code Generation Library ），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。\"]},\"285\":{\"h\":\"20. Spring AOP and AspectJ AOP 有什么区别？\",\"t\":[\"Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。 Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。\"]},\"286\":{\"h\":\"21. Spring 框架中用到了哪些设计模式？\",\"t\":[\"工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。\",\"代理设计模式 : Spring AOP 功能的实现。\",\"单例设计模式 : Spring 中的 Bean 默认都是单例的。\",\"模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。\",\"包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。\",\"观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。\",\"适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。\"]},\"287\":{\"h\":\"22. Spring 事务实现方式有哪些？\",\"t\":[\"编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。\",\"声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。\"]},\"288\":{\"h\":\"23. Spring框架的事务管理有哪些优点？\",\"t\":[\"它提供了跨不同事务api（如JTA、JDBC、Hibernate、JPA和JDO）的一致编程模型。\",\"它为编程事务管理提供了比JTA等许多复杂事务API更简单的API。\",\"它支持声明式事务管理。\",\"它很好地集成了Spring的各种数据访问抽象。\"]},\"289\":{\"h\":\"24. spring事务定义的传播规则\",\"t\":[\"PROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。\",\"PROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。\",\"PROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。\",\"PROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。\",\"PROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\",\"PROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。\",\"PROPAGATION_NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。\"]},\"290\":{\"h\":\"25. SpringMVC 工作原理了解吗?\",\"t\":[\"原理如下图所示：\",\"上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 DispatcherServlet 的作用是接收请求，响应结果。\",\"流程说明（重要）：\",\"客户端（浏览器）发送请求，直接请求到 DispatcherServlet。\",\"DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。\",\"解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。\",\"HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。\",\"处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。\",\"ViewResolver 会根据逻辑 View 查找实际的 View。\",\"DispaterServlet 把返回的 Model 传给 View（视图渲染）。\",\"把 View 返回给请求者（浏览器）\"]},\"291\":{\"h\":\"26. 简单介绍 Spring MVC 的核心组件\",\"t\":[\"那么接下来就简单介绍一下 DispatcherServlet 和九大组件（按使用顺序排序的）：\",\"组件\",\"说明\",\"DispatcherServlet\",\"Spring MVC 的核心组件，是请求的入口，负责协调各个组件工作\",\"MultipartResolver\",\"内容类型( Content-Type )为 multipart/* 的请求的解析器，例如解析处理文件上传的请求，便于获取参数信息以及上传的文件\",\"HandlerMapping\",\"请求的处理器匹配器，负责为请求找到合适的 HandlerExecutionChain 处理器执行链，包含处理器（handler）和拦截器们（interceptors）\",\"HandlerAdapter\",\"处理器的适配器。因为处理器 handler 的类型是 Object 类型，需要有一个调用者来实现 handler 是怎么被执行。Spring 中的处理器的实现多变，比如用户处理器可以实现 Controller 接口、HttpRequestHandler 接口，也可以用 @RequestMapping 注解将方法作为一个处理器等，这就导致 Spring MVC 无法直接执行这个处理器。所以这里需要一个处理器适配器，由它去执行处理器\",\"HandlerExceptionResolver\",\"处理器异常解析器，将处理器（ handler ）执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果\",\"RequestToViewNameTranslator\",\"视图名称转换器，用于解析出请求的默认视图名\",\"LocaleResolver\",\"本地化（国际化）解析器，提供国际化支持\",\"ThemeResolver\",\"主题解析器，提供可设置应用整体样式风格的支持\",\"ViewResolver\",\"视图解析器，根据视图名和国际化，获得最终的视图 View 对象\",\"FlashMapManager\",\"FlashMap 管理器，负责重定向时，保存参数至临时存储（默认 Session）\",\"Spring MVC 对各个组件的职责划分的比较清晰。DispatcherServlet 负责协调，其他组件则各自做分内之事，互不干扰。\"]},\"292\":{\"h\":\"27. @Controller 注解有什么用？\",\"t\":[\"@Controller 注解标记一个类为 Spring Web MVC 控制器 Controller。Spring MVC 会将扫描到该注解的类，然后扫描这个类下面带有 @RequestMapping 注解的方法，根据注解信息，为这个方法生成一个对应的处理器对象，在上面的 HandlerMapping 和 HandlerAdapter组件中讲到过。\",\"当然，除了添加 @Controller 注解这种方式以外，你还可以实现 Spring MVC 提供的 Controller 或者 HttpRequestHandler 接口，对应的实现类也会被作为一个处理器对象\"]},\"293\":{\"h\":\"28. @RequestMapping 注解有什么用？\",\"t\":[\"@RequestMapping 注解，在上面已经讲过了，配置处理器的 HTTP 请求方法，URI等信息，这样才能将请求和方法进行映射。这个注解可以作用于类上面，也可以作用于方法上面，在类上面一般是配置这个控制器的 URI 前缀\"]},\"294\":{\"h\":\"29. @RestController 和 @Controller 有什么区别？\",\"t\":[\"@RestController 注解，在 @Controller 基础上，增加了 @ResponseBody 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 ACCEPT 请求头来决定。\"]},\"295\":{\"h\":\"30. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？\",\"t\":[\"@RequestMapping：可注解在类和方法上；@GetMapping 仅可注册在方法上\",\"@RequestMapping：可进行 GET、POST、PUT、DELETE 等请求方法；@GetMapping 是 @RequestMapping 的 GET 请求方法的特例，目的是为了提高清晰度。\"]},\"296\":{\"h\":\"31. @RequestParam 和 @PathVariable 两个注解的区别\",\"t\":[\"两个注解都用于方法参数，获取参数值的方式不同，@RequestParam 注解的参数从请求携带的参数中获取，而 @PathVariable 注解从请求的 URI 中获取\"]},\"297\":{\"h\":\"32. 返回 JSON 格式使用什么注解？\",\"t\":[\"可以使用 @ResponseBody 注解，或者使用包含 @ResponseBody 注解的 @RestController 注解。\",\"当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter。\"]},\"298\":{\"h\":\"33. 什么是springmvc拦截器以及如何使用它？\",\"t\":[\"Spring的处理程序映射机制包括处理程序拦截器，当你希望将特定功能应用于某些请求时，例如，检查用户主题时，这些拦截器非常有用。拦截器必须实现org.springframework.web.servlet包的HandlerInterceptor。此接口定义了三种方法：\",\"preHandle：在执行实际处理程序之前调用。\",\"postHandle：在执行完实际程序之后调用。\",\"afterCompletion：在完成请求后调用。\"]},\"299\":{\"h\":\"34. Spring MVC 和 Struts2 的异同？\",\"t\":[\"入口不同\",\"Spring MVC 的入门是一个 Servlet 控制器。\",\"Struts2 入门是一个 Filter 过滤器。\",\"配置映射不同，\",\"Spring MVC 是基于方法开发，传递参数是通过方法形参，一般设置为单例。\",\"Struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。\",\"视图不同\",\"Spring MVC 通过参数解析器是将 Request 对象内容进行解析成方法形参，将响应数据和页面封装成 ModelAndView 对象，最后又将模型数据通过 Request 对象传输到页面。其中，如果视图使用 JSP 时，默认使用 JSTL 。\",\"Struts2 采用值栈存储请求和响应的数据，通过 OGNL 存取数据。\"]},\"300\":{\"h\":\"35. REST 代表着什么?\",\"t\":[\"REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端\",\"可以看看 REST API design and development ，知乎上的 《怎样用通俗的语言解释 REST，以及 RESTful？》了解。\"]},\"301\":{\"h\":\"36. 什么是安全的 REST 操作?\",\"t\":[\"REST 接口是通过 HTTP 方法完成操作\",\"一些 HTTP 操作是安全的，如 GET 和 HEAD ，它不能在服务端修改资源\",\"换句话说，PUT、POST 和 DELETE 是不安全的，因为他们能修改服务端的资源\",\"所以，是否安全的界限，在于是否修改服务端的资源\"]},\"302\":{\"h\":\"37. REST API 是无状态的吗?\",\"t\":[\"是的，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的\",\"REST API 中的请求应该包含处理它所需的所有细节。它不应该依赖于以前或下一个请求或服务器端维护的一些数据，例如会话\",\"REST 规范为使其无状态设置了一个约束，在设计 REST API 时，你应该记住这一点\"]},\"303\":{\"h\":\"38. REST安全吗? 你能做什么来保护它?\",\"t\":[\"安全是一个宽泛的术语。它可能意味着消息的安全性，这是通过认证和授权提供的加密或访问限制提供的\",\"REST 通常不是安全的，需要开发人员自己实现安全机制\"]},\"304\":{\"h\":\"39. 为什么要用SpringBoot?\",\"t\":[\"在使用Spring框架进行开发的过程中，需要配置很多Spring框架包的依赖，如spring-core、spring-bean、spring-context等，而这些配置通常都是重复添加的，而且需要做很多框架使用及环境参数的重复配置，如开启注解、配置日志等。Spring Boot致力于弱化这些不必要的操作，提供默认配置，当然这些默认配置是可以按需修改的，快速搭建、开发和运行Spring应用。\",\"以下是使用SpringBoot的一些好处：\",\"自动配置，使用基于类路径和应用程序上下文的智能默认值，当然也可以根据需要重写它们以满足开发人员的需求。\",\"创建Spring Boot Starter 项目时，可以选择选择需要的功能，Spring Boot将为你管理依赖关系。\",\"SpringBoot项目可以打包成jar文件。可以使用Java-jar命令从命令行将应用程序作为独立的Java应用程序运行。\",\"在开发web应用程序时，springboot会配置一个嵌入式Tomcat服务器，以便它可以作为独立的应用程序运行。（Tomcat是默认的，当然你也可以配置Jetty或Undertow）\",\"SpringBoot包括许多有用的非功能特性（例如安全和健康检查）。\"]},\"305\":{\"h\":\"40. Spring Boot中如何实现对不同环境的属性配置文件的支持？\",\"t\":[\"Spring Boot支持不同环境的属性配置文件切换，通过创建application-{profile}.properties文件，其中{profile}是具体的环境标识名称，例如：application-dev.properties用于开发环境，application-test.properties用于测试环境，application-uat.properties用于uat环境。如果要想使用application-dev.properties文件，则在application.properties文件中添加spring.profiles.active=dev。\",\"如果要想使用application-test.properties文件，则在application.properties文件中添加spring.profiles.active=test。\"]},\"306\":{\"h\":\"41. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？\",\"t\":[\"启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：\",\"@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。\",\"@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。\",\"@ComponentScan：Spring组件扫描。\"]},\"307\":{\"h\":\"42. 你如何理解 Spring Boot 中的 Starters？\",\"t\":[\"Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。\",\"Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。\"]},\"308\":{\"h\":\"43. Spring Boot Starter 的工作原理是什么？\",\"t\":[\"Spring Boot 在启动的时候会干这几件事情：\",\"Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。\",\"根据 spring.factories 配置加载 AutoConfigure 类\",\"根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context\",\"总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可\"]},\"309\":{\"h\":\"44. 保护 Spring Boot 应用有哪些方法？\",\"t\":[\"在生产中使用HTTPS\",\"使用Snyk检查你的依赖关系\",\"升级到最新版本\",\"启用CSRF保护\",\"使用内容安全策略防止XSS攻击\"]},\"310\":{\"h\":\"45. Spring 、Spring Boot 和 Spring Cloud 的关系?\",\"t\":[\"Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。\",\"Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。\",\"Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。\",\"Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。\",\"用一组不太合理的包含关系来表达它们之间的关系。\",\"Spring ioc/aop > Spring > Spring Boot > Spring Cloud\"]},\"311\":{\"h\":\"参考\",\"t\":[\"https://juejin.cn/post/6844903860658503693\",\"https://www.cnblogs.com/jingmoxukong/p/9408037.html\",\"http://www.ityouknow.com/springboot/2019/07/24/springboot-interview.html\"]},\"312\":{\"h\":\"自定义工具类\",\"t\":[\"java 常用工具类 配置类\"]},\"313\":{\"h\":\"比较类 CommonUtils\",\"t\":[\"public final class CommonUtis { /** * string is not empty * * @param src * @return */ public static boolean isNotEmpty(String src) { return src != null && src.trim().length() > 0; } /** * list/set is not empty * * @param collection * @return */ public static boolean isNotEmpty(Collection<?> collection) { return collection != null && !collection.isEmpty(); } /** * map is not empty * * @param map * @return */ public static boolean isNotEmpty(Map<?, ?> map) { return map != null && !map.isEmpty(); } /** * 数组不为空 * * @param arr * @return * @see */ public static boolean isNotEmpty(Object[] arr) { return arr != null && arr.length > 0; } /** * 对字符串去空白符和换行符等 * * @return */ public static String stringTrim(String src) { return (null != src) ? src.trim() : null; } } \"]},\"314\":{\"h\":\"Redis 序列化及配置类\",\"t\":[\"@Configuration @EnableCaching public class RedisConfig { @Bean public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) { RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>(); redisTemplate.setConnectionFactory(factory); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer<Object>(Object.class)); return redisTemplate; } @Bean public RedisCacheManager redisCacheManager(RedisTemplate redisTemplate) { RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory()); RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig() .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer())); return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration); } } \"]},\"315\":{\"h\":\"MybatisPlus 分页拦截器配置类\",\"t\":[\"//MyBatisPlus相关配置 @Configuration public class MpConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor());//添加内部分页拦截器 return interceptor; } } \"]},\"316\":{\"h\":\"JwtUtils: 搭配Interceptor WebConfiguration\",\"t\":[\"@Component(\\\"JwtUtils\\\") public class JwtUtils { public static final Key SECRET_KEY = Keys.secretKeyFor(SignatureAlgorithm.HS512); @Autowired private RedisTemplate<String, String> redisTemplate; public String generateToken(String username) { String token = Jwts.builder().setSubject(username) .signWith(SECRET_KEY) .setIssuedAt(new Date(10)) .compact(); redisTemplate.opsForValue().set(username, token, 100000, TimeUnit.MILLISECONDS); return token; } public boolean validateToken(String token) { String username = getUsernameFromToken(token); // 从redis 中取出 该username 真实 token 与参数token比较 String re_token = redisTemplate.opsForValue().get(username); if (token.equals(re_token)) { System.out.println(\\\"比对成功\\\"); return true; } else { System.out.println(\\\"比对失败\\\"); return false; } } public String getUsernameFromToken(String token) { // Jws<Claims> jws = Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token); // parser()方法弃用后的新方法 Jws<Claims> jws = Jwts.parserBuilder().setSigningKey(SECRET_KEY).build().parseClaimsJws(token); Claims claims = jws.getBody(); return claims.getSubject(); } } \"]},\"317\":{\"h\":\"MyInterceptor 登录拦截配置\",\"t\":[\"@Component public class MyInterceptor implements HandlerInterceptor { @Resource(name = \\\"JwtUtils\\\") JwtUtils jwtUtils; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { response.setHeader(\\\"Access-Control-Allow-Origin\\\",request.getHeader(\\\"origin\\\")); response.setHeader(\\\"Access-Control-Allow-Credentials\\\", \\\"true\\\"); response.setHeader(\\\"Access-Control-Allow-Methods\\\", \\\"GET, POST, PUT,OPTIONS\\\"); response.setHeader(\\\"Access-Control-Allow-Headers\\\", \\\"*\\\"); String token = request.getHeader(\\\"auth\\\"); System.out.println(\\\"TOKEN: \\\" + token); if (token != null && jwtUtils.validateToken(token)) { System.out.println(\\\"放行\\\"); return true; } else { System.out.println(\\\"拦截\\\"); return false; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { HandlerInterceptor.super.afterCompletion(request, response, handler, ex); } } \"]},\"318\":{\"h\":\"MyWebConfiguration web配置类\",\"t\":[\"@Configuration public class MyWebConfig implements WebMvcConfigurer { @Autowired MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\\\"/**\\\") .excludePathPatterns( \\\"/pages/login.html\\\", \\\"/login\\\", \\\"*.css\\\", \\\"*.js\\\" ); } } \"]},\"319\":{\"h\":\"全局跨域配置 GlobalCorsConfig\",\"t\":[\"/*全局配置：跨域*/ @Configuration public class GlobalCorsConfig { @Bean public WebMvcConfigurer corsConfigurer(){ return new WebMvcConfigurer() { @Override //重写父类提供的跨域请求处理的接口 public void addCorsMappings(CorsRegistry registry) { //放行哪些原始域 registry.addMapping(\\\"/**\\\") //是否发送Cookie信息 .allowCredentials(true) //放行哪些原始域(头部信息) .allowedHeaders(\\\"*\\\") //放行哪些原始域(请求方式) .allowedMethods(\\\"GET\\\",\\\"POST\\\",\\\"PUT\\\",\\\"DELETE\\\") //放行哪些原始域 .allowedOrigins(\\\"*\\\") //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息） .exposedHeaders(\\\"Header1\\\",\\\"Header2\\\"); } }; } } \"]},\"320\":{\"h\":\"Kafka 面试题\"},\"321\":{\"h\":\"1. Apache Kafka是什么？\",\"t\":[\"Apach Kafka是一款分布式流处理平台，用于实时构建流处理应用。它有一个核心的功能广为人知，即作为企业级的消息引擎被广泛使用（通常也会称之为消息总线message bus）。\"]},\"322\":{\"h\":\"2. Kafka 的设计是什么样的？\",\"t\":[\"Kafka 将消息以 topic 为单位进行归纳\",\"将向 Kafka topic 发布消息的程序成为 producers.\",\"将预订 topics 并消费消息的程序成为 consumer.\",\"Kafka 以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 broker.\",\"producers 通过网络将消息发送到 Kafka 集群，集群向消费者提供消息\"]},\"323\":{\"h\":\"3. Kafka 如何保证高可用？\",\"t\":[\"Kafka 的基本架构组成是：由多个 broker 组成一个集群，每个 broker 是一个节点；当创建一个 topic 时，这个 topic 会被划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 只存放一部分数据。\",\"这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。\",\"在 Kafka 0.8 版本之前，是没有 HA 机制的，当任何一个 broker 所在节点宕机了，这个 broker 上的 partition 就无法提供读写服务，所以这个版本之前，Kafka 没有什么高可用性可言。\",\"在 Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 上的数据都会同步到其它机器，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，消息的生产者和消费者都跟这个 leader 打交道，其他 replica 作为 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。Kafka 负责均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。\",\"拥有了 replica 副本机制，如果某个 broker 宕机了，这个 broker 上的 partition 在其他机器上还存在副本。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从其 follower 中重新选举一个新的 leader 出来，这个新的 leader 会继续提供读写服务，这就有达到了所谓的高可用性。\",\"写数据的时候，生产者只将数据写入 leader 节点，leader 会将数据写入本地磁盘，接着其他 follower 会主动从 leader 来拉取数据，follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。\",\"消费数据的时候，消费者只会从 leader 节点去读取消息，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。\"]},\"324\":{\"h\":\"4. Kafka 消息是采用 Pull 模式，还是 Push 模式？\",\"t\":[\"生产者使用push模式将消息发布到Broker，消费者使用pull模式从Broker订阅消息。\",\"push模式很难适应消费速率不同的消费者，如果push的速度太快，容易造成消费者拒绝服务或网络拥塞；如果push的速度太慢，容易造成消费者性能浪费。但是采用pull的方式也有一个缺点，就是当Broker没有消息时，消费者会陷入不断地轮询中，为了避免这点，kafka有个参数可以让消费者阻塞知道是否有新消息到达。\"]},\"325\":{\"h\":\"5. Kafka 与传统消息系统之间的区别\",\"t\":[\"Kafka 持久化日志，这些日志可以被重复读取和无限期保留\",\"Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性\",\"Kafka 支持实时的流式处理\"]},\"326\":{\"h\":\"6. 什么是消费者组？\",\"t\":[\"消费者组是Kafka独有的概念，即消费者组是Kafka提供的可扩展且具有容错性的消费者机制。\",\"但实际上，消费者组（Consumer Group）其实包含两个概念，作为队列，消费者组允许你分割数据处理到一组进程集合上（即一个消费者组中可以包含多个消费者进程，他们共同消费该topic的数据），这有助于你的消费能力的动态调整；作为发布-订阅模型（publish-subscribe），Kafka允许你将同一份消息广播到多个消费者组里，以此来丰富多种数据使用场景。\",\"需要注意的是：在消费者组中，多个实例共同订阅若干个主题，实现共同消费。同一个组下的每个实例都配置有相同的组ID，被分配不同的订阅分区。当某个实例挂掉的时候，其他实例会自动地承担起它负责消费的分区。 因此，消费者组在一定程度上也保证了消费者程序的高可用性。\"]},\"327\":{\"h\":\"7. 在Kafka中，ZooKeeper的作用是什么？\",\"t\":[\"目前，Kafka使用ZooKeeper存放集群元数据、成员管理、Controller选举，以及其他一些管理类任务。之后，等KIP-500提案完成后，Kafka将完全不再依赖于ZooKeeper。\",\"“存放元数据”是指主题分区的所有数据都保存在 ZooKeeper 中，且以它保存的数据为权威，其他 “人” 都要与它保持对齐。\",\"“成员管理” 是指 Broker 节点的注册、注销以及属性变更，等等。\",\"“Controller 选举” 是指选举集群 Controller，而其他管理类任务包括但不限于主题删除、参数配置等。\",\"KIP-500 思想，是使用社区自研的基于Raft的共识算法，替代ZooKeeper，实现Controller自选举。\"]},\"328\":{\"h\":\"8. 解释下Kafka中位移（offset）的作用\",\"t\":[\"在Kafka中，每个主题分区下的每条消息都被赋予了一个唯一的ID数值，用于标识它在分区中的位置。这个ID数值，就被称为位移，或者叫偏移量。一旦消息被写入到分区日志，它的位移值将不能被修改。\"]},\"329\":{\"h\":\"9. kafka 为什么那么快？\",\"t\":[\"Cache Filesystem Cache PageCache缓存\",\"顺序写：由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。\",\"Zero-copy：零拷技术减少拷贝次数\",\"Batching of Messages：批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。\",\"Pull 拉模式：使用拉模式进行消息的获取消费，与消费端处理能力相符。\"]},\"330\":{\"h\":\"10. kafka producer发送数据，ack为0，1，-1分别是什么意思？\",\"t\":[\"1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。\",\"0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。\",\"-1producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。\"]},\"331\":{\"h\":\"11. Kafka如何保证消息不丢失?\",\"t\":[\"首先需要弄明白消息为什么会丢失，对于一个消息队列，会有 生产者、MQ、消费者 这三个角色，在这三个角色数据处理和传输过程中，都有可能会出现消息丢失。\",\"消息丢失的原因以及解决办法：\"]},\"332\":{\"h\":\"消费者异常导致的消息丢失\",\"t\":[\"消费者可能导致数据丢失的情况是：消费者获取到了这条消息后，还未处理，Kafka 就自动提交了 offset，这时 Kafka 就认为消费者已经处理完这条消息，其实消费者才刚准备处理这条消息，这时如果消费者宕机，那这条消息就丢失了。\",\"消费者引起消息丢失的主要原因就是消息还未处理完 Kafka 会自动提交了 offset，那么只要关闭自动提交 offset，消费者在处理完之后手动提交 offset，就可以保证消息不会丢失。但是此时需要注意重复消费问题，比如消费者刚处理完，还没提交 offset，这时自己宕机了，此时这条消息肯定会被重复消费一次，这就需要消费者根据实际情况保证幂等性。\"]},\"333\":{\"h\":\"生产者数据传输导致的消息丢失\",\"t\":[\"对于生产者数据传输导致的数据丢失主常见情况是生产者发送消息给 Kafka，由于网络等原因导致消息丢失，对于这种情况也是通过在 producer 端设置 acks=all 来处理，这个参数是要求 leader 接收到消息后，需要等到所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试。\"]},\"334\":{\"h\":\"Kafka 导致的消息丢失\",\"t\":[\"Kafka 导致的数据丢失一个常见的场景就是 Kafka 某个 broker 宕机，，而这个节点正好是某个 partition 的 leader 节点，这时需要重新重新选举该 partition 的 leader。如果该 partition 的 leader 在宕机时刚好还有些数据没有同步到 follower，此时 leader 挂了，在选举某个 follower 成 leader 之后，就会丢失一部分数据。\",\"对于这个问题，Kafka 可以设置如下 4 个参数，来尽量避免消息丢失：\",\"给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本；\",\"在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个参数的含义是一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 节点。\",\"在 producer 端设置 acks=all，这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了；\",\"在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个参数的含义是一旦写入失败，就无限重试，卡在这里了。\"]},\"335\":{\"h\":\"13. Kafka 如何保证消息的顺序性\",\"t\":[\"在某些业务场景下，我们需要保证对于有逻辑关联的多条MQ消息被按顺序处理，比如对于某一条数据，正常处理顺序是新增-更新-删除，最终结果是数据被删除；如果消息没有按序消费，处理顺序可能是删除-新增-更新，最终数据没有被删掉，可能会产生一些逻辑错误。对于如何保证消息的顺序性，主要需要考虑如下两点：\",\"如何保证消息在 Kafka 中顺序性；\",\"如何保证消费者处理消费的顺序性。\"]},\"336\":{\"h\":\"如何保证消息在 Kafka 中顺序性\",\"t\":[\"对于 Kafka，如果我们创建了一个 topic，默认有三个 partition。生产者在写数据的时候，可以指定一个 key，比如在订单 topic 中我们可以指定订单 id 作为 key，那么相同订单 id 的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。通过制定 key 的方式首先可以保证在 kafka 内部消息是有序的。\"]},\"337\":{\"h\":\"如何保证消费者处理消费的顺序性\",\"t\":[\"对于某个 topic 的一个 partition，只能被同组内部的一个 consumer 消费，如果这个 consumer 内部还是单线程处理，那么其实只要保证消息在 MQ 内部是有顺序的就可以保证消费也是有顺序的。但是单线程吞吐量太低，在处理大量 MQ 消息时，我们一般会开启多线程消费机制，那么如何保证消息在多个线程之间是被顺序处理的呢？对于多线程消费我们可以预先设置 N 个内存 Queue，具有相同 key 的数据都放到同一个内存 Queue 中；然后开启 N 个线程，每个线程分别消费一个内存 Queue 的数据即可，这样就能保证顺序性。当然，消息放到内存 Queue 中，有可能还未被处理，consumer 发生宕机，内存 Queue 中的数据会全部丢失，这就转变为上面提到的如何保证消息的可靠传输的问题了。\"]},\"338\":{\"h\":\"14. Kafka中的ISR、AR代表什么？ISR的伸缩指什么？\",\"t\":[\"ISR：In-Sync Replicas 副本同步队列\",\"AR:Assigned Replicas 所有副本\",\"ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度，当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR，存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。\",\"AR=ISR+OSR。\"]},\"339\":{\"h\":\"15. 描述下 Kafka 中的领导者副本（Leader Replica）和追随者副本（Follower Replica）的区别\",\"t\":[\"Kafka副本当前分为领导者副本和追随者副本。只有Leader副本才能对外提供读写服务，响应Clients端的请求。Follower副本只是采用拉（PULL）的方式，被动地同步Leader副本中的数据，并且在Leader副本所在的Broker宕机后，随时准备应聘Leader副本。\",\"加分点：\",\"强调Follower副本也能对外提供读服务。自Kafka 2.4版本开始，社区通过引入新的Broker端参数，允许Follower副本有限度地提供读服务。\",\"强调Leader和Follower的消息序列在实际场景中不一致。通常情况下，很多因素可能造成Leader和Follower之间的不同步，比如程序问题，网络问题，broker问题等，短暂的不同步我们可以关注（秒级别），但长时间的不同步可能就需要深入排查了，因为一旦Leader所在节点异常，可能直接影响可用性。\",\"注意：之前确保一致性的主要手段是高水位机制（HW），但高水位值无法保证Leader连续变更场景下的数据一致性，因此，社区引入了Leader Epoch机制，来修复高水位值的弊端。\"]},\"340\":{\"h\":\"16. 分区Leader选举策略有几种？\",\"t\":[\"分区的Leader副本选举对用户是完全透明的，它是由Controller独立完成的。你需要回答的是，在哪些场景下，需要执行分区Leader选举。每一种场景对应于一种选举策略。\",\"OfflinePartition Leader选举：每当有分区上线时，就需要执行Leader选举。所谓的分区上线，可能是创建了新分区，也可能是之前的下线分区重新上线。这是最常见的分区Leader选举场景。\",\"ReassignPartition Leader选举：当你手动运行kafka-reassign-partitions命令，或者是调用Admin的alterPartitionReassignments方法执行分区副本重分配时，可能触发此类选举。假设原来的AR是[1，2，3]，Leader是1，当执行副本重分配后，副本集合AR被设置成[4，5，6]，显然，Leader必须要变更，此时会发生Reassign Partition Leader选举。\",\"PreferredReplicaPartition Leader选举：当你手动运行kafka-preferred-replica-election命令，或自动触发了Preferred Leader选举时，该类策略被激活。所谓的Preferred Leader，指的是AR中的第一个副本。比如AR是[3，2，1]，那么，Preferred Leader就是3。\",\"ControlledShutdownPartition Leader选举：当Broker正常关闭时，该Broker上的所有Leader副本都会下线，因此，需要为受影响的分区执行相应的Leader选举。\",\"这4类选举策略的大致思想是类似的，即从AR中挑选首个在ISR中的副本，作为新Leader。\"]},\"341\":{\"h\":\"17. Kafka的哪些场景中使用了零拷贝（Zero Copy）？\",\"t\":[\"在Kafka中，体现Zero Copy使用场景的地方有两处：基于mmap的索引和日志文件读写所用的TransportLayer。\",\"先说第一个。索引都是基于MappedByteBuffer的，也就是让用户态和内核态共享内核态的数据缓冲区，此时，数据不需要复制到用户态空间。不过，mmap虽然避免了不必要的拷贝，但不一定就能保证很高的性能。在不同的操作系统下，mmap的创建和销毁成本可能是不一样的。很高的创建和销毁开销会抵消Zero Copy带来的性能优势。由于这种不确定性，在Kafka中，只有索引应用了mmap，最核心的日志并未使用mmap机制。\",\"再说第二个。TransportLayer是Kafka传输层的接口。它的某个实现类使用了FileChannel的transferTo方法。该方法底层使用sendfile实现了Zero Copy。对Kafka而言，如果I/O通道使用普通的PLAINTEXT，那么，Kafka就可以利用Zero Copy特性，直接将页缓存中的数据发送到网卡的Buffer中，避免中间的多次拷贝。相反，如果I/O通道启用了SSL，那么，Kafka便无法利用Zero Copy特性了。\"]},\"342\":{\"h\":\"18. 为什么Kafka不支持读写分离？\",\"t\":[\"在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。\",\"Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:\",\"数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。\",\"延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。\"]},\"343\":{\"h\":\"参考\",\"t\":[\"http://dockone.io/article/10853\",\"https://segmentfault.com/a/1190000023716306\",\"https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/index.html\"]},\"344\":{\"h\":\"MQ 面试题\"},\"345\":{\"h\":\"为什么使用MQ？\",\"t\":[\"使用MQ的场景很多，主要有三个：解耦、异步、削峰。\",\"解耦：假设现在，日志不光要插入到数据库里，还要在硬盘中增加文件类型的日志，同时，一些关键日志还要通过邮件的方式发送给指定的人。那么，如果按照原来的逻辑，A可能就需要在原来的代码上做扩展，除了B服务，还要加上日志文件的存储和日志邮件的发送。但是，如果你使用了MQ，那么，A服务是不需要做更改的，它还是将消息放到MQ中即可，其它的服务，无论是原来的B服务还是新增的日志文件存储服务或日志邮件发送服务，都直接从MQ中获取消息并处理即可。这就是解耦，它的好处是提高系统灵活性，扩展性。\",\"异步：可以将一些非核心流程，如日志，短信，邮件等，通过MQ的方式异步去处理。这样做的好处是缩短主流程的响应时间，提升用户体验。\",\"削峰：MQ的本质就是业务的排队。所以，面对突然到来的高并发，MQ也可以不用慌忙，先排好队，不要着急，一个一个来。削峰的好处就是避免高并发压垮系统的关键组件，如某个核心服务或数据库等。\",\"下面附场景解释：\"]},\"346\":{\"h\":\"解耦\",\"t\":[\"场景：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......\",\"在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！\",\"如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。\",\"总结：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。\"]},\"347\":{\"h\":\"异步\",\"t\":[\"场景：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。\",\"一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。\",\"如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了。\"]},\"348\":{\"h\":\"削峰\",\"t\":[\"场景：每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。\",\"使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。\",\"这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。\"]},\"349\":{\"h\":\"消息队列的缺点\",\"t\":[\"1、 系统可用性降低\",\"系统引入的外部依赖越多，越容易挂掉。\",\"2、 系统复杂度提高\",\"加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。\",\"3、 一致性问题\",\"A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这就数据不一致了。\"]},\"350\":{\"h\":\"Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？\",\"t\":[\"特性\",\"ActiveMQ\",\"RabbitMQ\",\"RocketMQ\",\"Kafka\",\"开发语言\",\"java\",\"erlang\",\"java\",\"scala\",\"单机吞吐量\",\"万级，比 RocketMQ、Kafka 低一个数量级\",\"同 ActiveMQ\",\"10 万级，支撑高吞吐\",\"10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景\",\"topic 数量对吞吐量的影响\",\"topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic\",\"topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源\",\"时效性\",\"ms 级\",\"微秒级，这是 RabbitMQ 的一大特点，延迟最低\",\"ms 级\",\"延迟在 ms 级以内\",\"可用性\",\"高，基于主从架构实现高可用\",\"同 ActiveMQ\",\"非常高，分布式架构\",\"非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\",\"消息可靠性\",\"有较低的概率丢失数据\",\"基本不丢\",\"经过参数优化配置，可以做到 0 丢失\",\"同 RocketMQ\",\"功能支持\",\"MQ 领域的功能极其完备\",\"基于 erlang 开发，并发能力很强，性能极好，延时很低\",\"MQ 功能较为完善，还是分布式的，扩展性好\",\"功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用\",\"社区活跃度\",\"低\",\"很高\",\"一般\",\"很高\",\"中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；\",\"大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。\",\"大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，几乎是全世界这个领域的事实性规范。\"]},\"351\":{\"h\":\"1. RabbitMQ是什么？\",\"t\":[\"RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。\"]},\"352\":{\"h\":\"2. RabbitMQ特点?\",\"t\":[\"可靠性: RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。\",\"灵活的路由 : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。\",\"扩展性: 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。\",\"高可用性 : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。\",\"多种协议: RabbitMQ除了原生支持AMQP协议，还支持STOMP， MQTT等多种消息 中间件协议。\",\"多语言客户端 :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。\",\"管理界面 : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。\",\"令插件机制: RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。\"]},\"353\":{\"h\":\"3. AMQP是什么?\",\"t\":[\"RabbitMQ就是 AMQP 协议的 Erlang 的实现(当然 RabbitMQ 还支持 STOMP2、 MQTT3 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。\",\"RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。\"]},\"354\":{\"h\":\"4. AMQP的3层协议？\",\"t\":[\"Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。\",\"Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。\",\"TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。\"]},\"355\":{\"h\":\"5. 说说Broker服务节点、Queue队列、Exchange交换器？\",\"t\":[\"Broker可以看做RabbitMQ的服务节点。一般请下一个Broker可以看做一个RabbitMQ服务器。\",\"Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。\",\"Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。\"]},\"356\":{\"h\":\"6. 如何保证消息的可靠性？\",\"t\":[\"分三点：\",\"生产者到RabbitMQ：事务机制和Confirm机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。\",\"RabbitMQ自身：持久化、集群、普通模式、镜像模式。\",\"RabbitMQ到消费者：basicAck机制、死信队列、消息补偿机制。\"]},\"357\":{\"h\":\"7. 生产者消息运转的流程？\",\"t\":[\"Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。\",\"Producer声明一个交换器并设置好相关属性。\",\"Producer声明一个队列并设置好相关属性。\",\"Producer通过路由键将交换器和队列绑定起来。\",\"Producer发送消息到Broker,其中包含路由键、交换器等信息。\",\"相应的交换器根据接收到的路由键查找匹配的队列。\",\"如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。\",\"关闭信道。\",\"管理连接。\"]},\"358\":{\"h\":\"8.消费者接收消息过程？\",\"t\":[\"Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。\",\"向Broker请求消费响应的队列中消息，可能会设置响应的回调函数。\",\"等待Broker回应并投递相应队列中的消息，接收消息。\",\"消费者确认收到的消息,ack。\",\"RabbitMq从队列中删除已经确定的消息。\",\"关闭信道。\",\"关闭连接。\"]},\"359\":{\"h\":\"9. 生产者如何将消息可靠投递到RabbitMQ？\",\"t\":[\"Client发送消息给MQ\",\"MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；\",\"Client收到Ack消息后，认为消息已经投递成功。\"]},\"360\":{\"h\":\"10. RabbitMQ如何将消息可靠投递到消费者？\",\"t\":[\"MQ将消息push给Client（或Client来pull消息）\",\"Client得到消息并做完业务逻辑\",\"Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等的问题；\",\"MQ将已消费的消息删除。\"]},\"361\":{\"h\":\"11. 如何保证RabbitMQ消息队列的高可用?\",\"t\":[\"RabbitMQ 有三种模式：单机模式，普通集群模式，镜像集群模式。\",\"单机模式：就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式\",\"普通集群模式：意思就是在多台机器上启动多个RabbitMQ实例，每个机器启动一个。\",\"镜像集群模式：这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据(元数据指RabbitMQ的配置数据)还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。\"]},\"362\":{\"h\":\"1. RocketMQ是什么？\",\"t\":[\"RocketMQ 是阿里巴巴开源的分布式消息中间件。支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。它里面有几个区别于标准消息中件间的概念，如Group、Topic、Queue等。系统组成则由Producer、Consumer、Broker、NameServer等。\",\"RocketMQ 特点\",\"是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式等特点\",\"Producer、Consumer、队列都可以分布式\",\"Producer 向一些队列轮流发送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 Consumer 实例消费这个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费这个 Topic 对应的队列集合\",\"能够保证严格的消息顺序\",\"支持拉（pull）和推（push）两种消息模式\",\"高效的订阅者水平扩展能力\",\"实时的消息订阅机制\",\"亿级消息堆积能力\",\"支持多种消息协议，如 JMS、OpenMessaging 等\",\"较少的依赖\"]},\"363\":{\"h\":\"2. RocketMQ由哪些角色组成，每个角色作用和特点是什么？\",\"t\":[\"角色\",\"作用\",\"Nameserver\",\"无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。\",\"Producer\",\"消息生产者，负责发消息到Broker。\",\"Broker\",\"就是MQ本身，负责收发消息、持久化消息等。\",\"Consumer\",\"消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。\"]},\"364\":{\"h\":\"3. RocketMQ消费模式有几种？\",\"t\":[\"消费模型由Consumer决定，消费维度为Topic。\",\"1、集群消费\",\"一条消息只会被同Group中的一个Consumer消费\",\"多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据\",\"2、广播消费\",\"消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。\"]},\"365\":{\"h\":\"4. RocketMQ消费消息是push还是pull？\",\"t\":[\"RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是长轮询机制，即拉取方式\",\"broker端属性 longPollingEnable 标记是否开启长轮询。默认开启\"]},\"366\":{\"h\":\"追问：为什么要主动拉取消息而不使用事件监听方式？\",\"t\":[\"事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。\",\"如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈。所以采取了pull的方式。\"]},\"367\":{\"h\":\"5. broker如何处理拉取请求的？\",\"t\":[\"Consumer首次请求Broker\",\"Broker中是否有符合条件的消息\",\"有\",\"响应Consumer\",\"等待下次Consumer的请求\",\"没有\",\"DefaultMessageStore#ReputMessageService#run方法\",\"PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送\",\"每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable\",\"当有新消息的时候返回请求\",\"挂起consumer的请求，即不断开连接，也不返回数据\",\"使用consumer的offset，\"]},\"368\":{\"h\":\"6. 如何让RocketMQ保证消息的顺序消费？\",\"t\":[\"首先多个queue只能保证单个queue里的顺序，queue是典型的FIFO，天然顺序。多个queue同时消费是无法绝对保证消息的有序性的。所以总结如下：\",\"同一topic，同一个QUEUE，发消息的时候一个线程去发送消息，消费的时候 一个线程去消费一个queue里的消息。\"]},\"369\":{\"h\":\"7. RocketMQ如何保证消息不丢失？\",\"t\":[\"首先在如下三个部分都可能会出现丢失消息的情况：\",\"Producer端\",\"Broker端\",\"Consumer端\",\"1 、Producer端如何保证消息不丢失\",\"采取send()同步发消息，发送结果是同步感知的。\",\"发送失败后可以重试，设置重试次数。默认3次。\",\"集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上。\",\"2、Broker端如何保证消息不丢失\",\"修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。\",\"集群部署，主从模式，高可用。\",\"3、Consumer端如何保证消息不丢失\",\"完全消费正常后在进行手动ack确认。\"]},\"370\":{\"h\":\"7. rocketMQ的消息堆积如何处理？\",\"t\":[\"首先要找到是什么原因导致的消息堆积，是Producer太多了，Consumer太少了导致的还是说其他情况，总之先定位问题。\",\"然后看下消息消费速度是否正常，正常的话，可以通过上线更多consumer临时解决消息堆积问题\"]},\"371\":{\"h\":\"追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？\",\"t\":[\"准备一个临时的topic\",\"queue的数量是堆积的几倍\",\"queue分布到多Broker中\",\"上线一台Consumer做消息的搬运工，把原来Topic中的消息挪到新的Topic里，不做业务逻辑处理，只是挪过去\",\"上线N台Consumer同时消费临时Topic中的数据\",\"改bug\",\"恢复原来的Consumer，继续消费之前的Topic\"]},\"372\":{\"h\":\"追问：堆积时间过长消息超时了？\",\"t\":[\"RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时。也就是说未被消费的消息不会存在超时删除这情况。\"]},\"373\":{\"h\":\"追问：堆积的消息会不会进死信队列？\",\"t\":[\"不会，消息在消费失败后会进入重试队列（%RETRY%+ConsumerGroup），18次（默认18次，网上所有文章都说是16次，无一例外。但是我没搞懂为啥是16次，这不是18个时间吗 ？）才会进入死信队列（%DLQ%+ConsumerGroup）。\"]},\"374\":{\"h\":\"8. RocketMQ为什么自研nameserver而不用zk？\",\"t\":[\"RocketMQ只需要一个轻量级的维护元数据信息的组件，为此引入zk增加维护成本还强依赖另一个中间件了。\",\"RocketMQ追求的是AP，而不是CP，也就是需要高可用。 \",\"zk是CP，因为zk节点间通过zap协议有数据共享，每个节点数据会一致，但是zk集群当挂了一半以上的节点就没法使用了。\",\"nameserver是AP，节点间不通信，这样会导致节点间数据信息会发生短暂的不一致，但每个broker都会定时向所有nameserver上报路由信息和心跳。当某个broker下线了，nameserver也会延时30s才知道，而且不会通知客户端（生产和消费者），只能靠客户端自己来拉，rocketMQ是靠消息重试机制解决这个问题的，所以是最终一致性。但nameserver集群只要有一个节点就可用。https://juejin.cn/post/6844904068771479559\"]},\"375\":{\"h\":\"Kafka 面试题\"},\"376\":{\"h\":\"1. Redis是什么？简述它的优缺点？\",\"t\":[\"Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存。\",\"因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value 数据库。\",\"优点：\",\"读写性能极高， Redis能读的速度是110000次/s，写的速度是81000次/s。\",\"支持数据持久化，支持AOF和RDB两种持久化方式。\",\"支持事务， Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\",\"数据结构丰富，除了支持string类型的value外，还支持hash、set、zset、list等数据结构。\",\"支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。\",\"丰富的特性 – Redis还支持 publish/subscribe， 通知， key 过期等特性。\",\"缺点：\",\"数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。\",\"主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。\"]},\"377\":{\"h\":\"2. Redis为什么这么快？\",\"t\":[\"内存存储：Redis是使用内存(in-memeroy)存储，没有磁盘IO上的开销。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。\",\"单线程实现（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。\",\"非阻塞IO：Redis使用多路复用IO技术，将epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。\",\"优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。\",\"使用底层模型不同：Redis直接自己构建了 VM (虚拟内存)机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。\",\"Redis的VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。\",\"Redis提高数据库容量的办法有两种：一种是可以将数据分割到多个RedisServer上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。需要特别注意的是Redis并没有使用OS提供的Swap，而是自己实现。\"]},\"378\":{\"h\":\"3. Redis相比Memcached有哪些优势？\",\"t\":[\"数据类型：Memcached所有的值均是简单的字符串，Redis支持更为丰富的数据类型，支持string(字符串)，list(列表)，Set(集合)、Sorted Set(有序集合)、Hash(哈希)等。\",\"持久化：Redis支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache不支持数据持久存储 。\",\"集群模式：Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据\",\"性能对比：Redis的速度比Memcached快很多。\",\"网络IO模型：Redis使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞IO模式。\",\"Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。\",\"这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。\"]},\"379\":{\"h\":\"4. 为什么要用 Redis 做缓存？\",\"t\":[\"从高并发上来说：\",\"直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。\",\"从高性能上来说：\",\"用户第一次访问数据库中的某些数据。 因为是从硬盘上读取的所以这个过程会比较慢。将该用户访问的数据存在缓存中，下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据。\"]},\"380\":{\"h\":\"5. 为什么要用 Redis 而不用 map/guava 做缓存?\",\"t\":[\"缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。\",\"使用Redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持Redis或memcached服务的高可用，整个程序架构上较为复杂。\",\"对比:\",\"Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；\",\"Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了；\",\"Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里；\",\"Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；\",\"Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了；\",\"Redis可单独部署，多个项目之间可以共享，本地内存无法共享；\",\"Redis有专门的管理工具可以查看缓存数据。\"]},\"381\":{\"h\":\"6. Redis的常用场景有哪些?\",\"t\":[\"1、缓存\",\"缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。\",\"2、排行榜\",\"很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。\",\"3、计数器\",\"什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。\",\"4、分布式会话\",\"集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。\",\"5、分布式锁\",\"在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。\",\"6、 社交网络\",\"点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过Redis的set能够很方便得出。\",\"7、最新列表\",\"Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。\",\"8、消息系统\",\"消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。\"]},\"382\":{\"h\":\"7. Redis的数据类型有哪些？\",\"t\":[\"有五种常用数据类型：String、Hash、Set、List、SortedSet。以及三种特殊的数据类型：Bitmap、HyperLogLog、Geospatial ，其中HyperLogLog、Bitmap的底层都是 String 数据类型，Geospatial 的底层是 Sorted Set 数据类型。\",\"五种常用的数据类型：\",\"1、String：String是最常用的一种数据类型，普通的key- value 存储都可以归为此类。其中Value既可以是数字也可以是字符串。使用场景：常规key-value缓存应用。常规计数: 微博数， 粉丝数。\",\"2、Hash：Hash 是一个键值(key => value)对集合。Redishash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值。\",\"3、Set：Set是一个无序的天然去重的集合，即Key-Set。此外还提供了交集、并集等一系列直接操作集合的方法，对于求共同好友、共同关注什么的功能实现特别方便。\",\"4、List：List是一个有序可重复的集合，其遵循FIFO的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过List，我们可以很方面的获得类似于最新回复这类的功能实现。\",\"5、SortedSet：类似于java中的TreeSet，是Set的可排序版。此外还支持优先级排序，维护了一个score的参数来实现。适用于排行榜和带权重的消息队列等场景。\",\"三种特殊的数据类型：\",\"1、Bitmap：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmap中叫做偏移量。使用Bitmap实现统计功能，更省空间。如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。\",\"2、Hyperloglog。HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大\",\"时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。场景：统计网页的UV（即Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。\",\"要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。\",\"3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。\"]},\"383\":{\"h\":\"8. Redis持久化机制？\",\"t\":[\"为了能够重用Redis数据，或者防止系统故障，我们需要将Redis中的数据写入到磁盘空间中，即持久化。\",\"Redis提供了两种不同的持久化方法可以将数据存储在磁盘中，一种叫快照RDB，另一种叫只追加文件AOF。\",\"RDB\",\"在指定的时间间隔内将内存中的数据集快照写入磁盘(Snapshot)，它恢复时是将快照文件直接读到内存里。\",\"优势：适合大规模的数据恢复；对数据完整性和一致性要求不高\",\"劣势：在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。\",\"AOF\",\"以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\",\"AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时， Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.。\",\"优势\",\"每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好\",\"每秒同步：appendfsync everysec 异步操作，每秒记录，如果一秒内宕机，有数据丢失\",\"不同步：appendfsync no 从不同步\",\"劣势\",\"相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb\",\"aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同\"]},\"384\":{\"h\":\"9. 如何选择合适的持久化方式\",\"t\":[\"如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化。\",\"如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB。\",\"如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行bgsave做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据的不丢失。\",\"补充：Redis4.0 对于持久化机制的优化\",\"Redis4.0相对与3.X版本其中一个比较大的变化是4.0添加了新的混合持久化方式。\",\"简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据，如下图：\",\"优势：混合持久化结合了RDB持久化 和 AOF 持久化的优点， 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。\",\"劣势：兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，阅读性较差。\"]},\"385\":{\"h\":\"10. Redis持久化数据和缓存怎么做扩容？\",\"t\":[\"如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。\",\"如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。\"]},\"386\":{\"h\":\"11. Redis过期键的删除策略\",\"t\":[\"Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。\",\"惰性删除：惰性删除不会去主动删除数据，而是在访问数据的时候，再检查当前键值是否过期，如果过期则执行删除并返回 null 给客户端，如果没有过期则返回正常信息给客户端。它的优点是简单，不需要对过期的数据做额外的处理，只有在每次访问的时候才会检查键值是否过期，缺点是删除过期键不及时，造成了一定的空间浪费。\",\"定期删除：Redis会周期性的随机测试一批设置了过期时间的key并进行处理。测试到的已过期的key将被删除。\",\"附：删除key常见的三种处理方式。\",\"1、定时删除\",\"在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。\",\"优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。\",\"缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。\",\"2、惰性删除\",\"设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。\",\"优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。\",\"缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。\",\"3、定期删除\",\"每隔一段时间，我们就对一些key进行检查，删除里面过期的key。\",\"优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。\",\"缺点：难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。\"]},\"387\":{\"h\":\"12. Redis key的过期时间和永久有效分别怎么设置？\",\"t\":[\"通过expire或pexpire命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。\",\"与expire和pexpire命令类似，客户端可以通过expireat和pexpireat命令，以秒或毫秒精度给数据库中的某个键设置过期时间，可以理解为：让某个键在某个时间点过期。\"]},\"388\":{\"h\":\"13. Redis内存淘汰策略\",\"t\":[\"Redis是不断的删除一些过期数据，但是很多没有设置过期时间的数据也会越来越多，那么Redis内存不够用的时候是怎么处理的呢？答案就是淘汰策略。此类的\",\"当Redis的内存超过最大允许的内存之后，Redis会触发内存淘汰策略，删除一些不常用的数据，以保证Redis服务器的正常运行。\",\"Redisv4.0前提供 6种数据淘汰策略：\",\"volatile-lru：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )\",\"allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）\",\"volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰\",\"volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰\",\"allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰\",\"no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！\",\"Redisv4.0后增加以下两种：\",\"volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最有可能被访问到)\",\"allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。\",\"内存淘汰策略可以通过配置文件来修改，Redis.conf对应的配置项是maxmemory-policy 修改对应的值就行，默认是noeviction。\",\"缓存异常有四种类型，分别是缓存和数据库的数据不一致、缓存雪崩、缓存击穿和缓存穿透。\"]},\"389\":{\"h\":\"14. 如何保证缓存与数据库双写时的数据一致性？\",\"t\":[\"背景：使用到缓存，无论是本地内存做缓存还是使用 Redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。\",\"共有四种方案：\",\"先更新数据库，后更新缓存\",\"先更新缓存，后更新数据库\",\"先删除缓存，后更新数据库\",\"先更新数据库，后删除缓存\",\"第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。\",\"第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。\",\"目前主要用第三和第四种方案。\"]},\"390\":{\"h\":\"15. 先删除缓存，后更新数据库\",\"t\":[\"该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）\",\"请求A进行写操作，删除缓存\",\"请求B查询发现缓存不存在\",\"请求B去数据库查询得到旧值\",\"请求B将旧值写入缓存\",\"请求A将新值写入数据库\",\"上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\"]},\"391\":{\"h\":\"答案一：延时双删\",\"t\":[\"最简单的解决办法延时双删\",\"使用伪代码如下：\",\"public void write(String key,Object data){ Redis.delKey(key); db.updateData(data); Thread.sleep(1000); Redis.delKey(key); } \",\"转化为中文描述就是 （1）先淘汰缓存 （2）再写数据库（这两步和原来一样） （3）休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。自行评估自己的项目的读数据业务逻辑的耗时，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。\",\"如果使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。\",\"此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）\",\"请求 A 更新操作，删除了 Redis\",\"请求主库进行更新操作，主库与从库进行同步数据的操作\",\"请 B 查询操作，发现 Redis 中没有数据\",\"去从库中拿去数据\",\"此时同步数据还未完成，拿到的数据是旧数据\",\"此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。\"]},\"392\":{\"h\":\"答案二：\",\"t\":[\"采用更新与读取操作进行异步串行化\",\"异步串行化\",\"我在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。\",\"这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。\",\"读操作去重\",\"多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。\",\"如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）\"]},\"393\":{\"h\":\"16. 先更新数据库，后删除缓存\",\"t\":[\"这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。\",\"此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：\",\"请求 A 先对数据库进行更新操作\",\"在对 Redis 进行删除操作的时候发现报错，删除失败\",\"此时将Redis 的 key 作为消息体发送到消息队列中\",\"系统接收到消息队列发送的消息后再次对 Redis 进行删除操作\",\"但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。\"]},\"394\":{\"h\":\"17. 什么是缓存击穿?\",\"t\":[\"缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。\",\"从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。\",\"解决方案：\",\"在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降\",\"热点数据缓存永远不过期。永不过期实际包含两层意思：\",\"物理不过期，针对热点key不设置过期时间\",\"逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建\"]},\"395\":{\"h\":\"18. 什么是缓存穿透?\",\"t\":[\"缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。\",\"缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿的根本区别在于传进来的key在Redis中是不存在的。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示。\",\"解决方法：\",\"将无效的key存放进Redis中：\",\"当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=\\\"null\\\"，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。\",\"使用布隆过滤器：\",\"如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。\",\"如何选择：针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。\"]},\"396\":{\"h\":\"19. 什么是缓存雪崩?\",\"t\":[\"如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。\",\"造成缓存雪崩的关键在于同一时间的大规模的key失效，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。\",\"解决方案：\",\"1、事前：\",\"均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。如把每个Key的失效时间都加个随机值，setRedis（Key，value，time + Math.random() * 10000）；，保证数据不会在同一时间大面积失效。\",\"分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。\",\"热点数据缓存永远不过期。永不过期实际包含两层意思：\",\"物理不过期，针对热点key不设置过期时间\",\"逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建\",\"保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。\",\"2、事中：\",\"互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降\",\"使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。\",\"3、事后：\",\"开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。\"]},\"397\":{\"h\":\"20. 什么是缓存预热?\",\"t\":[\"缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。\",\"如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。\",\"缓存预热解决方案：\",\"数据量不大的时候，工程启动的时候进行加载缓存动作；\",\"数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；\",\"数据量太大的时候，优先保证热点数据进行提前加载到缓存。\"]},\"398\":{\"h\":\"21. 什么是缓存降级？\",\"t\":[\"缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。\",\"在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：\",\"一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；\",\"警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；\",\"错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；\",\"严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。\"]},\"399\":{\"h\":\"22. Redis为何选择单线程？\",\"t\":[\"在Redis 6.0以前，Redis的核心网络模型选择用单线程来实现。先来看下官方的回答：\",\"It's not very frequent that CPU becomes your bottleneck with Redis， as usually Redisis either memory or network bound. For instance， using pipelining Redisrunning on an average Linux system can deliver even 1 million requests per second， so if your application mainly uses O(N) or O(log(N)) commands， it is hardly going to use too much CPU.\",\"核心意思就是，对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis的话，如果不考虑 RDB/AOF 等持久化方案，Redis是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis选择了单线程的 I/O 多路复用来实现它的核心网络模型。\",\"实际上更加具体的选择单线程的原因如下：\",\"避免过多的上下文切换开销：如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。\",\"避免同步机制的开销：如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而不同的数据结构对同步访问的加锁粒度又不尽相同，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。\",\"简单可维护：如果 Redis使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis的实现变得更加复杂。\",\"总而言之，Redis选择单线程可以说是多方博弈之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。\"]},\"400\":{\"h\":\"23. Redis真的是单线程？\",\"t\":[\"讨论 这个问题前，先看下 Redis的版本中两个重要的节点：\",\"Redisv4.0（引入多线程处理异步任务）\",\"Redis 6.0（在网络模型中实现多线程 I/O ）\",\"所以，网络上说的Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程。\",\"且Redis6.0引入多线程I/O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。\",\"Redis在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。\",\"在 Redisv4.0 之后增加了一些的非阻塞命令如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC。\"]},\"401\":{\"h\":\"24. Redis 6.0为何引入多线程？\",\"t\":[\"很简单，就是 Redis的网络 I/O 瓶颈已经越来越明显了。\",\"随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，要提升 Redis的性能有两个方向：\",\"优化网络 I/O 模块\",\"提高机器内存读写的速度\",\"后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I/O 的优化又可以分为两个方向：\",\"零拷贝技术或者 DPDK 技术\",\"利用多核优势\",\"零拷贝技术有其局限性，无法完全适配 Redis这一类复杂的网络 I/O 场景，更多网络 I/O 对 CPU 时间的消耗和 Linux 零拷贝技术。而 DPDK 技术通过旁路网卡 I/O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。\",\"总结起来，Redis支持多线程主要就是两个原因：\",\"可以充分利用服务器 CPU 资源，目前主线程只能利用一个核\",\"多线程任务可以分摊 Redis 同步 IO 读写负荷\"]},\"402\":{\"h\":\"25. Redis 6.0 采用多线程后，性能的提升效果如何？\",\"t\":[\"Redis 作者 antirez 在 RedisConf 2019 分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是一倍以上。\",\"国内也有大牛曾使用 unstable 版本在阿里云 esc 进行过测试，GET/SET 命令在 4 线程 IO 时性能相比单线程是几乎是翻倍了。\"]},\"403\":{\"h\":\"26. 介绍下Redis的线程模型\",\"t\":[\"Redis的线程模型包括Redis 6.0之前和Redis 6.0。\",\"下面介绍的是Redis 6.0之前。\",\"Redis 是基于 reactor 模式开发了网络事件处理器，这个处理器叫做文件事件处理器（file event handler）。由于这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。采用 IO 多路复用机制同时监听多个 Socket，根据 socket 上的事件来选择对应的事件处理器来处理这个事件。\",\"IO多路复用是 IO 模型的一种，有时也称为异步阻塞 IO，是基于经典的 Reactor 设计模式设计的。多路指的是多个 Socket 连接，复用指的是复用一个线程。多路复用主要有三种技术：Select，Poll，Epoll。\",\"Epoll 是最新的也是目前最好的多路复用技术。\",\"模型如下图：\",\"文件事件处理器的结构包含了四个部分：\",\"多个 Socket。Socket 会产生 AE_READABLE 和 AE_WRITABLE 事件： \",\"当 socket 变得可读时或者有新的可以应答的 socket 出现时，socket 就会产生一个 AE_READABLE 事件\",\"当 socket 变得可写时，socket 就会产生一个 AE_WRITABLE 事件。\",\"IO 多路复用程序\",\"文件事件分派器\",\"事件处理器。事件处理器包括：连接应答处理器、命令请求处理器、命令回复处理器，每个处理器对应不同的 socket 事件： \",\"如果是客户端要连接 Redis，那么会为 socket 关联连接应答处理器\",\"如果是客户端要写数据到 Redis（读、写请求命令），那么会为 socket 关联命令请求处理器\",\"如果是客户端要从 Redis 读数据，那么会为 socket 关联命令回复处理器\",\"多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个队列中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。\",\"下图是客户端与 Redis 通信的一次完整的流程：\",\"Redis 启动初始化的时候，Redis 会将连接应答处理器与 AE_READABLE 事件关联起来。\",\"如果一个客户端跟 Redis 发起连接，此时 Redis 会产生一个 AE_READABLE 事件，由于开始之初 AE_READABLE 是与连接应答处理器关联，所以由连接应答处理器来处理该事件，这时连接应答处理器会与客户端建立连接，创建客户端响应的 socket，同时将这个 socket 的 AE_READABLE 事件与命令请求处理器关联起来。\",\"如果这个时间客户端向 Redis 发送一个命令（set k1 v1），这时 socket 会产生一个 AE_READABLE 事件，IO 多路复用程序会将该事件压入队列中，此时事件分派器从队列中取得该事件，由于该 socket 的 AE_READABLE 事件已经和命令请求处理器关联了，因此事件分派器会将该事件交给命令请求处理器处理，命令请求处理器读取事件中的命令并完成。操作完成后，Redis 会将该 socket 的 AE_WRITABLE 事件与命令回复处理器关联。\",\"如果客户端已经准备好接受数据后，Redis 中的该 socket 会产生一个 AE_WRITABLE 事件，同样会压入队列然后被事件派发器取出交给相对应的命令回复处理器，由该命令回复处理器将准备好的响应数据写入 socket 中，供客户端读取。\",\"命令回复处理器写完后，就会删除该 socket 的 AE_WRITABLE 事件与命令回复处理器的关联关系。\"]},\"404\":{\"h\":\"27. Redis 6.0 多线程的实现机制？\",\"t\":[\"流程简述如下：\",\"主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。\",\"主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。\",\"主线程阻塞等待 IO 线程读取 Socket 完毕。\",\"主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。\",\"主线程阻塞等待 IO 线程将数据回写 Socket 完毕。\",\"该设计有如下特点：\",\"IO 线程要么同时在读 Socket，要么同时在写，不会同时读或写。\",\"IO 线程只负责读写 Socket 解析命令，不负责命令处理。\"]},\"405\":{\"h\":\"28. Redis 6.0开启多线程后，是否会存在线程并发安全问题？\",\"t\":[\"从实现机制可以看出，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。\",\"所以我们不需要去考虑控制 Key、Lua、事务，LPUSH/LPOP 等等的并发及线程安全问题。\"]},\"406\":{\"h\":\"29. Redis 6.0 与 Memcached 多线程模型的对比\",\"t\":[\"**相同点：**都采用了 Master 线程 -Worker 线程的模型。\",\"不同点：Memcached 执行主逻辑也是在 Worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。\",\"而 Redis 把处理逻辑交还给 Master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。\"]},\"407\":{\"h\":\"30. Redis事务的概念\",\"t\":[\"Redis的事务并不是我们传统意义上理解的事务，我们都知道 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。\",\"事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。\",\"总结：\",\"1. Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。鉴于这个原因，所以说Redis的事务严格意义上来说是不具备原子性的。\",\"2. Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\",\"3. 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。\",\"当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的Redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。\"]},\"408\":{\"h\":\"31. Redis事务的三个阶段\",\"t\":[\"multi 开启事务\",\"大量指令入队\",\"exec执行事务块内命令，截止此处一个事务已经结束。\",\"discard 取消事务\",\"watch 监视一个或多个key，如果事务执行前key被改动，事务将打断。unwatch 取消监视。\",\"事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队.\"]},\"409\":{\"h\":\"32. Redis事务相关命令\",\"t\":[\"Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的\",\"WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。\",\"MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。\",\"EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。\",\"UNWATCH命令可以取消watch对所有key的监控。\"]},\"410\":{\"h\":\"33. Redis事务支持隔离性吗?\",\"t\":[\"Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。\"]},\"411\":{\"h\":\"34. Redis为什么不支持事务回滚？\",\"t\":[\"Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，这些问题不能在入队时发现，这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中.\",\"因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。\"]},\"412\":{\"h\":\"35. Redis事务其他实现\",\"t\":[\"基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行， 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。\",\"基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。\"]},\"413\":{\"h\":\"36. Redis常见使用方式有哪些？\",\"t\":[\"Redis的几种常见使用方式包括：\",\"Redis单副本；\",\"Redis多副本（主从）；\",\"Redis Sentinel（哨兵）；\",\"Redis Cluster；\",\"Redis自研。\",\"使用场景：\",\"如果数据量很少，主要是承载高并发高性能的场景，比如缓存一般就几个G的话，单机足够了。\",\"主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。\",\"哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。\",\"Redis cluster 主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有master的容量总和就是Redis cluster可缓存的数据容量。\"]},\"414\":{\"h\":\"37. 介绍下Redis单副本\",\"t\":[\"Redis单副本，采用单个Redis节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。\",\"优点：\",\"架构简单，部署方便；\",\"高性价比：缓存使用时无需备用节点（单实例可用性可以用supervisor或crontab保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；\",\"高性能。\",\"缺点：\",\"不保证数据的可靠性；\",\"在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；\",\"高性能受限于单核CPU的处理能力（Redis是单线程机制），CPU为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用Memcached替代。\"]},\"415\":{\"h\":\"38. 介绍下Redis多副本（主从）\",\"t\":[\"Redis多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。\",\"优点：\",\"高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；\",\"读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。\",\"缺点：\",\"故障恢复复杂，如果没有RedisHA系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；\",\"主库的写能力受到单机的限制，可以考虑分片；\",\"主库的存储能力受到单机的限制，可以考虑Pika；\",\"原生复制的弊端在早期的版本中也会比较突出，如：Redis复制中断后，Slave会发起psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于COW机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘IO和CPU（压缩）资源消耗；发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。\"]},\"416\":{\"h\":\"39. 介绍下Redis Sentinel（哨兵）\",\"t\":[\"主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。\",\"Redis Sentinel是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群。\",\"其中Redis Sentinel集群是由若干Sentinel节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel的节点数量要满足2n+1（n>=1）的奇数个。\",\"优点：\",\"Redis Sentinel集群部署简单；\",\"能够解决Redis主从模式下的高可用切换问题；\",\"很方便实现Redis数据节点的线形扩展，轻松突破Redis自身单线程瓶颈，可极大满足Redis大容量或高性能的业务需求；\",\"可以实现一套Sentinel监控一组Redis数据节点或多组数据节点。\",\"缺点：\",\"部署相对Redis主从模式要复杂一些，原理理解更繁琐；\",\"资源浪费，Redis数据节点中slave节点作为备份节点不提供服务；\",\"Redis Sentinel主要是针对Redis数据节点中的主节点的高可用切换，对Redis的数据节点做失败判定分为主观下线和客观下线两种，对于Redis的从节点有对节点做主观下线操作，并不执行故障转移。\",\"不能解决读写分离问题，实现起来相对复杂。\"]},\"417\":{\"h\":\"40. 介绍下Redis Cluster\",\"t\":[\"Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 Redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。\",\"Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。\",\"Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。\",\"Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。\",\"优点：\",\"无中心架构；\",\"数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；\",\"可扩展性：可线性扩展到1000多个节点，节点可动态添加或删除；\",\"高可用性：部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升；\",\"降低运维成本，提高系统的扩展性和可用性。\",\"缺点：\",\"Client实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅JedisCluster相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。\",\"节点会因为某些原因发生阻塞（阻塞时间大于clutser-node-timeout），被判断下线，这种failover是没有必要的。\",\"数据通过异步复制，不保证数据的强一致性。\",\"多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。\",\"Slave在集群中充当“冷备”，不能缓解读压力，当然可以通过SDK的合理设计来提高Slave资源的利用率。\",\"Key批量操作限制，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作。对于映射为不同slot值的Key由于Keys不支持跨slot查询，所以执行mset、mget、sunion等操作支持不友好。\",\"Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能。\",\"Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点。\",\"不支持多数据库空间，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。\",\"复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。\",\"避免产生hot-key，导致主库节点成为系统的短板。\",\"避免产生big-key，导致网卡撑爆、慢查询等。\",\"重试时间应该大于cluster-node-time时间。\",\"Redis Cluster不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。\"]},\"418\":{\"h\":\"41. 介绍下Redis自研\",\"t\":[\"Redis自研的高可用解决方案，主要体现在配置中心、故障探测和failover的处理机制上，通常需要根据企业业务的实际线上环境来定制化。\",\"优点：\",\"高可靠性、高可用性；\",\"自主可控性高；\",\"贴切业务实际需求，可缩性好，兼容性好。\",\"缺点：\",\"实现复杂，开发成本高；\",\"需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；\",\"维护成本高。\"]},\"419\":{\"h\":\"42. Redis高可用方案具体怎么实施？\",\"t\":[\"使用官方推荐的哨兵(sentinel)机制就能实现，当主节点出现故障时，由Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。它有四个主要功能：\",\"集群监控，负责监控Redis master和slave进程是否正常工作。\",\"消息通知，如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。\",\"故障转移，如果master node挂掉了，会自动转移到slave node上。\",\"配置中心，如果故障转移发生了，通知client客户端新的master地址。\"]},\"420\":{\"h\":\"43. 了解主从复制的原理吗？\",\"t\":[\"1、主从架构的核心原理\",\"当启动一个slave node的时候，它会发送一个PSYNC命令给master node\",\"如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据; 否则如果是slave node第一次连接master node，那么会触发一次full resynchronization\",\"开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。\",\"slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。\",\"2、主从复制的断点续传\",\"从Redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份\",\"master node会在内存中常见一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制\",\"但是如果没有找到对应的offset，那么就会执行一次resynchronization\",\"3、无磁盘化复制\",\"master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了\",\"repl-diskless-sync repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来\",\"4、过期key处理\",\"slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。\"]},\"421\":{\"h\":\"44. 由于主从延迟导致读取到过期数据怎么处理？\",\"t\":[\"通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key，同样也会做过期检测，充分发挥Redis惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。\",\"Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。\"]},\"422\":{\"h\":\"45. 主从复制的过程中如果因为网络原因停止复制了会怎么样？\",\"t\":[\"如果出现网络故障断开连接了，会自动重连的，从Redis 2.8开始，就支持主从复制的断点续传，可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。\",\"master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。\",\"master node会在内存中创建一个backlog，master和slave都会保存一个replica offset，还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制。\",\"但是如果没有找到对应的offset，那么就会执行一次resynchronization全量复制。\"]},\"423\":{\"h\":\"46. Redis主从架构数据会丢失吗，为什么？\",\"t\":[\"有两种数据丢失的情况：\",\"异步复制导致的数据丢失：因为master -> slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。\",\"脑裂导致的数据丢失：某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了。因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据。\"]},\"424\":{\"h\":\"47. 如何解决主从架构数据丢失的问题？\",\"t\":[\"数据丢失的问题是不可避免的，但是我们可以尽量减少。\",\"在Redis的配置文件里设置参数\",\"min-slaves-to-write 1 min-slaves-max-lag 10 \",\"min-slaves-to-write默认情况下是0，min-slaves-max-lag默认情况下是10。\",\"上面的配置的意思是要求至少有1个slave，数据复制和同步的延迟不能超过10秒。如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。\",\"减小min-slaves-max-lag参数的值，这样就可以避免在发生故障时大量的数据丢失，一旦发现延迟超过了该值就不会往master中写入数据。\",\"那么对于client，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间后重新写入master来保证数据不丢失；也可以将数据写入kafka消息队列，隔一段时间去消费kafka中的数据。\"]},\"425\":{\"h\":\"48. Redis哨兵是怎么工作的？\",\"t\":[\"每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。\",\"如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被当前 Sentinel 标记为主观下线。\",\"如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。\",\"当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。\",\"当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 ）。\",\"若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会变成主观下线。若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。\",\"sentinel节点会与其他sentinel节点进行“沟通”，投票选举一个sentinel节点进行故障处理，在从节点中选取一个主节点，其他从节点挂载到新的主节点上自动复制新主节点的数据。\"]},\"426\":{\"h\":\"49. 故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么？\",\"t\":[\"如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来，会考虑slave的一些信息。\",\"跟master断开连接的时长。 如果一个slave跟master断开连接已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master.\",\"( down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state \",\"slave优先级。 按照slave优先级进行排序，slave priority越低，优先级就越高\",\"复制offset。 如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高\",\"run id 如果上面两个条件都相同，那么选择一个run id比较小的那个slave。\"]},\"427\":{\"h\":\"50. 同步配置的时候其他哨兵根据什么更新自己的配置呢？\",\"t\":[\"执行切换的那个哨兵，会从要切换到的新master（salve->master）那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。\",\"如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch 作为新的version号。\",\"这个version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置的。\"]},\"428\":{\"h\":\"51. 为什么Redis哨兵集群只有2个节点无法正常工作？\",\"t\":[\"哨兵集群必须部署2个以上节点。\",\"如果两个哨兵实例，即两个Redis实例，一主一从的模式。\",\"则Redis的配置quorum=1，表示一个哨兵认为master宕机即可认为master已宕机。\",\"但是如果是机器1宕机了，那哨兵1和master都宕机了，虽然哨兵2知道master宕机了，但是这个时候，需要majority，也就是大多数哨兵都是运行的，2个哨兵的majority就是2（2的majority=2，3的majority=2，5的majority=3，4的majority=2），2个哨兵都运行着，就可以允许执行故障转移。\",\"但此时哨兵1没了就只有1个哨兵了了，此时就没有majority来允许执行故障转移，所以故障转移不会执行。\"]},\"429\":{\"h\":\"52. Redis cluster中是如何实现数据分布的？这种方式有什么优点？\",\"t\":[\"Redis cluster有固定的16384个hash slot（哈希槽），对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot。\",\"Redis cluster中每个master都会持有部分slot（槽），比如有3个master，那么可能每个master持有5000多个hash slot。\",\"hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去。每次增加或减少master节点都是对16384取模，而不是根据master数量，这样原本在老的master上的数据不会因master的新增或减少而找不到。并且增加或减少master时Redis cluster移动hash slot的成本是非常低的。\"]},\"430\":{\"h\":\"53. Redis cluster节点间通信是什么机制？\",\"t\":[\"Redis cluster节点间采取gossip协议进行通信，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更之后U不断地i将元数据发送给其他节点让其他节点进行数据变更。\",\"节点互相之间不断通信，保持整个集群所有节点的数据是完整的。 主要交换故障信息、节点的增加和移除、hash slot信息等。\",\"这种机制的好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力;\",\"缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后。\"]},\"431\":{\"h\":\"54. 什么是分布式锁？为什么用分布式锁？\",\"t\":[\"锁在程序中的作用就是同步工具，保证共享资源在同一时刻只能被一个线程访问，Java中的锁我们都很熟悉了，像synchronized 、Lock都是我们经常使用的，但是Java的锁只能保证单机的时候有效，分布式集群环境就无能为力了，这个时候我们就需要用到分布式锁。\",\"分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源。\",\"思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库。\",\"一般来说，分布式锁需要满足的特性有这么几点：\",\"1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；\",\"2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；\",\"3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；\",\"4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了。\"]},\"432\":{\"h\":\"55. 常见的分布式锁有哪些解决方案？\",\"t\":[\"实现分布式锁目前有三种流行方案，即基于关系型数据库、Redis、ZooKeeper 的方案\",\"1、基于关系型数据库，如MySQL 基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。\",\"缺点：\",\"这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。\",\"这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。\",\"这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。\",\"这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。\",\"2、基于Redis实现\",\"优点：\",\"Redis 锁实现简单，理解逻辑简单，性能好，可以支撑高并发的获取、释放锁操作。\",\"缺点：\",\"Redis 容易单点故障，集群部署，并不是强一致性的，锁的不够健壮；\",\"key 的过期时间设置多少不明确，只能根据实际情况调整；\",\"需要自己不断去尝试获取锁，比较消耗性能。\",\"3、基于zookeeper\",\"优点：\",\"zookeeper 天生设计定位就是分布式协调，强一致性，锁很健壮。如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。\",\"缺点：\",\"在高请求高并发下，系统疯狂的加锁释放锁，最后 zk 承受不住这么大的压力可能会存在宕机的风险。\"]},\"433\":{\"h\":\"56. Redis实现分布式锁\"},\"434\":{\"h\":\"分布式锁的三个核心要素\",\"t\":[\"1、加锁\",\"使用setnx来加锁。key是锁的唯一标识，按业务来决定命名，value这里设置为test。\",\"setx key test \",\"当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败；\",\"2、解锁\",\"有加锁就得有解锁。当得到的锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式就是执行del指令。\",\"del key \",\"释放锁之后，其他线程就可以继续执行setnx命令来获得锁。\",\"3、锁超时\",\"锁超时知道的是：如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程北向进来。\",\"所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一段时间后自动释放。setnx不支持超时参数，所以需要额外指令，\",\"expire key 30 \"]},\"435\":{\"h\":\"上述分布式锁存在的问题\",\"t\":[\"通过上述setnx 、del和expire实现的分布式锁还是存在着一些问题。\",\"1、SETNX 和 EXPIRE 非原子性\",\"假设一个场景中，某一个线程刚执行setnx，成功得到了锁。此时setnx刚执行成功，还未来得及执行expire命令，节点就挂掉了。此时这把锁就没有设置过期时间，别的线程就再也无法获得该锁。\",\"解决措施:\",\"由于setnx指令本身是不支持传入超时时间的，而在Redis2.6.12版本上为set指令增加了可选参数, 用法如下：\",\"SET key value [EX seconds][PX milliseconds] [NX|XX] \",\"EX second: 设置键的过期时间为second秒；\",\"PX millisecond：设置键的过期时间为millisecond毫秒；\",\"NX：只在键不存在时，才对键进行设置操作；\",\"XX：只在键已经存在时，才对键进行设置操作；\",\"SET操作完成时，返回OK，否则返回nil。\",\"2、锁误解除\",\"如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。\",\"解决办法：\",\"在del释放锁之前加一个判断，验证当前的锁是不是自己加的锁。\",\"具体在加锁的时候把当前线程的id当做value，可生成一个 UUID 标识当前线程，在删除之前验证key对应的value是不是自己线程的id。\",\"还可以使用 lua 脚本做验证标识和解锁操作。\",\"3、超时解锁导致并发\",\"如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。\",\"A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：\",\"将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。\",\"为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。\",\"4、不可重入\",\"当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。\",\"5、无法等待锁释放\",\"上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。\",\"可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。\",\"另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。\",\"具体实现参考：https://xiaomi-info.github.io/2019/12/17/Redis-distributed-lock/\"]},\"436\":{\"h\":\"57. 了解RedLock吗？\",\"t\":[\"Redlock是一种算法，Redlock也就是 Redis Distributed Lock，可用实现多节点Redis的分布式锁。\",\"RedLock官方推荐，Redisson完成了对Redlock算法封装。\",\"此种方式具有以下特性：\",\"互斥访问：即永远只有一个 client 能拿到锁\",\"避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。\",\"容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务\"]},\"437\":{\"h\":\"58. RedLock的原理\",\"t\":[\"假设有5个完全独立的Redis主服务器\",\"获取当前时间戳\",\"client尝试按照顺序使用相同的key,value获取所有Redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的Redis服务。并且试着获取下一个Redis实例。\",\"比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁\",\"client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个Redis实例成功获取锁，才算真正的获取锁成功\",\"如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);\",\"如果客户端由于某些原因获取锁失败，便会开始解锁所有Redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁\",\"算法示意图如下：\"]},\"438\":{\"h\":\"59. Redis如何做内存优化？\",\"t\":[\"控制key的数量。当使用Redis存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis本质是一个数据结构服务器，它为我们提供多种数据结构，如hash，list，set，zset 等结构。使用Redis时不要进入一个误区，大量使用get/set这样的API，把Redis当成Memcached使用。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存。\",\"缩减键值对象，降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。\",\"key长度：如在设计键时，在完整描述业务情况下，键值越短越好。\",\"value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。\",\"编码优化。Redis对外提供了string,list,hash,set,zet等类型，但是Redis内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。可参考文章：https://cloud.tencent.com/developer/article/1162213\"]},\"439\":{\"h\":\"60. 如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？\",\"t\":[\"如果是读高并发的话，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，每秒几万没问题，使用一主多从+哨兵集群的缓存架构来承载每秒10W+的读并发，主从复制，读写分离。\",\"使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例。如果读并发继续增加的话，只需要增加Redis从实例就行了。\",\"如果需要缓存1T+的数据，选择Redis cluster模式，每个主节点存一部分数据，假设一个master存32G，那只需要n*32G>=1T，n个这样的master节点就可以支持1T+的海量数据的存储了。\",\"Redis单主的瓶颈不在于读写的并发，而在于内存容量，即使是一主多从也是不能解决该问题，因为一主多从架构下，多个slave的数据和master的完全一样。假如master是10G那slave也只能存10G数据。所以数据量受单主的影响。 而这个时候又需要缓存海量数据，那就必须得有多主了，并且多个主保存的数据还不能一样。Redis官方给出的 Redis cluster 模式完美的解决了这个问题。\"]},\"440\":{\"h\":\"Java 基础一\",\"t\":[\"Java 基础一\"]},\"441\":{\"h\":\"Java概述\"},\"442\":{\"h\":\"Java语言有哪些特点？\",\"t\":[\"面向对象（封装，继承，多态）；\",\"平台无关性，平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。\",\"可靠性、安全性；\",\"支持多线程。C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；\",\"支持网络编程并且很方便。Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便；\",\"编译与解释并存；\"]},\"443\":{\"h\":\"Java和C++有什么关系，它们有什么区别？\",\"t\":[\"都是面向对象的语言，都支持封装、继承和多态；\",\"C++ 支持指针，而 Java 没有指针的概念；\",\"C++ 支持多继承，而 Java 不支持多重继承，但允许一个类实现多个接口；\",\"Java 是完全面向对象的语言，并且还取消了 C/C++ 中的结构和联合，使编译程序更加简洁；\",\"Java 自动进行无用内存回收操作，不再需要程序员进行手动删除，而 C++ 中必须由程序释放内存资源，这就增加了程序员的负担。\",\"Java 不支持操作符重载，操作符重载则被认为是 C++ 的突出特征；\",\"Java 允许预处理，但不支持预处理器功能，所以为了实现预处理，它提供了引入语句（import），但它与 C++ 预处理器的功能类似；\",\"Java 不支持缺省参数函数，而 C++ 支持；\",\"C 和 C++ 不支持字符串变量，在 C 和 C++ 程序中使用“Null”终止符代表字符串的结束。在 Java 中字符串是用类对象（String 和 StringBuffer）来实现的；\",\"goto 语句是 C 和 C++ 的“遗物”，Java 不提供 goto 语句，虽然 Java 指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读；\",\"Java 不支持 C++ 中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。\"]},\"444\":{\"h\":\"JVM、JRE和JDK的关系是什么？\",\"t\":[\"JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。\",\"JRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。\",\"JDK包含JRE，JRE包含JVM。\"]},\"445\":{\"h\":\"\",\"t\":[\"这个问题，面试官可以扩展提问，Java 是编译执行的语言，还是解释执行的语言?\",\"Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。因此，也可以看出字节码对于Java生态的重要性。\",\"之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用javac命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图所示。\"]},\"446\":{\"h\":\"采用字节码的好处是什么?\",\"t\":[\"Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\"]},\"447\":{\"h\":\"Oracle JDK 和 OpenJDK 的区别是什么？\",\"t\":[\"可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。\",\"Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次；\",\"OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是OpenJDK 的一个实现，并不是完全开源的；\",\"Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，建议选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；\",\"在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；\",\"Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；\",\"Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPLv2 许可获得许可。\"]},\"448\":{\"h\":\"基础语法\"},\"449\":{\"h\":\"Java有哪些数据类型？\",\"t\":[\"Java 语言的数据类型分为两种：基本数据类型和引用数据类型。\",\"1.基本数据类型包括 boolean（布尔型）、float（单精度浮点型）、char（字符型）、byte（字节型）、short（短整型）、int（整型）、long（长整型）和 double （双精度浮点型）共 8 种，如下表所示。\",\"基本类型\",\"位数\",\"字节\",\"默认值\",\"int\",\"32\",\"4\",\"0\",\"short\",\"16\",\"2\",\"0\",\"long\",\"64\",\"8\",\"0L\",\"byte\",\"8\",\"1\",\"0\",\"char\",\"16\",\"2\",\"'u0000'\",\"float\",\"32\",\"4\",\"0f\",\"double\",\"64\",\"8\",\"0d\",\"boolean\",\"1\",\"false\",\"对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。\",\"Java虚拟机规范讲到：在JVM中并没有提供boolean专用的字节码指令，而boolean类型数据在经过编译后在JVM中会通过int类型来表示，此时boolean数据4字节32位，而boolean数组将会被编码成Java虚拟机的byte数组，此时每个boolean数据1字节占8bit。\",\"注意：\",\"Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析：\",\"char a = 'h'char :单引号，String a = \\\"hello\\\" :双引号\",\"2.引用数据类型建立在基本数据类型的基础上，包括数组、类和接口。引用数据类型是由用户自定义，用来限制其他数据的类型。另外，Java 语言中不支持 C++中的指针类型、结构类型、联合类型和枚举类型。\"]},\"450\":{\"h\":\"switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？\",\"t\":[\"Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。\",\"从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。\",\"从 Java 7 开始，expr还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。\"]},\"451\":{\"h\":\"？\",\"t\":[\"Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\",\"default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\",\"private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\",\"public : 对所有类可见。使用对象：类、接口、变量、方法\",\"protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\"]},\"452\":{\"h\":\"break ,continue ,return 的区别及作用？\",\"t\":[\"break 跳出总上一层循环，不再执行循环(结束当前的循环体)\",\"continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)\",\"return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)\"]},\"453\":{\"h\":\"关键字\"},\"454\":{\"h\":\"final、finally、finalize的区别？\",\"t\":[\"final 用于修饰变量、方法和类。\",\"final 变量：被修饰的变量不可变，不可变分为引用不可变和对象不可变，final 指的是引用不可变，final 修饰的变量必须初始化，通常称被修饰的变量为常量。\",\"final 方法：被修饰的方法不允许任何子类重写，子类可以使用该方法。\",\"final 类：被修饰的类不能被继承，所有方法不能被重写。\",\"finally 作为异常处理的一部分，它只能在 try/catch 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，System.exit (0) 可以阻断 finally 执行。\",\"finalize 是在 java.lang.Object 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 gc 启动，该对象被回收的时候被调用。\",\"一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。\"]},\"455\":{\"h\":\"为什么要用static关键字？\",\"t\":[\"通常来说，用new创建类的对象时，数据存储空间才被分配，方法才供外界调用。但有时我们只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法。在这两种情况下，static关键字，满足了我们的需求。\"]},\"456\":{\"h\":\"”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？\",\"t\":[\"“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。\",\"Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。\"]},\"457\":{\"h\":\"是否可以在static环境中访问非static变量？\",\"t\":[\"static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。\"]},\"458\":{\"h\":\"static静态方法能不能引用非静态资源？\",\"t\":[\"不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。\"]},\"459\":{\"h\":\"static静态方法里面能不能引用静态资源？\",\"t\":[\"可以，因为都是类初始化的时候加载的，大家相互都认识。\"]},\"460\":{\"h\":\"非静态方法里面能不能引用静态资源？\",\"t\":[\"可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。\"]},\"461\":{\"h\":\"java静态变量、代码块、和静态方法的执行顺序是什么？\",\"t\":[\"基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块\",\"代码块执行顺序静态代码块——> 构造代码块 ——> 构造函数——> 普通代码块\",\"继承中代码块执行顺序：父类静态块——>子类静态块——>父类代码块——>父类构造器——>子类代码块——>子类构造器\",\"想要深入了解，可以参考这篇文章 ：https://juejin.cn/post/6844903986475040781\"]},\"462\":{\"h\":\"面向对象\"},\"463\":{\"h\":\"面向对象和面向过程的区别？\",\"t\":[\"面向过程：\",\"优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。\",\"缺点：没有面向对象易维护、易复用、易扩展。\",\"面向对象：\",\"优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。\",\"缺点：性能比面向过程低。\"]},\"464\":{\"h\":\"讲讲面向对象三大特性\",\"t\":[\"封装。封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\",\"继承。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。\",\"多态性。它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。\"]},\"465\":{\"h\":\"Java语言是如何实现多态的？\",\"t\":[\"本质上多态分两种：\",\"1、编译时多态（又称静态多态）\",\"2、运行时多态（又称动态多态）\",\"重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。\",\"**我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。**这也是为什么有时候多态方法又被称为延迟方法的原因。\",\"Java实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。\",\"继承：在多态中必须存在有继承关系的子类和父类。\",\"重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\",\"向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。\",\"Java多态的实现原理可看这篇文章：https://my.oschina.net/u/4432600/blog/4535042\"]},\"466\":{\"h\":\"重载（Overload）和重写（Override）的区别是什么？\",\"t\":[\"方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\",\"重写发生在子类与父类之间, 重写方法返回值和形参都不能改变，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。即外壳不变，核心重写！\",\"重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。\"]},\"467\":{\"h\":\"重载的方法能否根据返回值类型进行区分？\",\"t\":[\"不能根据返回值类型来区分重载的方法。因为调用时不指定类型信息，编译器不知道你要调用哪个函数。\",\"float max(int a, int b); int max(int a, int b); \",\"当调用max（1,2）;时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。\"]},\"468\":{\"h\":\"构造器（constructor）是否可被重写（override）？\",\"t\":[\"构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。\"]},\"469\":{\"h\":\"抽象类和接口的区别是什么？\",\"t\":[\"语法层面上的区别：\",\"抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；\",\"抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；\",\"接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；\",\"一个类只能继承一个抽象类，而一个类却可以实现多个接口。\",\"设计层面上的区别：\",\"抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\",\"设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。\",\"想要深入了解，可以参考这篇文章 ：https://www.cnblogs.com/dolphin0520/p/3811437.html\"]},\"470\":{\"h\":\"抽象类能使用 final 修饰吗？\",\"t\":[\"不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类\"]},\"471\":{\"h\":\"java 创建对象有哪几种方式？\",\"t\":[\"java中提供了以下四种创建对象的方式:\",\"new创建新对象\",\"通过反射机制\",\"采用clone机制\",\"通过序列化机制\",\"前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。\"]},\"472\":{\"h\":\"什么是不可变对象?好处是什么?\",\"t\":[\"不可变对象指对象一旦被创建,状态就不能再改变,任何修改都会创建一个新的对象,如 String、Integer及其它包装类.不可变对象最大的好处是线程安全.\"]},\"473\":{\"h\":\"能否创建一个包含可变对象的不可变对象?\",\"t\":[\"当然可以,比如final Person[] persons = new Persion[]{}. persons是不可变对象的引用,但其数组中的Person实例却是可变的.这种情况下需要特别谨慎,不要共享可变对象的引用.这种情况下,如果数据需要变化时,就返回原对象的一个拷贝.\"]},\"474\":{\"h\":\"值传递和引用传递的区别的什么？为什么说Java中只有值传递？\",\"t\":[\"值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\",\"引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\",\"基本类型作为参数被传递时肯定是值传递；引用类型作为参数被传递时也是值传递，只不过“值”为对应的引用。\",\"想要深入了解，可以参考这篇文章 ：http://www.itwanger.com/java/2019/11/26/java-yinyong-value.html\"]},\"475\":{\"h\":\"对象相等判断\"},\"476\":{\"h\":\"== 和 equals 区别是什么？\",\"t\":[\"==常用于相同的基本数据类型之间的比较，也可用于相同类型的对象之间的比较；\",\"如果==比较的是基本数据类型，那么比较的是两个基本数据类型的值是否相等；\",\"如果==是比较的两个对象，那么比较的是两个对象的引用，也就是判断两个对象是否指向了同一块内存区域；\",\"equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象\",\"看一看Object类中equals方法的源码：\",\"public boolean equals(Object obj) { return (this == obj); } \",\"它的作用也是判断两个对象是否相等，般有两种使用情况：\",\"情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。\",\"情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。\",\"java语言规范要求equals方法具有以下特性：\",\"自反性。对于任意不为null的引用值x，x.equals(x)一定是true。\",\"对称性）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。\",\"传递性。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。\",\"一致性。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。\",\"对于任意不为null的引用值x，x.equals(null)返回false。\"]},\"477\":{\"h\":\"\",\"t\":[\"hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。\",\"散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\"]},\"478\":{\"h\":\"\",\"t\":[\"以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：\",\"当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。\",\"但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\"]},\"479\":{\"h\":\"hashCode(),equals()两种方法是什么关系?\",\"t\":[\"要弄清楚这两种方法的关系，就需要对哈希表有一个基本的认识。其基本的结构如下：\",\"对于hashcode方法，会返回一个哈希值，哈希值对数组的长度取余后会确定一个存储的下标位置，如图中用数组括起来的第一列。\",\"不同的哈希值取余之后的结果可能是相同的，用equals方法判断是否为相同的对象，不同则在链表中插入。\",\"则有hashCode()与equals()的相关规定：\",\"如果两个对象相等，则hashcode一定也是相同的；\",\"两个对象相等，对两个对象分别调用equals方法都返回true；\",\"两个对象有相同的hashcode值，它们也不一定是相等的；\"]},\"480\":{\"h\":\"为什么重写 equals 方法必须重写 hashcode 方法 ？\",\"t\":[\"判断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，而equals()方法判断出来的结果为true。\",\"在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。\"]},\"481\":{\"h\":\"String,StringBuffer, StringBuilder 的区别是什么？\",\"t\":[\"1.可变与不可变。String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.\",\"String类利用了final修饰的char类型数组存储字符，源码如下:\",\"private final char value[];\",\"StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，这两种对象都是可变的。\",\"源码如下:\",\"char[] value;\",\"2.是否多线程安全。\",\"String中的对象是不可变的，也就可以理解为常量，显然线程安全。\",\"StringBuilder是非线程安全的。\",\"StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。\",\"源码如下:\",\" @Override public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } \",\"3.性能\",\"每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\"]},\"482\":{\"h\":\"String为什么要设计成不可变的？\",\"t\":[\"1.便于实现字符串池（String pool）\",\"在Java中，由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。\",\"String a = \\\"Hello world!\\\"; String b = \\\"Hello world!\\\"; \",\"如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！\",\"2.使多线程安全\",\"在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全。\",\"3.避免安全问题\",\"在网络连接和数据库连接中字符串常常作为参数，例如，网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向对象的值，那么会引起很严重的安全问题。\",\"4.加快字符串处理速度\",\"由于String是不可变的，保证了hashcode的唯一性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象。所以HashMap中的键往往都使用String。\",\"总体来说，String不可变的原因要包括 设计考虑，效率优化，以及安全性这三大方面。\"]},\"483\":{\"h\":\"参考\",\"t\":[\"https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html\",\"http://c.biancheng.net/view/769.html\",\"http://www.51gjie.com/java/81.html\",\"http://www.justdojava.com/2019/03/21/Java-and-equals/\",\"https://blog.csdn.net/qq_28051453/article/details/52701171\",\"https://www.cnblogs.com/wkfvawl/p/11693260.html\",\"To Java\"]},\"484\":{\"h\":\"Java 基础二\",\"t\":[\"Java 基础二\",\"String相关\",\"字符型常量和字符串常量的区别？\",\"什么是字符串常量池？\",\"String str=\\\"aaa\\\"与 String str=new String(\\\"aaa\\\")一样吗？new String(“aaa”);创建了几个字符串对象?\",\"String 是最基本的数据类型吗?\",\"String有哪些特性?\",\"在使用 HashMap 的时候，用 String 做 key 有什么好处？\",\"包装类型\",\"包装类型是什么？基本类型和包装类型有什么区别？\",\"解释一下自动装箱和自动拆箱？\",\"int 和 Integer 有什么区别?\",\"两个new生成的Integer变量的对比\",\"Integer变量和int变量的对比\",\"非new生成的Integer变量和new Integer()生成变量的对比\",\"两个非new生成的Integer对象的对比\",\"反射\",\"什么是反射？\",\"反射机制的优缺点有哪些？\",\"如何获取反射中的Class对象？\",\"Java反射API有几类？\",\"反射使用的步骤？\",\"为什么引入反射概念？反射机制的应用有哪些？\",\"反射机制的原理是什么？\",\"泛型\",\"Java中的泛型是什么 ?\",\"使用泛型的好处是什么?\",\"Java泛型的原理是什么 ? 什么是类型擦除 ?\",\"什么是泛型中的限定通配符和非限定通配符 ?\",\"List<? extends T>和List <? super T>之间有什么区别 ?\",\"可以把List<String>传递给一个接受List<Object>参数的方法吗？\",\"Array中可以用泛型吗?\",\"判断ArrayList<String>与ArrayList<Integer>是否相等？\",\"序列化\",\"Java序列化与反序列化是什么？\",\"为什么需要序列化与反序列化？\",\"序列化实现的方式有哪些？\",\"Serializable接口\",\"Externalizable接口\",\"两种序列化的对比\",\"什么是serialVersionUID？\",\"为什么还要显示指定serialVersionUID的值?\",\"serialVersionUID什么时候修改？\",\"Java 序列化中如果有些字段不想进行序列化，怎么办？\",\"静态变量会被序列化吗?\",\"异常\",\"Error 和 Exception 区别是什么？\",\"非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？\",\"throw 和 throws 的区别是什么？\",\"NoClassDefFoundError 和 ClassNotFoundException 区别？\",\"Java常见异常有哪些？\",\"try-catch-finally 中哪个部分可以省略？\",\"try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\",\"JVM 是如何处理异常的？\",\"IO\",\"Java的IO 流分为几种？\",\"字节流如何转为字符流？\",\"字符流与字节流的区别？\",\"BIO、NIO、AIO的区别？\",\"Java IO都有哪些设计模式？\",\"参考\"]},\"485\":{\"h\":\"String相关\"},\"486\":{\"h\":\"字符型常量和字符串常量的区别？\",\"t\":[\"形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；\",\"含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象；\",\"占内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)。\"]},\"487\":{\"h\":\"什么是字符串常量池？\",\"t\":[\"java中常量池的概念主要有三个：全局字符串常量池，class文件常量池，运行时常量池。我们现在所说的就是全局字符串常量池，对这个想弄明白的同学可以看这篇Java中几种常量池的区分。\",\"jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。\",\"字符串常量池的位置也是随着jdk版本的不同而位置不同。在jdk6中，常量池的位置在永久代（方法区）中，此时常量池中存储的是对象。在jdk7中，常量池的位置在堆中，此时，常量池存储的就是引用了。在jdk8中，永久代（方法区）被元空间取代了。\"]},\"488\":{\"h\":\"String str=\\\"aaa\\\"与 String str=new String(\\\"aaa\\\")一样吗？ 创建了几个字符串对象?\",\"t\":[\"使用String a = “aaa” ;，程序运行时会在常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。\",\"使用String b = new String(\\\"aaa\\\");`，程序会在堆内存中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。\",\"具体分析，见以下代码：\",\" @Test public void test(){ String s = new String(\\\"2\\\"); s.intern(); String s2 = \\\"2\\\"; System.out.println(s == s2); String s3 = new String(\\\"3\\\") + new String(\\\"3\\\"); s3.intern(); String s4 = \\\"33\\\"; System.out.println(s3 == s4); } \",\"运行结果：\",\"jdk6 false false jdk7 false true \",\"这段代码在jdk6中输出是false false，但是在jdk7中输出的是false true。我们通过图来一行行解释。\",\"先来认识下intern()函数：\",\"intern函数的作用是将对应的符号常量进入特殊处理，在JDK1.6以前 和 JDK1.7以后有不同的处理；\",\"在JDK1.6中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，则将该字符串常量加入到字符串常量区，也就是在字符串常量区建立该常量；\",\"在JDK1.7中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，说明该字符串常量在堆中，则处理是把堆区该对象的引用加入到字符串常量池中，以后别人拿到的是该字符串常量的引用，实际存在堆中\",\"JDK1.6\",\"String s = new String(\\\"2\\\");创建了两个对象，一个在堆中的StringObject对象，一个是在常量池中的“2”对象。 s.intern();在常量池中寻找与s变量内容相同的对象，发现已经存在内容相同对象“2”，返回对象2的地址。 String s2 = \\\"2\\\";使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回对象\\\"2\\\"的地址。 System.out.println(s == s2);从上面可以分析出，s变量和s2变量地址指向的是不同的对象，所以返回false\",\"String s3 = new String(\\\"3\\\") + new String(\\\"3\\\");创建了两个对象，一个在堆中的StringObject对象，一个是在常量池中的“3”对象。中间还有2个匿名的new String(\\\"3\\\")我们不去讨论它们。 s3.intern();在常量池中寻找与s3变量内容相同的对象，没有发现“33”对象，在常量池中创建“33”对象，返回“33”对象的地址。 String s4 = \\\"33\\\";使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回对象\\\"33\\\"的地址。 System.out.println(s3 == s4);从上面可以分析出，s3变量和s4变量地址指向的是不同的对象，所以返回false\",\"JDK1.7\",\"String s = new String(\\\"2\\\");创建了两个对象，一个在堆中的StringObject对象，一个是在堆中的“2”对象，并在常量池中保存“2”对象的引用地址。 s.intern();在常量池中寻找与s变量内容相同的对象，发现已经存在内容相同对象“2”，返回对象“2”的引用地址。 String s2 = \\\"2\\\";使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回对象“2”的引用地址。 System.out.println(s == s2);从上面可以分析出，s变量和s2变量地址指向的是不同的对象，所以返回false\",\"String s3 = new String(\\\"3\\\") + new String(\\\"3\\\");创建了两个对象，一个在堆中的StringObject对象，一个是在堆中的“3”对象，并在常量池中保存“3”对象的引用地址。中间还有2个匿名的new String(\\\"3\\\")我们不去讨论它们。 s3.intern();在常量池中寻找与s3变量内容相同的对象，没有发现“33”对象，将s3对应的StringObject对象的地址保存到常量池中，返回StringObject对象的地址。 String s4 = \\\"33\\\";使用字面量创建，在常量池寻找是否有相同内容的对象，发现有，返回其地址，也就是StringObject对象的引用地址。 System.out.println(s3 == s4);从上面可以分析出，s3变量和s4变量地址指向的是相同的对象，所以返回true。\"]},\"489\":{\"h\":\"String 是最基本的数据类型吗?\",\"t\":[\"不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。\"]},\"490\":{\"h\":\"String有哪些特性?\",\"t\":[\"不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性；\",\"常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用；\",\"final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。\"]},\"491\":{\"h\":\"在使用 HashMap 的时候，用 String 做 key 有什么好处？\",\"t\":[\"HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。\"]},\"492\":{\"h\":\"包装类型\"},\"493\":{\"h\":\"包装类型是什么？基本类型和包装类型有什么区别？\",\"t\":[\"Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，把基本类型转换成包装类型的过程叫做装箱（boxing）；反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing），使得二者可以相互转换。\",\"Java 为每个原始类型提供了包装类型：\",\"原始类型: boolean，char，byte，short，int，long，float，double\",\"包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\",\"基本类型和包装类型的区别主要有以下 几点：\",\"包装类型可以为 null，而基本类型不可以。它使得包装类型可以应用于 POJO 中，而基本类型则不行。那为什么 POJO 的属性必须要用包装类型呢？《阿里巴巴 Java 开发手册》上有详细的说明， 数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。\",\"包装类型可用于泛型，而基本类型不可以。泛型不能使用基本类型，因为使用基本类型时会编译出错。\",\"List<int> list = new ArrayList<>(); // 提示 Syntax error, insert \\\"Dimensions\\\" to complete ReferenceType List<Integer> list = new ArrayList<>(); \",\"因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。\",\"基本类型比包装类型更高效。基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。 很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。\"]},\"494\":{\"h\":\"解释一下自动装箱和自动拆箱？\",\"t\":[\"自动装箱：将基本数据类型重新转化为对象\",\" public class Test { public static void main(String[] args) { // 声明一个Integer对象，用到了自动的装箱：解析为:Integer num = Integer.valueOf(9); Integer num = 9; } } \",\"9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的。但jdk1.5 开始引入了自动装箱/拆箱机制，就可以进行这样的声明，自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。\",\"自动拆箱：将对象重新转化为基本数据类型\",\" public class Test { public static void main(String[] args) { / /声明一个Integer对象 Integer num = 9; // 进行计算时隐含的有自动拆箱 System.out.print(num--); } } \",\"因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。\"]},\"495\":{\"h\":\"int 和 Integer 有什么区别?\",\"t\":[\"Integer是int的包装类；int是基本数据类型；\",\"Integer变量必须实例化后才能使用；int变量不需要；\",\"Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；\",\"Integer的默认值是null；int的默认值是0。\"]},\"496\":{\"h\":\"两个new生成的Integer变量的对比\",\"t\":[\"由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。\",\"Integer i = new Integer(10000); Integer j = new Integer(10000); System.out.print(i == j); //false \"]},\"497\":{\"h\":\"Integer变量和int变量的对比\",\"t\":[\"Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）\",\" int a = 10000; Integer b = new Integer(10000); Integer c=10000; System.out.println(a == b); // true System.out.println(a == c); // true \"]},\"498\":{\"h\":\"非new生成的Integer变量和new Integer()生成变量的对比\",\"t\":[\"非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）\",\" Integer b = new Integer(10000); Integer c=10000; System.out.println(b == c); // false \"]},\"499\":{\"h\":\"两个非new生成的Integer对象的对比\",\"t\":[\"对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false\",\"Integer i = 100; Integer j = 100; System.out.print(i == j); //true Integer i = 128; Integer j = 128; System.out.print(i == j); //false \",\"当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。当值超出此范围，会在堆中new出一个对象来存储。\",\"给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，源码如下：\",\"public static Integer valueOf(String s, int radix) throws NumberFormatException { return Integer.valueOf(parseInt(s,radix)); } \",\"/** * （1）在-128~127之内：静态常量池中cache数组是static final类型，cache数组对象会被存储于静态常量池中。 * cache数组里面的元素却不是static final类型，而是cache[k] = new Integer(j++)， * 那么这些元素是存储于堆中，只是cache数组对象存储的是指向了堆中的Integer对象（引用地址） * * （2）在-128~127 之外：新建一个 Integer对象，并返回。 */ public static Integer valueOf(int i) { assert IntegerCache.high >= 127; if (i >= IntegerCache.low && i <= IntegerCache.high) { return IntegerCache.cache[i + (-IntegerCache.low)]; } return new Integer(i); } \",\"IntegerCache是Integer的内部类，源码如下：\",\" /** * 缓存支持自动装箱的对象标识语义 -128和127（含）。 * 缓存在第一次使用时初始化。 缓存的大小可以由-XX：AutoBoxCacheMax = <size>选项控制。 * 在VM初始化期间，java.lang.Integer.IntegerCache.high属性可以设置并保存在私有系统属性中 */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\\\"java.lang.Integer.IntegerCache.high\\\"); if (integerCacheHighPropValue != null) { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k < cache.length; k++) { cache[k] = new Integer(j++); // 创建一个对象 } } private IntegerCache() {} } \"]},\"500\":{\"h\":\"反射\"},\"501\":{\"h\":\"什么是反射？\",\"t\":[\"反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\"]},\"502\":{\"h\":\"反射机制的优缺点有哪些？\",\"t\":[\"优点：能够运行时动态获取类的实例，提高灵活性；可与动态编译结合Class.forName('com.mysql.jdbc.Driver.class');，加载MySQL的驱动类。\",\"缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时，有缓存会快很多；ReflflectASM工具类，通过字节码生成的方式加快反射速度。\"]},\"503\":{\"h\":\"如何获取反射中的Class对象？\",\"t\":[\"Class.forName(“类的路径”)；当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。\",\"Class clz = Class.forName(\\\"java.lang.String\\\"); \",\"类名.class。这种方法只适合在编译前就知道操作的 Class。\",\"Class clz = String.class; \",\"对象名.getClass()。\",\"String str = new String(\\\"Hello\\\"); Class clz = str.getClass(); \",\"如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。\"]},\"504\":{\"h\":\"Java反射API有几类？\",\"t\":[\"反射 API 用来生成 JVM 中的类、接口或则对象的信息。\",\"Class 类：反射的核心类，可以获取类的属性，方法等信息。\",\"Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。\",\"Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。\",\"Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法。\"]},\"505\":{\"h\":\"反射使用的步骤？\",\"t\":[\"获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可以任意调用类的方法。\",\"调用 Class 类中的方法，既就是反射的使用阶段。\",\"使用反射 API 来操作这些信息。\",\"具体可以看下面的例子：\",\"public class Apple { private int price; public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public static void main(String[] args) throws Exception{ //正常的调用 Apple apple = new Apple(); apple.setPrice(5); System.out.println(\\\"Apple Price:\\\" + apple.getPrice()); //使用反射调用 Class clz = Class.forName(\\\"com.chenshuyi.api.Apple\\\"); Method setPriceMethod = clz.getMethod(\\\"setPrice\\\", int.class); Constructor appleConstructor = clz.getConstructor(); Object appleObj = appleConstructor.newInstance(); setPriceMethod.invoke(appleObj, 14); Method getPriceMethod = clz.getMethod(\\\"getPrice\\\"); System.out.println(\\\"Apple Price:\\\" + getPriceMethod.invoke(appleObj)); } } \",\"从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：\",\"Apple Price:5 Apple Price:14 \",\"从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：\",\"获取类的 Class 对象实例\",\"Class clz = Class.forName(\\\"com.zhenai.api.Apple\\\"); \",\"根据 Class 对象实例获取 Constructor 对象\",\"Constructor appleConstructor = clz.getConstructor(); \",\"使用 Constructor 对象的 newInstance 方法获取反射类对象\",\"Object appleObj = appleConstructor.newInstance(); \",\"而如果要调用某一个方法，则需要经过下面的步骤：\",\"获取方法的 Method 对象\",\"Method setPriceMethod = clz.getMethod(\\\"setPrice\\\", int.class); \",\"利用 invoke 方法调用方法\",\"setPriceMethod.invoke(appleObj, 14); \"]},\"506\":{\"h\":\"为什么引入反射概念？反射机制的应用有哪些？\",\"t\":[\"我们来看一下 Oracle 官方文档中对反射的描述：\",\"从 Oracle 官方文档中可以看出，反射主要应用在以下几方面：\",\"反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。\",\"反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。\",\"测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。\",\"也就是说，Oracle 希望开发者将反射作为一个工具，用来帮助程序员实现本不可能实现的功能。\",\"举两个最常见使用反射的例子，来说明反射机制的强大之处：\",\"第一种：JDBC 的数据库的连接\",\"在JDBC 的操作中，如果要想进行数据库的连接，则必须按照以上的几步完成\",\"通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）；\",\"通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码；\",\"通过Connection 接口接收连接。\",\"public class ConnectionJDBC { /** * @param args */ //驱动程序就是之前在classpath中配置的JDBC的驱动程序的JAR 包中 public static final String DBDRIVER = \\\"com.mysql.jdbc.Driver\\\"; //连接地址是由各个数据库生产商单独提供的，所以需要单独记住 public static final String DBURL = \\\"jdbc:mysql://localhost:3306/test\\\"; //连接数据库的用户名 public static final String DBUSER = \\\"root\\\"; //连接数据库的密码 public static final String DBPASS = \\\"\\\"; public static void main(String[] args) throws Exception { Connection con = null; //表示数据库的连接对象 Class.forName(DBDRIVER); //1、使用CLASS 类加载驱动程序 ,反射机制的体现 con = DriverManager.getConnection(DBURL,DBUSER,DBPASS); //2、连接数据库 System.out.println(con); con.close(); // 3、关闭数据库 } \",\"第二种：Spring 框架的使用，最经典的就是xml的配置模式。\",\"Spring 通过 XML 配置模式装载 Bean 的过程：\",\"将程序内所有 XML 或 Properties 配置文件加载入内存中；\",\"Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息；\",\"使用反射机制，根据这个字符串获得某个类的Class实例；\",\"动态配置实例的属性。\",\"Spring这样做的好处是：\",\"不用每一次都要在代码里面去new或者做其他的事情；\",\"以后要改的话直接改配置文件，代码维护起来就很方便了；\",\"有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。\",\"模拟 Spring 加载 XML 配置文件：\",\"public class BeanFactory { private Map<String, Object> beanMap = new HashMap<String, Object>(); /** * bean工厂的初始化. * @param xml xml配置文件 */ public void init(String xml) { try { //读取指定的配置文件 SAXReader reader = new SAXReader(); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); //从class目录下获取指定的xml文件 InputStream ins = classLoader.getResourceAsStream(xml); Document doc = reader.read(ins); Element root = doc.getRootElement(); Element foo; //遍历bean for (Iterator i = root.elementIterator(\\\"bean\\\"); i.hasNext();) { foo = (Element) i.next(); //获取bean的属性id和class Attribute id = foo.attribute(\\\"id\\\"); Attribute cls = foo.attribute(\\\"class\\\"); //利用Java反射机制，通过class的名称获取Class对象 Class bean = Class.forName(cls.getText()); //获取对应class的信息 java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(bean); //获取其属性描述 java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); //设置值的方法 Method mSet = null; //创建一个对象 Object obj = bean.newInstance(); //遍历该bean的property属性 for (Iterator ite = foo.elementIterator(\\\"property\\\"); ite.hasNext();) { Element foo2 = (Element) ite.next(); //获取该property的name属性 Attribute name = foo2.attribute(\\\"name\\\"); String value = null; //获取该property的子元素value的值 for(Iterator ite1 = foo2.elementIterator(\\\"value\\\"); ite1.hasNext();) { Element node = (Element) ite1.next(); value = node.getText(); break; } for (int k = 0; k < pd.length; k++) { if (pd[k].getName().equalsIgnoreCase(name.getText())) { mSet = pd[k].getWriteMethod(); //利用Java的反射极致调用对象的某个set方法，并将值设置进去 mSet.invoke(obj, value); } } } //将对象放入beanMap中，其中key为id值，value为对象 beanMap.put(id.getText(), obj); } } catch (Exception e) { System.out.println(e.toString()); } } //other codes } \"]},\"507\":{\"h\":\"反射机制的原理是什么？\",\"t\":[\"Class actionClass=Class.forName(“MyClass”); Object action=actionClass.newInstance(); Method method = actionClass.getMethod(“myMethod”,null); method.invoke(action,null); \",\"反射获取类实例 Class.forName()，并没有将实现留给了java,而是交给了jvm去加载！主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader。最后，jvm又会回调 ClassLoader 进类加载！\",\"newInstance() 主要做了三件事：\",\"权限检测，如果不通过直接抛出异常；\",\"查找无参构造器，并将其缓存起来；\",\"调用具体方法的无参构造方法，生成实例并返回。\",\"获取Method对象，\",\"上面的Class对象是在加载类时由JVM构造的，JVM为每个类管理一个独一无二的Class对象，这份Class对象里维护着该类的所有Method，Field，Constructor的cache，这份cache也可以被称作根对象。\",\"每次getMethod获取到的Method对象都持有对根对象的引用，因为一些重量级的Method的成员变量（主要是MethodAccessor），我们不希望每次创建Method对象都要重新初始化，于是所有代表同一个方法的Method对象都共享着根对象的MethodAccessor，每一次创建都会调用根对象的copy方法复制一份：\",\" Method copy() { Method res = new Method(clazz, name, parameterTypes, returnType, exceptionTypes, modifiers, slot, signature, annotations, parameterAnnotations, annotationDefault); res.root = this; res.methodAccessor = methodAccessor; return res; } \",\"调用invoke()方法。调用invoke方法的流程如下：\",\"调用Method.invoke之后，会直接去调MethodAccessor.invoke。MethodAccessor就是上面提到的所有同名method共享的一个实例，由ReflectionFactory创建。\",\"创建机制采用了一种名为inflation的方式（JDK1.4之后）：如果该方法的累计调用次数<=15，会创建出NativeMethodAccessorImpl，它的实现就是直接调用native方法实现反射；如果该方法的累计调用次数>15，会由java代码创建出字节码组装而成的MethodAccessorImpl。（是否采用inflation和15这个数字都可以在jvm参数中调整） 以调用MyClass.myMethod(String s)为例，生成出的MethodAccessorImpl字节码翻译成Java代码大致如下：\",\"public class GeneratedMethodAccessor1 extends MethodAccessorImpl { public Object invoke(Object obj, Object[] args) throws Exception { try { MyClass target = (MyClass) obj; String arg0 = (String) args[0]; target.myMethod(arg0); } catch (Throwable t) { throw new InvocationTargetException(t); } } } \"]},\"508\":{\"h\":\"泛型\"},\"509\":{\"h\":\"Java中的泛型是什么 ?\",\"t\":[\"泛型是 JDK1.5 的一个新特性，**泛型就是将类型参数化，其在编译时才确定具体的参数。**这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。\"]},\"510\":{\"h\":\"使用泛型的好处是什么?\",\"t\":[\"远在 JDK 1.4 版本的时候，那时候是没有泛型的概念的，如果使用 Object 来实现通用、不同类型的处理，有这么两个缺点：\",\"每次使用时都需要强制转换成想要的类型\",\"在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全。\",\"如这个例子：\",\"List list = new ArrayList(); list.add(\\\"www.cnblogs.com\\\"); list.add(23); String name = (String)list.get(0); String number = (String)list.get(1); //ClassCastException \",\"上面的代码在运行时会发生强制类型转换异常。这是因为我们在存入的时候，第二个是一个 Integer 类型，但是取出来的时候却将其强制转换为 String 类型了。Sun 公司为了使 Java 语言更加安全，减少运行时异常的发生。于是在 JDK 1.5 之后推出了泛型的概念。\",\"根据《Java 编程思想》中的描述，泛型出现的动机在于：有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。\",\"使用泛型的好处有以下几点：\",\"类型安全\",\"泛型的主要目标是提高 Java 程序的类型安全\",\"编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常\",\"符合越早出错代价越小原则\",\"消除强制类型转换\",\"泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换\",\"所得即所需，这使得代码更加可读，并且减少了出错机会\",\"潜在的性能收益\",\"由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改\",\"所有工作都在编译器中完成\",\"编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已\"]},\"511\":{\"h\":\"Java泛型的原理是什么 ? 什么是类型擦除 ?\",\"t\":[\"泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除。Java中的泛型基本上都是在编译器这个层次来实现的，也就是说：**泛型只存在于编译阶段，而不存在于运行阶段。**在编译后的 class 文件中，是没有泛型这个概念的。\",\"类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数。\",\"例如：\",\"public class Caculate<T> { private T num; } \",\"我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。反编译一下这个 Caculate 类：\",\"public class Caculate{ public Caculate(){} private Object num; } \",\"发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。\",\"那么是不是所有的泛型类型都以 Object 进行擦除呢？大部分情况下，泛型类型都会以 Object 进行替换，而有一种情况则不是。那就是使用到了extends和super语法的有界类型，如：\",\"public class Caculate<T extends String> { private T num; } \",\"这种情况的泛型类型，num 会被替换为 String 而不再是 Object。这是一个类型限定的语法，它限定 T 是 String 或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为 String 或者 String 的子类，所以无论你限定 T 为什么类型，String 都是父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除。\",\"实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。\",\"实际上编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除成 Object 类型，当这些方法被调用后，编译器会额外插入一行 checkcast 指令用于强制类型转换。这一个过程就叫做『泛型翻译』。\"]},\"512\":{\"h\":\"什么是泛型中的限定通配符和非限定通配符 ?\",\"t\":[\"限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。\",\"非限定通配符 ？,可以用任意类型来替代。如List<?> 的意思是这个集合是一个可以持有任意类型的集合，它可以是List<A>，也可以是List<B>,或者List<C>等等。\"]},\"513\":{\"h\":\"List<? extends T>和List <? super T>之间有什么区别 ?\",\"t\":[\"这两个List的声明都是限定通配符的例子，List<? extends T>可以接受任何继承自T的类型的List，而List<? super T>可以接受任何T的父类构成的List。\"]},\"514\":{\"h\":\"可以把List 传递给一个接受List 参数的方法吗？\",\"t\":[\"不可以。真这样做的话会导致编译错误。因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储String。\",\"List<Object> objectList; List<String> stringList; objectList = stringList; //compilation error incompatible types \"]},\"515\":{\"h\":\"Array中可以用泛型吗?\",\"t\":[\"不可以。这也是为什么 Joshua Bloch 在 《Effective Java》一书中建议使用 List 来代替 Array，因为 List 可以提供编译期的类型安全保证，而 Array 却不能。\"]},\"516\":{\"h\":\"判断 与 是否相等？\",\"t\":[\"ArrayList<String> a = new ArrayList<String>(); ArrayList<Integer> b = new ArrayList<Integer>(); Class c1 = a.getClass(); Class c2 = b.getClass(); System.out.println(c1 == c2); \",\"输出的结果是 true。因为无论对于 ArrayList 还是 ArrayList，它们的 Class 类型都是一直的，都是 ArrayList.class。\",\"那它们声明时指定的 String 和 Integer 到底体现在哪里呢？\",\"**答案是体现在类编译的时候。**当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String 类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存入或取出错误的数据。\"]},\"517\":{\"h\":\"序列化\"},\"518\":{\"h\":\"Java序列化与反序列化是什么？\",\"t\":[\"Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：\",\"**序列化：**序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。\",\"而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。\",\"**反序列化：**客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。\"]},\"519\":{\"h\":\"为什么需要序列化与反序列化？\",\"t\":[\"简要描述：对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化\",\"深入描述：\",\"对象序列化可以实现分布式对象。\",\"主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。\",\"java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。\",\"可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的\\\"深复制\\\"，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。\",\"序列化可以将内存中的类写入文件或数据库中。\",\"比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。\",\"总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。\",\"对象、文件、数据，有许多不同的格式，很难统一传输和保存。\",\"序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。\"]},\"520\":{\"h\":\"序列化实现的方式有哪些？\",\"t\":[\"实现Serializable接口或者Externalizable接口。\"]},\"521\":{\"h\":\"接口\",\"t\":[\"类通过实现 java.io.Serializable 接口以启用其序列化功能。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。\",\"如以下例子：\",\"import java.io.Serializable; public class User implements Serializable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \\\"User{\\\" + \\\"name='\\\" + name + '}'; } } \",\"通过下面的代码进行序列化及反序列化：\",\"public class SerializableDemo { public static void main(String[] args) { //Initializes The Object User user = new User(); user.setName(\\\"cosen\\\"); System.out.println(user); //Write Obj to File try (FileOutputStream fos = new FileOutputStream(\\\"tempFile\\\"); ObjectOutputStream oos = new ObjectOutputStream( fos)) { oos.writeObject(user); } catch (IOException e) { e.printStackTrace(); } //Read Obj from File File file = new File(\\\"tempFile\\\"); try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) { User newUser = (User)ois.readObject(); System.out.println(newUser); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } //OutPut: //User{name='cosen'} //User{name='cosen'} \"]},\"522\":{\"h\":\"接口\",\"t\":[\"Externalizable继承自Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。\",\"当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。否则所有变量的值都会变成默认值。\",\"public class User implements Externalizable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(name); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { name = (String) in.readObject(); } @Override public String toString() { return \\\"User{\\\" + \\\"name='\\\" + name + '}'; } } \",\"通过下面的代码进行序列化及反序列化：\",\"public class ExternalizableDemo1 { public static void main(String[] args) { //Write Obj to file User user = new User(); user.setName(\\\"cosen\\\"); try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\\\"tempFile\\\"))){ oos.writeObject(user); } catch (IOException e) { e.printStackTrace(); } //Read Obj from file File file = new File(\\\"tempFile\\\"); try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))){ User newInstance = (User) ois.readObject(); //output System.out.println(newInstance); } catch (IOException | ClassNotFoundException e ) { e.printStackTrace(); } } } //OutPut: //User{name='cosen'} \"]},\"523\":{\"h\":\"两种序列化的对比\",\"t\":[\"实现Serializable接口\",\"实现Externalizable接口\",\"系统自动存储必要的信息\",\"程序员决定存储哪些信息\",\"Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持\",\"必须实现接口内的两个方法\",\"性能略差\",\"性能略好\"]},\"524\":{\"h\":\"什么是serialVersionUID？\",\"t\":[\"serialVersionUID 用来表明类的不同版本间的兼容性\",\"Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。\"]},\"525\":{\"h\":\"为什么还要显示指定serialVersionUID的值?\",\"t\":[\"如果不显示指定serialVersionUID, JVM在序列化时会根据属性自动生成一个serialVersionUID, 然后与属性一起序列化, 再进行持久化或网络传输. 在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID, 然后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID进行比较, 如果相同则反序列化成功, 否则报错.\",\"如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.\",\"在实际开发中, 不显示指定serialVersionUID的情况会导致什么问题? 如果我们的类写完后不再修改, 那当然不会有问题, 但这在实际开发中是不可能的, 我们的类会不断迭代, 一旦类被修改了, 那旧对象反序列化就会报错. 所以在实际开发中, 我们都会显示指定一个serialVersionUID, 值是多少无所谓, 只要不变就行。\"]},\"526\":{\"h\":\"serialVersionUID什么时候修改？\",\"t\":[\"《阿里巴巴Java开发手册》中有以下规定：\",\"想要深入了解的小伙伴，可以看这篇文章：https://juejin.cn/post/6844903746682486791\"]},\"527\":{\"h\":\"Java 序列化中如果有些字段不想进行序列化，怎么办？\",\"t\":[\"对于不想进行序列化的变量，使用 transient 关键字修饰。\",\"transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。transient 只能修饰变量，不能修饰类和方法。\"]},\"528\":{\"h\":\"静态变量会被序列化吗?\",\"t\":[\"不会。因为序列化是针对对象而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化.\",\"看到这个结论, 是不是有人会问, serialVersionUID也被static修饰, 为什么serialVersionUID会被序列化? 其实serialVersionUID属性并没有被序列化, JVM在序列化对象时会自动生成一个serialVersionUID, 然后将我们显示指定的serialVersionUID属性值赋给自动生成的serialVersionUID。\"]},\"529\":{\"h\":\"异常\"},\"530\":{\"h\":\"Error 和 Exception 区别是什么？\",\"t\":[\"Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。\",\"Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。\",\"Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。Exception 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。\",\"Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。\"]},\"531\":{\"h\":\"非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？\",\"t\":[\"非受检查异常：包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。例如：NullPointException(空指针)、NumberFormatException（字符串转换为数字）、IndexOutOfBoundsException(数组越界)、ClassCastException(类转换异常)、ArrayStoreException(数据存储异常，操作数组时类型不一致)等。\",\"受检查异常：是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException等。\",\"非受检查异常和受检查异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。\"]},\"532\":{\"h\":\"throw 和 throws 的区别是什么？\",\"t\":[\"Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。\",\"throws 关键字和 throw 关键字在使用上的几点区别如下：\",\"throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。\",\"throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。\",\"举例如下：\",\"throw 关键字：\",\"public static void main(String[] args) { String s = \\\"abc\\\"; if(s.equals(\\\"abc\\\")) { throw new NumberFormatException(); } else { System.out.println(s); } //function(); } \",\"throws 关键字：\",\"public static void function() throws NumberFormatException{ String s = \\\"abc\\\"; System.out.println(Double.parseDouble(s)); } public static void main(String[] args) { try { function(); } catch (NumberFormatException e) { System.err.println(\\\"非数据类型不能转换。\\\"); //e.printStackTrace(); } } \"]},\"533\":{\"h\":\"NoClassDefFoundError 和 ClassNotFoundException 区别？\",\"t\":[\"NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是编译后被删除了等原因导致。\",\"ClassNotFoundException 是一个受检查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。\"]},\"534\":{\"h\":\"Java常见异常有哪些？\",\"t\":[\"java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。\",\"java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.\",\"java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。\",\"java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。\",\"java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。\",\"java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。\",\"java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。\",\"java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。\",\"java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。\",\"java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。\",\"java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。\",\"java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。\",\"java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。\",\"java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。\",\"java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。\"]},\"535\":{\"h\":\"try-catch-finally 中哪个部分可以省略？\",\"t\":[\"catch 可以省略。更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。\",\"理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。\",\"至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。\"]},\"536\":{\"h\":\"try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\",\"t\":[\"会执行，在 return 前执行。\",\"在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。 代码示例1：\",\"public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; } return a; } //执行结果：30 \",\"代码示例2：\",\"public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; } finally { a = 40; //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40 return a; } } // 执行结果：40 \"]},\"537\":{\"h\":\"JVM 是如何处理异常的？\",\"t\":[\"在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。\",\"JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。 想要深入了解的小伙伴可以看这篇文章：https://www.cnblogs.com/qdhxhz/p/10765839.html\"]},\"538\":{\"h\":\"IO\"},\"539\":{\"h\":\"Java的IO 流分为几种？\",\"t\":[\"按照流的方向：输入流（inputStream）和输出流（outputStream）；\",\"按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）；\",\"按照处理数据的单位： 字节流和字符流。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。\"]},\"540\":{\"h\":\"字节流如何转为字符流？\",\"t\":[\"字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。\",\"字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象。\"]},\"541\":{\"h\":\"字符流与字节流的区别？\",\"t\":[\"读写的时候字节流是按字节读写，字符流按字符读写。\",\"字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。\",\"在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。\",\"只是读写文件，和文件内容无关时，一般选择字节流。\"]},\"542\":{\"h\":\"BIO、NIO、AIO的区别？\",\"t\":[\"BIO：同步并阻塞，在服务器中实现的模式为一个连接一个线程。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO一般适用于连接数目小且固定的架构，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。\",\"NIO：同步并非阻塞，在服务器中实现的模式为一个请求一个线程，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。\",\"AIO：异步并非阻塞，在服务器中实现的模式为一个有效请求一个线程，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。\"]},\"543\":{\"h\":\"Java IO都有哪些设计模式？\",\"t\":[\"使用了适配器模式和装饰器模式\",\"适配器模式：\",\"Reader reader = new INputStreamReader(inputStream); \",\"把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作\",\"类适配器：Adapter类（适配器）继承Adaptee类（源角色）实现Target接口（目标角色）\",\"对象适配器：Adapter类（适配器）持有Adaptee类（源角色）对象实例，实现Target接口（目标角色） \",\"装饰器模式：\",\"new BufferedInputStream(new FileInputStream(inputStream)); \",\"一种动态地往一个类中添加新的行为的设计模式。就功能而言，装饰器模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。\",\"ConcreteComponent（具体对象）和Decorator（抽象装饰器）实现相同的Conponent（接口）并且Decorator（抽象装饰器）里面持有Conponent（接口）对象，可以传递请求。\",\"ConcreteComponent（具体装饰器）覆盖Decorator（抽象装饰器）的方法并用super进行调用，传递请求。\"]},\"544\":{\"h\":\"参考\",\"t\":[\"https://juejin.cn/post/6844903741032759310\",\"https://blog.csdn.net/chenliguan/article/details/53888018\",\"https://segmentfault.com/a/1190000010162647\",\"https://juejin.cn/post/6856664924203663367\",\"http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/\",\"https://www.cnblogs.com/lixuwu/p/10829368.html\",\"https://juejin.cn/post/6844903848167866375\",\"https://blog.csdn.net/lanzhupi/article/details/109809836\",\"https://juejin.cn/post/6844903746682486791\",\"https://blog.csdn.net/ThinkWon/article/details/101681073\",\"https://simplesnippets.tech/exception-handling-in-java-part-1/\",\"https://www.cnblogs.com/xingyunblog/p/8688859.html\",\"https://mp.weixin.qq.com/s/p5qM2UJ1uIWyongfVpRbCg\",\"https://juejin.cn/post/6844903520856965128\"]},\"545\":{\"h\":\"ConcurrentHashMap 面试题\",\"t\":[\"Hash: ConcurrentHashMap\",\"本文汇总了常考的 ConcurrentHashMap 面试题，面试 ConcurrentHashMap，看这一篇就够了！为帮助大家高效复习，专门用”★ “表示面试中出现的频率，”★ “越多，代表越高频！\"]},\"546\":{\"h\":\"实现原理\",\"t\":[\"ConcurrentHashMap 的实现原理是什么？ ★★★★★\",\"ConcurrentHashMap 在 JDK1.7 和 JDK1.8 的实现方式是不同的。\",\"先来看下JDK1.7\",\"JDK1.7 中的 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。\",\"如下图所示，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。\",\"Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：\",\"Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。\",\"存放元素的 HashEntry，也是一个静态内部类，主要的组成如下：\",\"其中，用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next，保证了多线程环境下数据获取时的可见性！\",\"再来看下JDK1.8\",\"在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的Node数组+链表+红黑树结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用 CAS + synchronized实现更加细粒度的锁。\",\"将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。\",\"JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？★★★★★\",\"在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁一步步转换。\",\"减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。\"]},\"547\":{\"h\":\"存取\",\"t\":[\"ConcurrentHashMap 的 put 方法执行逻辑是什么？★★★★\",\"先来看JDK1.7\",\"先定位到相应的 Segment ，然后再进行 put 操作。\",\"源代码如下：\",\"首先会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。\",\"尝试自旋获取锁。\",\"如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。\",\"再来看JDK1.8\",\"大致可以分为以下步骤：\",\"根据 key 计算出 hash 值；\",\"判断是否需要进行初始化；\",\"定位到 Node，拿到首节点 f，判断首节点 f：\",\"如果为 null ，则通过 CAS 的方式尝试添加；\",\"如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容；\",\"如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；\",\"当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。\",\"源代码如下：\",\"ConcurrentHashMap 的 get 方法执行逻辑是什么？★★★★\",\"同样，先来看JDK1.7\",\"首先，根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。\",\"由于 HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。\",\"源代码如下：\",\"再来看JDK1.8\",\"大致可以分为以下步骤：\",\"根据 key 计算出 hash 值，判断数组是否为空；\",\"如果是首节点，就直接返回；\",\"如果是红黑树结构，就从红黑树里面查询；\",\"如果是链表结构，循环遍历判断。\",\"源代码如下：\",\"ConcurrentHashMap 的 get 方法是否要加锁，为什么？★★★\",\"get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。\",\"这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 效率高的原因之一。\",\"get 方法不需要加锁与 volatile 修饰的哈希桶数组有关吗？★★★\",\"没有关系。哈希桶数组table用 volatile 修饰主要是保证在数组扩容的时候保证可见性。\"]},\"548\":{\"h\":\"其他\",\"t\":[\"ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？★★★\",\"我们先来说value 为什么不能为 null。因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。\",\"而用于单线程状态的 HashMap 却可以用containsKey(key) 去判断到底是否包含了这个 null 。\",\"我们用反证法来推理：\",\"假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用ConcurrentHashMap.get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。\",\"假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 ConcurrentHashMap.containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回 false 。\",\"但是在我们调用 ConcurrentHashMap.get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap.put(key, null)的操作。那么我们调用containsKey方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。\",\"至于 ConcurrentHashMap 中的 key 为什么也不能为 null 的问题，源码就是这样写的，哈哈。如果面试官不满意，就回答因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的 key 存在。想要深入了解的小伙伴，可以看这篇文章这道面试题我真不知道面试官想要的回答是什么\",\"ConcurrentHashMap 的并发度是什么？★★\",\"并发度可以理解为程序运行时能够同时更新 ConccurentHashMap且不产生锁竞争的最大线程数。在JDK1.7中，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度，默认是16，这个值可以在构造函数中设置。\",\"如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。\",\"如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。\",\"在JDK1.8中，已经摒弃了Segment的概念，选择了Node数组+链表+红黑树结构，并发度大小依赖于数组的大小。\",\"ConcurrentHashMap 迭代器是强一致性还是弱一致性？★★\",\"与 HashMap 迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。\",\"ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。\",\"这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章：http://ifeve.com/ConcurrentHashMap-weakly-consistent/\"]},\"549\":{\"h\":\"JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★\",\"t\":[\"数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。\",\"保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock 。JDK1.8 采用CAS+synchronized 保证线程安全。\",\"锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。\",\"链表转化为红黑树：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储。\",\"查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)。\",\"ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？★★★★★\",\"ConcurrentHashMap 的效率要高于 Hashtable，因为 Hashtable 给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用分段锁实现线程安全，在 JDK1.8 中采用CAS+synchronized实现线程安全。\",\"具体说一下Hashtable的锁机制 ★★★★★\",\"Hashtable 是使用 synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！\",\"多线程下安全的操作 map还有其他方法吗？★★★\",\"还可以使用Collections.synchronizedMap方法，对方法进行加同步锁。\",\"如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！\"]},\"550\":{\"h\":\"最后\",\"t\":[\"本篇的 ConcurrentHashMap 就到这里了，觉得不错的话，不要忘记点个赞~\",\"小伙伴们想看什么类型的文章，欢迎留言或私信~\"]},\"551\":{\"h\":\"巨人的肩膀\",\"t\":[\"https://www.cnblogs.com/keeya/p/9632958.html\",\"http://www.justdojava.com/2019/12/18/java-collection-15.1/\"]},\"552\":{\"h\":\"HashMap面试小抄\",\"t\":[\"Hash 详解\",\"对于JAVA求职者来说，HashMap 可谓是重中之重，是面试必考点。然而 HashMap 的知识点非常多，复习起来花费精力很大，库森当年校招面试时就经历过这种痛苦，结合自己的面试经验，斗胆写一篇关于 HashMap 的面试专题文章，希望对小伙伴有所帮助!\"]},\"553\":{\"h\":\"1. 存储结构\",\"t\":[\"HashMap的底层数据结构是什么？\",\"在JDK1.7 和JDK1.8 中有所差别：\",\"在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。\",\"在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：\",\"当链表超过 8 且数据总量超过 64 才会转红黑树。\",\"将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。\",\"更深入的面试问题，\",\"为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?\",\"因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。\",\"因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。\",\"不用红黑树，用二叉查找树可以么?\",\"可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。\",\"为什么链表改为红黑树的阈值是 8?\",\"是因为泊松分布，我们来看作者在源码中的注释：\",\" Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http://en.wikipedia.org/wiki/Poisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) / factorial(k)). The first values are: 0: 0.60653066 1: 0.30326533 2: 0.07581633 3: 0.01263606 4: 0.00157952 5: 0.00015795 6: 0.00001316 7: 0.00000094 8: 0.00000006 more: less than 1 in ten million \",\"翻译过来大概的意思是：理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。\"]},\"554\":{\"h\":\"字段结构\",\"t\":[\"默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？\",\"回答这个问题前，我们来先看下HashMap的默认构造函数：\",\" int threshold; // 容纳键值对的最大值 final float loadFactor; // 负载因子 int modCount; int size; \",\"Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。\",\"默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：\",\"如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。\",\"相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\",\"我们来追溯下作者在源码中的注释（JDK1.7）：\",\"As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur. \",\"翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。\"]},\"555\":{\"h\":\"2. 索引计算\",\"t\":[\"HashMap 中 key 的存储索引是怎么计算的？\",\"首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&（length-1）计算得到存储的位置。看看源码的实现：\",\"// jdk1.7 方法一： static int hash(int h) { int h = hashSeed; if (0 != h && k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // 为第一步：取hashCode值 h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } 方法二： static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样 return h & (length-1); //第三步：取模运算 } \",\"// jdk1.8 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); /* h = key.hashCode() 为第一步：取hashCode值 h ^ (h >>> 16) 为第二步：高位参与运算 */ } \",\"这里的 Hash 算法本质上就是三步：取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。\",\"扩展出以下几个问题，\",\"JDK1.8 为什么要 hashcode 异或其右移十六位的值？\",\"因为在JDK 1.7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。 从速度、功效、质量来考虑，JDK1.8 优化了高位运算的算法，通过hashCode()的高16位异或低16位实现：(h = k.hashCode()) ^ (h >>> 16)。这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。\",\"为什么 hash 值要与length-1相与？\",\"把 hash 值对数组长度取模运算，模运算的消耗很大，没有位运算快。\",\"当 length 总是 2 的n次方时，h& (length-1) 运算等价于对length取模，也就是 h%length，但是 & 比 % 具有更高的效率。\",\"HashMap数组的长度为什么是 2 的幂次方？\",\"这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2 的 N 次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空间不浪费。我们来举个例子，看下图：\",\"当 length =15时，6 和 7 的结果一样，这样表示他们在 table 存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，4和5的结果也是一样，这样就会导致查询速度降低。\",\"如果我们进一步分析，还会发现空间浪费非常大，以 length=15 为例，在 1、3、5、7、9、11、13、15 这八处没有存放数据。因为hash值在与14（即 1110）进行&运算时，得到的结果最后一位永远都是0，即 0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的。\",\"补充数组容量计算的小奥秘\",\"HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。会取大于或等于这个数的 且最近的2次幂作为 table 数组的初始容量，使用tableSizeFor(int)方法，如 tableSizeFor(10) = 16（2 的 4 次幂），tableSizeFor(20) = 32（2 的 5 次幂），也就是说 table 数组的长度总是 2 的次幂。JDK1.8 源码如下：\",\"static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } /* 解释：位或( | ) int n = cap - 1; 让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。 */ \"]},\"556\":{\"h\":\"3. put方法\",\"t\":[\"HashMap 的put方法流程？\",\"简要流程如下：\",\"首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；\",\"如果数组是空的，则调用 resize 进行初始化；\",\"如果没有哈希冲突直接放在对应的数组下标里；\",\"如果冲突了，且 key 已经存在，就覆盖掉 value；\",\"如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；\",\"如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。\",\"详细分析，见JDK1.8HashMap 的 put 方法源码:\",\" public V put(K key, V value) { // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; // 步骤1：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤2：计算index，并对null做处理 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node<K,V> e; K k; // 步骤3：节点key存在，直接覆盖value if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 步骤4：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 步骤5：该链为链表 else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //链表长度大于8转换为红黑树进行处理 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // key已经存在直接覆盖value if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 步骤6：超过最大容量 就扩容 if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } // 第31行treeifyBin方法部分代码 final void treeifyBin(Node<K,V>[] tab, int hash) { int n, index; Node<K,V> e; // static final int MIN_TREEIFY_CAPACITY = 64; // 如果大于8但是数组容量小于64，就进行扩容 if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY) resize(); } \"]},\"557\":{\"h\":\"扩展的问题\",\"t\":[\"JDK1.7 和1.8 的put方法区别是什么？\",\"区别在两处：\",\"解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定条件，链表会转换为红黑树。\",\"链表插入元素时，JDK1.7 使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的，具体原因会在另一篇文章分析。\"]},\"558\":{\"h\":\"4. 扩容机制\",\"t\":[\"HashMap 的扩容方式？\",\"Hashmap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 Hashmap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。\",\"那扩容的具体步骤是什么？让我们看看源码。\",\"先来看下JDK1.7 的代码：\",\"void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } \",\"这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。\",\"void transfer(Entry[] newTable) { Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组 Entry<K,V> e = src[j]; //取得旧Entry数组的每个元素 if (e != null) { src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do { Entry<K,V> next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 } while (e != null); } } } \",\"newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。\"]},\"559\":{\"h\":\"JDK1.8的优化\",\"t\":[\"扩容在JDK1.8中有什么不一样？\",\"JDK1.8做了两处优化：\",\"resize 之后，元素的位置在原来的位置，或者原来的位置 +oldCap (原来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计算hash ，只需要看看原来的 hash 值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧妙，省去了重新计算 hash 值的时间。\",\"如下图所示，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。\",\"元素在重新计算 hash 之后，因为 n 变为 2倍，那么 n-1 的 mask 范围在高位多 1 bit(红色)，因此新的index就会发生这样的变化：\",\"JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8 不会倒置，使用尾插法。\",\"下图为 16扩充为 32 的 resize 示意图：\",\"感兴趣的小伙伴可以看下 JDK1.8 的 resize 源码：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\"，\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每个bucket都移动到新的buckets中 for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // 链表优化重hash的代码块 Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; // 原索引 if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引+oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket里 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } \"]},\"560\":{\"h\":\"5. 其他\",\"t\":[\"还知道哪些hash算法？\",\"Hash函数是指把一个大范围映射到一个小范围，目的往往是为了节省空间，使得数据容易保存。 比较出名的有MurmurHash、MD4、MD5等等。\",\"key 可以为 Null 吗?\",\"可以，key 为 Null 的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。\",\"一般用什么作为HashMap的key?\",\"一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。\",\"因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。\",\"因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。\",\"用可变类当 HashMap 的 key 有什么问题?\",\"hashcode 可能发生改变，导致 put 进去的值，无法 get 出。如下所示\",\"HashMap<List<String>, Object> changeMap = new HashMap<>(); List<String> list = new ArrayList<>(); list.add(\\\"hello\\\"); Object objectValue = new Object(); changeMap.put(list, objectValue); System.out.println(changeMap.get(list)); list.add(\\\"hello world\\\");//hashcode发生了改变 System.out.println(changeMap.get(list)); \",\"输出值如下\",\"java.lang.Object@74a14482 null \"]},\"561\":{\"h\":\"最后\",\"t\":[\"以上便是 HashMap 的核心面试题了，限于篇幅原因，本文并没有讲到 HashMap 的线程不安全问题，后面会专门写一篇文章讲解，敬请期待呦！\"]},\"562\":{\"h\":\"参考\",\"t\":[\"Java 8系列之重新认识HashMap\",\"HashMap的loadFactor为什么是0.75？\",\"HashMap扩容拾遗\",\"[HashMap](https://www.cnblogs.com/chenssy/p/3521565.html)\",\"HashMap面试指南\"]},\"563\":{\"h\":\"Hash 线程安全篇\",\"t\":[\"Hash: Thread\",\"我们都知道 HashMap 是线程不安全的，那 HashMap 为什么线程不安全？JDK1.8 还有这些问题吗？如何解决这些问题呢？本文将对该问题进行解密。\"]},\"564\":{\"h\":\"多线程下扩容死循环\",\"t\":[\"JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。\",\"下面看看多线程情况下， JDK1.7 扩容死循环问题的分析。\",\"新建一个更大尺寸的hash表，然后把数据从老的hash表中迁移到新的hash表中。重点看下transfer方法：\",\"假设HashMap初始化大小为2，hash算法就是用key mod 表的长度，在mod 2以后都冲突在table[1]这里了。负载因子是 1.5 (默认为 0.75 )，由公式 threshold=负载因子 * hash表长度可得，threshold=1.5 * 2 =3，size=3，而 size>=threshold 就要扩容，所以 hash表要 resize 成 4。\",\"未resize前的table如下图：\",\"正常的ReHash，得到的结果如下图所示：\",\"我们来看看多线程下的ReHash，假设现在有两个线程同时进行，线程1和线程2，两个线程都会新建新的数组，下面是resize 的过程。\",\"Step1:\",\"假设 线程1 在执行到Entry<K,V> next = e.next;之后，cpu 时间片用完了，被调度挂起，这时线程1的 e 指向 节点A，线程1的 next 指向节点B。\",\"线程2继续执行，\",\"Step2:\",\"线程 1 被调度回来执行。\",\"先是执行 newTalbe[i] = e;\",\"然后是e = next，导致了e指向了节点B，\",\"而下一次循环的next = e.next导致了next指向了节点A。\",\"Step3:\",\"线程1 接着工作。把节点B摘下来，放到newTable[i]的第一个，然后把e和next往下移。\",\"Step4: 出现环形链表\",\"e.next = newTable[i] 导致A.next 指向了 节点B，此时的B.next 已经指向了节点A，出现环形链表。\",\"如果get一个在此链表中不存在的key时，就会出现死循环了。如 get(11)时，就发生了死循环。\",\"分析见get方法的源码：\",\"for循环中的e = e.next永远不会为空，那么，如果get一个在这个链表中不存在的key时，就会出现死循环了。\"]},\"565\":{\"h\":\"多线程的put可能导致元素的丢失\",\"t\":[\"多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。\",\"我们来看下JDK 1.8 中 put 方法的部分源码，重点看黄色部分：\",\"我们来演示个例子。\",\"假设线程1和线程2同时执行put，线程1执行put(“1”, “A”)，线程2执行put(“5”, “B”)，hash算法就是用key mod 表的长度，表长度为4，在mod 4 以后都冲突在table[1]这里了。注：下面的例子，只演示了 #1 和#2代码的情况，其他代码也会出现类似情况。\",\"正常情况下，put完成后，table的状态应该是下图中的任意一个。\",\"下面来看看异常情况，两个线程都执行了#1处的if ((p = tab[i = (n - 1) & hash]) == null)这句代码。\",\"此时假设线程1 先执行#2处的tab[i] = newNode(hash, key, value, null);\",\"那么table会变成如下状态：\",\"紧接着线程2 执行tab[i] = newNode(hash, key, value, null);\",\"此时table会变成如下状态:\",\"这样一来，元素A就丢失了。\"]},\"566\":{\"h\":\"put和get并发时，可能导致get为null\",\"t\":[\"线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。\",\"我们来看下JDK 1.8 中 resize 方法的部分源码，重点看黄色部分：\",\"在代码#1位置，用新计算的容量new了一个新的hash表，#2将新创建的空hash表赋值给实例变量table。\",\"注意此时实例变量table是空的，如果此时另一个线程执行get，就会get出null。\"]},\"567\":{\"h\":\"巨人的肩膀\",\"t\":[\"http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html\",\"https://coolshell.cn/articles/9606.html\",\"https://juejin.cn/post/6844903554264596487\",\"https://juejin.cn/post/6844903796225605640\"]},\"568\":{\"h\":\"Collection\",\"t\":[\"Collection\"]},\"569\":{\"h\":\"1. 常见的集合有哪些？\",\"t\":[\"Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。\",\"注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口。\",\"Java集合框架图如下：\",\"图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。\",\"Map代表的是存储key-value对的集合，可根据元素的key来访问value。\",\"上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。\"]},\"570\":{\"h\":\"2. 线程安全的集合有哪些？线程不安全的呢？\",\"t\":[\"线程安全的：\",\"Hashtable：比HashMap多了个线程安全。\",\"ConcurrentHashMap:是一种高效但是线程安全的集合。\",\"Vector：比Arraylist多了个同步化机制。\",\"Stack：栈，也是线程安全的，继承于Vector。\",\"线性不安全的：\",\"HashMap\",\"Arraylist\",\"LinkedList\",\"HashSet\",\"TreeSet\",\"TreeMap\"]},\"571\":{\"h\":\"3. Arraylist与 LinkedList 异同点？\",\"t\":[\"是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\",\"底层数据结构： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；\",\"插入和删除是否受元素位置的影响：ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。\",\"是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\",\"内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。\"]},\"572\":{\"h\":\"4. ArrayList 与 Vector 区别？\",\"t\":[\"Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。\",\"ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。\"]},\"573\":{\"h\":\"5. 说一说ArrayList 的扩容机制？\",\"t\":[\"ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是原容量的1.5倍。\",\"以JDK1.8为例说明:\",\"public boolean add(E e) { //判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾 ensureCapacityInternal(size + 1); // Increments modCount!! //将e添加到数组末尾 elementData[size++] = e; return true; } // 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private static int calculateCapacity(Object[] elementData, int minCapacity) { //如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力>ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容 if (minCapacity - elementData.length > 0) grow(minCapacity); } private void grow(int minCapacity) { // 获取elementData数组的内存空间长度 int oldCapacity = elementData.length; // 扩容至原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity >> 1); //校验容量是否够 if (newCapacity - minCapacity < 0) newCapacity = minCapacity; //若预设值大于默认的最大值，检查是否溢出 if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // 调用Arrays.copyOf方法将elementData数组指向新的内存空间 //并将elementData的数据复制到新的内存空间 elementData = Arrays.copyOf(elementData, newCapacity); } \"]},\"574\":{\"h\":\"6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？\",\"t\":[\"Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。\",\"Array 大小是固定的，ArrayList 的大小是动态变化的。\",\"ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。\"]},\"575\":{\"h\":\"7. HashMap的底层数据结构是什么？\",\"t\":[\"在JDK1.7 和JDK1.8 中有所差别：\",\"在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。\",\"在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：\",\"当链表超过 8 且数据总量超过 64 才会转红黑树。\",\"将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。\"]},\"576\":{\"h\":\"8. 解决hash冲突的办法有哪些？HashMap用的哪种？\",\"t\":[\"解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 。\",\"开放定址法也称为再散列法，基本思想就是，如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的节点上做标记，而不能真正删除节点。\",\"再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当R1=H1(key1)发生冲突时，再计算R2=H2(key1)，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。\",\"链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。\",\"建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。\"]},\"577\":{\"h\":\"9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?\",\"t\":[\"因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。\",\"因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。\"]},\"578\":{\"h\":\"10. HashMap默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？\",\"t\":[\"回答这个问题前，我们来先看下HashMap的默认构造函数：\",\" int threshold; // 容纳键值对的最大值 final float loadFactor; // 负载因子 int modCount; int size; \",\"Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。\",\"默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：\",\"如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。\",\"相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\",\"我们来追溯下作者在源码中的注释（JDK1.7）：\",\"As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur. \",\"翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。\"]},\"579\":{\"h\":\"11. HashMap 中 key 的存储索引是怎么计算的？\",\"t\":[\"首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&（length-1）计算得到存储的位置。看看源码的实现：\",\"// jdk1.7 方法一： static int hash(int h) { int h = hashSeed; if (0 != h && k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // 为第一步：取hashCode值 h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } 方法二： static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样 return h & (length-1); //第三步：取模运算 } \",\"// jdk1.8 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); /* h = key.hashCode() 为第一步：取hashCode值 h ^ (h >>> 16) 为第二步：高位参与运算 */ } \",\"这里的 Hash 算法本质上就是三步：取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。\"]},\"580\":{\"h\":\"12. HashMap 的put方法流程？\",\"t\":[\"简要流程如下：\",\"首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；\",\"如果数组是空的，则调用 resize 进行初始化；\",\"如果没有哈希冲突直接放在对应的数组下标里；\",\"如果冲突了，且 key 已经存在，就覆盖掉 value；\",\"如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；\",\"如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。\"]},\"581\":{\"h\":\"13. HashMap 的扩容方式？\",\"t\":[\"HashMap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 HashMap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。\",\"那扩容的具体步骤是什么？让我们看看源码。\",\"先来看下JDK1.7 的代码：\",\"void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } \",\"这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。\",\"void transfer(Entry[] newTable) { Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组 Entry<K,V> e = src[j]; //取得旧Entry数组的每个元素 if (e != null) { src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do { Entry<K,V> next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 } while (e != null); } } } \",\"newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。\"]},\"582\":{\"h\":\"14. 一般用什么作为HashMap的key?\",\"t\":[\"一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。\",\"因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。\",\"因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。\"]},\"583\":{\"h\":\"15. HashMap为什么线程不安全？\",\"t\":[\"多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。\",\"多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。\",\"put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。\",\"具体分析可见我的这篇文章：面试官：HashMap 为什么线程不安全？\"]},\"584\":{\"h\":\"16. ConcurrentHashMap 的实现原理是什么？\",\"t\":[\"ConcurrentHashMap 在 JDK1.7 和 JDK1.8 的实现方式是不同的。\",\"先来看下JDK1.7\",\"JDK1.7中的ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。\",\"其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。\",\"首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。\",\"再来看下JDK1.8\",\"在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的数组+链表+红黑树结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加低粒度的锁。\",\"将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。\"]},\"585\":{\"h\":\"17. ConcurrentHashMap 的 put 方法执行逻辑是什么？\",\"t\":[\"先来看JDK1.7\",\"首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。\",\"获取到锁后：\",\"将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。\",\"遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。\",\"不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。\",\"释放 Segment 的锁。\",\"再来看JDK1.8\",\"大致可以分为以下步骤：\",\"根据 key 计算出 hash值。\",\"判断是否需要进行初始化。\",\"定位到 Node，拿到首节点 f，判断首节点 f： \",\"如果为 null ，则通过cas的方式尝试添加。\",\"如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容。\",\"如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。\",\"当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。\",\"源码分析可看这篇文章：面试 ConcurrentHashMap ，看这一篇就够了！\"]},\"586\":{\"h\":\"18. ConcurrentHashMap 的 get 方法是否要加锁，为什么？\",\"t\":[\"get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。\",\"这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 安全效率高的原因之一。\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; //可以看到这些都用了volatile修饰 volatile V val; volatile Node<K,V> next; } \"]},\"587\":{\"h\":\"19. get方法不需要加锁与volatile修饰的哈希桶有关吗？\",\"t\":[\"没有关系。哈希桶table用volatile修饰主要是保证在数组扩容的时候保证可见性。\",\"static final class Segment<K,V> extends ReentrantLock implements Serializable { // 存放数据的桶 transient volatile HashEntry<K,V>[] table; \"]},\"588\":{\"h\":\"20. ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？\",\"t\":[\"我们先来说value 为什么不能为 null ，因为ConcurrentHashMap 是用于多线程的 ，如果map.get(key)得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。\",\"而用于单线程状态的HashMap却可以用containsKey(key) 去判断到底是否包含了这个 null 。\",\"我们用反证法来推理：\",\"假设ConcurrentHashMap 允许存放值为 null 的value，这时有A、B两个线程，线程A调用ConcurrentHashMap .get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。\",\"假设此时，返回为 null 的真实情况是没有找到对应的key。那么，我们可以用ConcurrentHashMap .containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回false。\",\"但是在我们调用ConcurrentHashMap .get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap .put(key, null )的操作。那么我们调用containsKey方法返回的就是true了，这就与我们的假设的真实情况不符合了，这就有了二义性。\",\"至于ConcurrentHashMap 中的key为什么也不能为 null 的问题，源码就是这样写的，哈哈。如果面试官不满意，就回答因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的key存在。想要深入了解的小伙伴，可以看这篇文章这道面试题我真不知道面试官想要的回答是什么\"]},\"589\":{\"h\":\"21. ConcurrentHashMap 的并发度是多少？\",\"t\":[\"在JDK1.7中，并发度默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。\"]},\"590\":{\"h\":\"22. ConcurrentHashMap 迭代器是强一致性还是弱一致性？\",\"t\":[\"与HashMap迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。\",\"ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。\",\"这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章[为什么ConcurrentHashMap 是弱一致的](http://ifeve.com/ConcurrentHashMap -weakly-consistent/)\"]},\"591\":{\"h\":\"23. JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？\",\"t\":[\"数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。\",\"保证线程安全机制：JDK1.7采用Segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8 采用CAS+Synchronized保证线程安全。\",\"锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。\",\"链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。\",\"查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。\"]},\"592\":{\"h\":\"24. ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？\",\"t\":[\"ConcurrentHashMap 的效率要高于Hashtable，因为Hashtable给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在JDK1.7中采用分段锁实现线程安全，在JDK1.8 中采用CAS+Synchronized实现线程安全。\"]},\"593\":{\"h\":\"25. 说一下Hashtable的锁机制 ?\",\"t\":[\"Hashtable是使用Synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！\"]},\"594\":{\"h\":\"26. 多线程下安全的操作 map还有其他方法吗？\",\"t\":[\"还可以使用Collections.synchronizedMap方法，对方法进行加同步锁\",\"private static class SynchronizedMap<K,V> implements Map<K,V>, Serializable { private static final long serialVersionUID = 1978198479659022715L; private final Map<K,V> m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map<K,V> m) { this.m = Objects.requireNon null (m); mutex = this; } SynchronizedMap(Map<K,V> m, Object mutex) { this.m = m; this.mutex = mutex; } // 省略部分代码 } \",\"如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！\"]},\"595\":{\"h\":\"27. HashSet 和 HashMap 区别?\",\"t\":[\"补充HashSet的实现：HashSet的底层其实就是HashMap，只不过我们HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存。如源码所示：\",\"public boolean add(E e) { return map.put(e, PRESENT)==null;// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值 } \",\"由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性。\"]},\"596\":{\"h\":\"28. Collection框架中实现比较要怎么做？\",\"t\":[\"第一种，实体类实现Comparable接口，并实现 compareTo(T t) 方法，称为内部比较器。\",\"第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)方法。\"]},\"597\":{\"h\":\"29. Iterator 和 ListIterator 有什么区别？\",\"t\":[\"遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。\",\"使用ListIterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。\",\"添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。\",\"修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。\",\"索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。\"]},\"598\":{\"h\":\"30. 讲一讲快速失败(fail-fast)和安全失败(fail-safe)\",\"t\":[\"快速失败（fail—fast）\",\"在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。\",\"原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。\",\"注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。\",\"场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如HashMap、ArrayList 这些集合类。\",\"安全失败（fail—safe）\",\"采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。\",\"原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。\",\"缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。\",\"场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如：ConcurrentHashMap。\"]},\"599\":{\"h\":\"巨人的肩膀\",\"t\":[\"https://juejin.cn/post/6844903966103306247\",\"https://www.javazhiyin.com/71751.html\",\"https://blog.csdn.net/qq_31780525/article/details/77431970\",\"https://www.cnblogs.com/zeroingToOne/p/9522814.html\"]},\"600\":{\"h\":\"AQS 锁\",\"t\":[\"AQS 锁 详解\"]},\"601\":{\"h\":\"简介\",\"t\":[\"Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。\",\"在AQS中的锁类型有两种：分别是**「Exclusive(独占锁)**「和」**Share(共享锁)」**。\",\"「独占锁」就是「每次都只有一个线程运行」，例如ReentrantLock。\",\"「共享锁」就是「同时可以多个线程运行」，如Semaphore、CountDownLatch、ReentrantReadWriteLock。\"]},\"602\":{\"h\":\"原理\",\"t\":[\"AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，则调用LockSupport().park()方法将Node中的线程状态改为WAITING，等待被唤醒或被中断 ，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。\",\"CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。\",\"主要原理图如下：\",\"AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。\",\"在FIFO队列中，「头节点占有锁」，也就是头节点才是锁的持有者，尾指针指向队列的最后一个等待线程节点，除了头节点和尾节点，节点之间都有**「前驱指针」和「后继指针」**\",\"在AQS中维护了一个**「共享变量state」**，标识当前的资源是否被线程持有，多线程竞争的时候，会去判断state是否为0，尝试的去把state修改为1\"]},\"603\":{\"h\":\"1. AQS数据结构\",\"t\":[\"AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。\",\"解释一下几个方法和属性值的含义：\",\"方法和属性值\",\"含义\",\"waitStatus\",\"当前节点在队列中的状态\",\"thread\",\"表示处于该节点的线程\",\"prev\",\"前驱指针\",\"predecessor\",\"返回前驱节点，没有的话抛出npe\",\"nextWaiter\",\"指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）\",\"next\",\"后继指针\",\"线程两种锁的模式：\",\"模式\",\"含义\",\"SHARED\",\"表示线程以共享的模式等待锁\",\"EXCLUSIVE\",\"表示线程正在以独占的方式等待锁\",\"waitStatus有下面几个枚举值：\",\"枚举\",\"含义\",\"0\",\"当一个Node被初始化的时候的默认值\",\"CANCELLED\",\"为1，表示线程获取锁的请求已经取消了\",\"CONDITION\",\"为-2，表示节点在等待队列中，节点线程等待唤醒\",\"PROPAGATE\",\"为-3，当前线程处在SHARED情况下，该字段才会使用\",\"SIGNAL\",\"为-1，表示线程已经准备好了，就等资源释放了\"]},\"604\":{\"h\":\"2. 同步状态State\",\"t\":[\"了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private volatile int state; \",\"下面提供了几个访问这个字段的方法：\",\"方法名\",\"描述\",\"protected final int getState()\",\"获取State的值\",\"protected final void setState(int newState)\",\"设置State的值\",\"protected final boolean compareAndSetState(int expect, int update)\",\"使用CAS方式更新State\",\"这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。\"]},\"605\":{\"h\":\"3. 线程加入等待队列\",\"t\":[\"ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。\",\"在非公平锁中，有一段这样的代码：\",\"// java.util.concurrent.locks.ReentrantLock static final class NonfairSync extends Sync { ... final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } ... } \",\"看一下这个Acquire是怎么写的：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } \",\"首先会调用 tryAcquire(arg) 方法，这个方法是需要同步组件自己实现的。 该方法保证线程安全的获取同步状态， tryAcquire(arg) 返回 true 表示获取成功也就正常退出了。否则会 构造同步节点（独占式Node.EXCLUSIVE）并通过 addWaiter(Node mode) 方法将加入到同步队列的尾部，最后调用acquireQueued(final Node node, int arg) 通过 “死循环”的方式获取同步状态。如果获取不到则阻塞节点中对应的线程，而被阻塞后的唤醒只能依靠前驱节点出队或者阻塞线程被中断来实现。\",\"再看一下tryAcquire方法：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } \",\"可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。\"]},\"606\":{\"h\":\"加入队列的时机\",\"t\":[\"当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。\"]},\"607\":{\"h\":\"如 何加入队列\",\"t\":[\"获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } private final boolean compareAndSetTail(Node expect, Node update) { return unsafe.compareAndSwapObject(this, tailOffset, expect, update); } \",\"主要的流程如下：\",\"通过当前的线程和锁模式新建一个节点。\",\"Pred指针指向尾节点Tail。\",\"将New中Node的Prev指针指向Pred。\",\"通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。\",\"当出现锁竞争以及释放锁的时候，AQS同步队列中的节点会发生变化，首先看一下添加节点的场景。\",\"这里会涉及到两个变化\",\"新的线程封装成Node节点追加到同步队列中，设置prev节点以及修改当前节点的前置节点的next节点指向自己\",\"通过CAS讲tail重新指向新的尾部节点\"]},\"608\":{\"h\":\"4. 等待队列中线程出队列时机\",\"t\":[\"前驱是头结点，就获取到了同步状态。\",\"head节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点，节点的变化过程如下 这个过程也是涉及到两个变化\",\"修改head节点指向下一个获得锁的节点\",\"新的获得锁的节点，将prev的指针指向null\",\"这里有一个小的变化，就是设置head节点不需要用CAS，原因是设置head节点是由获得锁的线程来完成的，而同步锁只能由一个线程获得，所以不需要CAS保证，只需要把head节点设置为原首节点的后继节点，并且断开原head节点的next引用即可\"]},\"609\":{\"h\":\"代码设计\",\"t\":[\"AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。\"]},\"610\":{\"h\":\"独占式同步状态获取\",\"t\":[\"acquire(int arg)方法为AQS提供的模板方法，该方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：\",\" public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } \",\"各个方法定义如下：\",\"tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。\",\"addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。\",\"acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。\",\"selfInterrupt：产生一个中断。\"]},\"611\":{\"h\":\"独占式同步状态释放\",\"t\":[\"当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS提供了release(int arg)方法释放同步状态：\",\" public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } \",\"该方法同样是先调用自定义同步器自定义的tryRelease(int arg)方法来释放同步状态，释放成功后，会调用unparkSuccessor(Node node)方法唤醒后继节点（如何唤醒LZ后面介绍）。 这里稍微总结下：\",\"在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的对尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。\"]},\"612\":{\"h\":\"共享式同步状态获取\",\"t\":[\"AQS提供acquireShared(int arg)方法共享式获取同步状态：\",\" public final void acquireShared(int arg) { if (tryAcquireShared(arg) < 0) //获取失败，自旋获取同步状态 doAcquireShared(arg); } \",\"从上面程序可以看出，方法首先是调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态，共享式获取同步状态的标志是返回 >= 0 的值表示获取成功。\",\"获取同步状态如下：\",\" private void doAcquireShared(int arg) { /共享式节点 final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { //前驱节点 final Node p = node.predecessor(); //如果其前驱节点，获取同步状态 if (p == head) { //尝试获取同步 int r = tryAcquireShared(arg); if (r >= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } \",\"tryAcquireShared(int arg)方法尝试获取同步状态，返回值为int，当其 >= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。 acquireShared(int arg)方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：acquireSharedInterruptibly(int arg)、tryAcquireSharedNanos(int arg,long nanos)，这里就不做解释了。\"]},\"613\":{\"h\":\"共享式同步状态释放\",\"t\":[\"获取同步状态后，需要调用release(int arg)方法释放同步状态，方法如下：\",\" public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } \",\"因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。\"]},\"614\":{\"h\":\"疑问\",\"t\":[\"Q：某个线程获取锁失败的后续流程是什么呢？\",\"A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。\",\"Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\",\"A：是CLH变体的FIFO双端队列。\",\"Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？\",\"A：前驱结点是头结点，并且当前线程获取锁成功\",\"Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？\",\"A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放\",\"Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？\",\"A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。\",\"那AQS只能用来实现独占且公平锁吗？显然不是，AQS又是如何实现非公平锁和共享锁的呢？ 其实AQS无论用来实现什么锁，这些锁本质的区别就是在于获取共享资源访问权的方式不同 ，而独占且公平的锁很明显获取访问权的方式是通过FIFO队列的顺序（即请求访问共享资源的顺序），而共享锁也是一样，只是可以获取访问权的线程数多了些；那么非公平锁是如何实现的呢？其实也很简单，就是舍弃队列的FIFO特性，只要持有共享资源的线程释放了锁，所有的在同步队列中的线程都会通过CAS操作去竞争锁；\"]},\"615\":{\"h\":\"ReentrantLock\",\"t\":[\"加锁：\",\"通过ReentrantLock的加锁方法Lock进行加锁操作。\",\"会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。\",\"AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。\",\"tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。\",\"解锁：\",\"通过ReentrantLock的解锁方法Unlock进行解锁。\",\"Unlock会调用内部类Sync的Release方法，该方法继承于AQS。\",\"Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。\",\"释放成功后，所有处理由AQS框架完成，与自定义同步器无关。\",\"通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。\"]},\"616\":{\"h\":\"非公平锁\",\"t\":[\"非公平锁则没有这些规则，是抢占模式，每来一个人不会去管队列如何，直接尝试获取锁。\",\"static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; final void lock() { // 不管是否有线程在AQS的FIFO队列中排队等待，直接执行一次CAS操作竞争锁 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // CAS失败，则准备进入FIFO队列，在进入队列之前，还有一次机会， // AQS的acquire方法通过调用tryAcquire再给当前线程一次机会，此时再失败则进入队列等待 acquire(1); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } } \",\"非公平模式下每个线程都有2次机会(CAS操作)插队竞争锁，2次均失败之后才会进入FIFO队列等待，然后公平锁模式下，线程是不允许插队竞争锁的， 只要FIFO队列中有线程在等待，则当前竞争锁的线程必须进入队列等待，这就是为什么公平锁的吞吐比非公平锁低的原因。\",\"重要的区别是在尝试获取锁时tryAcquire(arg)，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：\",\" final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { //没有 !hasQueuedPredecessors() 判断 if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) // overflow throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } return false; } \"]},\"617\":{\"h\":\"公平锁\",\"t\":[\"首先看下获取锁的过程：\",\" public void lock() { sync.lock(); } \",\"可以看到是使用 sync的方法，而这个方法是一个抽象方法，具体是由其子类(FairSync)来实现的，以下是公平锁的实现:\",\" final void lock() { acquire(1); } //AbstractQueuedSynchronizer 中的 acquire() public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } \",\"第一步是尝试获取锁(tryAcquire(arg)),这个也是由其子类实现：\",\" protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } return false; } } \",\"首先会判断 AQS 中的 state 是否等于 0，0 表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。\",\"注意:尝试之前会利用 hasQueuedPredecessors() 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(这是公平锁特有的情况)。\",\"如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(setExclusiveOwnerThread(current))。\",\"如果 state 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(ReentrantLock 支持重入)，是则需要将 state + 1，并将值更新。\",\"写入队列\",\"如果 tryAcquire(arg) 获取锁失败，则需要用 addWaiter(Node.EXCLUSIVE) 将当前线程写入队列中。\",\"写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))。\",\"释放锁\",\"公平锁和非公平锁的释放流程都是一样的：\",\"protected final boolean tryRelease(int releases) { int c = getState() - releases; // 非持有锁的线程调用此方法直接抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 状态为0，表示锁完全释放，此时需清除AOS中的线程记录 if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } \",\"首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 state 减到 0 才认为完全释放锁。\",\"释放之后需要调用 unparkSuccessor(h) 来唤醒被挂起的线程。\"]},\"618\":{\"h\":\"参考\",\"t\":[\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\",\"https://xie.infoq.cn/article/7e9a2689d223acaab1636f93d\",\"http://cmsblogs.com/?hmsr=toutiao.io&p=2197&utm_medium=toutiao.io&utm_source=toutiao.io\",\"https://blog.csdn.net/zl1zl2zl3/article/details/82215563\",\"https://youendless.com/post/reentrantlock/\"]},\"619\":{\"h\":\"多线程总结\",\"t\":[\"Thread: 多线程总结\"]},\"620\":{\"h\":\"1. 线程和进程有什么区别？\",\"t\":[\"线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。\",\"根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位\",\"资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。\",\"包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。\",\"内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的\",\"影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。\",\"执行过程：每个独立的进程有程序运行的入口. 顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行\"]},\"621\":{\"h\":\"2. 创建线程的三种方式的对比？\",\"t\":[\"1）采用实现Runnable. Callable接口的方式创建多线程。\",\"优势是：\",\"线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。\",\"在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU. 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。\",\"劣势是：\",\"编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。\",\"2）使用继承Thread类的方式创建多线程\",\"优势是：\",\"编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。\",\"劣势是：\",\"线程类已经继承了Thread类，所以不能再继承其他父类。\",\"3）Runnable和Callable的区别\",\"Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。\",\"Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。\",\"Call方法可以抛出异常，run方法不可以。\",\"运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。\"]},\"622\":{\"h\":\"3. 为什么要使用多线程呢?\",\"t\":[\"从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。\",\"从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。\",\"从计算机底层来说：\",\"单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。\",\"多核时代:多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。\"]},\"623\":{\"h\":\"4. 线程的状态流转\",\"t\":[\"线程的生命周期及五种基本状态：\",\"Java线程具有五中基本状态\",\"1）新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();\",\"2）就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；\",\"3）运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\",\"4）阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\",\"1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\",\"2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\",\"3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时. join()等待线程终止或者超时. 或者I/O处理完毕时，线程重新转入就绪状态。\",\"5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\"]},\"624\":{\"h\":\"5. 什么是线程死锁?如何避免死锁?\"},\"625\":{\"h\":\"死锁\",\"t\":[\"多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 \"]},\"626\":{\"h\":\"死锁必须具备以下四个条件：\",\"t\":[\"互斥条件：该资源任意一个时刻只由一个线程占用。\",\"请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\",\"不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\",\"循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\"]},\"627\":{\"h\":\"如何避免线程死锁?\",\"t\":[\"只要破坏产生死锁的四个条件中的其中一个就可以了\",\"破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）\",\"破坏请求与保持条件 一次性申请所有的资源。\",\"破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\",\"破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\",\"锁排序法：（必须回答出来的点） 指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？ 通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。\",\"使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁\"]},\"628\":{\"h\":\"6. 常见的对比\"},\"629\":{\"h\":\"Runnable VS Callable\",\"t\":[\"Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Callable 接口可以返回结果或抛出检查异常\",\"Runnable 接口不会返回结果或抛出检查异常，\",\"如果任务不需要返回结果或抛出异常推荐使用 Runnable接口，这样代码看起来会更加简洁\",\"工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））\"]},\"630\":{\"h\":\"shutdown() VS shutdownNow()\",\"t\":[\"shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。\",\"shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终\"]},\"631\":{\"h\":\"isTerminated() VS isShutdown()\",\"t\":[\"isShutDown 当调用 shutdown() 方法后返回为 true。\",\"isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true\"]},\"632\":{\"h\":\"7. sleep() 方法和 wait() 方法区别和共同点?\"},\"633\":{\"h\":\"区别\",\"t\":[\"sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。\",\"wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。\",\"sleep 方法没有释放锁，而 wait 方法释放了锁 。\",\"sleep 通常被用于暂停执行Wait 通常被用于线程间交互/通信\",\"sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法\"]},\"634\":{\"h\":\"相同\",\"t\":[\"两者都可以暂停线程的执行。\"]},\"635\":{\"h\":\"8.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法\",\"t\":[\"new 一个 Thread，线程进入了新建状态; 调用start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，（调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。）这是真正的多线程工作。\",\"直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。\"]},\"636\":{\"h\":\"9. Thread类中的yield方法有什么作用？\",\"t\":[\"Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。\"]},\"637\":{\"h\":\"10. 谈谈volatile的使用及其原理\",\"t\":[\"volatile的两层语义：\",\"volatile保证变量对所有线程的可见性：当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。\",\"jdk1.5以后volatile完全避免了指令重排优化，实现了有序性。\",\"volatile的原理:\",\"获取JIT（即时Java编译器，把字节码解释为机器语言发送给处理器）的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也是为什么JDK1.5以后可以使用双锁检测实现单例模式。\",\"lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主内存中，并且使得其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。\",\"具体原理见这篇文章：https://www.javazhiyin.com/61019.html\"]},\"638\":{\"h\":\"11. 如何创建线程实例并运行?\",\"t\":[\"Thread 类本质上是实现 Runnable 接口的一个实例，代表一个线程的实例。创建线程实例一般有两种方法：\",\"创建 Thread 的子类并重写 run()\",\"复制代码\",\"public class MyThread extends Thread { @Override public void run(){ System.out.println(\\\"MyThread running\\\"); } } \",\"run() 方在调用 start() 方法后被执行，而且一旦线程启动后 start() 方法后就会立即返回，而不是等到 run() 方法执行完毕后再返回。\",\"MyThread myThread = new MyThread(); myThread.start(); \",\"实现 Runnable 接口\",\"public class MyRunnable implements Runnable{ @Override public void run(){ System.out.println(\\\"MyRunnable running\\\"); } } \",\"在新建类时实现 Runnable 接口，然后在 Thread 类的构造函数中传入 MyRunnable 的实例对象，最后执行 start() 方法即可；\",\"Thread thread = new Thread(new MyRunnable()); thread.start(); \"]},\"639\":{\"h\":\"12. 线程阻塞的三种情况\",\"t\":[\"当线程因为某种原因放弃 CPU 使用权后，即让出了 CPU 时间片，暂时就会停止运行，知道线程进入可运行状态（Runnable），才有机会再次获得 CPU 时间片转入 RUNNING 状态。一般来讲，阻塞的情况可以分为如下三种：\",\"等待阻塞（Object.wait -> 等待队列）\",\"RUNNING 状态的线程执行 Object.wait() 方法后，JVM 会将线程放入等待序列（waitting queue）；\",\"同步阻塞（lock -> 锁池）\",\"RUNNING 状态的线程在获取对象的同步锁时，若该 同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中；\",\"其他阻塞（sleep/join）\",\"RUNNING 状态的线程执行 Thread.sleep(long ms) 或 Thread.join() 方法，或发出 I/O 请求时，JVM 会将该线程置为阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时. 或者 I/O 处理完毕时，线程重新转入可运行状态（RUNNABLE）；\"]},\"640\":{\"h\":\"13. 线程死亡的三种方式\",\"t\":[\"正常结束\",\"run() 或者 call() 方法执行完成后，线程正常结束；\",\"异常结束\",\"线程抛出一个未捕获的 Exception 或 Error，导致线程异常结束；\",\"调用 stop()\",\"直接调用线程的 stop() 方法来结束该线程，但是一般不推荐使用该种方式，因为该方法通常容易导致死锁；\"]},\"641\":{\"h\":\"14. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\",\"t\":[\"JVM执行start方法，会另起一条线程执行thread的run方法，这才起到多线程的效果~\",\"如果直接调用Thread的run()方法，其方法还是运行在主线程中，没有起到多线程效果。\"]},\"642\":{\"h\":\"15. 守护线程是什么？\",\"t\":[\"守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。\"]},\"643\":{\"h\":\"16. 了解Fork/Join框架吗？\",\"t\":[\"Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\",\"Fork/Join框架需要理解两个点，「分而治之」和「工作窃取算法」。\",\"「分而治之」\",\"以上Fork/Join框架的定义，就是分而治之思想的体现啦\",\"「工作窃取算法」\",\"把大任务拆分成小任务，放到不同队列执行，交由不同的线程分别执行时。有的线程优先把自己负责的任务执行完了，其他线程还在慢慢悠悠处理自己的任务，这时候为了充分提高效率，就需要工作盗窃算法啦~\",\"工作盗窃算法就是，「某个线程从其他队列中窃取任务进行执行的过程」。一般就是指做得快的线程（盗窃线程）抢慢的线程的任务来做，同时为了减少锁竞争，通常使用双端队列，即快线程和慢线程各在一端。\"]},\"644\":{\"h\":\"17. CAS了解吗？\",\"t\":[\"CAS：全称 Compare and swap，即比较并交换，它是一条 CPU 同步原语。是一种硬件对并发的支持，针对多处理器操作而设计的一种特殊指令，用于管理对共享数据的并发访问。\",\"CAS 是一种无锁的非阻塞算法的实现。\",\"CAS 包含了 3 个操作数：\",\"需要读写的内存值 V\",\"旧的预期值 A\",\"要修改的更新值 B\",\"当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作（他的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。）\",\"CAS 并发原语体现在 Java 语言中的 sum.misc.Unsafe 类中的各个方法。调用 Unsafe 类中的 CAS 方法， JVM 会帮助我们实现出 CAS 汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于 CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，CAS 是一条 CPU 的原子指令，不会造成数据不一致问题。\"]},\"645\":{\"h\":\"18. CAS有什么缺陷？\",\"t\":[\"1. ABA 问题\",\"并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。\",\"可以通过AtomicStampedReference解决ABA问题，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。\",\"2. 循环时间长开销\",\"自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。\",\"很多时候，CAS思想体现，是有个自旋次数的，就是为了避开这个耗时问题~\",\"3. 只能保证一个变量的原子操作。\",\"CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。\",\"可以通过这两个方式解决这个问题：\",\"使用互斥锁来保证原子性；\",\"将多个变量封装成对象，通过AtomicReference来保证原子性。\"]},\"646\":{\"h\":\"19. synchronized 和 volatile 的区别是什么？\",\"t\":[\"volatile 解决的是内存可见性问题，会使得所有对 volatile 变量的读写都直接写入主存，即 保证了变量的可见性。\",\"synchronized 解决的事执行控制的问题，它会阻止其他线程获取当前对象的监控锁，这样一来就让当前对象中被 synchronized 关键字保护的代码块无法被其他线程访问，也就是无法并发执行。而且，synchronized 还会创建一个 内存屏障，内存屏障指令保证了所有 CPU 操作结果都会直接刷到主存中，从而 保证操作的内存可见性，同时也使得这个锁的线程的所有操作都 happens-before 于随后获得这个锁的线程的操作。\",\"两者的区别主要有如下：\",\"volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\",\"volatile 仅能使用在变量级别；synchronized 则可以使用在 变量. 方法. 和类级别的\",\"volatile 仅能实现变量的修改可见性，不能保证原子性；而synchronized 则可以 保证变量的修改可见性和原子性\",\"volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\",\"volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。\"]},\"647\":{\"h\":\"20. synchronized 和 Lock 有什么区别？\",\"t\":[\"synchronized 可以给类. 方法. 代码块加锁；而 lock 只能给代码块加锁。\",\"synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。\",\"通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\"]},\"648\":{\"h\":\"21. synchronized 和 ReentrantLock 区别是什么？\",\"t\":[\"1.两者都是可重入锁\",\"可重入锁：重入锁，也叫做递归锁，可重入锁指的是在一个线程中可以多次获取同一把锁，比如： 一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁， 两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\",\"2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API\",\"synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的\",\"ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）\",\"3.ReentrantLock 比 synchronized 增加了一些高级功能\",\"相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）\",\"等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\",\"ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。\",\"ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”\",\"4.使用选择\",\"除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。\",\"synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放\"]},\"649\":{\"h\":\"22. synchronized的用法有哪些?\",\"t\":[\"修饰普通方法:作用于当前对象实例，进入同步代码前要获得当前对象实例的锁\",\"修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁\",\"修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁\",\"特别注意：\",\"①如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁\",\"②尽量不要使用 synchronized(String s) ,因为JVM中，字符串常量池具有缓冲功能\"]},\"650\":{\"h\":\"23. Synchronized的作用有哪些？\",\"t\":[\"原子性：确保线程互斥的访问同步代码；\",\"可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；\",\"有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”。\"]},\"651\":{\"h\":\"24. 说一下 synchronized 底层实现原理？\",\"t\":[\"synchronized 同步代码块的实现是通过 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。\",\"其内部包含一个计数器，当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止\",\"synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\"]},\"652\":{\"h\":\"25. 多线程中 synchronized 锁升级的原理是什么？\",\"t\":[\"synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。\",\"锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。\"]},\"653\":{\"h\":\"\",\"t\":[\"synchronized 的非公平其实在源码中应该有不少地方，因为设计者就没按公平锁来设计，核心有以下几个点：\",\"1）当持有锁的线程释放锁时，该线程会执行以下两个重要操作：\",\"先将锁的持有者 owner 属性赋值为 null\",\"唤醒等待链表中的一个线程（假定继承者）。\",\"在1和2之间，如果有其他线程刚好在尝试获取锁（例如自旋），则可以马上获取到锁。\",\"2）当线程尝试获取锁失败，进入阻塞时，放入链表的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入链表，不代表你就会先被唤醒。\"]},\"654\":{\"h\":\"27. JVM对synchronized的优化有哪些？\",\"t\":[\"从最近几个jdk版本中可以看出，Java的开发团队一直在对synchronized优化，其中最大的一次优化就是在jdk6的时候，新增了两个锁状态，通过锁消除、锁粗化、自旋锁等方法使用各种场景，给synchronized性能带来了很大的提升。\"]},\"655\":{\"h\":\"\",\"t\":[\"上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：无锁——>偏向锁——>轻量级锁——>重量级锁，并且膨胀方向不可逆。\"]},\"656\":{\"h\":\"\",\"t\":[\"一句话总结它的作用：减少统一线程获取锁的代价。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。\",\"核心思想：\",\"如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查**Mark Word**的锁标记位为偏向锁以及当前线程ID等于**Mark Word**的ThreadID即可，这样就省去了大量有关锁申请的操作。\"]},\"657\":{\"h\":\"\",\"t\":[\"轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。\"]},\"658\":{\"h\":\"\",\"t\":[\"重量级锁是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。\",\"重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。\"]},\"659\":{\"h\":\"\",\"t\":[\"消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。比如下面代码的method1和method2的执行效率是一样的，因为object锁是私有变量，不存在所得竞争关系。\"]},\"660\":{\"h\":\"\",\"t\":[\"锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。比如下面method3经过锁粗化优化之后就和method4执行效率一样了。\"]},\"661\":{\"h\":\"\",\"t\":[\"轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。\",\"自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。\",\"自适应自旋锁：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。\",\"为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？\",\"重量级锁底层依赖于系统的同步函数来实现，在 linux 中使用 pthread_mutex_t（互斥锁）来实现。\",\"这些底层的同步函数操作会涉及到：操作系统用户态和内核态的切换、进程的上下文切换，而这些操作都是比较耗时的，因此重量级锁操作的开销比较大。\",\"而在很多情况下，可能获取锁时只有一个线程，或者是多个线程交替获取锁，在这种情况下，使用重量级锁就不划算了，因此引入了偏向锁和轻量级锁来降低没有并发竞争时的锁开销。\"]},\"662\":{\"h\":\"\",\"t\":[\"可以的。\",\"具体的触发时机：在全局安全点（safepoint）中，执行清理任务的时候会触发尝试降级锁。\",\"当锁降级时，主要进行了以下操作：\",\"1）恢复锁对象的 markword 对象头；\",\"2）重置 ObjectMonitor，然后将该 ObjectMonitor 放入全局空闲列表，等待后续使用。\"]},\"663\":{\"h\":\"29. ThreadLocal是什么?\",\"t\":[\"ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。\",\"//创建一个ThreadLocal变量 static ThreadLocal<String> localVariable = new ThreadLocal<>(); \",\"ThreadLocal的应用场景有\",\"数据库连接池\",\"会话管理中使用\"]},\"664\":{\"h\":\"30. ThreadLocal的实现原理\",\"t\":[\"Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。\",\"ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。\",\"每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。\",\"ThreadLocal内存结构图：\",\"由结构图是可以看出：\",\"Thread对象中持有一个ThreadLocal.ThreadLocalMap的成员变量。\",\"ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。\"]},\"665\":{\"h\":\"31. 知道ThreadLocal 内存泄露问题吗？\",\"t\":[\"先看看一下的TreadLocal的引用示意图哈，\",\"ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用，如下：\",\"弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。\",\"弱引用比较容易被回收。因此，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是因为ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会**「造成了内存泄漏问题」**。\",\"如何**「解决内存泄漏问题」**？使用完ThreadLocal后，及时调用remove()方法释放内存空间。\"]},\"666\":{\"h\":\"32. 了解ReentrantLock吗？\",\"t\":[\"ReetrantLock是一个可重入的独占锁，主要有两个特性，一个是支持公平锁和非公平锁，一个是可重入。 ReetrantLock实现依赖于AQS(AbstractQueuedSynchronizer)。\",\"ReetrantLock主要依靠AQS维护一个阻塞队列，多个线程对加锁时，失败则会进入阻塞队列。等待唤醒，重新尝试加锁。\"]},\"667\":{\"h\":\"33. ReadWriteLock是什么？\",\"t\":[\"首先ReentrantLock某些时候有局限，如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。\",\"因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能\"]},\"668\":{\"h\":\"1. 为什么要用线程池？\",\"t\":[\"线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。\",\"使用线程池的好处：\",\"降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\",\"提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。\",\"提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\"]},\"669\":{\"h\":\"2. 执行execute()方法和submit()方法的区别是什么呢？\",\"t\":[\"execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\",\"submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\"]},\"670\":{\"h\":\"3. 你说下线程池核心参数？\",\"t\":[\"corePoolSize ： 核心线程大小。线程池一直运行，核心线程就不会停止。\",\"maximumPoolSize ：线程池最大线程数量。非核心线程数量=maximumPoolSize-corePoolSize\",\"keepAliveTime ：非核心线程的心跳时间。如果非核心线程在keepAliveTime内没有运行任务，非核心线程会消亡。\",\"workQueue ：阻塞队列。ArrayBlockingQueue，LinkedBlockingQueue等，用来存放线程任务。\",\"defaultHandler ：饱和策略。ThreadPoolExecutor类中一共有4种饱和策略。通过实现RejectedExecutionHandler接口。 \",\"AbortPolicy ： 线程任务丢弃报错。默认饱和策略。\",\"DiscardPolicy ： 线程任务直接丢弃不报错。\",\"DiscardOldestPolicy ： 将workQueue队首任务丢弃，将最新线程任务重新加入队列执行。\",\"CallerRunsPolicy ：线程池之外的线程直接调用run方法执行。\",\"ThreadFactory ：线程工厂。新建线程工厂。\"]},\"671\":{\"h\":\"4. 线程池执行任务的流程？\",\"t\":[\"线程池执行execute/submit方法向线程池添加任务，当任务小于核心线程数corePoolSize，线程池中可以创建新的线程。\",\"当任务大于核心线程数corePoolSize，就向阻塞队列添加任务。\",\"如果阻塞队列已满，需要通过比较参数maximumPoolSize，在线程池创建新的线程，当线程数量大于maximumPoolSize，说明当前设置线程池中线程已经处理不了了，就会执行饱和策略。\"]},\"672\":{\"h\":\"5. 常用的JAVA线程池有哪几种类型？\",\"t\":[\"1、newCachedThreadPool\",\"创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\",\"这种类型的线程池特点是：\",\"工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。\",\"如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。\",\"在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。\",\"2、newFixedThreadPool\",\"创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。\",\"FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\",\"3、newSingleThreadExecutor\",\"创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。\",\"4、newScheduleThreadPool\",\"创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。\"]},\"673\":{\"h\":\"6. 线程池常用的阻塞队列有哪些?\",\"t\":[\"LinkedBlockingQueue 对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。\",\"这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。\",\"SynchronousQueue 第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。 我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。\",\"DelayedWorkQueue 第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。\",\"DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。\"]},\"674\":{\"h\":\"7. 源码中线程池是怎么复用线程的？\",\"t\":[\"源码中ThreadPoolExecutor中有个内置对象Worker，每个worker都是一个线程，worker线程数量和参数有关，每个worker会while死循环从阻塞队列中取数据，通过置换worker中Runnable对象，运行其run方法起到线程置换的效果，这样做的好处是避免多线程频繁线程切换，提高程序运行性能。\"]},\"675\":{\"h\":\"8. 如何合理配置线程池参数？\",\"t\":[\"自定义线程池就需要我们自己配置最大线程数 maximumPoolSize ，为了高效的并发运行，这时需要看我们的业务是IO密集型还是CPU密集型。\",\"CPU密集型 CPU密集的意思是该任务需要最大的运算，而没有阻塞，CPU一直全速运行。CPU密集任务只有在真正的多核CPU上才能得到加速(通过多线程)。而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那么多。\",\"IO密集型 IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上这种加速主要就是利用了被浪费掉的阻塞时间。\",\"IO 密集型时，大部分线程都阻塞，故需要多配制线程数。公式为：\",\"CPU核数*2 CPU核数/(1-阻塞系数) 阻塞系数在0.8~0.9之间 查看CPU核数： System.out.println(Runtime.getRuntime().availableProcessors()); \",\"当以上都不适用时，选用动态化线程池，看美团技术团队的实践：https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\"]},\"676\":{\"h\":\"9. Executor和Executors的区别？\",\"t\":[\"Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。\",\"Executor 接口对象能执行我们的线程任务。ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。\",\"使用ThreadPoolExecutor 可以创建自定义线程池。Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。\"]},\"677\":{\"h\":\"1. 说一说什么是AQS？\",\"t\":[\"AQS 是一个锁框架，它定义了锁的实现机制，并开放出扩展的地方，让子类去实现，比如我们在 lock 的时候，AQS 开放出 state 字段，让子类可以根据 state 字段来决定是否能够获得锁，对于获取不到锁的线程 AQS 会自动进行管理，无需子类锁关心，这就是 lock 时锁的内部机制，封装的很好，又暴露出子类锁需要扩展的地方；\",\"AQS 底层是由同步队列 + 条件队列联手组成，同步队列管理着获取不到锁的线程的排队和释放，条件队列是在一定场景下，对同步队列的补充，比如获得锁的线程从空队列中拿数据，肯定是拿不到数据的，这时候条件队列就会管理该线程，使该线程阻塞；\",\"AQS 围绕两个队列，提供了四大场景，分别是：获得锁、释放锁、条件队列的阻塞，条件队列的唤醒，分别对应着 AQS 架构图中的四种颜色的线的走向。\"]},\"678\":{\"h\":\"2. AQS使用了哪些设计模式？\",\"t\":[\"AQS同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\",\"使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）\",\"将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\",\"这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。\",\"AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：\",\"isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。 \"]},\"679\":{\"h\":\"3. 了解AQS中同步队列的数据结构吗？\",\"t\":[\"当前线程获取同步状态失败，同步器将当前线程机等待状态等信息构造成一个Node节点加入队列，放在队尾，同步器重新设置尾节点\",\"加入队列后，会阻塞当前线程\",\"同步状态被释放并且同步器重新设置首节点，同步器唤醒等待队列中第一个节点，让其再次获取同步状态\"]},\"680\":{\"h\":\"4. 了解AQS 对资源的共享方式吗？\",\"t\":[\"AQS定义两种资源共享方式\",\"Exclusive\",\"（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：\",\"公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\",\"非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\",\"Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\",\"ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。\",\"不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。\"]},\"681\":{\"h\":\"5. AQS 组件了解吗?\",\"t\":[\"Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\",\"CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。\",\"CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\"]},\"682\":{\"h\":\"1. 介绍一下 Atomic 原子类\",\"t\":[\"Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。\",\"所以，所谓原子类说简单点就是具有原子 / 原子操作特征的类。\",\"并发包 java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic 下：\",\"![atomic](https://gitee.com/alan-tang-tt/yuan/raw/master/死磕 java并发包/resource/atomic1.png)\"]},\"683\":{\"h\":\"2. JUC 包中的原子类是哪4类？\",\"t\":[\"基本类型 使用原子的方式更新基本类型：\",\"AtomicInteger ： 整型原子类\",\"AtomicLong： 长整型原子类\",\"AtomicBoolean： 布尔型原子类\",\"数组类型 使用原子的方式更新数组里的某个元素：\",\"AtomicIntegerArray： 整型数组原子类\",\"AtomicLongArray： 长整型数组原子类\",\"AtomicReferenceArray： 引用类型数组原子类\",\"引用类型 使用原子的方式更新引用类型：\",\"AtomicReference： 引用类型原子类\",\"AtomicStampedReference： 原子更新带有版本号的引用类型。该类将整型数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\",\"AtomicMarkableReference： 原子更新带有标记位的引用类型。对象属性修改类型\",\"AtomicIntegerFieldUpdater： 原子更新整型字段的更新器\",\"AtomicLongFieldUpdater： 原子更新长整型字段的更新器\",\"AtomicMarkableReference： 原子更新带有标记位的引用类型\"]},\"684\":{\"h\":\"3. 简单介绍一下 AtomicInteger 类的原理\",\"t\":[\"AtomicInteger 类主要利用 CAS和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\",\"AtomicInteger 类的部分源码：\",\" // 更新操作时提供“比较并替换”的作用 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try{ valueOffset = unsafe.objectFieldOffset(AutomicInteger.class.getDeclaredField(\\\"value\\\")); }catch(Exception ex){ throw new Error(ex); } } private volatile int value; \"]},\"685\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/java1024/p/13390538.html\",\"https://segmentfault.com/a/1190000039258680\",\"https://github.com/pengMaster/BestNote\",\"http://static.kancloud.cn/alex_wsc/java_source_interview/1875015\",\"https://blog.csdn.net/zycxnanwang/article/details/105321401\",\"https://blog.csdn.net/weixin_45124488/article/details/115200512\"]},\"686\":{\"h\":\"多线程基础\",\"t\":[\"Thread: 多线程基础\"]},\"687\":{\"h\":\"1. 线程和进程有什么区别？\",\"t\":[\"线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。\",\"根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位\",\"资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。\",\"包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。\",\"内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的\",\"影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。\",\"执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行\"]},\"688\":{\"h\":\"2. 创建线程的三种方式的对比？\",\"t\":[\"1）采用实现Runnable、Callable接口的方式创建多线程。\",\"优势是：\",\"线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。\",\"在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。\",\"劣势是：\",\"编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。\",\"2）使用继承Thread类的方式创建多线程\",\"优势是：\",\"编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。\",\"劣势是：\",\"线程类已经继承了Thread类，所以不能再继承其他父类。\",\"3）Runnable和Callable的区别\",\"Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。\",\"Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。\",\"Call方法可以抛出异常，run方法不可以。\",\"运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。\"]},\"689\":{\"h\":\"3. 为什么要使用多线程呢?\",\"t\":[\"从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。\",\"从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。\",\"从计算机底层来说：\",\"单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。\",\"多核时代:多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。\"]},\"690\":{\"h\":\"4. 线程的状态流转\",\"t\":[\"线程的生命周期及五种基本状态：\",\"Java线程具有五中基本状态\",\"1）新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();\",\"2）就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；\",\"3）运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\",\"4）阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\",\"1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\",\"2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\",\"3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\",\"5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\"]},\"691\":{\"h\":\"5. 什么是线程死锁?如何避免死锁?\"},\"692\":{\"h\":\"死锁\",\"t\":[\"多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 \"]},\"693\":{\"h\":\"死锁必须具备以下四个条件：\",\"t\":[\"互斥条件：该资源任意一个时刻只由一个线程占用。\",\"请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\",\"不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\",\"循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\"]},\"694\":{\"h\":\"如何避免线程死锁?\",\"t\":[\"只要破坏产生死锁的四个条件中的其中一个就可以了\",\"破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）\",\"破坏请求与保持条件 一次性申请所有的资源。\",\"破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\",\"破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\",\"锁排序法：（必须回答出来的点） 指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？ 通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。\",\"使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁\"]},\"695\":{\"h\":\"6. 常见的对比\"},\"696\":{\"h\":\"Runnable vs Callable\",\"t\":[\"Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Callable 接口可以返回结果或抛出检查异常\",\"Runnable 接口不会返回结果或抛出检查异常，\",\"如果任务不需要返回结果或抛出异常推荐使用 Runnable接口，这样代码看起来会更加简洁\",\"工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））\"]},\"697\":{\"h\":\"execute() vs submit()\",\"t\":[\"execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\",\"submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功（可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。）\"]},\"698\":{\"h\":\"shutdown()VSshutdownNow()\",\"t\":[\"shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。\",\"shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终\"]},\"699\":{\"h\":\"isTerminated() VS isShutdown()\",\"t\":[\"isShutDown 当调用 shutdown() 方法后返回为 true。\",\"isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true\"]},\"700\":{\"h\":\"7. sleep() 方法和 wait() 方法区别和共同点?\"},\"701\":{\"h\":\"区别\",\"t\":[\"sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。\",\"wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。\",\"sleep 方法没有释放锁，而 wait 方法释放了锁 。\",\"sleep 通常被用于暂停执行Wait 通常被用于线程间交互/通信\",\"sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法\"]},\"702\":{\"h\":\"相同\",\"t\":[\"两者都可以暂停线程的执行。\"]},\"703\":{\"h\":\"8.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法\",\"t\":[\"new 一个 Thread，线程进入了新建状态; 调用start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，（调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。）这是真正的多线程工作。\",\"直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。\"]},\"704\":{\"h\":\"9.ThreadLocal是什么？有什么用？\",\"t\":[\"ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。\",\"简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。\"]},\"705\":{\"h\":\"10. Thread类中的yield方法有什么作用？\",\"t\":[\"Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。\"]},\"706\":{\"h\":\"11. Java中的fork join框架是什么？\",\"t\":[\"fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。\"]},\"707\":{\"h\":\"12. synchronized和ReentrantLock 的区别\",\"t\":[\"1.两者都是可重入锁\",\"可重入锁：重入锁，也叫做递归锁，可重入锁指的是在一个线程中可以多次获取同一把锁，比如： 一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁， 两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\",\"2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API\",\"synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的\",\"ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）\",\"3.ReentrantLock 比 synchronized 增加了一些高级功能\",\"相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）\",\"等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\",\"ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。\",\"ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”\",\"4.使用选择\",\"除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。\",\"synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放\"]},\"708\":{\"h\":\"13. 谈谈volatile的使用及其原理\",\"t\":[\"volatile的两层语义：\",\"1、volatile保证变量对所有线程的可见性：当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。\",\"2、jdk1.5以后volatile完全避免了指令重排优化，实现了有序性。\",\"volatile的原理:\",\"获取JIT（即时Java编译器，把字节码解释为机器语言发送给处理器）的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也是为什么JDK1.5以后可以使用双锁检测实现单例模式。\",\"lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主内存中，并且使得其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。\",\"具体原理见这篇文章：https://www.javazhiyin.com/61019.html\"]},\"709\":{\"h\":\"14. synchronized 关键字和 volatile 关键字的区别\",\"t\":[\"volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。\",\"volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。实际开发中使用 synchronized 关键字的场景还是更多一些。\",\"多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞\",\"volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证\",\"volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。\"]},\"710\":{\"h\":\"线程池核心设计与实现\",\"t\":[\"Thread: 线程池设计\"]},\"711\":{\"h\":\"2.1 总体设计\",\"t\":[\"Java中的线程池核心实现类是ThreadPoolExecutor\",\"ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。\",\"ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。\",\"ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\",\"线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。\",\"线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。\",\"线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。\",\"线程池运行机制：\",\"线程池如何维护自身状态。\",\"线程池如何管理任务。\",\"线程池如何管理线程。\"]},\"712\":{\"h\":\"2.2 生命周期管理\",\"t\":[\"线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。\",\"如下代码所示：\",\"private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); \",\"ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。\",\"ThreadPoolExecutor的运行状态有5种，分别为：\",\"其生命周期转换如下入所示：\",\"图3 线程池生命周期\",\"参数\",\"keepAliveTime：非核心线程空闲时间（没有任务执行时）达到keepAliveTime，该线程会退出（避免资源浪费就应该要退出）\"]},\"713\":{\"h\":\"2.3 任务执行机制\",\"t\":[\"任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。\",\"首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：\",\"首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。\",\"如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。\",\"如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\",\"如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\",\"如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\",\"其执行流程如下图所示：\",\"图4 任务调度流程\",\"2.3.2 任务缓冲\",\"任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。\",\"阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\",\"下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：\",\"图5 阻塞队列\",\"使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：\"]},\"714\":{\"h\":\"2.4 Worker线程管理\",\"t\":[\"2.4.1 Worker线程\",\"线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：\",\"private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ final Thread thread;//Worker持有的线程 Runnable firstTask;//初始化的任务，可以为null } \",\"Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。\",\"Worker执行任务的模型如下图所示：\",\"图7 Worker执行任务\",\"线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。\",\"Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。\",\"1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。\",\"在线程回收过程中就使用到了这种特性，回收过程如下图所示：\",\"2.4.2 Worker线程增加\",\"增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：\",\"图9 申请线程执行流程图\",\"2.4.3 Worker线程回收\",\"线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。\",\"try { while (task != null || (task = getTask()) != null) { //执行任务 } } finally { processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己 } \",\"线程回收的工作是在processWorkerExit方法完成的。\",\"图10 线程销毁流程\",\"事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。\",\"2.4.4 Worker线程执行任务\",\"在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：\",\"1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。\",\"执行流程如下图所示：\",\"图11 执行任务流程\"]},\"715\":{\"h\":\"线程池参数设置\"},\"716\":{\"h\":\"1. 常规设置\",\"t\":[\"分 IO 密集型任务或者分 CPU 密集型任务\"]},\"717\":{\"h\":\"\",\"t\":[\"CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading 很高。\",\"CPU密集型：corePoolSize = CPU核数 + 1\",\"《Java并发编程实战》一书中给出的原因是：**即使当计算（CPU）密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个“额外”的线程也能确保 CPU 的时钟周期不会被浪费。**把它理解为一个备份的线程就行了。\",\"注意：这个地方还有个需要注意的小点就是，如果你的服务器上部署的不止一个应用，你就得考虑其他的应用的线程池配置情况。\",\"经过精密的计算，你咔一下设置为核心数，结果项目部署上去了，发现还有其他的应用在和你抢 CPU。\"]},\"718\":{\"h\":\"\",\"t\":[\"IO密集型的话，是指系统大部分时间在跟I/O交互，而这个时间线程不会占用CPU来处理，即在这个时间范围内，可以由其他线程来使用CPU，因而可以多配置一些线程。\",\"业界的一些线程池参数配置方案：\",\"第一个就是我们上面说的，和实际业务场景有所偏离。\",\"第二个设置为 2*CPU 核心数，有点像是把任务都当做 IO 密集型去处理了。而且一个项目里面一般来说不止一个自定义线程池吧？比如有专门处理数据上送的线程池，有专门处理查询请求的线程池，这样去做一个简单的线程隔离。但是如果都用这样的参数配置的话，显然是不合理的。\",\"第三个不说了，理想状态。流量是不可能这么均衡的，就拿美团来说，下午3，4点的流量，能和 12 点左右午饭时的流量比吗？\"]},\"719\":{\"h\":\"2.\",\"t\":[\"可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间。可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：\",\"成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。\"]},\"720\":{\"h\":\"\",\"t\":[\"动态化线程池的核心设计包括以下三个方面：\",\"简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。\",\"参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。\",\"增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。\",\"图17 动态化线程池整体设计\",\"3.3.2 功能架构\",\"动态化线程池提供如下功能：\",\"动态调参：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 任务监控：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 负载告警：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 操作监控：创建/修改和删除线程池都会通知到应用的开发负责人。 操作日志：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 权限校验：只有应用开发负责人才能够修改应用的线程池参数。\"]},\"721\":{\"h\":\"3.2.2\",\"t\":[\"JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：\",\"setMaximumPoolSize 也可以设置：\",\"这个地方就很简单了，逻辑不太复杂。\",\"1.首先是参数合法性校验。\",\"2.然后用传递进来的值，覆盖原来的值。\",\"3.判断工作线程是否是大于最大线程数，如果大于，则对空闲线程发起中断请求。\",\"经过前面两个方法的分析，我们知道了最大线程数和核心线程数可以动态调整。\",\"重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，\",\"如何动态指定队列长度？\",\"按照这个思路自定义一个队列，让其可以对 Capacity 参数进行修改即可。\",\"操作起来也非常方便，把 LinkedBlockingQueue 粘贴一份出来，修改个名字，然后把 Capacity 参数的 final 修饰符去掉，并提供其对应的 get/set 方法。\"]},\"722\":{\"h\":\"面试题\",\"t\":[\"问题一：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？\",\"线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法：\",\"全部启动：\",\"仅启动一个：\",\"问题二：核心线程数会被回收吗？需要什么设置？\",\"核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：\",\"allowCoreThreadTimeOut 该值默认为 false。\"]},\"723\":{\"h\":\"参考\",\"t\":[\"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\",\"https://blog.csdn.net/z55887/article/details/79060070\",\"https://www.cnblogs.com/thisiswhy/p/12690630.html\",\"http://ifeve.com/how-to-calculate-threadpool-size/\"]},\"724\":{\"h\":\"进程通信的几种方式\",\"t\":[\"Thread: 通信\"]},\"725\":{\"h\":\"管道\",\"t\":[\"可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。\",\"管道这种通信方式效率低，不适合进程间频繁地交换数据\",\"所谓的管道，就是内核里面的一串缓存。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。\"]},\"726\":{\"h\":\"消息队列\",\"t\":[\"比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。\",\"消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。\",\"消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。\",\"消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。\",\"消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。\"]},\"727\":{\"h\":\"共享内存\",\"t\":[\"消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这一问题。\",\"现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。\",\"共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。\"]},\"728\":{\"h\":\"信号量\",\"t\":[\"用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。\",\"为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。\",\"信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。\",\"信号量表示资源的数量，控制信号量的方式有两种原子操作：\",\"一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。\",\"另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；\"]},\"729\":{\"h\":\"信号\",\"t\":[\"对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。\",\"信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样\",\"运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如\",\"Ctrl+C 产生 SIGINT 信号，表示终止该进程；\",\"Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束；\",\"信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。\",\"1.执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。\",\"2.捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。\",\"3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。\"]},\"730\":{\"h\":\"socket\",\"t\":[\"前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。\"]},\"731\":{\"h\":\"总结\",\"t\":[\"由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。\",\"Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。\",\"匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。\",\"命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。\",\"消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。\",\"共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。\",\"那么，就需要信号量来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。\",\"与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中唯一的异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。\",\"前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。\",\"线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。\"]},\"732\":{\"h\":\"1. 等待通知机制\",\"t\":[\"两个线程通过对同一对象调用等待 wait() 和通知 notify() 方法来进行通讯。\",\"等待通知有着一个经典范式：\",\"线程 A 作为消费者：\",\"获取对象的锁。\",\"进入 while(判断条件)，并调用 wait() 方法。\",\"当条件满足跳出循环执行具体处理逻辑。\",\"线程 B 作为生产者:\",\"获取对象锁。\",\"更改与线程 A 共用的判断条件。\",\"调用 notify() 方法。\",\"伪代码如下:\",\"//Thread A synchronized(Object){ while(条件){ Object.wait(); } //do something } //Thread B synchronized(Object){ 条件=false;//改变条件 Object.notify(); } \"]},\"733\":{\"h\":\"2. join() 方法\",\"t\":[\"在 join 线程完成后会调用 notifyAll() 方法，是在 JVM 实现中调用，所以这里看不出来。\"]},\"734\":{\"h\":\"3. volatile 共享内存\"},\"735\":{\"h\":\"4. 管道通信\"},\"736\":{\"h\":\"5. 并发工具\",\"t\":[\"CountDownLatch 并发工具\",\"CyclicBarrier 并发工具\"]},\"737\":{\"h\":\"参考\",\"t\":[\"https://crossoverjie.top/2018/03/16/java-senior/thread-communication/\"]},\"738\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"739\":{\"h\":\"Audio\"},\"740\":{\"h\":\"Com408\"},\"741\":{\"h\":\"Pdf\"},\"742\":{\"h\":\"Video\"},\"743\":{\"h\":\"Fofa\"},\"744\":{\"h\":\"Cloudflare\"},\"745\":{\"h\":\"Pages\"},\"746\":{\"h\":\"Site\"},\"747\":{\"h\":\"Workers\"},\"748\":{\"h\":\"Datasource\"},\"749\":{\"h\":\"Java\"},\"750\":{\"h\":\"Project\"},\"751\":{\"h\":\"Spring\"},\"752\":{\"h\":\"Utils\"},\"753\":{\"h\":\"中间件\"},\"754\":{\"h\":\"Base\"},\"755\":{\"h\":\"Basic\"},\"756\":{\"h\":\"Map\"},\"757\":{\"h\":\"Thread\"}},\"dirtCount\":0,\"index\":[[\"伪代码如下\",{\"1\":{\"732\":1}}],[\"伪装域名\",{\"1\":{\"69\":4,\"71\":4}}],[\"享有最快的进程间通信方式之名\",{\"1\":{\"731\":1}}],[\"毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程\",{\"1\":{\"731\":1}}],[\"毕竟namespace不是必须的\",{\"1\":{\"191\":1}}],[\"竖线就是匿名管道\",{\"1\":{\"731\":1}}],[\"命名管道突破了匿名管道只能在亲缘关系进程间的通信限制\",{\"1\":{\"731\":1}}],[\"命名管道\",{\"1\":{\"731\":1}}],[\"命令中的\",{\"1\":{\"731\":1}}],[\"命令和其他的一些基础构件\",{\"1\":{\"444\":1}}],[\"命令来释放锁\",{\"1\":{\"435\":1}}],[\"命令返回有效回复\",{\"1\":{\"425\":1}}],[\"命令的频率会从\",{\"1\":{\"425\":1}}],[\"命令的时间超过\",{\"1\":{\"425\":1}}],[\"命令的执行是原子性的\",{\"1\":{\"407\":1}}],[\"命令\",{\"1\":{\"425\":2,\"731\":1}}],[\"命令只会因为错误的语法而失败\",{\"1\":{\"411\":1}}],[\"命令是一个乐观锁\",{\"1\":{\"409\":1}}],[\"命令回复处理器写完后\",{\"1\":{\"403\":1}}],[\"命令回复处理器\",{\"1\":{\"403\":1}}],[\"命令请求处理器读取事件中的命令并完成\",{\"1\":{\"403\":1}}],[\"命令请求处理器\",{\"1\":{\"403\":1}}],[\"命令在\",{\"1\":{\"402\":1}}],[\"命令观察是不是\",{\"1\":{\"141\":1}}],[\"匿名管道的生命周期随着进程创建而建立\",{\"1\":{\"731\":1}}],[\"匿名管道是特殊文件只存在于内存\",{\"1\":{\"731\":1}}],[\"匿名管道顾名思义\",{\"1\":{\"731\":1}}],[\"匿名管道\",{\"1\":{\"731\":1}}],[\"忽略信号\",{\"1\":{\"729\":1,\"731\":1}}],[\"捕捉信号\",{\"1\":{\"729\":1,\"731\":1}}],[\"捕获然后丢弃并且+finally扫尾处理\",{\"1\":{\"535\":1}}],[\"管道通信\",{\"0\":{\"735\":1}}],[\"管道分为\",{\"1\":{\"731\":1}}],[\"管道传输的数据是无格式的流且大小受限\",{\"1\":{\"725\":1}}],[\"管道这种通信方式效率低\",{\"1\":{\"725\":1}}],[\"管道\",{\"0\":{\"725\":1}}],[\"管理连接\",{\"1\":{\"357\":1}}],[\"管理界面\",{\"1\":{\"352\":1}}],[\"管理器\",{\"1\":{\"291\":1}}],[\"粘贴一份出来\",{\"1\":{\"721\":1}}],[\"权限校验\",{\"1\":{\"720\":1}}],[\"权限检测\",{\"1\":{\"507\":1}}],[\"谁在什么时候修改了线程池参数\",{\"1\":{\"720\":1}}],[\"谁抢到就是谁的\",{\"1\":{\"680\":1}}],[\"美团内部通讯工具\",{\"1\":{\"720\":1}}],[\"美国地区cf反代ip查询代码\",{\"1\":{\"65\":1}}],[\"美国\",{\"1\":{\"52\":1,\"57\":1,\"65\":1}}],[\"界面化操作\",{\"1\":{\"720\":1}}],[\"界面挑选\",{\"1\":{\"70\":1}}],[\"帮助开发同学了解线程池状态\",{\"1\":{\"720\":1}}],[\"帮助文档甚至rpc框架功能的完备\",{\"1\":{\"206\":1}}],[\"考虑到在实际应用中我们获取并发性的场景主要是两种\",{\"1\":{\"720\":1}}],[\"收益在于\",{\"1\":{\"719\":1}}],[\"收到所有\",{\"1\":{\"323\":1}}],[\"收到三个重复确认说明网络状况还可以\",{\"1\":{\"24\":1}}],[\"收到客户端的\",{\"1\":{\"14\":1}}],[\"业界的一些线程池参数配置方案\",{\"1\":{\"718\":1}}],[\"额外\",{\"1\":{\"717\":1}}],[\"硬盘\",{\"1\":{\"717\":1}}],[\"销毁线程\",{\"1\":{\"714\":1}}],[\"销毁过程\",{\"0\":{\"275\":1},\"1\":{\"276\":1}}],[\"申请线程执行流程图\",{\"1\":{\"714\":1}}],[\"移除引用这样的操作来控制线程的生命周期\",{\"1\":{\"714\":1}}],[\"移除最不经常使用的key\",{\"1\":{\"388\":1}}],[\"移除最近最少使用的key\",{\"1\":{\"388\":1}}],[\"亦或是直接拒绝该任务\",{\"1\":{\"713\":1}}],[\"亦称面向消息的中间件\",{\"1\":{\"351\":1}}],[\"决定接下来执行的流程\",{\"1\":{\"713\":1}}],[\"达到keepalivetime\",{\"1\":{\"712\":1}}],[\"拒绝该任务\",{\"1\":{\"711\":1}}],[\"缓冲到队列中等待线程执行\",{\"1\":{\"711\":1}}],[\"缓存的大小可以由\",{\"1\":{\"499\":1}}],[\"缓存在第一次使用时初始化\",{\"1\":{\"499\":1}}],[\"缓存支持自动装箱的对象标识语义\",{\"1\":{\"499\":1}}],[\"缓存是通过integer的内部类integercache来完成的\",{\"1\":{\"499\":1}}],[\"缓存slots\",{\"1\":{\"417\":1}}],[\"缓存使用时无需备用节点\",{\"1\":{\"414\":1}}],[\"缓存降级是指缓存失效或缓存服务器挂掉的情况下\",{\"1\":{\"398\":1}}],[\"缓存预热解决方案\",{\"1\":{\"397\":1}}],[\"缓存预热是指系统上线后\",{\"1\":{\"397\":1}}],[\"缓存穿透的关键在于在redis中查不到key值\",{\"1\":{\"395\":1}}],[\"缓存穿透是指用户请求的数据在缓存中不存在即没有命中\",{\"1\":{\"395\":1}}],[\"缓存击穿跟缓存雪崩有点类似\",{\"1\":{\"394\":1}}],[\"缓存击穿和缓存穿透\",{\"1\":{\"388\":1}}],[\"缓存雪崩是大规模的key失效\",{\"1\":{\"394\":1}}],[\"缓存雪崩\",{\"1\":{\"388\":1}}],[\"缓存异常有四种类型\",{\"1\":{\"388\":1}}],[\"缓存现在几乎是所有中大型网站都在用的必杀技\",{\"1\":{\"381\":1}}],[\"缓存有过期机制\",{\"1\":{\"380\":1}}],[\"缓存具有一致性\",{\"1\":{\"380\":1}}],[\"缓存不具有一致性\",{\"1\":{\"380\":1}}],[\"缓存分为本地缓存和分布式缓存\",{\"1\":{\"380\":1}}],[\"缓存\",{\"1\":{\"142\":1,\"175\":1,\"381\":1}}],[\"缓存至redis等k\",{\"1\":{\"136\":1}}],[\"缓存处理\",{\"1\":{\"33\":1}}],[\"顶层接口executor提供了一种思想\",{\"1\":{\"711\":1}}],[\"屏障才会开门\",{\"1\":{\"681\":1}}],[\"屏蔽一切可能违反数据完整性的操作\",{\"1\":{\"116\":1}}],[\"倒计时器\",{\"1\":{\"681\":1}}],[\"唤醒出队等\",{\"1\":{\"680\":1}}],[\"唤醒等待链表中的一个线程\",{\"1\":{\"653\":1}}],[\"架构图中的四种颜色的线的走向\",{\"1\":{\"677\":1}}],[\"架构简单\",{\"1\":{\"414\":1}}],[\"围绕两个队列\",{\"1\":{\"677\":1}}],[\"饱和策略\",{\"1\":{\"670\":1}}],[\"弱引用比较容易被回收\",{\"1\":{\"665\":1}}],[\"弱引用\",{\"1\":{\"665\":1}}],[\"许多情况下\",{\"1\":{\"661\":1}}],[\"许可获得许可\",{\"1\":{\"447\":1}}],[\"③可实现选择性通知\",{\"1\":{\"648\":1,\"707\":1}}],[\"③非单例循环依赖\",{\"1\":{\"281\":1}}],[\"②尽量不要使用\",{\"1\":{\"649\":1}}],[\"②可实现公平锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"②单例模式下的setter循环依赖\",{\"1\":{\"281\":1}}],[\"①如果一个线程a调用一个实例对象的非静态\",{\"1\":{\"649\":1}}],[\"①等待可中断\",{\"1\":{\"648\":1,\"707\":1}}],[\"①构造器的循环依赖\",{\"1\":{\"281\":1}}],[\"于后面对同一个锁的lock操作\",{\"1\":{\"650\":1}}],[\"于随后获得这个锁的线程的操作\",{\"1\":{\"646\":1}}],[\"于是会将该进程唤醒运行\",{\"1\":{\"728\":1}}],[\"于是可以使用\",{\"1\":{\"511\":1}}],[\"于是在\",{\"1\":{\"510\":1}}],[\"于是在创建对象时其hashcode就可以放心的缓存了\",{\"1\":{\"482\":1}}],[\"于是所有代表同一个方法的method对象都共享着根对象的methodaccessor\",{\"1\":{\"507\":1}}],[\"于是我们可以在缓存之前再加一个布隆过滤器\",{\"1\":{\"395\":1}}],[\"于是尝试get\",{\"1\":{\"281\":1}}],[\"汇编指令\",{\"1\":{\"644\":1}}],[\"抢慢的线程的任务来做\",{\"1\":{\"643\":1}}],[\"盗窃线程\",{\"1\":{\"643\":1}}],[\"守护线程是运行在后台的一种特殊进程\",{\"1\":{\"642\":1}}],[\"守护线程是什么\",{\"0\":{\"642\":1}}],[\"谈谈volatile的使用及其原理\",{\"0\":{\"637\":1,\"708\":1}}],[\"睡眠时\",{\"1\":{\"633\":1,\"701\":1}}],[\"睡眠不释放锁\",{\"1\":{\"633\":1,\"701\":1}}],[\"靠按序申请资源来预防\",{\"1\":{\"627\":1,\"694\":1}}],[\"临界资源需要互斥访问\",{\"1\":{\"627\":1,\"694\":1}}],[\"临时\",{\"1\":{\"284\":1}}],[\"临时节点\",{\"1\":{\"251\":1}}],[\"临时邮箱\",{\"1\":{\"60\":1,\"65\":1}}],[\"临时移动\",{\"1\":{\"27\":1}}],[\"破坏循环等待条件\",{\"1\":{\"627\":2,\"694\":2}}],[\"破坏不剥夺条件\",{\"1\":{\"627\":1,\"694\":1}}],[\"破坏请求与保持条件\",{\"1\":{\"627\":1,\"694\":1}}],[\"破坏互斥条件\",{\"1\":{\"627\":1,\"694\":1}}],[\"破坏数据库的一致性\",{\"1\":{\"113\":1}}],[\"停止执行\",{\"1\":{\"623\":1,\"690\":1}}],[\"绪状态是进入到运行状态的唯一入口\",{\"1\":{\"623\":1,\"690\":1}}],[\"影响关系\",{\"1\":{\"620\":1,\"687\":1}}],[\"影响了正常的\",{\"1\":{\"14\":1}}],[\"故需要多配制线程数\",{\"1\":{\"675\":1}}],[\"故又称为轻型进程\",{\"1\":{\"620\":1,\"687\":1}}],[\"故障转移时会从剩下的slave选举一个新的master\",{\"0\":{\"426\":1}}],[\"故障转移\",{\"1\":{\"419\":1}}],[\"故障探测和failover的处理机制上\",{\"1\":{\"418\":1}}],[\"故障自动转移\",{\"1\":{\"416\":1}}],[\"故障恢复复杂\",{\"1\":{\"415\":1}}],[\"插队竞争锁\",{\"1\":{\"616\":1}}],[\"插入和删除主要在同义词链表中进行\",{\"1\":{\"576\":1}}],[\"插入和删除元素的话\",{\"1\":{\"571\":1}}],[\"插入和删除是否受元素位置的影响\",{\"1\":{\"571\":1}}],[\"插入的时候\",{\"1\":{\"480\":1}}],[\"插入数据成功\",{\"1\":{\"223\":1}}],[\"插入非连续的数据\",{\"1\":{\"158\":1}}],[\"插入连续的数据\",{\"1\":{\"158\":1}}],[\"疑问\",{\"0\":{\"614\":1}}],[\"疑似可替换\",{\"1\":{\"70\":1}}],[\"何加入队列\",{\"0\":{\"607\":1}}],[\"何影响\",{\"1\":{\"179\":1}}],[\"描述\",{\"1\":{\"604\":1}}],[\"描述下\",{\"0\":{\"339\":1}}],[\"意为同步状态\",{\"1\":{\"604\":1}}],[\"意思就是要么成功执行要么失败完全不执行\",{\"1\":{\"376\":1}}],[\"意思就是在多台机器上启动多个rabbitmq实例\",{\"1\":{\"361\":1}}],[\"枚举\",{\"1\":{\"603\":1}}],[\"尾指针指向队列的最后一个等待线程节点\",{\"1\":{\"602\":1}}],[\"独占\",{\"1\":{\"680\":1}}],[\"独占方式\",{\"1\":{\"678\":2}}],[\"独占式同步状态释放\",{\"0\":{\"611\":1}}],[\"独占式同步状态获取\",{\"0\":{\"610\":1}}],[\"独占式获取和释放同步状态\",{\"1\":{\"609\":1}}],[\"独占式node\",{\"1\":{\"605\":1}}],[\"独占锁\",{\"1\":{\"601\":2}}],[\"独占性\",{\"1\":{\"431\":1}}],[\"称为内部比较器\",{\"1\":{\"596\":1}}],[\"称之为半自动orm映射工具\",{\"1\":{\"174\":1}}],[\"现代操作系统\",{\"1\":{\"727\":1}}],[\"现调整为对每个数组元素加锁\",{\"1\":{\"591\":1}}],[\"现在的系统动不动就要求百万级甚至千万级的并发量\",{\"1\":{\"622\":1,\"689\":1}}],[\"现在redis用在缓存的场合非常多\",{\"1\":{\"381\":1}}],[\"现在还只支持request与response请求\",{\"1\":{\"244\":1}}],[\"现在要加\",{\"1\":{\"161\":1}}],[\"现在用的公司基本也很少了\",{\"1\":{\"125\":1}}],[\"呢\",{\"0\":{\"574\":1}}],[\"校验容量是否够\",{\"1\":{\"573\":1}}],[\"线性不安全的\",{\"1\":{\"570\":1}}],[\"线程完成后会调用\",{\"1\":{\"733\":1}}],[\"线程间的通信目的主要是用于线程同步\",{\"1\":{\"731\":1}}],[\"线程间的切换和调度的成本远远小于进程\",{\"1\":{\"622\":1,\"689\":1}}],[\"线程销毁流程\",{\"1\":{\"714\":1}}],[\"线程回收的工作是在processworkerexit方法完成的\",{\"1\":{\"714\":1}}],[\"线程就会被回收\",{\"1\":{\"711\":1}}],[\"线程管理部分是消费者\",{\"1\":{\"711\":1}}],[\"线程管理\",{\"1\":{\"711\":1}}],[\"线程工厂\",{\"1\":{\"670\":1}}],[\"线程任务直接丢弃不报错\",{\"1\":{\"670\":1}}],[\"线程任务丢弃报错\",{\"1\":{\"670\":1}}],[\"线程d也在读数据\",{\"1\":{\"667\":1}}],[\"线程b在读数据造成的数据不一致\",{\"1\":{\"667\":1}}],[\"线程b执行了concurrenthashmap\",{\"1\":{\"548\":1,\"588\":1}}],[\"线程试图获取锁也就是获取\",{\"1\":{\"651\":1}}],[\"线程抛出一个未捕获的\",{\"1\":{\"640\":1}}],[\"线程正常结束\",{\"1\":{\"640\":1}}],[\"线程死亡的三种方式\",{\"0\":{\"640\":1}}],[\"线程重新转入可运行状态\",{\"1\":{\"639\":1}}],[\"线程重新转入就绪状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"线程阻塞的三种情况\",{\"0\":{\"639\":1}}],[\"线程下的普通方法去执行\",{\"1\":{\"635\":1,\"703\":1}}],[\"线程进入了新建状态\",{\"1\":{\"635\":1,\"703\":1}}],[\"线程进入阻塞状态\",{\"1\":{\"633\":2,\"701\":2}}],[\"线程会自动苏醒\",{\"1\":{\"633\":1,\"701\":1}}],[\"线程会进入到阻塞状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"线程已获得的资源在末使用完之前不能被其他线程强行剥夺\",{\"1\":{\"626\":1,\"693\":1}}],[\"线程执行完了或者因异常退出了run\",{\"1\":{\"623\":1,\"690\":1}}],[\"线程在获取synchronized同步锁失败\",{\"1\":{\"623\":1,\"690\":1}}],[\"线程要想进入运行状态执行\",{\"1\":{\"623\":1,\"690\":1}}],[\"线程要么同时在读\",{\"1\":{\"404\":1}}],[\"线程即进入就绪状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"线程的状态变为\",{\"1\":{\"630\":1,\"698\":1}}],[\"线程的状态流转\",{\"0\":{\"623\":1,\"690\":1}}],[\"线程的生命周期及五种基本状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"线程的模型\",{\"1\":{\"406\":1}}],[\"线程可以比作是轻量级的进程\",{\"1\":{\"622\":1,\"689\":1}}],[\"线程可以看做轻量级的进程\",{\"1\":{\"620\":1,\"687\":1}}],[\"线程类已经继承了thread类\",{\"1\":{\"621\":1,\"688\":1}}],[\"线程类只是实现了runnable接口或callable接口\",{\"1\":{\"621\":1,\"688\":1}}],[\"线程是稀缺资源\",{\"1\":{\"668\":1}}],[\"线程是进程的一部分\",{\"1\":{\"620\":1,\"687\":1}}],[\"线程是不允许插队竞争锁的\",{\"1\":{\"616\":1}}],[\"线程之间切换的开销小\",{\"1\":{\"620\":1,\"687\":1}}],[\"线程具有许多传统进程所具有的特征\",{\"1\":{\"620\":1,\"687\":1}}],[\"线程和进程有什么区别\",{\"0\":{\"620\":1,\"687\":1}}],[\"线程所在节点的状态会变成取消状态\",{\"1\":{\"614\":1}}],[\"线程继续等待\",{\"1\":{\"614\":1}}],[\"线程不会自动苏醒\",{\"1\":{\"633\":1,\"701\":1}}],[\"线程不会从同步队列中移除\",{\"1\":{\"610\":1}}],[\"线程不安全的呢\",{\"0\":{\"570\":1}}],[\"线程加入等待队列\",{\"0\":{\"605\":1}}],[\"线程两种锁的模式\",{\"1\":{\"603\":1}}],[\"线程2此时执行get\",{\"1\":{\"566\":1,\"583\":1}}],[\"线程2执行put\",{\"1\":{\"565\":1}}],[\"线程2继续执行\",{\"1\":{\"564\":1}}],[\"线程1执行put时\",{\"1\":{\"566\":1,\"583\":1}}],[\"线程1执行put\",{\"1\":{\"565\":1}}],[\"线程1的\",{\"1\":{\"564\":1}}],[\"线程1\",{\"1\":{\"564\":2}}],[\"线程1和线程2\",{\"1\":{\"564\":1}}],[\"线程安全的\",{\"1\":{\"570\":1}}],[\"线程安全的集合有哪些\",{\"0\":{\"570\":1}}],[\"线程安全篇\",{\"0\":{\"563\":1}}],[\"线程安全\",{\"1\":{\"549\":1,\"594\":1}}],[\"线程安全问题都是由全局变量及静态变量引起的\",{\"1\":{\"282\":1}}],[\"线程a调用concurrenthashmap\",{\"1\":{\"548\":1,\"588\":1}}],[\"线程里\",{\"1\":{\"406\":1}}],[\"线程只负责读写\",{\"1\":{\"404\":1}}],[\"线程将数据回写\",{\"1\":{\"404\":1}}],[\"线程读取\",{\"1\":{\"404\":1}}],[\"线程\",{\"1\":{\"402\":1,\"404\":1,\"406\":2,\"435\":3,\"564\":1,\"620\":1,\"687\":1,\"732\":2}}],[\"线程隔离的\",{\"1\":{\"237\":1}}],[\"线程池被创建后如果没有任务过来\",{\"1\":{\"722\":1}}],[\"线程池被创建后里面有线程吗\",{\"1\":{\"722\":1}}],[\"线程池队列任务积压到一定值的时候会通过大象\",{\"1\":{\"720\":1}}],[\"线程池粒度\",{\"1\":{\"720\":1}}],[\"线程池构造参数有8个\",{\"1\":{\"720\":1}}],[\"线程池参数在管理平台可配置可修改\",{\"1\":{\"721\":1}}],[\"线程池参数动态化前后的参数修改流程对比如下\",{\"1\":{\"719\":1}}],[\"线程池参数设置\",{\"0\":{\"715\":1}}],[\"线程池还要判断是什么引发了这次销毁\",{\"1\":{\"714\":1}}],[\"线程池做的工作是根据当前线程池的状态维护一定数量的线程引用\",{\"1\":{\"714\":1}}],[\"线程池在执行shutdown方法或tryterminate方法时会调用interruptidleworkers方法来中断空闲的线程\",{\"1\":{\"714\":1}}],[\"线程池在内部实际上构建了一个生产者消费者模型\",{\"1\":{\"711\":1}}],[\"线程池使用一张hash表去持有线程的引用\",{\"1\":{\"714\":1}}],[\"线程池需要管理线程的生命周期\",{\"1\":{\"714\":1}}],[\"线程池为了掌握线程的状态并维护线程的生命周期\",{\"1\":{\"714\":1}}],[\"线程池中线程的销毁依赖jvm自动的回收\",{\"1\":{\"714\":1}}],[\"线程池中是以生产者消费者模式\",{\"1\":{\"713\":1}}],[\"线程池中可以创建新的线程\",{\"1\":{\"671\":1}}],[\"线程池要保证在running的状态下执行任务\",{\"1\":{\"713\":1}}],[\"线程池生命周期\",{\"1\":{\"712\":1}}],[\"线程池内部使用一个变量维护两个值\",{\"1\":{\"712\":1}}],[\"线程池运行的状态\",{\"1\":{\"712\":1}}],[\"线程池运行机制\",{\"1\":{\"711\":1}}],[\"线程池如何管理线程\",{\"1\":{\"711\":1}}],[\"线程池如何管理任务\",{\"1\":{\"711\":1}}],[\"线程池如何维护自身状态\",{\"1\":{\"711\":1}}],[\"线程池设计\",{\"1\":{\"710\":1}}],[\"线程池核心设计与实现\",{\"0\":{\"710\":1}}],[\"线程池并不需要一个任务队列来存储任务\",{\"1\":{\"673\":1}}],[\"线程池的本质是对任务和线程的管理\",{\"1\":{\"713\":1}}],[\"线程池的运行状态\",{\"1\":{\"712\":1}}],[\"线程池的运行主要分成两部分\",{\"1\":{\"711\":1}}],[\"线程池的线程数是固定的\",{\"1\":{\"673\":1}}],[\"线程池的状态变为\",{\"1\":{\"630\":1,\"698\":1}}],[\"线程池常用的阻塞队列有哪些\",{\"0\":{\"673\":1}}],[\"线程池执行execute\",{\"1\":{\"671\":1}}],[\"线程池执行任务的流程\",{\"0\":{\"671\":1}}],[\"线程池之外的线程直接调用run方法执行\",{\"1\":{\"670\":1}}],[\"线程池最大线程数量\",{\"1\":{\"670\":1}}],[\"线程池一直运行\",{\"1\":{\"670\":1}}],[\"线程池会直接覆盖原来的corepoolsize值\",{\"1\":{\"721\":1}}],[\"线程池会判断该任务后续的流转\",{\"1\":{\"711\":1}}],[\"线程池会返回一个\",{\"1\":{\"697\":1}}],[\"线程池会返回一个future类型的对象\",{\"1\":{\"669\":1}}],[\"线程池会终止当前正在运行的任务\",{\"1\":{\"630\":1,\"698\":1}}],[\"线程池提供了一种限制和管理资源\",{\"1\":{\"668\":1}}],[\"线程池不再接受新任务了\",{\"1\":{\"630\":1,\"698\":1}}],[\"线程池\",{\"1\":{\"228\":1,\"673\":1}}],[\"栈\",{\"1\":{\"570\":1}}],[\"紧接着线程2\",{\"1\":{\"565\":1}}],[\"紧接着会调用beanpostprocess的前置初始化方法postprocessbeforeinitialization\",{\"1\":{\"274\":1}}],[\"敬请期待呦\",{\"1\":{\"561\":1}}],[\"吗\",{\"1\":{\"560\":1}}],[\"感兴趣的小伙伴可以看下\",{\"1\":{\"559\":1}}],[\"示意图\",{\"1\":{\"559\":1}}],[\"示例\",{\"1\":{\"52\":1}}],[\"旧的预期值\",{\"1\":{\"644\":1}}],[\"旧的entry数组不再引用任何对象\",{\"1\":{\"558\":1,\"581\":1}}],[\"旧链表迁移新链表的时候\",{\"1\":{\"559\":1}}],[\"红色\",{\"1\":{\"559\":1}}],[\"红黑树搜索时间复杂度是\",{\"1\":{\"553\":2,\"575\":1,\"577\":1}}],[\"红黑树的根节点\",{\"1\":{\"546\":2,\"584\":1}}],[\"红黑树\",{\"0\":{\"150\":1},\"1\":{\"80\":1,\"150\":1}}],[\"范围在高位多\",{\"1\":{\"559\":1}}],[\"省略部分代码\",{\"1\":{\"594\":1}}],[\"省略构造方法\",{\"1\":{\"205\":1}}],[\"省去了重新计算\",{\"1\":{\"559\":1}}],[\"链地址法\",{\"1\":{\"576\":3}}],[\"链的尾部\",{\"1\":{\"558\":1,\"581\":1}}],[\"链表法适用于经常进行插入和删除的情况\",{\"1\":{\"576\":1}}],[\"链表优化重hash的代码块\",{\"1\":{\"559\":1}}],[\"链表插入元素时\",{\"1\":{\"557\":1}}],[\"链表插入键值对\",{\"1\":{\"556\":1,\"580\":1}}],[\"链表会转换为红黑树\",{\"1\":{\"557\":1}}],[\"链表长度大于8转换为红黑树进行处理\",{\"1\":{\"556\":1}}],[\"链表结构已经能保证查询性能\",{\"1\":{\"553\":1,\"577\":1}}],[\"链表和红黑树在达到一定条件会进行转换\",{\"1\":{\"553\":1,\"575\":1}}],[\"链表则是主要为了解决哈希冲突而存在的\",{\"1\":{\"553\":1,\"575\":1}}],[\"链表转化为红黑树\",{\"1\":{\"549\":1,\"591\":1}}],[\"步骤6\",{\"1\":{\"556\":1}}],[\"步骤5\",{\"1\":{\"556\":1}}],[\"步骤4\",{\"1\":{\"556\":1}}],[\"步骤3\",{\"1\":{\"556\":1}}],[\"步骤2\",{\"1\":{\"556\":1}}],[\"步骤1\",{\"1\":{\"556\":1}}],[\"步中\",{\"1\":{\"112\":1}}],[\"见jdk1\",{\"1\":{\"556\":1}}],[\"见以下代码\",{\"1\":{\"488\":1}}],[\"十进制数值为8\",{\"1\":{\"555\":1}}],[\"十分低效\",{\"1\":{\"83\":1}}],[\"质量来考虑\",{\"1\":{\"555\":1}}],[\"功效\",{\"1\":{\"555\":1}}],[\"功能架构\",{\"1\":{\"720\":1}}],[\"功能\",{\"1\":{\"350\":1}}],[\"功能较为简单\",{\"1\":{\"350\":1}}],[\"功能较为完善\",{\"1\":{\"350\":1}}],[\"功能支持\",{\"1\":{\"350\":1}}],[\"功能的实现\",{\"1\":{\"286\":1}}],[\"功能更加完善\",{\"1\":{\"232\":1}}],[\"功能项目主页\",{\"0\":{\"0\":1}}],[\"较好地体现了面向对象的思想\",{\"1\":{\"621\":1,\"688\":1}}],[\"较高的值会降低空间开销\",{\"1\":{\"554\":1,\"578\":1}}],[\"较少的依赖\",{\"1\":{\"362\":1}}],[\"较少\",{\"1\":{\"35\":1}}],[\"桶中的频率遵循泊松分布\",{\"1\":{\"553\":1}}],[\"翻译过来大概的意思是\",{\"1\":{\"553\":1,\"554\":1,\"578\":1}}],[\"右旋\",{\"1\":{\"553\":1,\"577\":1}}],[\"冲突的话\",{\"1\":{\"558\":1,\"581\":1}}],[\"冲突的时候\",{\"0\":{\"577\":1},\"1\":{\"553\":1}}],[\"冲突加剧\",{\"1\":{\"549\":1}}],[\"希望本文提供的动态化线程池思路能对大家有帮助\",{\"1\":{\"719\":1}}],[\"希望对小伙伴有所帮助\",{\"1\":{\"552\":1}}],[\"希望开发者将反射作为一个工具\",{\"1\":{\"506\":1}}],[\"斗胆写一篇关于\",{\"1\":{\"552\":1}}],[\"库森当年校招面试时就经历过这种痛苦\",{\"1\":{\"552\":1}}],[\"库森特将面试题分为多期\",{\"1\":{\"7\":1}}],[\"欢迎留言或私信~\",{\"1\":{\"550\":1}}],[\"小伙伴们想看什么类型的文章\",{\"1\":{\"550\":1}}],[\"小时还没有收到客户端的任何数据\",{\"1\":{\"19\":1}}],[\"小时\",{\"1\":{\"19\":1}}],[\"觉得不错的话\",{\"1\":{\"550\":1}}],[\"迭代过程中被修改\",{\"1\":{\"598\":1}}],[\"迭代器遍历的是开始遍历那一刻拿到的集合拷贝\",{\"1\":{\"598\":1}}],[\"迭代器并不能访问到修改后的内容\",{\"1\":{\"598\":1}}],[\"迭代器在遍历时直接访问集合中的内容\",{\"1\":{\"598\":1}}],[\"迭代器就会发现并反映出来\",{\"1\":{\"548\":1,\"590\":1}}],[\"迭代器就不会反映出来\",{\"1\":{\"548\":1,\"590\":1}}],[\"迭代器是弱一致性\",{\"1\":{\"548\":1,\"590\":1}}],[\"迭代器是强一致性不同\",{\"1\":{\"548\":1}}],[\"迭代器是强一致性还是弱一致性\",{\"0\":{\"590\":1},\"1\":{\"548\":1}}],[\"迭代太快\",{\"1\":{\"98\":1}}],[\"哈哈\",{\"1\":{\"548\":1,\"588\":1}}],[\"哈希桶table用volatile修饰主要是保证在数组扩容的时候保证可见性\",{\"1\":{\"587\":1}}],[\"哈希桶数组table用\",{\"1\":{\"547\":1}}],[\"哈希值对数组的长度取余后会确定一个存储的下标位置\",{\"1\":{\"479\":1}}],[\"哈希槽\",{\"1\":{\"429\":1}}],[\"哈希\",{\"1\":{\"378\":1}}],[\"哈希表\",{\"1\":{\"194\":1}}],[\"哈希索引的效率会很低\",{\"1\":{\"150\":1}}],[\"哈希法\",{\"1\":{\"46\":1}}],[\"却无法办到\",{\"1\":{\"647\":1}}],[\"却可以用containskey\",{\"1\":{\"548\":1}}],[\"却不能\",{\"1\":{\"515\":1}}],[\"循环会结束\",{\"1\":{\"714\":1}}],[\"循环栅栏\",{\"1\":{\"681\":1}}],[\"循环时间长开销\",{\"1\":{\"645\":1}}],[\"循环等待条件\",{\"1\":{\"626\":1,\"693\":1}}],[\"循环遍历判断\",{\"1\":{\"547\":1}}],[\"循环依赖主要发生在第一\",{\"1\":{\"281\":1}}],[\"涉及到的共享变量都使用\",{\"1\":{\"547\":1}}],[\"偏向锁就会立即升级为轻量级锁\",{\"1\":{\"657\":1}}],[\"偏向锁\",{\"1\":{\"546\":1}}],[\"抛弃了原有的\",{\"1\":{\"546\":1,\"584\":1}}],[\"抛出该异常\",{\"1\":{\"534\":6}}],[\"扮演锁的角色\",{\"1\":{\"546\":1,\"584\":1}}],[\"★★\",{\"1\":{\"548\":2}}],[\"★★★\",{\"1\":{\"547\":2,\"548\":1,\"549\":1}}],[\"★★★★\",{\"1\":{\"547\":2}}],[\"★★★★★\",{\"0\":{\"549\":1},\"1\":{\"546\":2,\"549\":2}}],[\"★\",{\"1\":{\"545\":2}}],[\"装饰器模式相比生成子类更为灵活\",{\"1\":{\"543\":1}}],[\"装饰器模式\",{\"1\":{\"543\":1}}],[\"装配\",{\"0\":{\"278\":1},\"1\":{\"268\":1,\"278\":2}}],[\"充分调用操作系统参与并发操作\",{\"1\":{\"542\":1}}],[\"充分发挥redis惰性删除的策略\",{\"1\":{\"421\":1}}],[\"输入流\",{\"1\":{\"539\":1}}],[\"输出值如下\",{\"1\":{\"560\":1}}],[\"输出的结果是\",{\"1\":{\"516\":1}}],[\"输出其价格\",{\"1\":{\"505\":1}}],[\"譬如\",{\"1\":{\"534\":2}}],[\"算术条件异常\",{\"1\":{\"534\":1}}],[\"算法本质上就是三步\",{\"1\":{\"555\":1,\"579\":1}}],[\"算法简化会带来弊端\",{\"1\":{\"549\":1}}],[\"算法示意图如下\",{\"1\":{\"437\":1}}],[\"算法\",{\"1\":{\"24\":1,\"388\":1}}],[\"违法访问错误\",{\"1\":{\"534\":1}}],[\"受查异常和非受查异常都可以被抛出\",{\"1\":{\"532\":1}}],[\"受检查异常\",{\"1\":{\"531\":1}}],[\"拋出异常对象\",{\"1\":{\"532\":1}}],[\"堆\",{\"1\":{\"673\":1}}],[\"堆栈溢出错误\",{\"1\":{\"534\":1}}],[\"堆栈溢出等\",{\"1\":{\"530\":1}}],[\"堆积的消息会不会进死信队列\",{\"0\":{\"373\":1}}],[\"堆积时间过长消息超时了\",{\"0\":{\"372\":1}}],[\"型的是\",{\"1\":{\"527\":1}}],[\"真这样做的话会导致编译错误\",{\"1\":{\"514\":1}}],[\"真实\",{\"1\":{\"316\":1}}],[\"潜在的性能收益\",{\"1\":{\"510\":1}}],[\"符合越早出错代价越小原则\",{\"1\":{\"510\":1}}],[\"符合我们对线程隔离的常规理解\",{\"1\":{\"406\":1}}],[\"远在\",{\"1\":{\"510\":1}}],[\"远程通讯\",{\"1\":{\"209\":1}}],[\"驱动程序就是之前在classpath中配置的jdbc的驱动程序的jar\",{\"1\":{\"506\":1}}],[\"驱动要求实现smart\",{\"1\":{\"417\":1}}],[\"密码\",{\"1\":{\"506\":1}}],[\"密集型去处理了\",{\"1\":{\"718\":1}}],[\"密集型任务\",{\"1\":{\"716\":1}}],[\"密集型任务或者分\",{\"1\":{\"716\":1}}],[\"密集型时\",{\"1\":{\"675\":1}}],[\"密集型\",{\"1\":{\"399\":1}}],[\"密集型的线程偶尔由于页缺失故障或者其他原因而暂停时\",{\"1\":{\"717\":1}}],[\"密集型的\",{\"1\":{\"399\":1}}],[\"测试时可以利用反射\",{\"1\":{\"506\":1}}],[\"测试到的已过期的key将被删除\",{\"1\":{\"386\":1}}],[\"拆箱机制\",{\"1\":{\"493\":1,\"494\":1}}],[\"含义\",{\"1\":{\"603\":3}}],[\"含义上\",{\"1\":{\"486\":1}}],[\"含\",{\"1\":{\"499\":1}}],[\"含有空值的列很难进行查询优化\",{\"1\":{\"160\":1}}],[\"判断条件\",{\"1\":{\"732\":1}}],[\"判断工作线程是否是大于最大线程数\",{\"1\":{\"721\":1}}],[\"判断该链为红黑树\",{\"1\":{\"556\":1}}],[\"判断该链表是否大于\",{\"1\":{\"556\":1,\"580\":1}}],[\"判断数组是否为空\",{\"1\":{\"547\":1}}],[\"判断是否可以容纳e\",{\"1\":{\"573\":1}}],[\"判断是否需要进行初始化\",{\"1\":{\"547\":1,\"585\":1}}],[\"判断是链表还是红黑树\",{\"1\":{\"547\":1,\"585\":1}}],[\"判断首节点\",{\"1\":{\"547\":1,\"585\":1}}],[\"判断\",{\"0\":{\"516\":1},\"1\":{\"616\":1}}],[\"判断arraylist<string>与arraylist<integer>是否相等\",{\"1\":{\"484\":1}}],[\"判断的时候先根据hashcode进行的判断\",{\"1\":{\"480\":1}}],[\"黑客就有可能改变字符串指向对象的值\",{\"1\":{\"482\":1}}],[\"散列表存储的是键值对\",{\"1\":{\"477\":1}}],[\"认为这两个对象相等\",{\"1\":{\"476\":1}}],[\"认为消息已经投递成功\",{\"1\":{\"359\":1}}],[\"般有两种使用情况\",{\"1\":{\"476\":1}}],[\"抽象装饰器\",{\"1\":{\"543\":3}}],[\"抽象类能使用\",{\"0\":{\"470\":1}}],[\"抽象类作为很多子类的父类\",{\"1\":{\"469\":1}}],[\"抽象类是对整个类整体进行抽象\",{\"1\":{\"469\":1}}],[\"抽象类是对一种事物的抽象\",{\"1\":{\"469\":1}}],[\"抽象类中的成员变量可以是各种类型的\",{\"1\":{\"469\":1}}],[\"抽象类可以提供成员方法的实现细节\",{\"1\":{\"469\":1}}],[\"抽象类和接口的区别是什么\",{\"0\":{\"469\":1}}],[\"抽象rpcserver\",{\"1\":{\"230\":1}}],[\"父类\",{\"1\":{\"464\":1}}],[\"父类静态块\",{\"1\":{\"461\":1}}],[\"派生类\",{\"1\":{\"464\":1}}],[\"讲讲面向对象三大特性\",{\"0\":{\"464\":1}}],[\"讲一讲快速失败\",{\"0\":{\"598\":1}}],[\"讲一讲前缀索引\",{\"0\":{\"155\":1}}],[\"讲一讲mysql的最左前缀原则\",{\"0\":{\"154\":1}}],[\"讲一讲聚簇索引与非聚簇索引\",{\"0\":{\"151\":1}}],[\"讲一讲https\",{\"0\":{\"37\":1}}],[\"易理解\",{\"1\":{\"542\":1}}],[\"易于实现\",{\"1\":{\"523\":1}}],[\"易维护\",{\"1\":{\"463\":1}}],[\"易扩展\",{\"1\":{\"463\":2}}],[\"易复用\",{\"1\":{\"463\":2}}],[\"嵌入式开发\",{\"1\":{\"463\":1}}],[\"嵌套查询是先查一个表\",{\"1\":{\"186\":1,\"187\":1}}],[\"满足了我们的需求\",{\"1\":{\"455\":1}}],[\"逻辑不太复杂\",{\"1\":{\"721\":1}}],[\"逻辑上理解是占用\",{\"1\":{\"449\":1}}],[\"逻辑过期\",{\"1\":{\"394\":1,\"396\":1}}],[\"厂商的具体实现\",{\"1\":{\"449\":1}}],[\"布尔型原子类\",{\"1\":{\"683\":1}}],[\"布尔型\",{\"1\":{\"449\":1}}],[\"商业软件\",{\"1\":{\"447\":1}}],[\"商品按时间的上新排行榜等\",{\"1\":{\"381\":1}}],[\"供jvm使用\",{\"1\":{\"445\":1}}],[\"供客户端读取\",{\"1\":{\"403\":1}}],[\"遗物\",{\"1\":{\"443\":1}}],[\"终端的进程\",{\"1\":{\"729\":1}}],[\"终止后\",{\"1\":{\"672\":1}}],[\"终止遍历\",{\"1\":{\"598\":1}}],[\"终止符代表字符串的结束\",{\"1\":{\"443\":1}}],[\"终于一个完整的rpc框架三个角色都有了\",{\"1\":{\"253\":1}}],[\"键\",{\"1\":{\"477\":1}}],[\"键值越短越好\",{\"1\":{\"438\":1}}],[\"键只需要花费\",{\"1\":{\"382\":1}}],[\"缩减键值对象\",{\"1\":{\"438\":1}}],[\"缩短超时时间\",{\"1\":{\"14\":1}}],[\"脚本做验证标识和解锁操作\",{\"1\":{\"435\":1}}],[\"验证当前的锁是不是自己加的锁\",{\"1\":{\"435\":1}}],[\"别的线程就再也无法获得该锁\",{\"1\":{\"435\":1}}],[\"别的线程北向进来\",{\"1\":{\"434\":1}}],[\"别人给你解锁了\",{\"1\":{\"431\":1}}],[\"承受不住这么大的压力可能会存在宕机的风险\",{\"1\":{\"432\":1}}],[\"理想状态\",{\"1\":{\"718\":1}}],[\"理想状态下\",{\"1\":{\"11\":1}}],[\"理想情况下使用随机的哈希码\",{\"1\":{\"553\":1}}],[\"理论上\",{\"1\":{\"535\":1}}],[\"理解逻辑简单\",{\"1\":{\"432\":1}}],[\"至于具体线程等待队列的维护\",{\"1\":{\"680\":1}}],[\"至于concurrenthashmap\",{\"1\":{\"588\":1}}],[\"至于\",{\"1\":{\"548\":1}}],[\"至于加上finally\",{\"1\":{\"535\":1}}],[\"至于这个\",{\"1\":{\"431\":1}}],[\"至少包含一个线程\",{\"1\":{\"620\":1,\"687\":1}}],[\"至少一个字符结束标志\",{\"1\":{\"486\":1}}],[\"至少能保证一部分用户是可以正常使用\",{\"1\":{\"396\":1}}],[\"至少感知到有至少一个\",{\"1\":{\"334\":1}}],[\"东西\",{\"1\":{\"431\":3}}],[\"思路是\",{\"1\":{\"431\":1}}],[\"思想\",{\"1\":{\"327\":1}}],[\"顾名思义\",{\"1\":{\"431\":1}}],[\"像synchronized\",{\"1\":{\"431\":1}}],[\"像乐观锁适用于写比较少的情况下\",{\"1\":{\"116\":1}}],[\"槽\",{\"1\":{\"429\":1}}],[\"投票选举一个sentinel节点进行故障处理\",{\"1\":{\"425\":1}}],[\"沟通\",{\"1\":{\"425\":1}}],[\"距离最后一次有效回复\",{\"1\":{\"425\":1}}],[\"隔一段时间去消费kafka中的数据\",{\"1\":{\"424\":1}}],[\"隔离级别与锁的关系\",{\"0\":{\"119\":1}}],[\"隔离级别\",{\"1\":{\"102\":1}}],[\"隔离性\",{\"1\":{\"74\":1,\"101\":1,\"112\":1}}],[\"脑裂导致的数据丢失\",{\"1\":{\"423\":1}}],[\"断开了连接\",{\"1\":{\"420\":1}}],[\"断路器\",{\"1\":{\"310\":1}}],[\"兼容性好\",{\"1\":{\"418\":1}}],[\"兼容性差\",{\"1\":{\"384\":1}}],[\"贴切业务实际需求\",{\"1\":{\"418\":1}}],[\"冷备\",{\"1\":{\"417\":1}}],[\"冷数据保存到磁盘\",{\"1\":{\"377\":1}}],[\"冷数据\",{\"1\":{\"377\":1}}],[\"部分节点不可用时\",{\"1\":{\"417\":1}}],[\"部署相对redis主从模式要复杂一些\",{\"1\":{\"416\":1}}],[\"部署结构\",{\"1\":{\"415\":1}}],[\"部署方便\",{\"1\":{\"414\":1}}],[\"部署完成后在网址后面加上这个\",{\"1\":{\"71\":1}}],[\"部署代码\",{\"1\":{\"60\":1}}],[\"部署日志\",{\"1\":{\"53\":1}}],[\"轻操作\",{\"1\":{\"542\":1}}],[\"轻松突破redis自身单线程瓶颈\",{\"1\":{\"416\":1}}],[\"轻量级锁失败后\",{\"1\":{\"661\":1}}],[\"轻量级锁是由偏向锁升级而来\",{\"1\":{\"657\":1}}],[\"轻量级锁\",{\"1\":{\"546\":1}}],[\"轻量\",{\"1\":{\"263\":1}}],[\"轻量代码编辑器下载\",{\"1\":{\"68\":1}}],[\"费事费力\",{\"1\":{\"416\":1}}],[\"阻塞系数在0\",{\"1\":{\"675\":1}}],[\"阻塞系数\",{\"1\":{\"675\":1}}],[\"阻塞队列就是生产者存放元素的容器\",{\"1\":{\"713\":1}}],[\"阻塞队列常用于生产者和消费者的场景\",{\"1\":{\"713\":1}}],[\"阻塞队列缓存任务\",{\"1\":{\"713\":1}}],[\"阻塞队列\",{\"1\":{\"670\":1,\"713\":2}}],[\"阻塞的情况可以分为如下三种\",{\"1\":{\"639\":1}}],[\"阻塞的获得结果\",{\"1\":{\"237\":1}}],[\"阻塞状态又可以分为三种\",{\"1\":{\"623\":1,\"690\":1}}],[\"阻塞状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"阻塞和唤醒线程功能以及队列模型的简单框架\",{\"1\":{\"601\":1}}],[\"阻塞时间大于clutser\",{\"1\":{\"417\":1}}],[\"阻塞请求\",{\"1\":{\"415\":1}}],[\"压缩\",{\"1\":{\"415\":1}}],[\"压缩解压缩等\",{\"1\":{\"8\":1}}],[\"浪费内存空间\",{\"1\":{\"413\":1}}],[\"剩下的都是引用类型\",{\"1\":{\"489\":1}}],[\"剩下的命令还是会继续运行完\",{\"1\":{\"412\":1}}],[\"剩下的字段都无法使用索引\",{\"1\":{\"84\":1}}],[\"失败则返回false\",{\"1\":{\"678\":3}}],[\"失败则会进入阻塞队列\",{\"1\":{\"666\":1}}],[\"失败的命令是由编程错误造成的\",{\"1\":{\"411\":1}}],[\"失败超时等情况\",{\"1\":{\"346\":1}}],[\"监控一直持续到exec命令\",{\"1\":{\"409\":1}}],[\"监视一个或多个key\",{\"1\":{\"408\":1}}],[\"监听\",{\"1\":{\"226\":1}}],[\"截止此处一个事务已经结束\",{\"1\":{\"408\":1}}],[\"修饰代码块\",{\"1\":{\"649\":1}}],[\"修饰静态方法\",{\"1\":{\"649\":1}}],[\"修饰普通方法\",{\"1\":{\"649\":1}}],[\"修饰主要是保证在数组扩容的时候保证可见性\",{\"1\":{\"547\":1}}],[\"修饰的方法并没有\",{\"1\":{\"651\":1}}],[\"修饰的哈希桶数组有关吗\",{\"1\":{\"547\":1}}],[\"修饰的\",{\"1\":{\"547\":1,\"586\":1}}],[\"修饰的变量必须初始化\",{\"1\":{\"454\":1}}],[\"修饰\",{\"1\":{\"547\":1}}],[\"修饰了\",{\"1\":{\"546\":1}}],[\"修饰符去掉\",{\"1\":{\"721\":1}}],[\"修饰符\",{\"1\":{\"481\":1}}],[\"修饰吗\",{\"0\":{\"470\":1}}],[\"修复之后我们就可以再次重新启动redis服务器了\",{\"1\":{\"407\":1}}],[\"修改个名字\",{\"1\":{\"721\":1}}],[\"修改前的参数值是什么\",{\"1\":{\"720\":1}}],[\"修改和删除线程池都会通知到应用的开发负责人\",{\"1\":{\"720\":1}}],[\"修改线程池配置\",{\"1\":{\"720\":1}}],[\"修改参数成本高等问题\",{\"1\":{\"720\":1}}],[\"修改为1\",{\"1\":{\"617\":1}}],[\"修改head节点指向下一个获得锁的节点\",{\"1\":{\"608\":1}}],[\"修改集合中的元素\",{\"1\":{\"597\":1}}],[\"修改元素\",{\"1\":{\"597\":1}}],[\"修改阈值\",{\"1\":{\"558\":1,\"581\":1}}],[\"修改阈值为int的最大值\",{\"1\":{\"558\":1,\"581\":1}}],[\"修改某个类的域\",{\"1\":{\"534\":1}}],[\"修改对应的值就行\",{\"1\":{\"388\":1}}],[\"修改刷盘策略为同步刷盘\",{\"1\":{\"369\":1}}],[\"修改datadir为一个存在目录\",{\"1\":{\"251\":1}}],[\"修改数据表范式\",{\"1\":{\"138\":1}}],[\"修改数据的话\",{\"1\":{\"120\":1}}],[\"修改时在申请排他锁\",{\"1\":{\"120\":1}}],[\"修改之前的记录\",{\"1\":{\"112\":1}}],[\"修改事务\",{\"1\":{\"112\":1}}],[\"修改\",{\"1\":{\"20\":1,\"112\":1,\"598\":1}}],[\"然而\",{\"1\":{\"552\":1}}],[\"然而如果在写入的过程中出现系统崩溃\",{\"1\":{\"407\":1}}],[\"然而如果网络中断事件是发生在客户端执行exec命令之后\",{\"1\":{\"407\":1}}],[\"然后用传递进来的值\",{\"1\":{\"721\":1}}],[\"然后用多个库来抗更高的并发\",{\"1\":{\"128\":1}}],[\"然后获取任务去执行\",{\"1\":{\"714\":1}}],[\"然后获得其使用索引的情况\",{\"1\":{\"137\":1}}],[\"然后当前线程被阻塞\",{\"1\":{\"681\":1}}],[\"然后在\",{\"1\":{\"638\":1}}],[\"然后自动执行\",{\"1\":{\"635\":1,\"703\":1}}],[\"然后逐个调用线程的interrupt方法来中断线程\",{\"1\":{\"630\":1,\"698\":1}}],[\"然后公平锁模式下\",{\"1\":{\"616\":1}}],[\"然后是e\",{\"1\":{\"564\":1}}],[\"然后把\",{\"1\":{\"721\":1}}],[\"然后把e和next往下移\",{\"1\":{\"564\":1}}],[\"然后把数据从老的hash表中迁移到新的hash表中\",{\"1\":{\"564\":1}}],[\"然后把新的值保存进去\",{\"1\":{\"481\":1}}],[\"然后给每一段数据配一把锁\",{\"1\":{\"546\":1,\"584\":1}}],[\"然后如果在\",{\"1\":{\"536\":1}}],[\"然后与属性一起序列化\",{\"1\":{\"525\":1}}],[\"然后返回旧的v\",{\"1\":{\"595\":1}}],[\"然后返回实例\",{\"1\":{\"511\":1}}],[\"然后返回放弃前offset行\",{\"1\":{\"136\":1}}],[\"然后调用\",{\"1\":{\"507\":1}}],[\"然后会对值进行缓存\",{\"1\":{\"499\":1}}],[\"然后进行比较\",{\"1\":{\"497\":1}}],[\"然后到了真正要被回收的时候\",{\"1\":{\"454\":1}}],[\"然后对16384取模\",{\"1\":{\"429\":1}}],[\"然后接替继续执行切换\",{\"1\":{\"427\":1}}],[\"然后发送给slave\",{\"1\":{\"420\":1}}],[\"然后master会将内存中缓存的写命令发送给slave\",{\"1\":{\"420\":1}}],[\"然后mysql服务端基于lastname\",{\"1\":{\"156\":1}}],[\"然后写入缓存中\",{\"1\":{\"392\":1}}],[\"然后同步等待缓存更新完成\",{\"1\":{\"392\":1}}],[\"然后一条一条的执行\",{\"1\":{\"392\":1}}],[\"然后每个系统在需要加锁时\",{\"1\":{\"431\":1}}],[\"然后每个队列对应一个工作线程\",{\"1\":{\"392\":1}}],[\"然后每次你写消息到queue的时候\",{\"1\":{\"361\":1}}],[\"然后看下消息消费速度是否正常\",{\"1\":{\"370\":1}}],[\"然后开启选举\",{\"1\":{\"423\":1}}],[\"然后开启\",{\"1\":{\"337\":1}}],[\"然后根据hashcode计算出hash值\",{\"1\":{\"555\":1,\"579\":1}}],[\"然后根据文件中配置的\",{\"1\":{\"308\":1}}],[\"然后根据lastname\",{\"1\":{\"156\":1}}],[\"然后扫描这个类下面带有\",{\"1\":{\"292\":1}}],[\"然后找到对应字典页码\",{\"1\":{\"146\":1}}],[\"然后再把e添加在末尾\",{\"1\":{\"573\":1}}],[\"然后再进行\",{\"1\":{\"547\":1}}],[\"然后再从本地磁盘加载到内存中\",{\"1\":{\"420\":1}}],[\"然后再将数据缓存的问题\",{\"1\":{\"397\":1}}],[\"然后再去更新数据库\",{\"1\":{\"392\":1}}],[\"然后再调用postprocessafterinitialization去做一些bean初始化之后的自定义工作\",{\"1\":{\"276\":1}}],[\"然后再关联\",{\"1\":{\"136\":1}}],[\"然后再给这个代码块取一个名字\",{\"1\":{\"98\":1}}],[\"然后并行重放不同库的日志\",{\"1\":{\"133\":1}}],[\"然后主库会自动把数据给同步到从库上去\",{\"1\":{\"131\":1}}],[\"然后我们就单单只是写主库\",{\"1\":{\"131\":1}}],[\"然后将该\",{\"1\":{\"662\":1}}],[\"然后将我们显示指定的serialversionuid属性值赋给自动生成的serialversionuid\",{\"1\":{\"528\":1}}],[\"然后将这个新版serialversionuid与序列化时生成的旧版serialversionuid进行比较\",{\"1\":{\"525\":1}}],[\"然后将指针指向新的string\",{\"1\":{\"481\":1}}],[\"然后将sql执行结果返回\",{\"1\":{\"182\":1}}],[\"然后将原来的联合查询改为对中间表的查询\",{\"1\":{\"140\":1}}],[\"然后将原记录复制到\",{\"1\":{\"112\":1}}],[\"然后将较多的访问频率很低的字段放到另外一个表里去\",{\"1\":{\"128\":1}}],[\"然后你用过哪些分库分表的中间件\",{\"1\":{\"122\":1}}],[\"然后操作的时候你对一个用户就操作那个表就好了\",{\"1\":{\"121\":1}}],[\"然后查询的时候你就查一个表\",{\"1\":{\"121\":1}}],[\"然后\",{\"1\":{\"103\":1}}],[\"然后以流的方式进行交互\",{\"1\":{\"329\":1}}],[\"然后以\",{\"1\":{\"82\":1}}],[\"然后粘贴\",{\"1\":{\"62\":1}}],[\"然后广播给所有其它节点\",{\"1\":{\"42\":1}}],[\"然后客户端还会生成一个随机码\",{\"1\":{\"37\":1}}],[\"然后客户端重传一次\",{\"1\":{\"18\":1}}],[\"然后连接到\",{\"1\":{\"37\":1}}],[\"鉴于这个原因\",{\"1\":{\"407\":1}}],[\"产生\",{\"1\":{\"729\":2}}],[\"产生一个中断\",{\"1\":{\"610\":1}}],[\"产生一个聚集索引树\",{\"1\":{\"112\":1}}],[\"产生了事件\",{\"1\":{\"403\":1}}],[\"出现不一致的情况\",{\"1\":{\"712\":1}}],[\"出现冲突时\",{\"1\":{\"576\":1}}],[\"出现环形链表\",{\"1\":{\"564\":2}}],[\"出现时\",{\"1\":{\"403\":1}}],[\"出\",{\"1\":{\"560\":1}}],[\"出来\",{\"1\":{\"323\":2}}],[\"介绍一下\",{\"0\":{\"682\":1}}],[\"介绍一下事务具有的四个特征\",{\"0\":{\"101\":1}}],[\"介绍下redis自研\",{\"0\":{\"418\":1}}],[\"介绍下redis\",{\"0\":{\"416\":1,\"417\":1}}],[\"介绍下redis多副本\",{\"0\":{\"415\":1}}],[\"介绍下redis单副本\",{\"0\":{\"414\":1}}],[\"介绍下redis的线程模型\",{\"0\":{\"403\":1}}],[\"绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持\",{\"1\":{\"401\":1}}],[\"零拷贝技术\",{\"1\":{\"401\":1}}],[\"零拷贝技术有其局限性\",{\"1\":{\"401\":1}}],[\"零拷贝技术或者\",{\"1\":{\"401\":1}}],[\"零拷技术减少拷贝次数\",{\"1\":{\"329\":1}}],[\"瓶颈已经越来越明显了\",{\"1\":{\"401\":1}}],[\"讨论\",{\"1\":{\"400\":1}}],[\"核心数\",{\"1\":{\"718\":1}}],[\"核心线程数默认是不会被回收的\",{\"1\":{\"722\":1}}],[\"核心线程数会被回收吗\",{\"1\":{\"722\":1}}],[\"核心线程可以无限等待获取任务\",{\"1\":{\"714\":1}}],[\"核心线程就不会停止\",{\"1\":{\"670\":1}}],[\"核心线程大小\",{\"1\":{\"670\":1}}],[\"核心思想\",{\"1\":{\"656\":1}}],[\"核心有以下几个点\",{\"1\":{\"653\":1}}],[\"核心被利用到\",{\"1\":{\"622\":2,\"689\":2}}],[\"核心作用是对象状态的保存与重建\",{\"1\":{\"518\":1}}],[\"核心重写\",{\"1\":{\"466\":1}}],[\"核心意思就是\",{\"1\":{\"399\":1}}],[\"核心功能\",{\"1\":{\"208\":1}}],[\"严重错误\",{\"1\":{\"398\":1}}],[\"严重消耗着服务器的资源\",{\"1\":{\"20\":1}}],[\"警告\",{\"1\":{\"398\":1}}],[\"降级一般是有损的操作\",{\"1\":{\"398\":1}}],[\"降低资源消耗\",{\"1\":{\"668\":1}}],[\"降低redis内存使用最直接的方式就是缩减键\",{\"1\":{\"438\":1}}],[\"降低了程序的性能\",{\"1\":{\"667\":1}}],[\"降低了压力\",{\"1\":{\"430\":1}}],[\"降低了系统的可用性\",{\"1\":{\"376\":1}}],[\"降低运维成本\",{\"1\":{\"417\":1}}],[\"降低优化器的优化时间\",{\"1\":{\"157\":1}}],[\"降低传送数据的效率\",{\"1\":{\"22\":1}}],[\"哨兵集群必须部署2个以上节点\",{\"1\":{\"428\":1}}],[\"哨兵会自动选举\",{\"1\":{\"416\":1}}],[\"哨兵进程会主动选举新的\",{\"1\":{\"413\":1}}],[\"哨兵模式\",{\"1\":{\"413\":1}}],[\"哨兵\",{\"0\":{\"416\":1},\"1\":{\"396\":1,\"413\":1}}],[\"均匀过期\",{\"1\":{\"396\":1}}],[\"马上又会有新的流量把数据库打死\",{\"1\":{\"396\":1}}],[\"永久代\",{\"1\":{\"487\":1}}],[\"永久移动\",{\"1\":{\"27\":1}}],[\"永不过期实际包含两层意思\",{\"1\":{\"394\":1,\"396\":1}}],[\"热点数据缓存永远不过期\",{\"1\":{\"394\":1,\"396\":1}}],[\"热数据\",{\"1\":{\"377\":1}}],[\"深复制\",{\"1\":{\"519\":1}}],[\"深入描述\",{\"1\":{\"519\":1}}],[\"深深的耦合在一起\",{\"1\":{\"393\":1}}],[\"深度太大\",{\"1\":{\"80\":1}}],[\"待那个队列对应的工作线程完成了上一个操作\",{\"1\":{\"392\":1}}],[\"待实现\",{\"1\":{\"212\":2}}],[\"拿到首节点\",{\"1\":{\"547\":1,\"585\":1}}],[\"拿到一把锁\",{\"1\":{\"431\":1}}],[\"拿到的数据是旧数据\",{\"1\":{\"391\":1}}],[\"拿转账来说\",{\"1\":{\"74\":1}}],[\"休眠1秒\",{\"1\":{\"391\":1}}],[\"背景\",{\"1\":{\"389\":1}}],[\"背景知识\",{\"0\":{\"208\":1,\"221\":1,\"228\":1,\"235\":1,\"242\":1,\"249\":1,\"256\":1}}],[\"禁止驱逐数据\",{\"1\":{\"388\":1}}],[\"难以确定删除操作执行的时长和频率\",{\"1\":{\"386\":1}}],[\"立即执行对其进行删除的操作\",{\"1\":{\"386\":1}}],[\"立即发出确认报文\",{\"1\":{\"16\":2}}],[\"惰性删除不会去主动删除数据\",{\"1\":{\"386\":1}}],[\"惰性删除\",{\"1\":{\"386\":2}}],[\"惰性删除和定期删除两种策略配合使用\",{\"1\":{\"386\":1}}],[\"阅读性较差\",{\"1\":{\"384\":1}}],[\"混合持久化结合了rdb持久化\",{\"1\":{\"384\":1}}],[\"混合模式\",{\"1\":{\"108\":1}}],[\"恢复锁对象的\",{\"1\":{\"662\":1}}],[\"恢复速度慢于rdb\",{\"1\":{\"383\":1}}],[\"恢复原来的consumer\",{\"1\":{\"371\":1}}],[\"劣势是\",{\"1\":{\"621\":2,\"688\":2}}],[\"劣势\",{\"1\":{\"383\":2,\"384\":1}}],[\"统计网页的uv\",{\"1\":{\"382\":1}}],[\"统计过慢查询吗\",{\"0\":{\"137\":1}}],[\"位或\",{\"1\":{\"555\":1}}],[\"位\",{\"1\":{\"449\":1}}],[\"位数\",{\"1\":{\"449\":1}}],[\"位就能表示\",{\"1\":{\"382\":1}}],[\"位图\",{\"1\":{\"382\":1}}],[\"底层是由同步队列\",{\"1\":{\"677\":1}}],[\"底层是依赖双向链表实现的\",{\"1\":{\"382\":1}}],[\"底层实现原理\",{\"0\":{\"651\":1}}],[\"底层使用的是双向循环链表数据结构\",{\"1\":{\"571\":1}}],[\"底层使用的是object数组\",{\"1\":{\"571\":1}}],[\"底层数据结构\",{\"1\":{\"571\":1}}],[\"底层的通信\",{\"1\":{\"223\":1}}],[\"粉丝数\",{\"1\":{\"382\":1}}],[\"五种常用的数据类型\",{\"1\":{\"382\":1}}],[\"五层模型只出现在计算机网络教学过程中\",{\"1\":{\"8\":1}}],[\"五层模型\",{\"1\":{\"8\":1}}],[\"踩\",{\"1\":{\"381\":1}}],[\"社交网站的访问量通常来说比较大\",{\"1\":{\"381\":1}}],[\"社交网络\",{\"1\":{\"381\":1}}],[\"社区活跃度\",{\"1\":{\"350\":1}}],[\"社区引入了leader\",{\"1\":{\"339\":1}}],[\"社区通过引入新的broker端参数\",{\"1\":{\"339\":1}}],[\"社区很活跃\",{\"1\":{\"127\":1}}],[\"秒\",{\"1\":{\"435\":4}}],[\"秒一次的频率向它已知的所有master\",{\"1\":{\"425\":1}}],[\"秒一次改为每秒一次\",{\"1\":{\"425\":1}}],[\"秒杀等场景\",{\"1\":{\"381\":1}}],[\"秒级别\",{\"1\":{\"339\":1}}],[\"减到\",{\"1\":{\"617\":1}}],[\"减1后二进制为111\",{\"1\":{\"555\":1}}],[\"减小min\",{\"1\":{\"424\":1}}],[\"减库存\",{\"1\":{\"381\":1}}],[\"减少统一线程获取锁的代价\",{\"1\":{\"656\":1}}],[\"减少内存开销\",{\"1\":{\"546\":1}}],[\"减少运行时异常的发生\",{\"1\":{\"510\":1}}],[\"减少一个master\",{\"1\":{\"429\":1}}],[\"减少max\",{\"1\":{\"417\":1}}],[\"减少了\",{\"1\":{\"179\":1}}],[\"减少了50\",{\"1\":{\"173\":1}}],[\"减少了建立和关闭连接的消耗和延迟\",{\"1\":{\"33\":1}}],[\"减少死锁产生概率\",{\"1\":{\"118\":1}}],[\"减少这个等待时间就能释放更多的资源\",{\"1\":{\"43\":1}}],[\"减少syn\",{\"1\":{\"43\":1}}],[\"排序\",{\"1\":{\"414\":1}}],[\"排在刚才更新库的操作之后\",{\"1\":{\"392\":1}}],[\"排行榜\",{\"1\":{\"381\":1}}],[\"排他锁只可以加一个\",{\"1\":{\"115\":1}}],[\"排他锁\",{\"1\":{\"114\":2,\"115\":1}}],[\"虚拟机为了避免线程真实地在操作系统层面挂起\",{\"1\":{\"661\":1}}],[\"虚拟机团队在\",{\"1\":{\"648\":1,\"707\":1}}],[\"虚拟机\",{\"1\":{\"444\":1}}],[\"虚拟内存\",{\"1\":{\"377\":2}}],[\"虚读\",{\"1\":{\"75\":1}}],[\"切换线程不值得\",{\"1\":{\"661\":1}}],[\"切换ip后还会引入数据不一致的问题\",{\"1\":{\"376\":1}}],[\"切面\",{\"1\":{\"283\":1}}],[\"丰富的特性\",{\"1\":{\"376\":1}}],[\"准备一个临时的topic\",{\"1\":{\"371\":1}}],[\"采取send\",{\"1\":{\"369\":1}}],[\"采用的是虚拟内存技术\",{\"1\":{\"727\":1}}],[\"采用实现runnable\",{\"1\":{\"621\":1,\"688\":1}}],[\"采用安全失败机制的集合容器\",{\"1\":{\"598\":1}}],[\"采用链表存储\",{\"1\":{\"571\":1}}],[\"采用数组存储\",{\"1\":{\"571\":1}}],[\"采用cas\",{\"1\":{\"584\":1}}],[\"采用cas+synchronized保证线程安全\",{\"1\":{\"591\":1}}],[\"采用cas+synchronized\",{\"1\":{\"549\":1}}],[\"采用clone机制\",{\"1\":{\"471\":1}}],[\"采用字节码的好处是什么\",{\"0\":{\"446\":1}}],[\"采用双机主备架构\",{\"1\":{\"415\":1}}],[\"采用主从\",{\"1\":{\"415\":1}}],[\"采用单个redis节点部署架构\",{\"1\":{\"414\":1}}],[\"采用多线程后\",{\"0\":{\"402\":1}}],[\"采用更新与读取操作进行异步串行化\",{\"1\":{\"392\":1}}],[\"采用值栈存储请求和响应的数据\",{\"1\":{\"299\":1}}],[\"采用以下注解可实现\",{\"1\":{\"271\":1}}],[\"采用表级锁\",{\"1\":{\"92\":1}}],[\"采用\",{\"1\":{\"37\":1,\"403\":1,\"546\":1,\"549\":1}}],[\"采用https加密的网站在搜索结果中的排名将会更高\",{\"1\":{\"36\":1}}],[\"天生设计定位就是分布式协调\",{\"1\":{\"432\":1}}],[\"天然顺序\",{\"1\":{\"368\":1}}],[\"天城大佬\",{\"1\":{\"57\":1}}],[\"追问\",{\"0\":{\"366\":1,\"371\":1,\"372\":1,\"373\":1}}],[\"广播消费\",{\"1\":{\"364\":1}}],[\"广播通信\",{\"1\":{\"10\":1}}],[\"角色\",{\"1\":{\"363\":1}}],[\"亿级消息堆积能力\",{\"1\":{\"362\":1}}],[\"定位结点的hash算法简化会带来弊端\",{\"1\":{\"591\":1}}],[\"定位节点的\",{\"1\":{\"549\":1}}],[\"定位到\",{\"1\":{\"547\":1,\"585\":2}}],[\"定时删除对内存是最友好的\",{\"1\":{\"386\":1}}],[\"定时删除\",{\"1\":{\"386\":1}}],[\"定时消息\",{\"1\":{\"362\":1}}],[\"定期删除策略变得和定时删除策略一样\",{\"1\":{\"386\":1}}],[\"定期删除\",{\"1\":{\"386\":2}}],[\"定期通过异步操作把数据库中的数据flush到硬盘上进行保存\",{\"1\":{\"376\":1}}],[\"定义了一个属性成员\",{\"1\":{\"511\":1}}],[\"定义了一个通用的response的对象\",{\"1\":{\"223\":1}}],[\"定义了一个通用的request的对象\",{\"1\":{\"223\":1}}],[\"定义在jdk的object\",{\"1\":{\"477\":1}}],[\"定义抽象类就是让其他类继承的\",{\"1\":{\"470\":1}}],[\"定义和特定于应用程序的配置选项\",{\"1\":{\"268\":1}}],[\"定义更加通用的消息格式\",{\"1\":{\"225\":1}}],[\"定义客户端需要调用\",{\"1\":{\"216\":1}}],[\"批量消息\",{\"1\":{\"362\":1}}],[\"批量量处理\",{\"1\":{\"329\":1}}],[\"元数据更新有延时\",{\"1\":{\"430\":1}}],[\"元数据的更新比较分散\",{\"1\":{\"430\":1}}],[\"元数据指rabbitmq的配置数据\",{\"1\":{\"361\":1}}],[\"元素a就丢失了\",{\"1\":{\"565\":1}}],[\"元素在重新计算\",{\"1\":{\"559\":1}}],[\"元素的位置在原来的位置\",{\"1\":{\"559\":1}}],[\"元素的使用\",{\"1\":{\"277\":1}}],[\"元素太少\",{\"1\":{\"553\":1,\"577\":1}}],[\"元素相同的角色\",{\"1\":{\"268\":1}}],[\"跟reentrantlock自定义同步器无关\",{\"1\":{\"615\":1}}],[\"跟master断开连接的时长\",{\"1\":{\"426\":1}}],[\"跟其他slave机器不能连接\",{\"1\":{\"423\":1}}],[\"跟普通集群模式不一样的是\",{\"1\":{\"361\":1}}],[\"跟随着这篇文档以及数个迭代版本的代码\",{\"1\":{\"206\":1}}],[\"镜像集群模式\",{\"1\":{\"361\":2}}],[\"镜像模式\",{\"1\":{\"356\":1}}],[\"报错\",{\"1\":{\"356\":1}}],[\"报文的确认\",{\"1\":{\"18\":1}}],[\"报文不一定会到达服务端\",{\"1\":{\"18\":1}}],[\"报文能够到达服务端\",{\"1\":{\"18\":1}}],[\"报文\",{\"1\":{\"17\":1,\"18\":5}}],[\"报文功能正常\",{\"1\":{\"13\":3}}],[\"报文段\",{\"1\":{\"17\":1}}],[\"报文段后\",{\"1\":{\"17\":1,\"18\":1}}],[\"报文段中维护了序号字段和确认序号字段\",{\"1\":{\"12\":1}}],[\"报文段才到达服务器\",{\"1\":{\"12\":1}}],[\"报文段请求建立连接\",{\"1\":{\"12\":1}}],[\"信号事件的来源主要有硬件来源\",{\"1\":{\"731\":1}}],[\"信号可以在应用进程和内核之间直接交互\",{\"1\":{\"731\":1}}],[\"信号是进程间通信机制中唯一的异步通信机制\",{\"1\":{\"729\":1,\"731\":1}}],[\"信号跟信号量虽然名字相似度\",{\"1\":{\"729\":1}}],[\"信号\",{\"0\":{\"729\":1},\"1\":{\"729\":4}}],[\"信号量其实是一个计数器\",{\"1\":{\"731\":1}}],[\"信号量其实是一个整型的计数器\",{\"1\":{\"728\":1}}],[\"信号量不仅可以实现访问的互斥性\",{\"1\":{\"731\":1}}],[\"信号量和信号都是在同一台主机上进行进程间通信\",{\"1\":{\"730\":1}}],[\"信号量表示资源的数量\",{\"1\":{\"728\":1}}],[\"信号量就实现了这一保护机制\",{\"1\":{\"728\":1}}],[\"信号量\",{\"0\":{\"728\":1},\"1\":{\"681\":2}}],[\"信道服用\",{\"1\":{\"354\":1}}],[\"信息也发送给服务端\",{\"1\":{\"40\":1}}],[\"信息\",{\"1\":{\"40\":2,\"152\":1}}],[\"信息后\",{\"1\":{\"40\":1}}],[\"绑定\",{\"1\":{\"353\":1}}],[\"绑定在一起\",{\"1\":{\"278\":1}}],[\"己的插件\",{\"1\":{\"352\":1}}],[\"己经提供了一些内置的交换器来实现\",{\"1\":{\"352\":1}}],[\"令插件机制\",{\"1\":{\"352\":1}}],[\"令人困惑的性质\",{\"1\":{\"279\":1}}],[\"群中的节点等\",{\"1\":{\"352\":1}}],[\"集合在被遍历期间如果内容发生变化\",{\"1\":{\"598\":1}}],[\"集合等数据结构能很方便的的实现这些功能\",{\"1\":{\"381\":1}}],[\"集合\",{\"1\":{\"378\":1}}],[\"集\",{\"1\":{\"352\":1}}],[\"集群里就会有两个master\",{\"1\":{\"423\":1}}],[\"集群监控\",{\"1\":{\"419\":1}}],[\"集群仍可用\",{\"1\":{\"417\":1}}],[\"集群规模不是很大\",{\"1\":{\"413\":1}}],[\"集群模式下只能使用1个数据库空间\",{\"1\":{\"417\":1}}],[\"集群模式下\",{\"1\":{\"381\":1}}],[\"集群模式\",{\"1\":{\"378\":1,\"417\":1}}],[\"集群部署\",{\"1\":{\"369\":2,\"432\":1}}],[\"集群消费\",{\"1\":{\"364\":1}}],[\"集群中节点\",{\"1\":{\"352\":1}}],[\"集群向消费者提供消息\",{\"1\":{\"322\":1}}],[\"集群\",{\"1\":{\"322\":1,\"356\":1}}],[\"队列长度等\",{\"1\":{\"720\":1}}],[\"队列容量必须声明\",{\"1\":{\"720\":1}}],[\"队列集合称为\",{\"1\":{\"362\":1}}],[\"队列都可以分布式\",{\"1\":{\"362\":1}}],[\"队列\",{\"1\":{\"353\":1}}],[\"队列可以在集群中的机器上设置镜像\",{\"1\":{\"352\":1}}],[\"队列中\",{\"1\":{\"347\":1}}],[\"交由不同的线程分别执行时\",{\"1\":{\"643\":1}}],[\"交换器等信息\",{\"1\":{\"357\":1}}],[\"交换器类型\",{\"1\":{\"353\":1}}],[\"交换器和队列绑定\",{\"1\":{\"353\":1}}],[\"交换器绑定在一起\",{\"1\":{\"352\":1}}],[\"交给重载方法创建sqlsessionfactory对象\",{\"1\":{\"195\":1}}],[\"交给执行器\",{\"1\":{\"88\":1,\"99\":1}}],[\"针对多处理器操作而设计的一种特殊指令\",{\"1\":{\"644\":1}}],[\"针对这种key异常多\",{\"1\":{\"395\":1}}],[\"针对一些恶意攻击\",{\"1\":{\"395\":1}}],[\"针对热点key不设置过期时间\",{\"1\":{\"394\":1,\"396\":1}}],[\"针对更复杂的路由功能\",{\"1\":{\"352\":1}}],[\"针对数据量大的表\",{\"1\":{\"135\":1}}],[\"灵活的路由\",{\"1\":{\"352\":1}}],[\"灵活度高\",{\"1\":{\"172\":2,\"178\":1}}],[\"技术通过旁路网卡\",{\"1\":{\"401\":1}}],[\"技术\",{\"1\":{\"401\":1}}],[\"技术挑战不是特别高\",{\"1\":{\"350\":1}}],[\"技术实力较为一般\",{\"1\":{\"350\":1}}],[\"技术上来说是b+tree\",{\"1\":{\"148\":1}}],[\"低29位保存workercount\",{\"1\":{\"712\":1}}],[\"低\",{\"1\":{\"350\":1}}],[\"低一个数量级\",{\"1\":{\"350\":1}}],[\"领域的功能极其完备\",{\"1\":{\"350\":1}}],[\"丢失\",{\"1\":{\"350\":1}}],[\"丢失了data对象的类信息\",{\"1\":{\"244\":1}}],[\"少数机器宕机\",{\"1\":{\"350\":1}}],[\"延时双删\",{\"0\":{\"391\":1}}],[\"延时很低\",{\"1\":{\"350\":1}}],[\"延时问题\",{\"1\":{\"342\":1}}],[\"延迟在\",{\"1\":{\"350\":1}}],[\"延迟最低\",{\"1\":{\"350\":1}}],[\"微博数\",{\"1\":{\"382\":1}}],[\"微秒级\",{\"1\":{\"350\":1}}],[\"微软\",{\"1\":{\"52\":1}}],[\"吞吐量会大幅度下降\",{\"1\":{\"350\":1}}],[\"吞吐量会有较小幅度的下降\",{\"1\":{\"350\":1}}],[\"几点\",{\"1\":{\"493\":1}}],[\"几率很小吧\",{\"1\":{\"392\":1}}],[\"几乎\",{\"1\":{\"510\":1}}],[\"几乎支持所有常用语言\",{\"1\":{\"352\":1}}],[\"几乎是全世界这个领域的事实性规范\",{\"1\":{\"350\":1}}],[\"几乎可以解决企业开发中的所有问题\",{\"1\":{\"310\":1}}],[\"几千的级别\",{\"1\":{\"350\":1}}],[\"高3位保存runstate\",{\"1\":{\"712\":1}}],[\"高位参与运算\",{\"1\":{\"555\":1,\"579\":1}}],[\"高性能受限于单核cpu的处理能力\",{\"1\":{\"414\":1}}],[\"高性能\",{\"1\":{\"414\":1}}],[\"高性价比\",{\"1\":{\"414\":1}}],[\"高实时\",{\"1\":{\"362\":1}}],[\"高可用\",{\"1\":{\"369\":1}}],[\"高可用性\",{\"1\":{\"352\":1,\"417\":1,\"418\":1,\"431\":1}}],[\"高可靠性\",{\"1\":{\"415\":1,\"418\":1}}],[\"高可靠\",{\"1\":{\"362\":1}}],[\"高\",{\"1\":{\"350\":1}}],[\"高吞吐\",{\"1\":{\"350\":1}}],[\"高效的订阅者水平扩展能力\",{\"1\":{\"362\":1}}],[\"高效\",{\"1\":{\"175\":2}}],[\"支撑高吞吐\",{\"1\":{\"350\":1}}],[\"支持应用粒度\",{\"1\":{\"720\":1}}],[\"支持线程池参数动态调整\",{\"1\":{\"720\":1}}],[\"支持定时及周期性任务执行\",{\"1\":{\"672\":1}}],[\"支持重入\",{\"1\":{\"617\":1}}],[\"支持泛型\",{\"1\":{\"510\":1}}],[\"支持指针\",{\"1\":{\"443\":1}}],[\"支持网络编程并且很方便\",{\"1\":{\"442\":1}}],[\"支持多继承\",{\"1\":{\"443\":1}}],[\"支持多线程\",{\"1\":{\"442\":1}}],[\"支持多种消息协议\",{\"1\":{\"362\":1}}],[\"支持多种序列化方式\",{\"1\":{\"212\":1}}],[\"支持多种存储引擎\",{\"1\":{\"92\":1}}],[\"支持水平扩容\",{\"1\":{\"439\":1}}],[\"支持string\",{\"1\":{\"378\":1}}],[\"支持主从复制\",{\"1\":{\"376\":1}}],[\"支持aof和rdb两种持久化方式\",{\"1\":{\"376\":1}}],[\"支持数据持久化\",{\"1\":{\"376\":1}}],[\"支持拉\",{\"1\":{\"362\":1}}],[\"支持实时的流式处理\",{\"1\":{\"325\":1}}],[\"支持当前事务\",{\"1\":{\"289\":3}}],[\"支持\",{\"1\":{\"272\":1,\"285\":1,\"443\":1,\"451\":1}}],[\"支持几种\",{\"0\":{\"272\":1}}],[\"支持基于依赖的注解\",{\"1\":{\"266\":1}}],[\"支持基本的\",{\"1\":{\"124\":1}}],[\"支持国际化\",{\"1\":{\"266\":1}}],[\"支持不同的序列化器\",{\"1\":{\"244\":1}}],[\"支持服务端暴露多个服务接口\",{\"1\":{\"212\":1}}],[\"支持的数据库\",{\"1\":{\"179\":1}}],[\"支持的功能非常完善\",{\"1\":{\"127\":1}}],[\"支持编写动态\",{\"1\":{\"179\":1}}],[\"支持编写动态sql语句\",{\"1\":{\"173\":1}}],[\"支持存储过程\",{\"1\":{\"175\":1}}],[\"支持动态\",{\"1\":{\"175\":1}}],[\"支持对象与数据库的\",{\"1\":{\"179\":1}}],[\"支持对象与数据库的orm字段关系映射\",{\"1\":{\"173\":1}}],[\"支持对象关系组件维护\",{\"1\":{\"173\":1,\"179\":1}}],[\"支持分库分表\",{\"1\":{\"126\":1}}],[\"支持行级锁\",{\"1\":{\"92\":1}}],[\"支持全文索引\",{\"1\":{\"92\":1}}],[\"支持外键\",{\"1\":{\"92\":1}}],[\"支持事务消息\",{\"1\":{\"362\":1}}],[\"支持事务\",{\"1\":{\"92\":1,\"376\":1}}],[\"支持哪些存储引擎\",{\"0\":{\"92\":1}}],[\"支持上面四种隔离级别\",{\"1\":{\"76\":1}}],[\"支持自建psub\",{\"1\":{\"71\":1}}],[\"支持一对一\",{\"1\":{\"9\":1}}],[\"支持电子邮件的smtp协议等\",{\"1\":{\"8\":1}}],[\"支持万维网应用的http协议\",{\"1\":{\"8\":1}}],[\"越多\",{\"1\":{\"545\":1}}],[\"越容易挂掉\",{\"1\":{\"349\":1}}],[\"越少越好\",{\"1\":{\"157\":1}}],[\"到底体现在哪里呢\",{\"1\":{\"516\":1}}],[\"到处运行\",{\"1\":{\"442\":1,\"445\":1}}],[\"到\",{\"1\":{\"348\":1}}],[\"到了后期\",{\"1\":{\"310\":1}}],[\"到了后面你的\",{\"1\":{\"121\":1}}],[\"到了一个新的月份的时候\",{\"1\":{\"128\":1}}],[\"哪个slave复制了越多的数据\",{\"1\":{\"426\":1}}],[\"哪个系统需要数据自己去\",{\"1\":{\"346\":1}}],[\"哪怕是高峰期的时候\",{\"1\":{\"348\":1}}],[\"哪些可降级\",{\"1\":{\"398\":1}}],[\"哪些列上适合创建索引\",{\"0\":{\"85\":1}}],[\"哪些是已经被对方确认接收的\",{\"1\":{\"12\":1}}],[\"头节点占有锁\",{\"1\":{\"602\":1}}],[\"头插法\",{\"1\":{\"559\":1}}],[\"头发都白了啊\",{\"1\":{\"346\":1}}],[\"头部信息\",{\"1\":{\"319\":1}}],[\"头部的位置\",{\"1\":{\"71\":2}}],[\"头部压缩\",{\"1\":{\"34\":1}}],[\"四个原语实现的\",{\"1\":{\"409\":1}}],[\"四个系统如果挂了该咋办\",{\"1\":{\"346\":1}}],[\"四次挥手阶段的包丢失了怎么办\",{\"1\":{\"19\":1}}],[\"场景\",{\"1\":{\"346\":1,\"347\":1,\"348\":1,\"382\":1,\"401\":1,\"598\":2}}],[\"邮件等\",{\"1\":{\"345\":1}}],[\"削峰的好处就是避免高并发压垮系统的关键组件\",{\"1\":{\"345\":1}}],[\"削峰\",{\"0\":{\"348\":1},\"1\":{\"345\":2}}],[\"异同点\",{\"0\":{\"571\":1}}],[\"异或其右移十六位的值\",{\"1\":{\"555\":1}}],[\"异步并非阻塞\",{\"1\":{\"542\":1}}],[\"异步复制导致的数据丢失\",{\"1\":{\"423\":1}}],[\"异步串行化\",{\"1\":{\"392\":1}}],[\"异步操作\",{\"1\":{\"383\":1}}],[\"异步\",{\"0\":{\"347\":1},\"1\":{\"345\":2}}],[\"异常结束\",{\"1\":{\"640\":1}}],[\"异常描述以及异常发生时应用程序的状态\",{\"1\":{\"537\":1}}],[\"异常\",{\"0\":{\"529\":1},\"1\":{\"263\":1,\"484\":1,\"510\":1,\"530\":1}}],[\"异常处理的重要子类\",{\"1\":{\"530\":1}}],[\"异常处理部分还不完善\",{\"1\":{\"417\":1}}],[\"异常处理\",{\"1\":{\"263\":1}}],[\"显的缺点\",{\"1\":{\"342\":1}}],[\"显然是不合理的\",{\"1\":{\"718\":1}}],[\"显然不是\",{\"1\":{\"614\":1}}],[\"显然不是结果\",{\"1\":{\"555\":1}}],[\"显然线程安全\",{\"1\":{\"481\":1}}],[\"显然\",{\"1\":{\"340\":1,\"536\":1}}],[\"显然在一个应用中我们不可能只传输一种类型的数据\",{\"1\":{\"223\":1}}],[\"显然成本太大\",{\"1\":{\"161\":1}}],[\"体现在大多数的hashmap类的操作\",{\"1\":{\"554\":1,\"578\":1}}],[\"体现zero\",{\"1\":{\"341\":1}}],[\"体现为该单例的成员属性\",{\"1\":{\"282\":1}}],[\"短整型\",{\"1\":{\"449\":1}}],[\"短信\",{\"1\":{\"345\":1}}],[\"短暂的不同步我们可以关注\",{\"1\":{\"339\":1}}],[\"短时间内关闭了大量的client连接\",{\"1\":{\"20\":1}}],[\"允许开发同学简单的查看\",{\"1\":{\"720\":1}}],[\"允许线程池监听同步外部的消息\",{\"1\":{\"720\":1}}],[\"允许多个线程同时访问\",{\"1\":{\"681\":1}}],[\"允许存放值为\",{\"1\":{\"548\":1,\"588\":1}}],[\"允许预处理\",{\"1\":{\"443\":1}}],[\"允许follower副本有限度地提供读服务\",{\"1\":{\"339\":1}}],[\"允许将time\",{\"1\":{\"20\":1}}],[\"列仍然可用\",{\"1\":{\"352\":1}}],[\"列表\",{\"1\":{\"338\":1,\"378\":1}}],[\"列如\",{\"1\":{\"120\":1}}],[\"具有更高的效率\",{\"1\":{\"555\":1}}],[\"具有高性能\",{\"1\":{\"362\":1}}],[\"具有相同\",{\"1\":{\"337\":1}}],[\"具体原理见这篇文章\",{\"1\":{\"637\":1,\"708\":1}}],[\"具体原因会在另一篇文章分析\",{\"1\":{\"557\":1}}],[\"具体原因为\",{\"1\":{\"153\":1}}],[\"具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的\",{\"1\":{\"605\":1}}],[\"具体说一下hashtable的锁机制\",{\"1\":{\"549\":1}}],[\"具体装饰器\",{\"1\":{\"543\":1}}],[\"具体对象\",{\"1\":{\"543\":1}}],[\"具体是由其子类\",{\"1\":{\"617\":1}}],[\"具体是什么类型\",{\"1\":{\"511\":1}}],[\"具体是怎么操作的\",{\"0\":{\"186\":1,\"187\":1}}],[\"具体可以看下面的例子\",{\"1\":{\"505\":1}}],[\"具体分析可见我的这篇文章\",{\"1\":{\"583\":1}}],[\"具体分析\",{\"1\":{\"488\":1}}],[\"具体实现方法如下\",{\"1\":{\"607\":1}}],[\"具体实现参考\",{\"1\":{\"435\":1}}],[\"具体实现类\",{\"1\":{\"237\":1}}],[\"具体在加锁的时候把当前线程的id当做value\",{\"1\":{\"435\":1}}],[\"具体到\",{\"1\":{\"399\":1}}],[\"具体的触发时机\",{\"1\":{\"662\":1}}],[\"具体的业务逻辑用语言描述如下\",{\"1\":{\"393\":1}}],[\"具体的落盘策略可以进行配置\",{\"1\":{\"106\":1}}],[\"具体数据\",{\"1\":{\"223\":1}}],[\"具体看executor中的7步骤\",{\"1\":{\"194\":1}}],[\"具体细节取决于不同的实现\",{\"1\":{\"148\":1}}],[\"具体地\",{\"1\":{\"147\":1}}],[\"具体而言\",{\"1\":{\"19\":1}}],[\"卡在这里了\",{\"1\":{\"334\":1}}],[\"挂起consumer的请求\",{\"1\":{\"367\":1}}],[\"挂了还有一个\",{\"1\":{\"334\":1}}],[\"挂了\",{\"1\":{\"334\":1}}],[\"挂多个从库\",{\"1\":{\"131\":1}}],[\"宕机前有部分数据未能及时同步到从机\",{\"1\":{\"376\":1}}],[\"宕机\",{\"1\":{\"334\":1,\"416\":1}}],[\"宕机了\",{\"1\":{\"323\":1}}],[\"端设置\",{\"1\":{\"333\":1,\"334\":2}}],[\"端口给注册中心\",{\"1\":{\"251\":1}}],[\"端口在\",{\"1\":{\"71\":1}}],[\"端口改为80或者2052\",{\"1\":{\"61\":1}}],[\"端口发起\",{\"1\":{\"38\":1}}],[\"端口\",{\"1\":{\"35\":1,\"37\":1,\"69\":4}}],[\"拉链法\",{\"1\":{\"576\":2}}],[\"拉模式\",{\"1\":{\"329\":1}}],[\"拉你进群\",{\"1\":{\"47\":1}}],[\"磁盘的顺序写大多数情况下比随机写内存还要快\",{\"1\":{\"329\":1}}],[\"替代zookeeper\",{\"1\":{\"327\":1}}],[\"替换\",{\"1\":{\"201\":2}}],[\"替换成\",{\"1\":{\"198\":1}}],[\"替换成变量的值\",{\"1\":{\"181\":1}}],[\"替换为\",{\"1\":{\"181\":1,\"201\":1}}],[\"替换自定义域\",{\"1\":{\"70\":1}}],[\"选用动态化线程池\",{\"1\":{\"675\":1}}],[\"选择\",{\"1\":{\"673\":1}}],[\"选择性通知\",{\"1\":{\"648\":1,\"707\":1}}],[\"选择的\",{\"1\":{\"648\":1,\"707\":1}}],[\"选择了node数组+链表+红黑树结构\",{\"1\":{\"548\":1}}],[\"选择了与\",{\"1\":{\"546\":1,\"584\":1}}],[\"选择redis\",{\"1\":{\"439\":1}}],[\"选择合理的事务大小\",{\"1\":{\"120\":1}}],[\"选择合适的路由和交换结点\",{\"1\":{\"8\":1}}],[\"选项所指定的值\",{\"1\":{\"425\":1}}],[\"选举\",{\"1\":{\"327\":1}}],[\"人都以为你这个请求就成功了\",{\"1\":{\"349\":1}}],[\"人\",{\"1\":{\"327\":1}}],[\"人员流动相比于传统的项目也更加频繁\",{\"1\":{\"98\":1}}],[\"容纳键值对的最大值\",{\"1\":{\"554\":1,\"578\":1}}],[\"容错性\",{\"1\":{\"436\":1}}],[\"容易单点故障\",{\"1\":{\"432\":1}}],[\"容易出现相互影响的情况\",{\"1\":{\"417\":1}}],[\"容易造成消费者性能浪费\",{\"1\":{\"324\":1}}],[\"容易造成消费者拒绝服务或网络拥塞\",{\"1\":{\"324\":1}}],[\"容器会给每一个请求分配一个线程\",{\"1\":{\"282\":1}}],[\"容器能够自动装配\",{\"1\":{\"278\":1}}],[\"容器需要知道需要什么\",{\"1\":{\"278\":1}}],[\"容器中节点分布在\",{\"1\":{\"553\":1}}],[\"容器中\",{\"1\":{\"308\":1}}],[\"容器中组合在一起时\",{\"1\":{\"278\":1}}],[\"容器中未打开注解装配\",{\"1\":{\"268\":1}}],[\"容器管理的bean一般不需要知道容器的状态和直接使用容器\",{\"1\":{\"274\":1}}],[\"容器仅有一个单实例\",{\"1\":{\"272\":1}}],[\"容器将它们装配在一起\",{\"1\":{\"265\":1}}],[\"容器通过读取提供的配置元数据来接收对象进行实例化\",{\"1\":{\"264\":1}}],[\"容器使用依赖注入来管理组成应用程序的组件\",{\"1\":{\"264\":1}}],[\"容器创建对象\",{\"1\":{\"264\":1}}],[\"容器\",{\"0\":{\"264\":1},\"1\":{\"263\":1,\"264\":1}}],[\"拥有更多的数据结构和并支持更丰富的数据操作\",{\"1\":{\"378\":1}}],[\"拥有了\",{\"1\":{\"323\":1}}],[\"拥塞避免算法让拥塞窗口缓慢增长\",{\"1\":{\"24\":1}}],[\"拥塞避免\",{\"1\":{\"24\":2}}],[\"拥塞控制\",{\"1\":{\"22\":1}}],[\"拥塞控制和\",{\"1\":{\"22\":1}}],[\"打到所有节点上去更新\",{\"1\":{\"430\":1}}],[\"打车距离计算等\",{\"1\":{\"382\":1}}],[\"打交道\",{\"1\":{\"323\":1}}],[\"打开自动配置的功能\",{\"1\":{\"306\":1}}],[\"副本进行交互的\",{\"1\":{\"342\":1}}],[\"副本集合ar被设置成\",{\"1\":{\"340\":1}}],[\"副本同步队列\",{\"1\":{\"338\":1}}],[\"副本\",{\"1\":{\"323\":1}}],[\"副本机制\",{\"1\":{\"323\":2}}],[\"形成清晰的模型\",{\"1\":{\"621\":1,\"688\":1}}],[\"形成死循环\",{\"1\":{\"564\":1,\"583\":1}}],[\"形成返回路径之后\",{\"1\":{\"536\":1}}],[\"形成自己的多个\",{\"1\":{\"323\":1}}],[\"形式上\",{\"1\":{\"486\":1}}],[\"形象的说\",{\"1\":{\"270\":1}}],[\"机制就能实现\",{\"1\":{\"419\":1}}],[\"机制就是暂时把不经常访问的数据\",{\"1\":{\"377\":1}}],[\"机制是互斥的\",{\"1\":{\"356\":1}}],[\"机制\",{\"1\":{\"323\":1,\"377\":1}}],[\"机制的\",{\"1\":{\"323\":1}}],[\"暴露哪些头部信息\",{\"1\":{\"319\":1}}],[\"暴露两个服务接口\",{\"1\":{\"230\":1}}],[\"拦截\",{\"1\":{\"317\":1}}],[\"拦截器必须实现org\",{\"1\":{\"298\":1}}],[\"登录拦截配置\",{\"0\":{\"317\":1}}],[\"搭配interceptor\",{\"0\":{\"316\":1}}],[\"搭建workers订阅节点\",{\"0\":{\"57\":1}}],[\"整数除零等\",{\"1\":{\"534\":1}}],[\"整型数组原子类\",{\"1\":{\"683\":1}}],[\"整型原子类\",{\"1\":{\"683\":1}}],[\"整型\",{\"1\":{\"449\":1}}],[\"整个过程需要人为干预\",{\"1\":{\"415\":1}}],[\"整个过程会耗费一定的时间\",{\"1\":{\"342\":1}}],[\"整个程序架构上较为复杂\",{\"1\":{\"380\":1}}],[\"整个数据库加载在内存当中操作\",{\"1\":{\"376\":1}}],[\"整个窗口就会往右移动\",{\"1\":{\"23\":1}}],[\"整体对外提供了一套在微服务架构中服务治理的解决方案\",{\"1\":{\"310\":1}}],[\"帝国生态基础上面发展而来\",{\"1\":{\"310\":1}}],[\"帝国\",{\"1\":{\"310\":1}}],[\"启用csrf保护\",{\"1\":{\"309\":1}}],[\"启动\",{\"1\":{\"454\":1}}],[\"启动初始化的时候\",{\"1\":{\"403\":1}}],[\"启动完毕后\",{\"1\":{\"308\":1}}],[\"启动器依赖就能使用了\",{\"1\":{\"307\":1}}],[\"启动类上面的注解是\",{\"1\":{\"306\":1}}],[\"启动本地zookeeper服务端\",{\"1\":{\"251\":1}}],[\"启动netty服务器\",{\"1\":{\"237\":1}}],[\"资源开销\",{\"1\":{\"620\":1,\"687\":1}}],[\"资源隔离性较差\",{\"1\":{\"417\":1}}],[\"资源浪费\",{\"1\":{\"416\":1}}],[\"资源\",{\"1\":{\"401\":1}}],[\"资源即可\",{\"1\":{\"308\":1}}],[\"资源消耗较少\",{\"1\":{\"114\":1}}],[\"资源消耗更多\",{\"1\":{\"35\":1}}],[\"资源消耗\",{\"1\":{\"35\":1,\"415\":1}}],[\"组成\",{\"1\":{\"546\":1,\"553\":2,\"575\":2,\"584\":1}}],[\"组成一个集群\",{\"1\":{\"323\":1}}],[\"组合了\",{\"1\":{\"306\":1}}],[\"组件了解吗\",{\"0\":{\"681\":1}}],[\"组件\",{\"1\":{\"271\":1,\"291\":1}}],[\"组件之间依赖关系由容器在运行期决定\",{\"1\":{\"270\":1}}],[\"安全失败\",{\"1\":{\"598\":1}}],[\"安全效率高的原因之一\",{\"1\":{\"586\":1}}],[\"安全是一个宽泛的术语\",{\"1\":{\"303\":1}}],[\"安全性相对\",{\"1\":{\"41\":1}}],[\"安全性较高\",{\"1\":{\"35\":1}}],[\"安全性较差\",{\"1\":{\"35\":1}}],[\"安全性\",{\"1\":{\"35\":1,\"36\":1,\"442\":1}}],[\"换言之\",{\"1\":{\"383\":1}}],[\"换句话说\",{\"1\":{\"301\":1}}],[\"换另一个域名测试\",{\"1\":{\"62\":1}}],[\"知道threadlocal\",{\"0\":{\"665\":1}}],[\"知道线程进入可运行状态\",{\"1\":{\"639\":1}}],[\"知乎上的\",{\"1\":{\"300\":1}}],[\"知名的rpc框架\",{\"1\":{\"236\":1}}],[\"格式传递到客户端\",{\"1\":{\"300\":1}}],[\"格式化的\",{\"1\":{\"297\":1}}],[\"格式使用什么注解\",{\"0\":{\"297\":1}}],[\"格式的配置文件中指定\",{\"1\":{\"268\":1}}],[\"格式的数据\",{\"1\":{\"244\":1}}],[\"格式的限制\",{\"1\":{\"87\":1}}],[\"互斥条件\",{\"1\":{\"626\":1,\"693\":1}}],[\"互斥访问\",{\"1\":{\"436\":1}}],[\"互斥性\",{\"1\":{\"431\":1}}],[\"互斥锁\",{\"1\":{\"396\":1,\"661\":1}}],[\"互不干扰\",{\"1\":{\"291\":1}}],[\"互联网业务系统所要处理的线上流量越来越大\",{\"1\":{\"401\":1}}],[\"互联网电子商务系统\",{\"1\":{\"175\":1}}],[\"互联网公司的面试中\",{\"1\":{\"7\":1}}],[\"国内也有大牛曾使用\",{\"1\":{\"402\":1}}],[\"国际化\",{\"1\":{\"291\":1}}],[\"国家简写网站查询\",{\"1\":{\"65\":1}}],[\"视图不同\",{\"1\":{\"299\":1}}],[\"视图解析器\",{\"1\":{\"291\":1}}],[\"视图名称转换器\",{\"1\":{\"291\":1}}],[\"视图渲染\",{\"1\":{\"290\":1}}],[\"视频网站视频的播放数等\",{\"1\":{\"381\":1}}],[\"视频教程\",{\"0\":{\"56\":1}}],[\"视频\",{\"1\":{\"10\":1}}],[\"视频会议\",{\"1\":{\"9\":1}}],[\"声明一个integer对象\",{\"1\":{\"494\":2}}],[\"声明式事务管理\",{\"1\":{\"287\":1}}],[\"声明为内部\",{\"1\":{\"277\":1}}],[\"观察者模式\",{\"1\":{\"286\":1}}],[\"做hash\",{\"1\":{\"556\":1}}],[\"做的方法做了一层包装\",{\"1\":{\"549\":1,\"594\":1}}],[\"做\",{\"0\":{\"491\":1},\"1\":{\"484\":1}}],[\"做缓存\",{\"0\":{\"379\":1,\"380\":1},\"1\":{\"389\":1}}],[\"做动态代理的\",{\"1\":{\"284\":1}}],[\"做一些属性被设定后的自定义的事情\",{\"1\":{\"274\":1}}],[\"做一定的冗余\",{\"1\":{\"135\":1}}],[\"编写简单\",{\"1\":{\"621\":1,\"688\":1}}],[\"编程稍微复杂\",{\"1\":{\"621\":1,\"688\":1}}],[\"编程比较复杂\",{\"1\":{\"542\":2}}],[\"编程思想\",{\"1\":{\"510\":1}}],[\"编程式事务管理\",{\"1\":{\"287\":1}}],[\"编译是通不过的\",{\"1\":{\"535\":1}}],[\"编译器要求必须用catch捕获以便进一步处理\",{\"1\":{\"535\":1}}],[\"编译器看任何代码都不顺眼\",{\"1\":{\"535\":1}}],[\"编译器不会检查运行时异常\",{\"1\":{\"531\":1}}],[\"编译器不会对这类错误进行检测\",{\"1\":{\"530\":1}}],[\"编译器不知道你要调用哪个函数\",{\"1\":{\"467\":1}}],[\"编译器会检查受检查异常\",{\"1\":{\"531\":1}}],[\"编译器会额外插入一行\",{\"1\":{\"511\":1}}],[\"编译器会报错\",{\"1\":{\"457\":1}}],[\"编译器在编译的时候去掉类型参数\",{\"1\":{\"511\":1}}],[\"编译器生成的代码跟不使用泛型\",{\"1\":{\"510\":1}}],[\"编译时期就可以检查出因\",{\"1\":{\"510\":1}}],[\"编译时多态在编译时就已经确定\",{\"1\":{\"465\":1}}],[\"编译时多态\",{\"1\":{\"465\":1}}],[\"编译时编织\",{\"1\":{\"284\":1}}],[\"编译与解释并存\",{\"1\":{\"442\":1}}],[\"编码不同将直接影响数据的内存占用和读写效率\",{\"1\":{\"438\":1}}],[\"编码优化\",{\"1\":{\"438\":1}}],[\"编码需要传入序列化器\",{\"1\":{\"245\":1}}],[\"编码\",{\"1\":{\"71\":1}}],[\"静态方法和\",{\"1\":{\"649\":1}}],[\"静态常量池中cache数组是static\",{\"1\":{\"499\":1}}],[\"静态变量会被序列化吗\",{\"0\":{\"528\":1},\"1\":{\"484\":1}}],[\"静态变量只有读操作\",{\"1\":{\"282\":1}}],[\"静态代理\",{\"1\":{\"284\":1}}],[\"肯定是拿不到数据的\",{\"1\":{\"677\":1}}],[\"肯定没有\",{\"1\":{\"281\":1}}],[\"肯定要\",{\"1\":{\"141\":1}}],[\"尝试释放资源\",{\"1\":{\"678\":2}}],[\"尝试之前会利用\",{\"1\":{\"617\":1}}],[\"尝试获取资源\",{\"1\":{\"678\":2}}],[\"尝试获取同步\",{\"1\":{\"612\":1}}],[\"尝试获取确认\",{\"1\":{\"19\":1}}],[\"尝试的去把state修改为1\",{\"1\":{\"602\":1}}],[\"尝试自旋获取锁\",{\"1\":{\"547\":1}}],[\"尝试加载某类时在内存中找不到该类的定义\",{\"1\":{\"533\":1}}],[\"尝试三级缓存singletonfactories\",{\"1\":{\"281\":1}}],[\"尝试二级缓存earlysingletonobjects\",{\"1\":{\"281\":1}}],[\"尝试一级缓存singletonobjects\",{\"1\":{\"281\":1}}],[\"举个例子\",{\"1\":{\"622\":2,\"689\":2}}],[\"举个简单的例子\",{\"1\":{\"152\":1}}],[\"举两个最常见使用反射的例子\",{\"1\":{\"506\":1}}],[\"举例如下\",{\"1\":{\"532\":1}}],[\"举例\",{\"1\":{\"281\":1}}],[\"名称匹配\",{\"1\":{\"278\":1}}],[\"去除不可能存在竞争的锁\",{\"1\":{\"659\":1}}],[\"去释放锁就会造成死锁\",{\"1\":{\"647\":1}}],[\"去修改数据时\",{\"1\":{\"645\":1}}],[\"去尝试获取锁\",{\"1\":{\"610\":1}}],[\"去判断到底是否包含了这个\",{\"1\":{\"548\":1,\"588\":1}}],[\"去掉不必要的属性避免存储无效数据\",{\"1\":{\"438\":1}}],[\"去从库中拿去数据\",{\"1\":{\"391\":1}}],[\"去做一些初始化相关的工作\",{\"1\":{\"274\":1,\"276\":1}}],[\"去注册中心根据服务名找到对应的服务端地址\",{\"1\":{\"250\":1}}],[\"规范为使其无状态设置了一个约束\",{\"1\":{\"302\":1}}],[\"规范定义了全局\",{\"1\":{\"272\":1}}],[\"规范化\",{\"1\":{\"212\":1}}],[\"种不同的访问权限\",{\"1\":{\"451\":1}}],[\"种\",{\"1\":{\"272\":1,\"449\":1}}],[\"层面\",{\"1\":{\"648\":1,\"707\":1}}],[\"层面实现的\",{\"1\":{\"648\":1,\"707\":1}}],[\"层返回数据给前端页面\",{\"1\":{\"271\":1}}],[\"层\",{\"1\":{\"271\":1}}],[\"层方案\",{\"1\":{\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1}}],[\"片段的小型java\",{\"1\":{\"269\":1}}],[\"间浪费主要体现在在list列表的结尾会预留一定的容量空间\",{\"1\":{\"571\":1}}],[\"间依赖关系\",{\"1\":{\"268\":1}}],[\"间接\",{\"1\":{\"175\":1}}],[\"您始终可以使用\",{\"1\":{\"279\":1}}],[\"您需要在使用它之前在\",{\"1\":{\"268\":1}}],[\"您可以通过在相关的类\",{\"1\":{\"268\":1}}],[\"您不是直接在代码中将组件和服务连接在一起\",{\"1\":{\"265\":1}}],[\"您不必创建对象\",{\"1\":{\"265\":1}}],[\"属性赋值为\",{\"1\":{\"653\":1}}],[\"属性不存在异常\",{\"1\":{\"534\":1}}],[\"属性\",{\"1\":{\"267\":2,\"506\":1}}],[\"属于程序无法处理的错误\",{\"1\":{\"530\":1}}],[\"属于同一个consumer\",{\"1\":{\"364\":1}}],[\"属于\",{\"1\":{\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1}}],[\"属于哪个域名\",{\"1\":{\"40\":1}}],[\"系统运作大部分的状况是cpu\",{\"1\":{\"717\":1}}],[\"系统运行的速度快\",{\"1\":{\"266\":1}}],[\"系统崩溃\",{\"1\":{\"530\":1}}],[\"系统自动存储必要的信息\",{\"1\":{\"523\":1}}],[\"系统疯狂的加锁释放锁\",{\"1\":{\"432\":1}}],[\"系统上线初期\",{\"1\":{\"397\":1}}],[\"系统拥挤\",{\"1\":{\"396\":1}}],[\"系统接收到消息队列发送的消息后再次对\",{\"1\":{\"393\":1}}],[\"系统接收一个请求\",{\"1\":{\"347\":1}}],[\"系统组成则由producer\",{\"1\":{\"362\":1}}],[\"系统写库失败了\",{\"1\":{\"349\":1}}],[\"系统处理完了直接返回成功了\",{\"1\":{\"349\":1}}],[\"系统复杂度提高\",{\"1\":{\"349\":1}}],[\"系统引入的外部依赖越多\",{\"1\":{\"349\":1}}],[\"系统可用性降低\",{\"1\":{\"349\":1}}],[\"系统就会快速将积压的消息给解决掉\",{\"1\":{\"348\":1}}],[\"系统就跟其它系统彻底解耦了\",{\"1\":{\"346\":1}}],[\"系统依然会按照每秒\",{\"1\":{\"348\":1}}],[\"系统也绝对不会挂掉\",{\"1\":{\"348\":1}}],[\"系统也要这个数据呢\",{\"1\":{\"346\":1}}],[\"系统从\",{\"1\":{\"348\":1}}],[\"系统从接受一个请求到返回响应给用户\",{\"1\":{\"347\":1}}],[\"系统每秒钟最多处理\",{\"1\":{\"348\":1}}],[\"系统风平浪静\",{\"1\":{\"348\":1}}],[\"系统连续发送\",{\"1\":{\"347\":1}}],[\"系统压根儿不需要去考虑要给谁发送数据\",{\"1\":{\"346\":1}}],[\"系统产生一条数据\",{\"1\":{\"346\":1}}],[\"系统产生一条比较关键的数据\",{\"1\":{\"346\":1}}],[\"系统要时时刻刻考虑\",{\"1\":{\"346\":1}}],[\"系统将这个数据发送过来\",{\"1\":{\"346\":1}}],[\"系统跟其它各种乱七八糟的系统严重耦合\",{\"1\":{\"346\":1}}],[\"系统负责人几乎崩溃\",{\"1\":{\"346\":1}}],[\"系统现在不需要了呢\",{\"1\":{\"346\":1}}],[\"系统发送数据到\",{\"1\":{\"346\":1}}],[\"系统管理员\",{\"1\":{\"103\":1}}],[\"仅启动一个\",{\"1\":{\"722\":1}}],[\"仅能实现变量的修改可见性\",{\"1\":{\"646\":1}}],[\"仅能使用在变量级别\",{\"1\":{\"646\":1}}],[\"仅能获得10\",{\"1\":{\"481\":1}}],[\"仅靠应用程序本身无法恢复\",{\"1\":{\"530\":1}}],[\"仅用于标识可序列化的语义\",{\"1\":{\"521\":1}}],[\"仅返回值类型不同的重载是不应该允许的\",{\"1\":{\"467\":1}}],[\"仅仅会启动一个rdb\",{\"1\":{\"420\":1,\"422\":1}}],[\"仅仅在基于portlet的web应用中才有意义\",{\"1\":{\"269\":1}}],[\"仅可注册在方法上\",{\"1\":{\"295\":1}}],[\"仅支持方法级别的\",{\"1\":{\"285\":1}}],[\"仅当用户使用支持\",{\"1\":{\"272\":1}}],[\"仅在当前\",{\"1\":{\"272\":2}}],[\"仅使用构造函数和\",{\"1\":{\"265\":1}}],[\"仅8字节\",{\"1\":{\"9\":1}}],[\"控制信号量的方式有两种原子操作\",{\"1\":{\"728\":1}}],[\"控制key的数量\",{\"1\":{\"438\":1}}],[\"控制器\",{\"1\":{\"290\":1,\"292\":1,\"299\":1}}],[\"控制层\",{\"1\":{\"271\":1}}],[\"控制反转\",{\"1\":{\"263\":1}}],[\"控件字段内容不能重复\",{\"1\":{\"94\":1}}],[\"概述\",{\"0\":{\"262\":1}}],[\"轮询\",{\"1\":{\"355\":1}}],[\"轮询负载均衡\",{\"1\":{\"258\":1}}],[\"轮询法\",{\"1\":{\"46\":1}}],[\"扩容至原来的1\",{\"1\":{\"573\":1}}],[\"扩容死循环问题的分析\",{\"1\":{\"564\":1}}],[\"扩容在jdk1\",{\"1\":{\"559\":1}}],[\"扩容前的数组大小如果已经达到最大\",{\"1\":{\"558\":1,\"581\":1}}],[\"扩容机制\",{\"0\":{\"558\":1}}],[\"扩容的时候有可能导致环形链表的出现\",{\"1\":{\"564\":1,\"583\":1}}],[\"扩容的时候会导致死循环\",{\"1\":{\"557\":1}}],[\"扩容的时候很简单\",{\"1\":{\"128\":1}}],[\"扩展的问题\",{\"0\":{\"557\":1}}],[\"扩展出以下几个问题\",{\"1\":{\"555\":1}}],[\"扩展性好\",{\"1\":{\"350\":1}}],[\"扩展性\",{\"1\":{\"345\":1,\"352\":1}}],[\"扩展性也不强\",{\"1\":{\"247\":1}}],[\"成本在于实现动态化以及监控成本不高\",{\"1\":{\"719\":1}}],[\"成为一个对象以后就可以调用对象所声明的所有的方法\",{\"1\":{\"494\":1}}],[\"成\",{\"1\":{\"334\":1,\"564\":1}}],[\"成就了\",{\"1\":{\"310\":1}}],[\"成对应的\",{\"1\":{\"291\":1}}],[\"成员管理\",{\"1\":{\"327\":2}}],[\"成员方法\",{\"1\":{\"282\":1}}],[\"成员变量\",{\"1\":{\"201\":1,\"203\":1}}],[\"成员变量mapperinterface\",{\"1\":{\"200\":1}}],[\"成功则返回true\",{\"1\":{\"678\":3}}],[\"成功获取锁并设置过期时间\",{\"1\":{\"435\":1}}],[\"成功获取到了锁\",{\"1\":{\"435\":1}}],[\"成功得到了锁\",{\"1\":{\"435\":1}}],[\"成功运行\",{\"1\":{\"252\":1}}],[\"成功启动\",{\"1\":{\"245\":1}}],[\"暂不支持此种数据\",{\"1\":{\"244\":1}}],[\"暂时就会停止运行\",{\"1\":{\"639\":1}}],[\"暂时放弃对cpu的使用权\",{\"1\":{\"623\":1,\"690\":1}}],[\"暂时无解\",{\"1\":{\"401\":1}}],[\"暂时无法到达服务器\",{\"1\":{\"12\":1}}],[\"暂时不支持此种消息\",{\"1\":{\"244\":1}}],[\"暂时有两种实现方式\",{\"1\":{\"244\":1}}],[\"暂时只引入了lombok包\",{\"1\":{\"214\":1}}],[\"依赖于\",{\"1\":{\"648\":2,\"707\":2}}],[\"依赖注入的目的并非为软件系统带来更多功能\",{\"1\":{\"270\":1}}],[\"依赖注入\",{\"1\":{\"270\":1}}],[\"依赖注入可以通过三种方式完成\",{\"1\":{\"265\":1}}],[\"依赖是指不能存在仅依赖主关键字一部分的属性\",{\"1\":{\"91\":1}}],[\"依次按照自定义的消息格式写入\",{\"1\":{\"244\":1}}],[\"答案是体现在类编译的时候\",{\"1\":{\"516\":1}}],[\"答案二\",{\"0\":{\"392\":1}}],[\"答案一\",{\"0\":{\"391\":1}}],[\"答案就是淘汰策略\",{\"1\":{\"388\":1}}],[\"答\",{\"1\":{\"243\":1}}],[\"长整型数组原子类\",{\"1\":{\"683\":1}}],[\"长整型原子类\",{\"1\":{\"683\":1}}],[\"长整型\",{\"1\":{\"449\":1}}],[\"长度\",{\"1\":{\"237\":1}}],[\"长连接\",{\"1\":{\"33\":1}}],[\"死磕\",{\"1\":{\"682\":1}}],[\"死锁必须具备以下四个条件\",{\"0\":{\"626\":1,\"693\":1}}],[\"死锁\",{\"0\":{\"625\":1,\"692\":1}}],[\"死锁是指两个或多个事务在同一资源上相互占用\",{\"1\":{\"118\":1}}],[\"死亡状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"死循环\",{\"1\":{\"605\":1}}],[\"死循环监听\",{\"1\":{\"237\":1}}],[\"死信队列\",{\"1\":{\"356\":1}}],[\"初始化的任务\",{\"1\":{\"714\":1}}],[\"初始化的第一步\",{\"1\":{\"281\":1}}],[\"初始化一个新的entry数组\",{\"1\":{\"558\":1,\"581\":1}}],[\"初始化之前\",{\"1\":{\"274\":1}}],[\"初始化注册中心\",{\"1\":{\"251\":1}}],[\"初始化\",{\"1\":{\"237\":3,\"487\":1}}],[\"初始化找到的proxyip为null\",{\"1\":{\"71\":2}}],[\"获得锁\",{\"1\":{\"677\":1}}],[\"获得最终的视图\",{\"1\":{\"291\":1}}],[\"获得一个代理类\",{\"1\":{\"237\":1}}],[\"获取对象锁\",{\"1\":{\"732\":1}}],[\"获取对象的锁\",{\"1\":{\"732\":1}}],[\"获取对应class的信息\",{\"1\":{\"506\":1}}],[\"获取不到任务时\",{\"1\":{\"714\":1}}],[\"获取元素的线程会等待队列变为非空\",{\"1\":{\"713\":1}}],[\"获取后将锁计数器设为1也就是加1\",{\"1\":{\"651\":1}}],[\"获取jit\",{\"1\":{\"637\":1,\"708\":1}}],[\"获取同步状态后\",{\"1\":{\"613\":1}}],[\"获取同步状态\",{\"1\":{\"612\":1}}],[\"获取同步状态如下\",{\"1\":{\"612\":1}}],[\"获取同步状态失败\",{\"1\":{\"610\":1}}],[\"获取失败后\",{\"1\":{\"615\":1}}],[\"获取失败\",{\"1\":{\"612\":1}}],[\"获取成功则将当前线程置为获得锁的独占线程\",{\"1\":{\"617\":1}}],[\"获取成功则退出clh同步队列\",{\"1\":{\"611\":1}}],[\"获取成功则设置锁状态并返回true\",{\"1\":{\"610\":1}}],[\"获取成员变量列表\",{\"1\":{\"203\":2}}],[\"获取锁失败\",{\"1\":{\"617\":1}}],[\"获取锁失败后\",{\"1\":{\"607\":1}}],[\"获取锁流程仍在继续\",{\"1\":{\"614\":1}}],[\"获取锁成功后释放时\",{\"1\":{\"435\":1}}],[\"获取state的值\",{\"1\":{\"604\":1}}],[\"获取到锁后\",{\"1\":{\"585\":1}}],[\"获取到了锁\",{\"1\":{\"435\":2}}],[\"获取elementdata数组的内存空间长度\",{\"1\":{\"573\":1}}],[\"获取method对象\",{\"1\":{\"507\":1}}],[\"获取mapper根标签下的\",{\"1\":{\"204\":1}}],[\"获取信息\",{\"1\":{\"507\":1}}],[\"获取该property的子元素value的值\",{\"1\":{\"506\":1}}],[\"获取该property的name属性\",{\"1\":{\"506\":1}}],[\"获取其属性描述\",{\"1\":{\"506\":1}}],[\"获取bean的属性id和class\",{\"1\":{\"506\":1}}],[\"获取方法的\",{\"1\":{\"505\":1}}],[\"获取类的\",{\"1\":{\"505\":1}}],[\"获取想要操作的类的class对象\",{\"1\":{\"505\":1}}],[\"获取所有锁用了2s\",{\"1\":{\"437\":1}}],[\"获取当前时间戳\",{\"1\":{\"437\":1}}],[\"获取参数值的方式不同\",{\"1\":{\"296\":1}}],[\"获取特定名字下的channel中的内容\",{\"1\":{\"237\":1}}],[\"获取子标签名\",{\"1\":{\"204\":1}}],[\"获取\",{\"1\":{\"204\":1,\"404\":1}}],[\"获取xml中的根元素\",{\"1\":{\"204\":1}}],[\"获取每个变量类型\",{\"1\":{\"203\":1}}],[\"获取实体类\",{\"1\":{\"203\":1}}],[\"获取config中的mapperstatement\",{\"1\":{\"198\":1}}],[\"获取csv地址时出错\",{\"1\":{\"71\":2}}],[\"获取连接\",{\"1\":{\"198\":1}}],[\"获取dirname下文件名\",{\"1\":{\"196\":1}}],[\"获取地址时出错\",{\"1\":{\"71\":2}}],[\"获取订阅\",{\"1\":{\"71\":1}}],[\"获取订阅器默认节点\",{\"1\":{\"71\":1}}],[\"获取响应的内容\",{\"1\":{\"71\":1}}],[\"获取资源\",{\"1\":{\"29\":2}}],[\"升级到最新版本\",{\"1\":{\"309\":1}}],[\"升级2\",{\"1\":{\"237\":1,\"244\":1}}],[\"升级1\",{\"1\":{\"237\":1,\"244\":1}}],[\"升级过程\",{\"0\":{\"237\":1,\"244\":1,\"251\":1,\"258\":1}}],[\"客户中添加新的测试用例\",{\"1\":{\"231\":1}}],[\"客户端有连接请求的时候\",{\"1\":{\"542\":1}}],[\"客户端从文件中或网络上获得序列化后的对象字节流\",{\"1\":{\"518\":1}}],[\"客户端可以清空事务队列\",{\"1\":{\"409\":1}}],[\"客户端可以继续向服务器发送任意多条命令\",{\"1\":{\"409\":1}}],[\"客户端可以通过expireat和pexpireat命令\",{\"1\":{\"387\":1}}],[\"客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间\",{\"1\":{\"387\":1}}],[\"客户端可以用这些命令实现自己的业务逻辑\",{\"1\":{\"354\":1}}],[\"客户端可以确认自己发送能力和接收能力正常\",{\"1\":{\"12\":1}}],[\"客户端每次发起请求都要先与zookeeper进行通信得到地址\",{\"1\":{\"261\":1}}],[\"客户端netty的实现\",{\"1\":{\"237\":1}}],[\"客户端代码重构完毕\",{\"1\":{\"237\":1}}],[\"客户端更加松耦合\",{\"1\":{\"225\":1}}],[\"客户端调用不同的方法\",{\"1\":{\"223\":1}}],[\"客户端根据不同的service进行动态代理\",{\"1\":{\"223\":1}}],[\"客户端与服务器端就要负责封装与解析以上结构数据\",{\"1\":{\"223\":1}}],[\"客户端只知道service接口\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"客户端只知道接口名\",{\"1\":{\"223\":1}}],[\"客户端只是发送处请求报文段\",{\"1\":{\"12\":1}}],[\"客户端不够通用\",{\"1\":{\"219\":1}}],[\"客户端不向服务端发送确认数据包\",{\"1\":{\"43\":1}}],[\"客户端启动失败\",{\"1\":{\"216\":1}}],[\"客户端建立socket连接\",{\"1\":{\"216\":1}}],[\"客户端查询了\",{\"1\":{\"216\":1,\"230\":1}}],[\"客户端和服务端共有的\",{\"1\":{\"216\":1}}],[\"客户端和服务器终于建立了安全连接\",{\"1\":{\"37\":1}}],[\"客户端和服务器之间用于传输http数据的\",{\"1\":{\"31\":1}}],[\"客户端和服务器进入established状态\",{\"1\":{\"11\":1}}],[\"客户端需要得到这个pojo对象数据\",{\"1\":{\"216\":1}}],[\"客户端缓存服务地址列表\",{\"1\":{\"212\":1}}],[\"客户端的io请求都是通过操作系统先完成之后\",{\"1\":{\"542\":1}}],[\"客户端的不成熟影响业务的稳定性\",{\"1\":{\"417\":1}}],[\"客户端的改造\",{\"1\":{\"251\":1}}],[\"客户端的代码太乱了\",{\"1\":{\"237\":1}}],[\"客户端的动态代理完成对request消息格式的封装\",{\"1\":{\"212\":1}}],[\"客户端的ack应答\",{\"1\":{\"15\":1}}],[\"客户端通过这个接口调用服务端的实现类\",{\"1\":{\"216\":1,\"223\":1}}],[\"客户端通过\",{\"1\":{\"99\":1}}],[\"客户端通过tcp连接发送连接请求到mysql连接器\",{\"1\":{\"88\":1}}],[\"客户端通过http协议和服务器进行cookie交互\",{\"1\":{\"42\":1}}],[\"客户端选项的tls选项必须关闭\",{\"1\":{\"69\":2}}],[\"客户端选项的伪装域名\",{\"1\":{\"69\":2}}],[\"客户端地址\",{\"1\":{\"69\":4}}],[\"客户端必要文明参数如下\",{\"1\":{\"69\":4}}],[\"客户端向服务端发送请求链接数据包\",{\"1\":{\"43\":1}}],[\"客户端向服务端发送连接释放报文\",{\"1\":{\"16\":1}}],[\"客户端存储\",{\"1\":{\"42\":1}}],[\"客户端关闭或者\",{\"1\":{\"41\":1}}],[\"客户端得到\",{\"1\":{\"38\":1}}],[\"客户端使用相同的密钥\",{\"1\":{\"37\":1}}],[\"客户端把加密后的随机码\",{\"1\":{\"37\":1}}],[\"客户端就会从服务器证书中取出服务器的公钥a\",{\"1\":{\"37\":1}}],[\"客户端就进入了\",{\"1\":{\"16\":1}}],[\"客户端解析证书并对其进行验证\",{\"1\":{\"37\":1}}],[\"客户端请求\",{\"1\":{\"37\":1}}],[\"客户端请求有语法错误\",{\"1\":{\"27\":1}}],[\"客户端请求建立连接\",{\"1\":{\"11\":1}}],[\"客户端time\",{\"1\":{\"20\":1}}],[\"客户端等待\",{\"1\":{\"18\":1}}],[\"客户端第四次挥手的\",{\"1\":{\"18\":1}}],[\"客户端知道第三次握手失败\",{\"1\":{\"15\":1}}],[\"客户端认为这个连接已经建立\",{\"1\":{\"15\":1}}],[\"客户端认为连接已建立\",{\"1\":{\"13\":1}}],[\"客户端\",{\"1\":{\"15\":1,\"18\":1,\"215\":1,\"245\":1,\"290\":1}}],[\"客户端收到服务端的连接释放报文后\",{\"1\":{\"16\":1}}],[\"客户端收到服务端的确认后\",{\"1\":{\"11\":1}}],[\"客户端收\",{\"1\":{\"13\":1}}],[\"客户端确认\",{\"1\":{\"13\":1}}],[\"客户端发送的连接请求都会注册到多路复用器上\",{\"1\":{\"542\":1}}],[\"客户端发起一次请求调用\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"客户端发\",{\"1\":{\"13\":2}}],[\"客户端在发送完最后一个\",{\"1\":{\"18\":1}}],[\"客户端在收到\",{\"1\":{\"12\":1}}],[\"客户端在长时间得不到应答的情况下重新发送请求报文段\",{\"1\":{\"12\":1}}],[\"博客\",{\"1\":{\"230\":1}}],[\"博主文章\",{\"1\":{\"54\":1}}],[\"封装线程池\",{\"1\":{\"720\":1}}],[\"封装的很好\",{\"1\":{\"677\":1}}],[\"封装是面向对象的特征之一\",{\"1\":{\"464\":1}}],[\"封装最好理解了\",{\"1\":{\"464\":1}}],[\"封装数据\",{\"1\":{\"237\":1}}],[\"封装不同的service请求为request对象\",{\"1\":{\"237\":1}}],[\"封装成response\",{\"1\":{\"230\":1}}],[\"封装\",{\"1\":{\"223\":1,\"442\":1,\"464\":2}}],[\"封装为mapperstatement对象\",{\"1\":{\"198\":1}}],[\"上图中淡绿色背景覆盖的是集合体系中常用的实现类\",{\"1\":{\"569\":1}}],[\"上图的一个笔误的小问题\",{\"1\":{\"290\":1}}],[\"上有详细的说明\",{\"1\":{\"493\":1}}],[\"上述命令执行都是立即返回的\",{\"1\":{\"435\":1}}],[\"上述分布式锁存在的问题\",{\"0\":{\"435\":1}}],[\"上述情况就会导致不一致的情形出现\",{\"1\":{\"390\":1}}],[\"上面列表中的\",{\"1\":{\"729\":1}}],[\"上面讲到锁有四种状态\",{\"1\":{\"655\":1}}],[\"上面的代码在运行时会发生强制类型转换异常\",{\"1\":{\"510\":1}}],[\"上面的代码整个的输出结果是\",{\"1\":{\"505\":1}}],[\"上面的class对象是在加载类时由jvm构造的\",{\"1\":{\"507\":1}}],[\"上面的配置的意思是要求至少有1个slave\",{\"1\":{\"424\":1}}],[\"上面有某个\",{\"1\":{\"323\":1}}],[\"上加入了\",{\"1\":{\"417\":1}}],[\"上从而降低吞吐量\",{\"1\":{\"401\":1}}],[\"上线n台consumer同时消费临时topic中的数据\",{\"1\":{\"371\":1}}],[\"上线一台consumer做消息的搬运工\",{\"1\":{\"371\":1}}],[\"上线了多台也在短时间内无法消费完堆积的消息怎么办\",{\"0\":{\"371\":1}}],[\"上去\",{\"1\":{\"323\":1}}],[\"上的事件来选择对应的事件处理器来处理这个事件\",{\"1\":{\"403\":1}}],[\"上的数据即可\",{\"1\":{\"323\":1}}],[\"上的数据都会同步到其它机器\",{\"1\":{\"323\":1}}],[\"上的\",{\"1\":{\"323\":2}}],[\"上\",{\"0\":{\"450\":3},\"1\":{\"323\":1}}],[\"上层进行封装\",{\"1\":{\"223\":1}}],[\"上个例子中response传输的是user对象\",{\"1\":{\"223\":1}}],[\"上传文件\",{\"1\":{\"29\":2}}],[\"动态调参\",{\"1\":{\"720\":1}}],[\"动态化线程池提供如下功能\",{\"1\":{\"720\":1}}],[\"动态化线程池整体设计\",{\"1\":{\"720\":1}}],[\"动态化线程池的核心设计包括以下三个方面\",{\"1\":{\"720\":1}}],[\"动态加载类到内存的时候\",{\"1\":{\"533\":1}}],[\"动态配置实例的属性\",{\"1\":{\"506\":1}}],[\"动态列表\",{\"1\":{\"363\":1}}],[\"动态代理的核心是\",{\"1\":{\"284\":1}}],[\"动态代理类\",{\"1\":{\"284\":1}}],[\"动态代理service类\",{\"1\":{\"237\":1}}],[\"动态代理封装request对象\",{\"1\":{\"223\":1}}],[\"动态代理\",{\"1\":{\"221\":1,\"223\":1,\"284\":2}}],[\"动态生成表名\",{\"1\":{\"175\":1}}],[\"甚至导致数据库承受不住而宕机崩溃\",{\"1\":{\"395\":1}}],[\"甚至连消息格式都没有统一\",{\"1\":{\"218\":1}}],[\"甚至是某个数据库上的某个表\",{\"1\":{\"129\":1}}],[\"​\",{\"1\":{\"215\":1}}],[\"目的是将所有可用的处理能力用来提升程序的性能\",{\"1\":{\"706\":1}}],[\"目的是为了提高清晰度\",{\"1\":{\"295\":1}}],[\"目的就是为了来处理runnable不支持的用例\",{\"1\":{\"629\":1,\"696\":1}}],[\"目的往往是为了节省空间\",{\"1\":{\"560\":1}}],[\"目标角色\",{\"1\":{\"543\":2}}],[\"目录\",{\"0\":{\"212\":1}}],[\"目前无法直接保证操作的原子性的\",{\"1\":{\"645\":1}}],[\"目前仅jediscluster相对成熟\",{\"1\":{\"417\":1}}],[\"目前主线程只能利用一个核\",{\"1\":{\"401\":1}}],[\"目前主要用第三和第四种方案\",{\"1\":{\"389\":1}}],[\"目前\",{\"1\":{\"327\":1,\"353\":1}}],[\"目前社区也还一直在开发和维护\",{\"1\":{\"126\":1}}],[\"目前使用的也不多\",{\"1\":{\"124\":1}}],[\"目前使用肥羊的订阅转换功能\",{\"1\":{\"71\":1}}],[\"序列化接口没有方法或字段\",{\"1\":{\"521\":1}}],[\"序列化以后就都是字节流了\",{\"1\":{\"519\":1}}],[\"序列化可以将内存中的类写入文件或数据库中\",{\"1\":{\"519\":1}}],[\"序列化一个对象可能得到整个对象序列\",{\"1\":{\"519\":1}}],[\"序列化是把对象转换成有序字节流\",{\"1\":{\"518\":1}}],[\"序列化中如果有些字段不想进行序列化\",{\"0\":{\"527\":1},\"1\":{\"484\":1}}],[\"序列化实现的方式有哪些\",{\"0\":{\"520\":1},\"1\":{\"484\":1}}],[\"序列化及配置类\",{\"0\":{\"314\":1}}],[\"序列化字节数组里包含类信息\",{\"1\":{\"244\":1}}],[\"序列化器的接口\",{\"1\":{\"244\":1}}],[\"序列化后的data\",{\"1\":{\"244\":3}}],[\"序列化后的数据\",{\"1\":{\"244\":1}}],[\"序列化后的字节数组\",{\"1\":{\"244\":1}}],[\"序列化方式\",{\"1\":{\"237\":1,\"244\":2,\"246\":1}}],[\"序列化要减少字节流长度\",{\"1\":{\"236\":1}}],[\"序列化\",{\"0\":{\"517\":1},\"1\":{\"210\":1,\"484\":1,\"518\":1}}],[\"序列号的作用不仅仅是应答的作用\",{\"1\":{\"22\":1}}],[\"序列号\",{\"1\":{\"16\":4,\"22\":2}}],[\"序列号为\",{\"1\":{\"11\":1}}],[\"学习一个zookeeper启动的例子\",{\"1\":{\"251\":1}}],[\"学习建议\",{\"1\":{\"206\":1}}],[\"学习使用门槛低\",{\"1\":{\"175\":1}}],[\"学习使用门槛高\",{\"1\":{\"175\":1}}],[\"子类通过继承的方式\",{\"1\":{\"609\":1}}],[\"子类不会覆盖父类的构造函数\",{\"1\":{\"468\":1}}],[\"子类对父类中某些方法进行重新定义\",{\"1\":{\"465\":1}}],[\"子类\",{\"1\":{\"464\":1}}],[\"子类可以使用该方法\",{\"1\":{\"454\":1}}],[\"子标签名\",{\"1\":{\"204\":1}}],[\"子查询表小的用in\",{\"1\":{\"96\":1}}],[\"根本区别\",{\"1\":{\"620\":1,\"687\":1}}],[\"根本不认识它\",{\"1\":{\"458\":1}}],[\"根标签的属性\",{\"1\":{\"204\":1}}],[\"根据消息进行修改配置\",{\"1\":{\"720\":1}}],[\"根据任务请求进行线程的分配\",{\"1\":{\"711\":1}}],[\"根据阻塞产生的原因不同\",{\"1\":{\"623\":1,\"690\":1}}],[\"根据reentrantlock初始化选择的公平锁和非公平锁\",{\"1\":{\"615\":1}}],[\"根据request中的interface调用服务端中相关实现类\",{\"1\":{\"230\":1}}],[\"根据字节流中所保存的对象状态及描述信息\",{\"1\":{\"518\":1}}],[\"根据这个字符串获得某个类的class实例\",{\"1\":{\"506\":1}}],[\"根据这个表里面的结果的外键id\",{\"1\":{\"186\":1,\"187\":1}}],[\"根据二进制代码许可协议获得许可\",{\"1\":{\"447\":1}}],[\"根据读请求的qps来决定加多少个redis从实例\",{\"1\":{\"439\":1}}],[\"根据公司的基础环境配置\",{\"1\":{\"415\":1}}],[\"根据唯一标识路由之后\",{\"1\":{\"392\":1}}],[\"根据数据的唯一标识\",{\"1\":{\"392\":1}}],[\"根据客户端的\",{\"1\":{\"294\":1}}],[\"根据注解信息\",{\"1\":{\"292\":1}}],[\"根据视图名和国际化\",{\"1\":{\"291\":1}}],[\"根据请求信息调用\",{\"1\":{\"290\":1}}],[\"根据其实现的aware接口\",{\"1\":{\"276\":1}}],[\"根据不同的负载均衡策略选择一个\",{\"1\":{\"258\":1}}],[\"根据服务名查询地址时\",{\"1\":{\"254\":1}}],[\"根据服务名查找地址\",{\"1\":{\"251\":1}}],[\"根据服务名返回地址\",{\"1\":{\"251\":1}}],[\"根据服务器性能不同加权\",{\"1\":{\"46\":1}}],[\"根据类信息把jsonobject\",{\"1\":{\"244\":1}}],[\"根据类型得到相应的序列化器\",{\"1\":{\"244\":1}}],[\"根据序号取出序列化器\",{\"1\":{\"244\":1}}],[\"根据interfacename在serviceprovide\",{\"1\":{\"230\":1}}],[\"根据获得的标签属性为\",{\"1\":{\"204\":1}}],[\"根据变量类型\",{\"1\":{\"203\":1}}],[\"根据接口名+方法名获取对应\",{\"1\":{\"200\":1}}],[\"根据传入的sqlsession和mapper成员变量创建一个mapperproxy对象\",{\"1\":{\"200\":1}}],[\"根据statementid获取mapperstatement对象\",{\"1\":{\"197\":1}}],[\"根据表达式的值动态拼接sql\",{\"1\":{\"190\":1}}],[\"根据你模块的耦合度\",{\"1\":{\"135\":1}}],[\"根据事务开始的时间不同\",{\"1\":{\"111\":1}}],[\"根据语句来选用是\",{\"1\":{\"108\":1}}],[\"根据\",{\"1\":{\"106\":1,\"308\":2,\"403\":1,\"447\":1,\"505\":1,\"510\":1,\"547\":3,\"555\":1,\"579\":1,\"585\":1}}],[\"根据中数据的物理顺序与键值的逻辑\",{\"1\":{\"79\":1,\"148\":1}}],[\"根据以上流程可知\",{\"1\":{\"40\":1}}],[\"继承于vector\",{\"1\":{\"570\":1}}],[\"继承自\",{\"1\":{\"549\":1}}],[\"继承了\",{\"1\":{\"546\":1,\"584\":1}}],[\"继承adaptee类\",{\"1\":{\"543\":1}}],[\"继承是指这样一种能力\",{\"1\":{\"464\":1}}],[\"继承中代码块执行顺序\",{\"1\":{\"461\":1}}],[\"继承和多态\",{\"1\":{\"443\":1}}],[\"继承\",{\"1\":{\"442\":1,\"463\":1,\"464\":1,\"465\":2}}],[\"继承invocationhandler\",{\"1\":{\"200\":1}}],[\"继续走return\",{\"1\":{\"536\":1}}],[\"继续执行下次循环\",{\"1\":{\"452\":1}}],[\"继续复制下去\",{\"1\":{\"420\":1,\"422\":1}}],[\"继续消费之前的topic\",{\"1\":{\"371\":1}}],[\"继续resultset\",{\"1\":{\"203\":1}}],[\"泛型类型必须用限定内的类型来进行初始化\",{\"1\":{\"512\":1}}],[\"泛型类型都会以\",{\"1\":{\"511\":1}}],[\"泛型翻译\",{\"1\":{\"511\":1}}],[\"泛型只存在于编译阶段\",{\"1\":{\"511\":1}}],[\"泛型这种语法糖的基本原理是类型擦除\",{\"1\":{\"511\":1}}],[\"泛型的一个附带好处是\",{\"1\":{\"510\":1}}],[\"泛型的主要目标是提高\",{\"1\":{\"510\":1}}],[\"泛型出现的动机在于\",{\"1\":{\"510\":1}}],[\"泛型方法\",{\"1\":{\"509\":1}}],[\"泛型接口\",{\"1\":{\"509\":1}}],[\"泛型就是将类型参数化\",{\"1\":{\"509\":1}}],[\"泛型是一种语法糖\",{\"1\":{\"511\":1}}],[\"泛型是\",{\"1\":{\"509\":1}}],[\"泛型不能使用基本类型\",{\"1\":{\"493\":1}}],[\"泛型\",{\"0\":{\"508\":1},\"1\":{\"203\":1,\"484\":1}}],[\"正好\",{\"1\":{\"728\":1}}],[\"正数表示成功\",{\"1\":{\"678\":1}}],[\"正常结束\",{\"1\":{\"640\":1}}],[\"正常情况下\",{\"1\":{\"565\":1}}],[\"正常的rehash\",{\"1\":{\"564\":1}}],[\"正常的调用\",{\"1\":{\"505\":1}}],[\"正常的话\",{\"1\":{\"370\":1}}],[\"正常处理顺序是新增\",{\"1\":{\"335\":1}}],[\"正则匹配\",{\"1\":{\"201\":1}}],[\"正例\",{\"1\":{\"136\":1}}],[\"需实现序列化接口\",{\"1\":{\"200\":1}}],[\"需要创建两个管道\",{\"1\":{\"731\":1}}],[\"需要调用下面的方法\",{\"1\":{\"722\":1}}],[\"需要调用release\",{\"1\":{\"613\":1}}],[\"需要什么设置\",{\"1\":{\"722\":1}}],[\"需要在文件系统创建一个类型为\",{\"1\":{\"731\":1}}],[\"需要在线程长时间不运行的时候进行回收\",{\"1\":{\"714\":1}}],[\"需要在自己本地写库\",{\"1\":{\"347\":1}}],[\"需要通过比较参数maximumpoolsize\",{\"1\":{\"671\":1}}],[\"需要重新从主内存中load操作或assign操作初始化变量值\",{\"1\":{\"650\":1}}],[\"需要重传\",{\"1\":{\"22\":1}}],[\"需要从主存中读取\",{\"1\":{\"646\":1}}],[\"需要读写的内存值\",{\"1\":{\"644\":1}}],[\"需要别的线程调用同一个对象上的\",{\"1\":{\"633\":1,\"701\":1}}],[\"需要一直等待么\",{\"1\":{\"614\":1}}],[\"需要一层动态代理根据反射封装不同的service\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"需要同步\",{\"1\":{\"546\":1}}],[\"需要显式地使用\",{\"1\":{\"533\":1}}],[\"需要解析字节码\",{\"1\":{\"502\":1}}],[\"需要解决netty的粘包问题\",{\"1\":{\"237\":1}}],[\"需要注意浅拷贝和深拷贝的区别\",{\"1\":{\"471\":1}}],[\"需要注意的是\",{\"1\":{\"326\":1}}],[\"需要释放锁\",{\"1\":{\"434\":1}}],[\"需要自己加锁和释放锁\",{\"1\":{\"647\":1}}],[\"需要自己不断去尝试获取锁\",{\"1\":{\"432\":1}}],[\"需要自动容错容灾的时候使用\",{\"1\":{\"413\":1}}],[\"需要majority\",{\"1\":{\"428\":1}}],[\"需要建立配套的周边设施\",{\"1\":{\"418\":1}}],[\"需要建立两表间的关系并引用主表的列\",{\"1\":{\"87\":1}}],[\"需要开发\",{\"1\":{\"415\":1}}],[\"需要开发人员自己实现安全机制\",{\"1\":{\"303\":1}}],[\"需要依靠客户端来实现往集群中分片写入数据\",{\"1\":{\"378\":1}}],[\"需要特别注意的是redis并没有使用os提供的swap\",{\"1\":{\"377\":1}}],[\"需要增加更多的机器资源\",{\"1\":{\"350\":1}}],[\"需要考虑的东西更多\",{\"1\":{\"349\":1}}],[\"需要考虑数据冗余\",{\"1\":{\"140\":1}}],[\"需要为受影响的分区执行相应的leader选举\",{\"1\":{\"340\":1}}],[\"需要执行分区leader选举\",{\"1\":{\"340\":1}}],[\"需要等到所有的\",{\"1\":{\"333\":1}}],[\"需要等待\",{\"1\":{\"21\":1}}],[\"需要配置很多spring框架包的依赖\",{\"1\":{\"304\":1}}],[\"需要有一个调用者来实现\",{\"1\":{\"291\":1}}],[\"需要用到\",{\"1\":{\"271\":1}}],[\"需要用到的sql语句参数\",{\"1\":{\"201\":1}}],[\"需要传入服务端自身的服务的网络地址\",{\"1\":{\"251\":1}}],[\"需要持有一个serialize器\",{\"1\":{\"244\":1}}],[\"需要其它方式\",{\"1\":{\"244\":1}}],[\"需要其他地区可更改以上代码的\",{\"1\":{\"65\":1}}],[\"需要松耦合\",{\"1\":{\"226\":1}}],[\"需要抽象\",{\"1\":{\"219\":1}}],[\"需要时调用getmapper取出\",{\"1\":{\"200\":1}}],[\"需要手动把一台从服务器切换为主服务器\",{\"1\":{\"416\":1}}],[\"需要手动将一个从节点晋升为主节点\",{\"1\":{\"415\":1}}],[\"需要手动指定新的\",{\"1\":{\"413\":1}}],[\"需要手动开关连接\",{\"1\":{\"179\":1}}],[\"需要手动编写\",{\"1\":{\"175\":1}}],[\"需要手动编写sql来完成\",{\"1\":{\"174\":1}}],[\"需要把所有元素都应用函数才能比较\",{\"1\":{\"161\":1}}],[\"需要按照建立索引时的字段顺序挨个使用\",{\"1\":{\"153\":1}}],[\"需要回表查询多次\",{\"1\":{\"151\":1}}],[\"需要回表的次数越多\",{\"1\":{\"151\":1}}],[\"需要进行一次中序遍历按序来扫\",{\"1\":{\"150\":1}}],[\"需要连接查询的情况也就越多\",{\"1\":{\"140\":1}}],[\"需要检查表是否有排它锁\",{\"1\":{\"99\":1}}],[\"需要删除worker重新创建\",{\"1\":{\"69\":1,\"70\":1}}],[\"需要更多的服务器资源\",{\"1\":{\"36\":1}}],[\"需要\",{\"1\":{\"35\":1,\"178\":1,\"648\":1,\"707\":1}}],[\"工具类的不同方法按照我们的需求创建了不同的线程池\",{\"1\":{\"676\":1}}],[\"工具类\",{\"1\":{\"629\":1,\"696\":1}}],[\"工程启动的时候进行加载缓存动作\",{\"1\":{\"397\":1}}],[\"工厂设计模式\",{\"1\":{\"286\":1}}],[\"工厂类\",{\"1\":{\"200\":1}}],[\"工作线程从阻塞队列中获取任务\",{\"1\":{\"713\":1}}],[\"工作线程的创建数量几乎没有限制\",{\"1\":{\"672\":1}}],[\"工作内存\",{\"1\":{\"646\":1}}],[\"工作盗窃算法就是\",{\"1\":{\"643\":1}}],[\"工作窃取算法\",{\"1\":{\"643\":2}}],[\"工作原理了解吗\",{\"0\":{\"290\":1}}],[\"工作任务类\",{\"1\":{\"230\":1}}],[\"工作量大\",{\"1\":{\"178\":1}}],[\"按顺序获取锁就可以避免死锁\",{\"1\":{\"627\":1,\"694\":1}}],[\"按顺序地执行\",{\"1\":{\"407\":1,\"412\":1}}],[\"按某一顺序申请资源\",{\"1\":{\"627\":1,\"694\":1}}],[\"按业务来决定命名\",{\"1\":{\"434\":1}}],[\"按命令执行的先后顺序排列\",{\"1\":{\"409\":1}}],[\"按使用顺序排序的\",{\"1\":{\"291\":1}}],[\"按照这个思路自定义一个队列\",{\"1\":{\"721\":1}}],[\"按照线程在队列中的排队顺序\",{\"1\":{\"680\":1}}],[\"按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表\",{\"1\":{\"553\":1}}],[\"按照处理数据的单位\",{\"1\":{\"539\":1}}],[\"按照实现功能分\",{\"1\":{\"539\":1}}],[\"按照流的方向\",{\"1\":{\"539\":1}}],[\"按照slave优先级进行排序\",{\"1\":{\"426\":1}}],[\"按照约定去读取\",{\"1\":{\"308\":1}}],[\"按照自定义的消息格式解码数据\",{\"1\":{\"244\":1}}],[\"按照锁的粒度分数据库锁有哪些\",{\"0\":{\"114\":1}}],[\"按标签id\",{\"1\":{\"198\":1}}],[\"按注释中的7步走\",{\"1\":{\"198\":1}}],[\"得到的结果如下图所示\",{\"1\":{\"564\":1}}],[\"得到的结果最后一位永远都是0\",{\"1\":{\"555\":1}}],[\"得到了\",{\"1\":{\"548\":1,\"588\":1}}],[\"得到对应实体类的字节码字符串以及相关的属性信息\",{\"1\":{\"506\":1}}],[\"得到序列化数组\",{\"1\":{\"244\":1}}],[\"得到服务端相应服务实现类\",{\"1\":{\"230\":1,\"237\":1}}],[\"得到服务名\",{\"1\":{\"230\":1,\"237\":1}}],[\"得到结果\",{\"1\":{\"230\":1}}],[\"得到结果集resultset\",{\"1\":{\"198\":1}}],[\"得到响应response\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"得到返回的user对象\",{\"1\":{\"216\":1}}],[\"得到xml文件路径\",{\"1\":{\"196\":1}}],[\"构造同步节点\",{\"1\":{\"605\":1}}],[\"构造器不能被继承\",{\"1\":{\"468\":1}}],[\"构造器\",{\"0\":{\"468\":1}}],[\"构造代码块\",{\"1\":{\"461\":2}}],[\"构造函数允许用户传入的容量不是\",{\"1\":{\"555\":1}}],[\"构造函数\",{\"1\":{\"278\":1,\"461\":1}}],[\"构造函数注入\",{\"1\":{\"265\":1,\"267\":1}}],[\"构造方法来制定是否是公平的\",{\"1\":{\"648\":1,\"707\":1}}],[\"构造方法\",{\"1\":{\"194\":1,\"196\":1,\"197\":1}}],[\"构建一个使用java\",{\"1\":{\"237\":1}}],[\"构建一颗b+树只能根据一个值来构建\",{\"1\":{\"84\":1}}],[\"及时调用remove\",{\"1\":{\"665\":1}}],[\"及其子类之外的异常\",{\"1\":{\"531\":1}}],[\"及其他技术\",{\"1\":{\"307\":1}}],[\"及返回类型\",{\"1\":{\"193\":1}}],[\"及指向含这些关键字记录的指针\",{\"1\":{\"149\":1}}],[\"手写一个rpc\",{\"1\":{\"206\":1}}],[\"手写简易mini\",{\"1\":{\"192\":2}}],[\"手动填写\",{\"1\":{\"58\":1}}],[\"外部类\",{\"1\":{\"451\":2}}],[\"外加master宕机的时长\",{\"1\":{\"426\":1}}],[\"外\",{\"1\":{\"181\":1}}],[\"外键\",{\"1\":{\"93\":1}}],[\"外键分别是什么\",{\"0\":{\"93\":1}}],[\"外键约束\",{\"1\":{\"87\":1}}],[\"入门是一个\",{\"1\":{\"299\":1}}],[\"入口不同\",{\"1\":{\"299\":1}}],[\"入\",{\"1\":{\"181\":1}}],[\"值新增的那个bit是1还是0就好了\",{\"1\":{\"559\":1}}],[\"值对数组长度取模运算\",{\"1\":{\"555\":1}}],[\"值对象缩减比较复杂\",{\"1\":{\"438\":1}}],[\"值要与length\",{\"1\":{\"555\":1}}],[\"值的时间\",{\"1\":{\"559\":1}}],[\"值的性能会稍差一点点\",{\"1\":{\"555\":1}}],[\"值的对象\",{\"1\":{\"478\":1}}],[\"值获取定位\",{\"1\":{\"547\":1}}],[\"值定位到具体的\",{\"1\":{\"547\":1}}],[\"值是多少无所谓\",{\"1\":{\"525\":1}}],[\"值作比较\",{\"1\":{\"478\":1}}],[\"值来判断对象加入的位置\",{\"1\":{\"478\":1}}],[\"值传递\",{\"1\":{\"474\":1}}],[\"值传递和引用传递的区别的什么\",{\"0\":{\"474\":1}}],[\"值\",{\"1\":{\"181\":1,\"474\":1,\"477\":1,\"486\":1,\"493\":1,\"547\":2,\"555\":1,\"556\":1,\"579\":1,\"580\":1,\"644\":1}}],[\"值重新分配到不同的库或表\",{\"1\":{\"128\":1}}],[\"号\",{\"1\":{\"181\":1}}],[\"字节输出流转字符输出流通过\",{\"1\":{\"540\":1}}],[\"字节输入流转字符输入流通过\",{\"1\":{\"540\":1}}],[\"字节流适合所有类型文件的数据传输\",{\"1\":{\"541\":1}}],[\"字节流和字符流\",{\"1\":{\"539\":1}}],[\"字节流如何转为字符流\",{\"0\":{\"540\":1},\"1\":{\"484\":1}}],[\"字节\",{\"1\":{\"449\":1}}],[\"字节型\",{\"1\":{\"449\":1}}],[\"字节数组\",{\"1\":{\"244\":2}}],[\"字符流只能够处理纯文本数据\",{\"1\":{\"541\":1}}],[\"字符流按字符读写\",{\"1\":{\"541\":1}}],[\"字符流与字节流的区别\",{\"0\":{\"541\":1},\"1\":{\"484\":1}}],[\"字符常量只占2个字节\",{\"1\":{\"486\":1}}],[\"字符常量相当于一个整型值\",{\"1\":{\"486\":1}}],[\"字符常量是单引号引起的一个字符\",{\"1\":{\"486\":1}}],[\"字符型常量和字符串常量的区别\",{\"0\":{\"486\":1},\"1\":{\"484\":1}}],[\"字符型\",{\"1\":{\"449\":1}}],[\"字符串索引越界异常\",{\"1\":{\"534\":1}}],[\"字符串转换为数字\",{\"1\":{\"531\":1}}],[\"字符串放入常量池\",{\"1\":{\"488\":1}}],[\"字符串放进常量池\",{\"1\":{\"488\":1}}],[\"字符串的地址赋给a\",{\"1\":{\"488\":1}}],[\"字符串常量池具有缓冲功能\",{\"1\":{\"649\":1}}],[\"字符串常量池的位置也是随着jdk版本的不同而位置不同\",{\"1\":{\"487\":1}}],[\"字符串常量占若干个字节\",{\"1\":{\"486\":1}}],[\"字符串常量代表一个地址值\",{\"1\":{\"486\":1}}],[\"字符串常量是双引号引起的若干个字符\",{\"1\":{\"486\":1}}],[\"字符串和类\",{\"1\":{\"279\":1}}],[\"字符串解析为地址\",{\"1\":{\"251\":1}}],[\"字符串\",{\"1\":{\"251\":1,\"378\":1,\"488\":2}}],[\"字符串替换\",{\"1\":{\"181\":1}}],[\"字段来决定是否能够获得锁\",{\"1\":{\"677\":1}}],[\"字段结构\",{\"0\":{\"554\":1}}],[\"字段关系映射\",{\"1\":{\"179\":1}}],[\"字段\",{\"1\":{\"157\":1,\"652\":1,\"677\":1}}],[\"字段比较重要\",{\"1\":{\"157\":1}}],[\"字段的数据类型是否合理等多方面的内容\",{\"1\":{\"140\":1}}],[\"字段的值为\",{\"1\":{\"112\":1}}],[\"字段为\",{\"1\":{\"112\":2}}],[\"预处理器的功能类似\",{\"1\":{\"443\":1}}],[\"预处理\",{\"1\":{\"201\":1}}],[\"预编译处理\",{\"1\":{\"181\":1}}],[\"预防措施有\",{\"1\":{\"44\":1}}],[\"预防方法有\",{\"1\":{\"43\":1}}],[\"标识\",{\"1\":{\"651\":1}}],[\"标识当前的资源是否被线程持有\",{\"1\":{\"602\":1}}],[\"标识当前线程\",{\"1\":{\"435\":1}}],[\"标识了可能抛出的异常列表\",{\"1\":{\"532\":1}}],[\"标记的变量可以被编译器优化\",{\"1\":{\"646\":1}}],[\"标记的变量不会被编译器优化\",{\"1\":{\"646\":1}}],[\"标记\",{\"1\":{\"558\":1,\"581\":1}}],[\"标记为客观下线时\",{\"1\":{\"425\":1}}],[\"标记为主观下线\",{\"1\":{\"425\":1}}],[\"标记是否开启长轮询\",{\"1\":{\"365\":1}}],[\"标准误算率是\",{\"1\":{\"382\":1}}],[\"标签开头\",{\"1\":{\"268\":1}}],[\"标签的resulttype即为目标类路径\",{\"1\":{\"203\":1}}],[\"标签\",{\"1\":{\"179\":2}}],[\"标示复位\",{\"1\":{\"15\":1}}],[\"软件\",{\"1\":{\"178\":1}}],[\"映射到相同的物理内存中\",{\"1\":{\"727\":1}}],[\"映射文件\",{\"1\":{\"178\":1}}],[\"映射关系\",{\"1\":{\"175\":1}}],[\"求变化要求迅速输出成果\",{\"1\":{\"178\":1}}],[\"调优和监控\",{\"1\":{\"668\":1}}],[\"调整为对每个数组元素加锁\",{\"1\":{\"549\":1}}],[\"调整系统内核参数\",{\"1\":{\"20\":1}}],[\"调factory对象的newinstance方法时传入sqlsession\",{\"1\":{\"194\":1}}],[\"调用hashmap的put方法\",{\"1\":{\"595\":1}}],[\"调用arrays\",{\"1\":{\"573\":1}}],[\"调用null对象的实例方法\",{\"1\":{\"534\":1}}],[\"调用该方法的方法中必须包含可处理异常的代码\",{\"1\":{\"532\":1}}],[\"调用method\",{\"1\":{\"507\":1}}],[\"调用invoke方法的流程如下\",{\"1\":{\"507\":1}}],[\"调用invoke\",{\"1\":{\"507\":1}}],[\"调用具体方法的无参构造方法\",{\"1\":{\"507\":1}}],[\"调用\",{\"1\":{\"505\":1,\"635\":2,\"640\":1,\"644\":1,\"703\":2,\"732\":1}}],[\"调用start\",{\"1\":{\"635\":1,\"703\":1}}],[\"调用spring\",{\"1\":{\"281\":1}}],[\"调用setbeanfactory\",{\"1\":{\"274\":1}}],[\"调用setbeanclassloader\",{\"1\":{\"274\":1}}],[\"调用setbeanname\",{\"1\":{\"274\":1}}],[\"调用selectone\",{\"1\":{\"194\":1}}],[\"调用session\",{\"1\":{\"177\":2}}],[\"调用beanpostprocess的后置初始化方法\",{\"1\":{\"274\":1}}],[\"调用bean自身定义的init方法\",{\"1\":{\"274\":1,\"276\":1}}],[\"调用方法\",{\"1\":{\"237\":1}}],[\"调用对应服务的实现类执行任务\",{\"1\":{\"216\":1}}],[\"调用本地方法得到response\",{\"1\":{\"210\":1}}],[\"调用远程方法\",{\"1\":{\"210\":1}}],[\"调用xmlutil添加mapperstatememt\",{\"1\":{\"194\":1}}],[\"调用preparedstatement的set方法来赋值\",{\"1\":{\"181\":1}}],[\"占内存大小\",{\"1\":{\"486\":1}}],[\"占位符需要和参数一一对应\",{\"1\":{\"176\":1}}],[\"占用部分资源的线程进一步申请其他资源时\",{\"1\":{\"627\":1,\"694\":1}}],[\"占用导致的\",{\"1\":{\"141\":1}}],[\"占用的空间为实际字符长度+1\",{\"1\":{\"95\":1}}],[\"释放资源则反序释放\",{\"1\":{\"627\":1,\"694\":1}}],[\"释放之后需要调用\",{\"1\":{\"617\":1}}],[\"释放后会唤醒其后继节点\",{\"1\":{\"611\":1}}],[\"释放成功后\",{\"1\":{\"611\":1,\"615\":1}}],[\"释放\",{\"1\":{\"585\":1}}],[\"释放旧entry数组的对象引用\",{\"1\":{\"558\":1,\"581\":1}}],[\"释放锁\",{\"1\":{\"617\":1,\"677\":1}}],[\"释放锁的过程\",{\"1\":{\"615\":1}}],[\"释放锁的最简单方式就是执行del指令\",{\"1\":{\"434\":1}}],[\"释放锁之后\",{\"1\":{\"434\":1}}],[\"释放锁操作\",{\"1\":{\"432\":1}}],[\"释放频繁造成系统资源浪费从而影响系统性能\",{\"1\":{\"176\":1}}],[\"释放前面对满足\",{\"1\":{\"112\":1}}],[\"全部启动\",{\"1\":{\"722\":1}}],[\"全称\",{\"1\":{\"644\":1}}],[\"全盘崩溃的情况\",{\"1\":{\"396\":1}}],[\"全局字符串常量池\",{\"1\":{\"487\":1}}],[\"全局配置\",{\"1\":{\"319\":1}}],[\"全局跨域配置\",{\"0\":{\"319\":1}}],[\"全局session作用域\",{\"1\":{\"269\":1}}],[\"全自动化的持久层框架\",{\"1\":{\"175\":1}}],[\"全表扫描\",{\"1\":{\"157\":1}}],[\"半自动化的持久层框架\",{\"1\":{\"175\":1}}],[\"半同步复制\",{\"1\":{\"133\":1}}],[\"办公自动化系统\",{\"1\":{\"175\":1}}],[\"操作和\",{\"1\":{\"731\":1}}],[\"操作起来也非常方便\",{\"1\":{\"721\":1}}],[\"操作日志\",{\"1\":{\"720\":1}}],[\"操作监控\",{\"1\":{\"720\":1}}],[\"操作系统用户态和内核态的切换\",{\"1\":{\"661\":1}}],[\"操作结果都会直接刷到主存中\",{\"1\":{\"646\":1}}],[\"操作时\",{\"1\":{\"622\":1,\"689\":1}}],[\"操作数组时类型不一致\",{\"1\":{\"531\":1}}],[\"操作数据库\",{\"1\":{\"175\":1}}],[\"操作符重载则被认为是\",{\"1\":{\"443\":1}}],[\"操作完成后\",{\"1\":{\"403\":1}}],[\"操作缓存就是直接操作内存\",{\"1\":{\"379\":1}}],[\"操作是安全的\",{\"1\":{\"301\":1}}],[\"操作\",{\"0\":{\"301\":1},\"1\":{\"547\":1,\"565\":1,\"583\":1,\"622\":1,\"689\":1,\"728\":2,\"731\":1}}],[\"操作及使用的数据对其它并发事务是隔离的\",{\"1\":{\"101\":1}}],[\"级以内\",{\"1\":{\"350\":1}}],[\"级\",{\"1\":{\"350\":2}}],[\"级联比\",{\"1\":{\"175\":1}}],[\"级联\",{\"1\":{\"175\":1}}],[\"级别\",{\"1\":{\"76\":1}}],[\"级别和\",{\"1\":{\"76\":1}}],[\"尤其当字段多\",{\"1\":{\"173\":1,\"180\":1}}],[\"很有可能就冲突了\",{\"1\":{\"728\":1}}],[\"很有会造成系统oom\",{\"1\":{\"672\":1}}],[\"很难统一传输和保存\",{\"1\":{\"519\":1}}],[\"很显然\",{\"1\":{\"493\":1}}],[\"很浪费内存\",{\"1\":{\"417\":1}}],[\"很方便实现redis数据节点的线形扩展\",{\"1\":{\"416\":1}}],[\"很简单\",{\"1\":{\"401\":1}}],[\"很像memcached\",{\"1\":{\"376\":1}}],[\"很高\",{\"1\":{\"350\":2,\"717\":1}}],[\"很高的创建和销毁开销会抵消zero\",{\"1\":{\"341\":1}}],[\"很多时候\",{\"1\":{\"645\":1}}],[\"很多网站都有排行榜应用的\",{\"1\":{\"381\":1}}],[\"很多系统都需要\",{\"1\":{\"346\":1}}],[\"很多因素可能造成leader和follower之间的不同步\",{\"1\":{\"339\":1}}],[\"很大很大很大的一个值\",{\"1\":{\"334\":1}}],[\"很好的集成\",{\"1\":{\"179\":1}}],[\"很好的与各种数据库兼容\",{\"1\":{\"173\":1,\"179\":1}}],[\"很安全\",{\"1\":{\"108\":1}}],[\"便会开始解锁所有redis实例\",{\"1\":{\"437\":1}}],[\"便于实现字符串池\",{\"1\":{\"482\":1}}],[\"便于获取参数信息以及上传的文件\",{\"1\":{\"291\":1}}],[\"便于统一管理\",{\"1\":{\"173\":1,\"179\":1}}],[\"便要销毁\",{\"1\":{\"275\":1}}],[\"便开始写入\",{\"1\":{\"106\":1}}],[\"配置模式装载\",{\"1\":{\"506\":1}}],[\"配置类\",{\"1\":{\"312\":1}}],[\"配置中心和客户端通知\",{\"1\":{\"416\":1}}],[\"配置中心\",{\"1\":{\"310\":1,\"419\":1}}],[\"配置加载\",{\"1\":{\"308\":1}}],[\"配置日志等\",{\"1\":{\"304\":1}}],[\"配置映射不同\",{\"1\":{\"299\":1}}],[\"配置处理器的\",{\"1\":{\"293\":1}}],[\"配置是通过使用\",{\"1\":{\"268\":1}}],[\"配置为组件类本身\",{\"1\":{\"268\":1}}],[\"配置\",{\"1\":{\"268\":2}}],[\"配置和组装的指令\",{\"1\":{\"264\":1}}],[\"配置它们并管理它们的完整生命周期\",{\"1\":{\"264\":1}}],[\"配置文件加载入内存中\",{\"1\":{\"506\":1}}],[\"配置文件中启用它\",{\"1\":{\"268\":1}}],[\"配置文件\",{\"0\":{\"205\":1},\"1\":{\"506\":1}}],[\"配置java对象与数据库表的对应关系\",{\"1\":{\"175\":1}}],[\"配置java对象与sql语句执行结果的对应关系\",{\"1\":{\"175\":1}}],[\"配置起来\",{\"1\":{\"172\":1}}],[\"配置管理系统\",{\"1\":{\"124\":1}}],[\"框架中用到了哪些设计模式\",{\"0\":{\"286\":1}}],[\"框架提供的命令进行编译\",{\"1\":{\"284\":1}}],[\"框架的使用\",{\"1\":{\"506\":1}}],[\"框架的核心是\",{\"1\":{\"264\":1}}],[\"框架的缺点\",{\"0\":{\"180\":1}}],[\"框架入口\",{\"1\":{\"195\":1}}],[\"框架\",{\"1\":{\"172\":1,\"178\":1}}],[\"详解\",{\"1\":{\"171\":1,\"552\":1,\"600\":1}}],[\"详细分析\",{\"1\":{\"556\":1}}],[\"详细原理看这篇文章\",{\"1\":{\"110\":1}}],[\"详细讲一下拥塞控制\",{\"0\":{\"24\":1}}],[\"详细讲一下tcp的滑动窗口\",{\"0\":{\"23\":1}}],[\"详细介绍一下\",{\"0\":{\"11\":1,\"16\":1}}],[\"放入全局空闲列表\",{\"1\":{\"662\":1}}],[\"放入全局等待读处理队列\",{\"1\":{\"404\":1}}],[\"放入链表的顺序\",{\"1\":{\"653\":1}}],[\"放到不同队列执行\",{\"1\":{\"643\":1}}],[\"放到newtable\",{\"1\":{\"564\":1}}],[\"放行哪些原始域\",{\"1\":{\"319\":4}}],[\"放行\",{\"1\":{\"317\":1}}],[\"放在队尾\",{\"1\":{\"679\":1}}],[\"放在后面才会走索引\",{\"1\":{\"169\":1}}],[\"放在匹配字段前是不走索引的\",{\"1\":{\"169\":1}}],[\"放进自己的relay\",{\"1\":{\"132\":1}}],[\"放进master上的binlog中\",{\"1\":{\"132\":1}}],[\"冰\",{\"1\":{\"169\":1}}],[\"模运算的消耗很大\",{\"1\":{\"555\":1}}],[\"模拟\",{\"1\":{\"506\":1}}],[\"模拟从数据库中取用户的行为\",{\"1\":{\"216\":1}}],[\"模型更加简单\",{\"1\":{\"406\":1}}],[\"模型如下图\",{\"1\":{\"403\":1}}],[\"模型的一种\",{\"1\":{\"403\":1}}],[\"模块\",{\"1\":{\"401\":1}}],[\"模板方法模式很经典的一个应用\",{\"1\":{\"678\":1}}],[\"模板方法模式\",{\"1\":{\"286\":1}}],[\"模糊搜索导致的索引失效\",{\"0\":{\"169\":1}}],[\"模式完美的解决了这个问题\",{\"1\":{\"439\":1}}],[\"模式开发了网络事件处理器\",{\"1\":{\"403\":1}}],[\"模式\",{\"0\":{\"324\":2},\"1\":{\"108\":1,\"603\":1}}],[\"反序列化\",{\"1\":{\"518\":1}}],[\"反序列化request\",{\"1\":{\"210\":1}}],[\"反编译一下这个\",{\"1\":{\"511\":1}}],[\"反之\",{\"1\":{\"493\":1}}],[\"反之返回该key\",{\"1\":{\"386\":1}}],[\"反之索引失效\",{\"1\":{\"168\":1}}],[\"反向双重查找\",{\"1\":{\"382\":1}}],[\"反射获取类实例\",{\"1\":{\"507\":1}}],[\"反射获取request对象\",{\"1\":{\"223\":1}}],[\"反射让开发人员可以枚举出类的全部成员\",{\"1\":{\"506\":1}}],[\"反射让开发人员可以通过外部类的全路径名创建对象\",{\"1\":{\"506\":1}}],[\"反射主要应用在以下几方面\",{\"1\":{\"506\":1}}],[\"反射的核心类\",{\"1\":{\"504\":1}}],[\"反射是在运行状态中\",{\"1\":{\"501\":1}}],[\"反射使用的步骤\",{\"0\":{\"505\":1},\"1\":{\"484\":1}}],[\"反射机制的体现\",{\"1\":{\"506\":1}}],[\"反射机制的原理是什么\",{\"0\":{\"507\":1},\"1\":{\"484\":1}}],[\"反射机制的应用有哪些\",{\"0\":{\"506\":1},\"1\":{\"484\":1}}],[\"反射机制的优缺点有哪些\",{\"0\":{\"502\":1},\"1\":{\"484\":1}}],[\"反射机制所需要的string参数\",{\"1\":{\"482\":1}}],[\"反射调用方法\",{\"1\":{\"230\":1,\"237\":1}}],[\"反射调用服务方法获得返回值\",{\"1\":{\"230\":1}}],[\"反射调用对应方法\",{\"1\":{\"223\":1}}],[\"反射封装成一个request\",{\"1\":{\"223\":1}}],[\"反射\",{\"0\":{\"500\":1},\"1\":{\"221\":1,\"484\":1,\"504\":1}}],[\"反代ip必须与反代端口对应\",{\"1\":{\"69\":4}}],[\"张三\",{\"1\":{\"168\":1,\"223\":1}}],[\"函数\",{\"1\":{\"477\":1,\"488\":1}}],[\"函数导致的索引失效\",{\"0\":{\"166\":1}}],[\"函数查看字段的差异值\",{\"1\":{\"160\":1}}],[\"干净\",{\"1\":{\"161\":1}}],[\"性别字段可能在大数据面前区分度就是0\",{\"1\":{\"161\":1}}],[\"性能略好\",{\"1\":{\"523\":1}}],[\"性能略差\",{\"1\":{\"523\":1}}],[\"性能\",{\"1\":{\"481\":1}}],[\"性能比面向过程低\",{\"1\":{\"463\":1}}],[\"性能比面向对象高\",{\"1\":{\"463\":1}}],[\"性能是最重要的因素\",{\"1\":{\"463\":1}}],[\"性能方面\",{\"1\":{\"447\":1}}],[\"性能消耗较小\",{\"1\":{\"432\":1}}],[\"性能好\",{\"1\":{\"432\":1}}],[\"性能的提升效果如何\",{\"0\":{\"402\":1}}],[\"性能较差但数据完整性比较好\",{\"1\":{\"383\":1}}],[\"性能非常好\",{\"1\":{\"381\":1}}],[\"性能对比\",{\"1\":{\"378\":1}}],[\"性能极好\",{\"1\":{\"350\":1}}],[\"性能应该会有所提升\",{\"1\":{\"232\":1}}],[\"性能也就越差\",{\"1\":{\"140\":1}}],[\"性能就越好\",{\"1\":{\"128\":1}}],[\"性能就会相对差一些了\",{\"1\":{\"121\":1}}],[\"区分构造函数注入和\",{\"0\":{\"267\":1}}],[\"区分\",{\"0\":{\"266\":1}}],[\"区分度的公式是count\",{\"1\":{\"161\":1}}],[\"区别在两处\",{\"1\":{\"557\":1}}],[\"区别在于前者实现的是编译时的多态性\",{\"1\":{\"466\":1}}],[\"区别是什么\",{\"0\":{\"476\":1,\"530\":1,\"531\":1,\"648\":1},\"1\":{\"484\":2}}],[\"区别\",{\"0\":{\"96\":1,\"533\":1,\"572\":1,\"595\":1,\"633\":1,\"701\":1},\"1\":{\"484\":1}}],[\"取得代之的确实是\",{\"1\":{\"651\":1}}],[\"取得旧entry数组的每个元素\",{\"1\":{\"558\":1,\"581\":1}}],[\"取key的\",{\"1\":{\"555\":1,\"579\":1}}],[\"取模运算\",{\"1\":{\"555\":1,\"579\":1}}],[\"取hashcode值\",{\"1\":{\"555\":2,\"579\":2}}],[\"取而代之的是数组+链表+红黑树的结构\",{\"1\":{\"549\":1,\"591\":1}}],[\"取消状态的节点会从队列中释放\",{\"1\":{\"614\":1}}],[\"取消了segment分段锁的数据结构\",{\"1\":{\"591\":1}}],[\"取消了\",{\"1\":{\"549\":1}}],[\"取消监视\",{\"1\":{\"408\":1}}],[\"取消事务\",{\"1\":{\"408\":1}}],[\"取消所有请求\",{\"1\":{\"71\":1}}],[\"取sqltype与枚举类定义中的类型比较\",{\"1\":{\"200\":1}}],[\"取出sql信息\",{\"1\":{\"198\":1}}],[\"取出mapperstatement\",{\"1\":{\"194\":1}}],[\"取值离散大的字段\",{\"1\":{\"160\":1}}],[\"除此之外\",{\"1\":{\"555\":1}}],[\"除非需要使用\",{\"1\":{\"648\":1,\"707\":1}}],[\"除非在时间和空间比较特殊的情况下\",{\"1\":{\"554\":1,\"578\":1}}],[\"除非你想存储null\",{\"1\":{\"160\":1}}],[\"除了头节点和尾节点\",{\"1\":{\"602\":1}}],[\"除了基本类型\",{\"1\":{\"489\":1}}],[\"除了支持string类型的value外\",{\"1\":{\"376\":1}}],[\"除了b服务\",{\"1\":{\"345\":1}}],[\"除了添加\",{\"1\":{\"292\":1}}],[\"除了使用主键进行的查询\",{\"1\":{\"137\":1}}],[\"除了数据表占数据空间之外\",{\"1\":{\"86\":1}}],[\"估算\",{\"1\":{\"157\":1}}],[\"~15\",{\"1\":{\"481\":1}}],[\"~\",{\"1\":{\"157\":1,\"348\":1,\"499\":1}}],[\"类主要利用\",{\"1\":{\"684\":1}}],[\"类上锁\",{\"1\":{\"649\":1}}],[\"类中的\",{\"1\":{\"644\":1}}],[\"类中的各个方法\",{\"1\":{\"644\":1}}],[\"类中的方法\",{\"1\":{\"505\":1}}],[\"类的部分源码\",{\"1\":{\"684\":1}}],[\"类的原理\",{\"0\":{\"684\":1}}],[\"类的构造函数中传入\",{\"1\":{\"638\":1}}],[\"类的路径\",{\"1\":{\"503\":1}}],[\"类本质上是实现\",{\"1\":{\"638\":1}}],[\"类适配器\",{\"1\":{\"543\":1}}],[\"类造型异常\",{\"1\":{\"534\":1}}],[\"类转换异常\",{\"1\":{\"531\":1}}],[\"类有两个重要的子类\",{\"1\":{\"530\":1}}],[\"类通过实现\",{\"1\":{\"521\":1}}],[\"类后面的两个尖括号\",{\"1\":{\"511\":1}}],[\"类加载驱动程序\",{\"1\":{\"506\":1}}],[\"类加载时编织\",{\"1\":{\"284\":1}}],[\"类进行数据库的连接\",{\"1\":{\"506\":1}}],[\"类名\",{\"1\":{\"503\":1}}],[\"类名的完整字符串\",{\"1\":{\"270\":1}}],[\"类对象\",{\"1\":{\"503\":1}}],[\"类及其子类\",{\"1\":{\"493\":1,\"531\":1}}],[\"类不能被继承\",{\"1\":{\"490\":1}}],[\"类覆盖了equals\",{\"1\":{\"476\":1}}],[\"类没有覆盖equals\",{\"1\":{\"476\":1}}],[\"类和接口\",{\"1\":{\"449\":1}}],[\"类库\",{\"1\":{\"444\":1}}],[\"类实例并在\",{\"1\":{\"277\":1}}],[\"类\",{\"1\":{\"277\":2,\"284\":1,\"308\":1,\"451\":2,\"454\":1,\"490\":1,\"504\":4,\"511\":1,\"524\":1,\"530\":1}}],[\"类允许通过简单地调用同一个类中的其他\",{\"1\":{\"268\":1}}],[\"类或其子类所赋值\",{\"1\":{\"200\":1}}],[\"类型都是一直的\",{\"1\":{\"516\":1}}],[\"类型擦除\",{\"1\":{\"511\":1}}],[\"类型不正确导致的\",{\"1\":{\"510\":1}}],[\"类型不一致导致的索引失效\",{\"0\":{\"165\":1}}],[\"类型安全\",{\"1\":{\"510\":1}}],[\"类型了\",{\"1\":{\"510\":1}}],[\"类型进行改变的时候\",{\"1\":{\"481\":1}}],[\"类型来使用\",{\"1\":{\"272\":1}}],[\"类型为xml解析时标签的的resulttype\",{\"1\":{\"203\":1}}],[\"类型\",{\"1\":{\"200\":1,\"291\":1,\"450\":1,\"510\":1,\"511\":2,\"516\":1}}],[\"类型的对象\",{\"1\":{\"697\":1}}],[\"类型的异常\",{\"1\":{\"533\":1}}],[\"类型的数据一定要在数值后面加上\",{\"1\":{\"449\":1}}],[\"类型的\",{\"1\":{\"382\":1}}],[\"类型的稍快\",{\"1\":{\"157\":1}}],[\"类型的查询虽然不是全表扫描\",{\"1\":{\"157\":1}}],[\"类型的性能关系如下\",{\"1\":{\"157\":1}}],[\"类型因为是全表扫描\",{\"1\":{\"157\":1}}],[\"类似\",{\"1\":{\"342\":1,\"681\":1}}],[\"类似的问题\",{\"1\":{\"142\":1}}],[\"类似于java中的treeset\",{\"1\":{\"382\":1}}],[\"类似于标准的\",{\"1\":{\"272\":1}}],[\"类似于http\",{\"1\":{\"223\":1}}],[\"类似于select\",{\"1\":{\"136\":1}}],[\"类似于\",{\"1\":{\"37\":1,\"377\":1}}],[\"扫尾\",{\"1\":{\"535\":1}}],[\"扫描全表索引的覆盖索引\",{\"1\":{\"157\":1}}],[\"扫码加我\",{\"1\":{\"47\":1}}],[\"官方文档中可以看出\",{\"1\":{\"506\":1}}],[\"官方文档中对反射的描述\",{\"1\":{\"506\":1}}],[\"官方文档中给的例子和解释如下\",{\"1\":{\"156\":1}}],[\"官方文档未明确定义\",{\"1\":{\"449\":1}}],[\"官方例子\",{\"1\":{\"251\":1}}],[\"官方优选域名\",{\"1\":{\"71\":4}}],[\"了\",{\"0\":{\"536\":1},\"1\":{\"454\":1,\"484\":1,\"548\":1,\"558\":1,\"581\":1,\"622\":1,\"689\":1}}],[\"了解这部分就相当于了解了线程池的核心运行机制\",{\"1\":{\"713\":1}}],[\"了解aqs\",{\"0\":{\"680\":1}}],[\"了解aqs中同步队列的数据结构吗\",{\"0\":{\"679\":1}}],[\"了解reentrantlock吗\",{\"0\":{\"666\":1}}],[\"了解redlock吗\",{\"0\":{\"436\":1}}],[\"了解fork\",{\"0\":{\"643\":1}}],[\"了解一下aqs的同步状态\",{\"1\":{\"604\":1}}],[\"了解主从复制的原理吗\",{\"0\":{\"420\":1}}],[\"了解curator开源zookeeper客户端中的使用\",{\"1\":{\"249\":1}}],[\"了解对象对象的类信息\",{\"1\":{\"244\":1}}],[\"了解\",{\"1\":{\"242\":1,\"300\":1}}],[\"了解索引下推吗\",{\"0\":{\"156\":1}}],[\"了一百万的数据\",{\"1\":{\"136\":1}}],[\"流分为几种\",{\"0\":{\"539\":1},\"1\":{\"484\":1}}],[\"流量是不可能这么均衡的\",{\"1\":{\"718\":1}}],[\"流量削峰及异步处理实时性低的业务\",{\"1\":{\"381\":1}}],[\"流量控制与tcp协议报头中的窗口大小有关\",{\"1\":{\"22\":1}}],[\"流量控制\",{\"1\":{\"22\":1}}],[\"流量控制等方法实现了可靠性传输\",{\"1\":{\"22\":1}}],[\"流程简述如下\",{\"1\":{\"404\":1}}],[\"流程说明\",{\"1\":{\"290\":1}}],[\"流程解析\",{\"0\":{\"194\":1}}],[\"流程是\",{\"1\":{\"155\":1}}],[\"叫做联合索引\",{\"1\":{\"153\":1}}],[\"联合类型和枚举类型\",{\"1\":{\"449\":1}}],[\"联合查询是几个表联合查询\",{\"1\":{\"186\":1,\"187\":1}}],[\"联合索引是什么\",{\"0\":{\"153\":1}}],[\"联通\",{\"1\":{\"69\":1}}],[\"已经指向了节点a\",{\"1\":{\"564\":1}}],[\"已经存在\",{\"1\":{\"556\":1,\"580\":1}}],[\"已经摒弃了segment的概念\",{\"1\":{\"548\":1}}],[\"已经下线\",{\"1\":{\"425\":1}}],[\"已经包含了score\",{\"1\":{\"152\":1}}],[\"已启用临时域名中转服务\",{\"1\":{\"71\":1}}],[\"覆盖原来的值\",{\"1\":{\"721\":1}}],[\"覆盖decorator\",{\"1\":{\"543\":1}}],[\"覆盖的可能性\",{\"1\":{\"279\":1}}],[\"覆盖索引\",{\"1\":{\"152\":1}}],[\"覆盖\",{\"1\":{\"152\":1,\"565\":1,\"583\":1}}],[\"回收过程如下图所示\",{\"1\":{\"714\":1}}],[\"回答这个问题前\",{\"1\":{\"554\":1,\"578\":1}}],[\"回表的操作属于随机io\",{\"1\":{\"151\":1}}],[\"回滚指针假设为\",{\"1\":{\"112\":1}}],[\"回滚指针\",{\"1\":{\"112\":1}}],[\"回滚操作\",{\"1\":{\"103\":1}}],[\"想要深入了解的小伙伴可以看这篇文章\",{\"1\":{\"537\":1}}],[\"想要深入了解的小伙伴\",{\"1\":{\"526\":1,\"548\":2,\"588\":1,\"590\":1}}],[\"想要深入了解\",{\"1\":{\"461\":1,\"469\":1,\"474\":1}}],[\"想要查找数据我们还需要根据主键再去聚集索引中进行查找\",{\"1\":{\"151\":1}}],[\"想要交流的小伙伴可加我个人微信\",{\"1\":{\"7\":1}}],[\"行为\",{\"1\":{\"409\":1,\"469\":2}}],[\"行号\",{\"1\":{\"151\":1}}],[\"行级冲突少\",{\"1\":{\"114\":1}}],[\"行级锁分为共享锁\",{\"1\":{\"114\":1}}],[\"行级锁能大大减少数据库操作的冲突\",{\"1\":{\"114\":1}}],[\"行级锁是mysql中锁定粒度最细的一种锁\",{\"1\":{\"114\":1}}],[\"行级锁\",{\"1\":{\"114\":1}}],[\"里的数组是无法自动扩容的\",{\"1\":{\"558\":1,\"581\":1}}],[\"里定义的方法\",{\"1\":{\"454\":1}}],[\"里使用\",{\"1\":{\"449\":1}}],[\"里消费即可\",{\"1\":{\"346\":1}}],[\"里面是不会有线程的\",{\"1\":{\"722\":1}}],[\"里面使用对象锁来保证多线程场景下\",{\"1\":{\"549\":1,\"594\":1}}],[\"里面持有conponent\",{\"1\":{\"543\":1}}],[\"里面消费\",{\"1\":{\"346\":1}}],[\"里面去\",{\"1\":{\"346\":1}}],[\"里\",{\"1\":{\"151\":1,\"179\":1}}],[\"适配器\",{\"1\":{\"543\":2}}],[\"适配器处理\",{\"1\":{\"290\":1}}],[\"适配器模式\",{\"1\":{\"286\":1,\"543\":1}}],[\"适合大规模的数据恢复\",{\"1\":{\"383\":1}}],[\"适合用prototype原型模式\",{\"1\":{\"282\":1}}],[\"适合对关系数据模型要求不高的软件开发\",{\"1\":{\"178\":1}}],[\"适合于需求变化频繁\",{\"1\":{\"175\":1}}],[\"适合于需求相对稳定\",{\"1\":{\"175\":1}}],[\"适合等值查询\",{\"1\":{\"150\":1}}],[\"适用于数据可靠性要求不高的纯缓存业务场景\",{\"1\":{\"414\":1}}],[\"适用于排行榜和带权重的消息队列等场景\",{\"1\":{\"382\":1}}],[\"适用于设置少量属性\",{\"1\":{\"267\":1}}],[\"适用于设置很多属性\",{\"1\":{\"267\":1}}],[\"适用于两种情况\",{\"1\":{\"162\":1}}],[\"适用于要求可靠传输的应用\",{\"1\":{\"9\":1}}],[\"适用于实时应用\",{\"1\":{\"9\":1}}],[\"适用场景如朋友的定位\",{\"1\":{\"382\":1}}],[\"适用场景\",{\"1\":{\"9\":1}}],[\"方在调用\",{\"1\":{\"638\":1}}],[\"方便程序员事后进行分析问题在哪里\",{\"1\":{\"729\":1}}],[\"方便任务的执行\",{\"1\":{\"673\":1}}],[\"方便\",{\"1\":{\"175\":2}}],[\"方便扫库\",{\"1\":{\"150\":1}}],[\"方法从阻塞队列中取任务\",{\"1\":{\"714\":1}}],[\"方法获取任务\",{\"1\":{\"714\":1}}],[\"方法获取计算的结果\",{\"1\":{\"676\":1}}],[\"方法获取反射类对象\",{\"1\":{\"505\":1}}],[\"方法则会阻塞当前线程一段时间后立即返回\",{\"1\":{\"669\":1,\"697\":1}}],[\"方法会阻塞当前线程直到任务完成\",{\"1\":{\"669\":1,\"697\":1}}],[\"方法用于提交需要返回值的任务\",{\"1\":{\"669\":1,\"697\":1}}],[\"方法用于提交不需要返回值的任务\",{\"1\":{\"669\":1,\"697\":1}}],[\"方法占用的锁是当前类的锁\",{\"1\":{\"649\":1}}],[\"方法配合\",{\"1\":{\"648\":1,\"707\":1}}],[\"方法即可\",{\"1\":{\"638\":1}}],[\"方法只是\",{\"1\":{\"635\":1,\"703\":1}}],[\"方法只会被调用一次\",{\"1\":{\"454\":1}}],[\"方法方可启动线程并使线程进入就绪状态\",{\"1\":{\"635\":1,\"703\":1}}],[\"方法当成一个\",{\"1\":{\"635\":1,\"703\":1}}],[\"方法时会执行run\",{\"0\":{\"641\":1}}],[\"方法时会执行\",{\"0\":{\"635\":1,\"703\":1}}],[\"方法时调getconnect取出\",{\"1\":{\"198\":1}}],[\"方法被调用后\",{\"1\":{\"633\":1,\"701\":1}}],[\"方法释放内存空间\",{\"1\":{\"665\":1}}],[\"方法释放了锁\",{\"1\":{\"633\":1,\"701\":1}}],[\"方法释放同步状态\",{\"1\":{\"611\":1,\"613\":1}}],[\"方法没有释放锁\",{\"1\":{\"633\":1,\"701\":1}}],[\"方法后就会立即返回\",{\"1\":{\"638\":1}}],[\"方法后被执行\",{\"1\":{\"638\":1}}],[\"方法后\",{\"1\":{\"631\":1,\"639\":1,\"699\":1}}],[\"方法后返回为\",{\"1\":{\"631\":1,\"699\":1}}],[\"方法后会回到sqlsession中\",{\"1\":{\"194\":1}}],[\"方法如下\",{\"1\":{\"613\":1}}],[\"方法尝试获取同步状态\",{\"1\":{\"612\":2}}],[\"方法首先是调用tryacquireshared\",{\"1\":{\"612\":1}}],[\"方法共享式获取同步状态\",{\"1\":{\"612\":1}}],[\"方法唤醒后继节点\",{\"1\":{\"611\":1}}],[\"方法为aqs提供的模板方法\",{\"1\":{\"610\":1}}],[\"方法将加入到同步队列的尾部\",{\"1\":{\"605\":1}}],[\"方法将node中的线程状态改为waiting\",{\"1\":{\"602\":1}}],[\"方法将原有entry数组的元素拷贝到新的entry数组里\",{\"1\":{\"558\":1,\"581\":1}}],[\"方法进行通知时\",{\"1\":{\"648\":1,\"707\":1}}],[\"方法进行扩容\",{\"1\":{\"573\":1}}],[\"方法进行判断\",{\"1\":{\"480\":1}}],[\"方法确保当前arraylist维护的数组具有存储新元素的能力\",{\"1\":{\"573\":1}}],[\"方法的区别是什么呢\",{\"0\":{\"669\":1}}],[\"方法的内容\",{\"1\":{\"635\":1,\"703\":1}}],[\"方法的时候\",{\"1\":{\"571\":1}}],[\"方法的部分源码\",{\"1\":{\"565\":1,\"566\":1}}],[\"方法的重载和重写都是实现多态的方式\",{\"1\":{\"466\":1}}],[\"方法是将\",{\"1\":{\"558\":1,\"581\":1}}],[\"方法是否要加锁\",{\"0\":{\"586\":1},\"1\":{\"547\":1}}],[\"方法源码\",{\"1\":{\"556\":1}}],[\"方法二\",{\"1\":{\"555\":1,\"579\":1}}],[\"方法一\",{\"1\":{\"555\":1,\"579\":1}}],[\"方法之后\",{\"1\":{\"548\":1,\"588\":1}}],[\"方法不响应中断\",{\"1\":{\"612\":1}}],[\"方法不需要加锁与\",{\"1\":{\"547\":1}}],[\"方法不需要加锁\",{\"1\":{\"547\":1,\"586\":1}}],[\"方法不存在异常\",{\"1\":{\"534\":1}}],[\"方法执行完毕后再返回\",{\"1\":{\"638\":1}}],[\"方法执行完成后\",{\"1\":{\"633\":1,\"640\":1,\"701\":1}}],[\"方法执行逻辑是什么\",{\"0\":{\"585\":1},\"1\":{\"547\":2}}],[\"方法执行错误\",{\"1\":{\"230\":1,\"237\":1}}],[\"方法创建某个类的实例\",{\"1\":{\"534\":1}}],[\"方法调用方法\",{\"1\":{\"505\":1}}],[\"方法等信息\",{\"1\":{\"504\":1}}],[\"方法区别和共同点\",{\"0\":{\"632\":1,\"700\":1}}],[\"方法区\",{\"1\":{\"487\":2}}],[\"方法判断出来的结果为true\",{\"1\":{\"480\":1}}],[\"方法必须重写\",{\"0\":{\"480\":1}}],[\"方法来进行通讯\",{\"1\":{\"732\":1}}],[\"方法来保证原子操作\",{\"1\":{\"684\":1}}],[\"方法来获取返回值\",{\"1\":{\"669\":1,\"697\":1}}],[\"方法来结束该线程\",{\"1\":{\"640\":1}}],[\"方法来判断\",{\"1\":{\"617\":1}}],[\"方法来释放同步状态\",{\"1\":{\"611\":1}}],[\"方法来检查\",{\"1\":{\"478\":1}}],[\"方法来两个对象的内容相等\",{\"1\":{\"476\":1}}],[\"方法来定义\",{\"1\":{\"268\":1}}],[\"方法才供外界调用\",{\"1\":{\"455\":1}}],[\"方法和submit\",{\"0\":{\"669\":1}}],[\"方法和\",{\"0\":{\"632\":1,\"700\":1}}],[\"方法和属性值\",{\"1\":{\"603\":1}}],[\"方法和类\",{\"1\":{\"454\":1}}],[\"方法和构造方法的访问\",{\"1\":{\"451\":1}}],[\"方法弃用后的新方法\",{\"1\":{\"316\":1}}],[\"方法完成操作\",{\"1\":{\"301\":1}}],[\"方法或字段声明上使用注解\",{\"1\":{\"268\":1}}],[\"方法默认索引从1开始\",{\"1\":{\"202\":1}}],[\"方法待实现\",{\"1\":{\"200\":1}}],[\"方法读取配置文件\",{\"1\":{\"195\":1}}],[\"方法名字相同\",{\"1\":{\"466\":1}}],[\"方法名\",{\"1\":{\"193\":1,\"198\":1,\"199\":1,\"223\":2,\"604\":1}}],[\"方法能重载吗\",{\"0\":{\"182\":1}}],[\"方法\",{\"0\":{\"480\":1,\"635\":2,\"641\":2,\"703\":2,\"733\":1},\"1\":{\"29\":1,\"194\":1,\"195\":1,\"196\":1,\"274\":3,\"281\":1,\"451\":4,\"454\":2,\"469\":1,\"476\":2,\"505\":2,\"506\":1,\"507\":2,\"522\":1,\"548\":1,\"555\":1,\"560\":2,\"571\":1,\"582\":2,\"588\":1,\"596\":2,\"605\":1,\"621\":2,\"623\":3,\"633\":1,\"635\":2,\"639\":1,\"641\":1,\"644\":1,\"646\":1,\"647\":1,\"649\":2,\"688\":2,\"690\":3,\"701\":1,\"703\":2,\"714\":1,\"721\":1,\"732\":2,\"733\":1}}],[\"关联命令回复处理器\",{\"1\":{\"403\":1}}],[\"关联命令请求处理器\",{\"1\":{\"403\":1}}],[\"关联连接应答处理器\",{\"1\":{\"403\":1}}],[\"关联表多时\",{\"1\":{\"173\":1,\"180\":1}}],[\"关注\",{\"1\":{\"381\":1}}],[\"关系映射能力强\",{\"1\":{\"178\":1}}],[\"关闭线程池\",{\"1\":{\"630\":2,\"698\":2}}],[\"关闭数据库\",{\"1\":{\"506\":1}}],[\"关闭jdk的安全检查来提升反射速度\",{\"1\":{\"502\":1}}],[\"关闭都转换为事件\",{\"1\":{\"377\":1}}],[\"关闭连接\",{\"1\":{\"358\":1}}],[\"关闭信道\",{\"1\":{\"357\":1,\"358\":1}}],[\"关闭会话\",{\"1\":{\"177\":1}}],[\"关闭的时候却是四次握手\",{\"0\":{\"17\":1}}],[\"关键字的场景还是更多一些\",{\"1\":{\"709\":1}}],[\"关键字的区别\",{\"0\":{\"709\":1}}],[\"关键字的作用是控制变量的序列化\",{\"1\":{\"527\":1}}],[\"关键字加到\",{\"1\":{\"649\":1}}],[\"关键字进行了很多优化\",{\"1\":{\"648\":1,\"707\":1}}],[\"关键字进行声明\",{\"1\":{\"533\":1}}],[\"关键字保护的代码块无法被其他线程访问\",{\"1\":{\"646\":1}}],[\"关键字声明相应的异常\",{\"1\":{\"532\":1}}],[\"关键字用在方法声明上\",{\"1\":{\"532\":1}}],[\"关键字用在方法内部\",{\"1\":{\"532\":1}}],[\"关键字在使用上的几点区别如下\",{\"1\":{\"532\":1}}],[\"关键字在方法上声明该方法要拋出的异常\",{\"1\":{\"532\":1}}],[\"关键字和\",{\"0\":{\"709\":1},\"1\":{\"532\":1}}],[\"关键字修饰\",{\"1\":{\"527\":1}}],[\"关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问\",{\"1\":{\"456\":1}}],[\"关键字是什么意思\",{\"0\":{\"456\":1}}],[\"关键字\",{\"0\":{\"453\":1},\"1\":{\"149\":1,\"532\":2}}],[\"结束当前的方法\",{\"1\":{\"452\":1}}],[\"结束当前的循环体\",{\"1\":{\"452\":1}}],[\"结束正在执行的循环\",{\"1\":{\"452\":1}}],[\"结构类型\",{\"1\":{\"449\":1}}],[\"结构更为清晰\",{\"1\":{\"237\":1}}],[\"结尾的对数据库操作的类\",{\"1\":{\"286\":1}}],[\"结合自己的面试经验\",{\"1\":{\"552\":1}}],[\"结合来看\",{\"1\":{\"206\":1}}],[\"结合b+tree的特点\",{\"1\":{\"158\":1}}],[\"结点中仅含其子树中的最大\",{\"1\":{\"149\":1}}],[\"结果项目部署上去了\",{\"1\":{\"717\":1}}],[\"结果为false\",{\"1\":{\"498\":1}}],[\"结果就导致在中午高峰期\",{\"1\":{\"348\":1}}],[\"结果每次一到\",{\"1\":{\"348\":1}}],[\"结果\",{\"0\":{\"217\":1,\"224\":1,\"231\":1,\"238\":1,\"245\":1,\"252\":1,\"259\":1},\"1\":{\"103\":1,\"291\":1,\"349\":1}}],[\"删\",{\"1\":{\"188\":1}}],[\"删的执行效率\",{\"1\":{\"147\":1}}],[\"删除元素时间复杂度不受元素位置的影响\",{\"1\":{\"571\":1}}],[\"删除失败\",{\"1\":{\"393\":1}}],[\"删除了\",{\"1\":{\"391\":1}}],[\"删除缓存\",{\"1\":{\"390\":1}}],[\"删除一些不常用的数据\",{\"1\":{\"388\":1}}],[\"删除里面过期的key\",{\"1\":{\"386\":1}}],[\"删除过期键会占用一部分\",{\"1\":{\"386\":1}}],[\"删除key常见的三种处理方式\",{\"1\":{\"386\":1}}],[\"删除\",{\"1\":{\"335\":1,\"598\":1}}],[\"删除和修改的时候\",{\"1\":{\"86\":1,\"147\":1}}],[\"删除文件\",{\"1\":{\"29\":2}}],[\"笔画等\",{\"1\":{\"146\":1}}],[\"参与一起扩容\",{\"1\":{\"547\":1,\"585\":1}}],[\"参数的\",{\"1\":{\"721\":1}}],[\"参数的方法吗\",{\"0\":{\"514\":1}}],[\"参数进行修改即可\",{\"1\":{\"721\":1}}],[\"参数修改后及时生效\",{\"1\":{\"720\":1}}],[\"参数可动态修改\",{\"1\":{\"720\":1}}],[\"参数配置等\",{\"1\":{\"327\":1}}],[\"参数列表\",{\"1\":{\"223\":1}}],[\"参数类型\",{\"1\":{\"223\":2}}],[\"参数\",{\"1\":{\"223\":1,\"230\":1,\"334\":2,\"712\":1}}],[\"参数值解析为\",{\"1\":{\"200\":1}}],[\"参数化\",{\"1\":{\"198\":1}}],[\"参数不同时\",{\"0\":{\"182\":1}}],[\"参数中设置的首选\",{\"1\":{\"38\":1}}],[\"参考博客\",{\"1\":{\"242\":1}}],[\"参考\",{\"0\":{\"143\":1,\"311\":1,\"343\":1,\"483\":1,\"544\":1,\"562\":1,\"618\":1,\"685\":1,\"723\":1,\"737\":1},\"1\":{\"484\":1}}],[\"另一个进程读取数据时候自然也是从内核中获取\",{\"1\":{\"731\":1}}],[\"另一个是\",{\"1\":{\"728\":1}}],[\"另一个加载器又尝试去加载它\",{\"1\":{\"533\":1}}],[\"另一端读取\",{\"1\":{\"725\":1}}],[\"另一方面同时管理线程和任务\",{\"1\":{\"711\":1}}],[\"另一方面\",{\"1\":{\"415\":1}}],[\"另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中\",{\"1\":{\"533\":1}}],[\"另一种是<\",{\"1\":{\"512\":1}}],[\"另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上\",{\"1\":{\"377\":1}}],[\"另一种方式是使用\",{\"1\":{\"435\":1}}],[\"另一种叫只追加文件aof\",{\"1\":{\"383\":1}}],[\"另一块是窗口内等待发送的分组\",{\"1\":{\"23\":1}}],[\"另外一个进程马上就能看到了\",{\"1\":{\"727\":1}}],[\"另外一个线程可以进行\",{\"1\":{\"622\":1,\"689\":1}}],[\"另外最重要的是\",{\"1\":{\"386\":1}}],[\"另外定期删除\",{\"1\":{\"386\":1}}],[\"另外期待与你的合作\",{\"1\":{\"206\":1}}],[\"另外\",{\"1\":{\"159\":1,\"381\":1,\"449\":1,\"622\":1,\"689\":1,\"725\":1,\"731\":1}}],[\"另外对重量级\",{\"1\":{\"142\":1}}],[\"务必禁止不带任何限制数据范围条件的查询语句\",{\"1\":{\"142\":1}}],[\"务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态\",{\"1\":{\"101\":1}}],[\"限于篇幅原因\",{\"1\":{\"561\":1}}],[\"限定通配符对类型进行了限制\",{\"1\":{\"512\":1}}],[\"限定数据的范围\",{\"1\":{\"142\":1}}],[\"限流降级\",{\"1\":{\"396\":1}}],[\"限制数据库权限\",{\"1\":{\"45\":1}}],[\"限制同时打开的syn半连接数目\",{\"1\":{\"43\":1}}],[\"飙升\",{\"1\":{\"141\":1}}],[\"飙升到\",{\"1\":{\"141\":1}}],[\"连进来导致\",{\"1\":{\"141\":1}}],[\"连接数据库\",{\"1\":{\"506\":1}}],[\"连接数据库的密码\",{\"1\":{\"506\":1}}],[\"连接数据库的用户名\",{\"1\":{\"506\":1}}],[\"连接地址是由各个数据库生产商单独提供的\",{\"1\":{\"506\":1}}],[\"连接的时候要输入数据库的连接地址\",{\"1\":{\"506\":1}}],[\"连接的时间要比客户端早一些\",{\"1\":{\"16\":1}}],[\"连接应答处理器\",{\"1\":{\"403\":1}}],[\"连接上的connection对象为成员变量\",{\"1\":{\"198\":1}}],[\"连接器\",{\"1\":{\"99\":1}}],[\"连接器会对该请求进行权限验证及连接资源分配\",{\"1\":{\"88\":1,\"99\":1}}],[\"连接发送连接请求到\",{\"1\":{\"99\":1}}],[\"连接后发起\",{\"1\":{\"38\":1}}],[\"连接\",{\"1\":{\"38\":1,\"96\":1,\"403\":1}}],[\"连接来处理多个\",{\"1\":{\"21\":1}}],[\"连接还没有释放\",{\"1\":{\"16\":1}}],[\"连接处于半关闭状态\",{\"1\":{\"16\":1}}],[\"连接成功\",{\"1\":{\"14\":1,\"251\":1}}],[\"连接称为半连接\",{\"1\":{\"14\":1}}],[\"连接都将被一直保持下去\",{\"1\":{\"11\":1}}],[\"连接对象个数\",{\"1\":{\"9\":1}}],[\"消费的时候\",{\"1\":{\"368\":1}}],[\"消费速度慢的情况\",{\"1\":{\"366\":1}}],[\"消费维度为topic\",{\"1\":{\"364\":1}}],[\"消费模型由consumer决定\",{\"1\":{\"364\":1}}],[\"消费完进行ack\",{\"1\":{\"363\":1}}],[\"消费\",{\"1\":{\"337\":1}}],[\"消费者是从队列里拿元素的线程\",{\"1\":{\"713\":1}}],[\"消费者确认收到的消息\",{\"1\":{\"358\":1}}],[\"消费者接收消息过程\",{\"0\":{\"358\":1}}],[\"消费者读取消息的操作都是与\",{\"1\":{\"342\":1}}],[\"消费者从\",{\"1\":{\"336\":1}}],[\"消费者在处理完之后手动提交\",{\"1\":{\"332\":1}}],[\"消费者引起消息丢失的主要原因就是消息还未处理完\",{\"1\":{\"332\":1}}],[\"消费者获取到了这条消息后\",{\"1\":{\"332\":1}}],[\"消费者可能导致数据丢失的情况是\",{\"1\":{\"332\":1}}],[\"消费者异常导致的消息丢失\",{\"0\":{\"332\":1}}],[\"消费者\",{\"1\":{\"331\":1}}],[\"消费者组在一定程度上也保证了消费者程序的高可用性\",{\"1\":{\"326\":1}}],[\"消费者组允许你分割数据处理到一组进程集合上\",{\"1\":{\"326\":1}}],[\"消费者组\",{\"1\":{\"326\":1}}],[\"消费者组是kafka独有的概念\",{\"1\":{\"326\":1}}],[\"消费者会陷入不断地轮询中\",{\"1\":{\"324\":1}}],[\"消费者使用pull模式从broker订阅消息\",{\"1\":{\"324\":1}}],[\"消费者只会从\",{\"1\":{\"323\":1}}],[\"消费者都要与之建立连接\",{\"1\":{\"251\":1}}],[\"消费数据的时候\",{\"1\":{\"323\":1}}],[\"消息链表\",{\"1\":{\"731\":1}}],[\"消息通知\",{\"1\":{\"419\":1}}],[\"消息队列通信的速度不是最及时的\",{\"1\":{\"731\":1}}],[\"消息队列通信过程中\",{\"1\":{\"726\":1}}],[\"消息队列实际上是保存在内核的\",{\"1\":{\"731\":1}}],[\"消息队列克服了管道通信的数据是无格式的字节流的问题\",{\"1\":{\"731\":1}}],[\"消息队列的消息体是可以用户自定义的数据类型\",{\"1\":{\"731\":1}}],[\"消息队列的读取和写入的过程\",{\"1\":{\"727\":1}}],[\"消息队列的缺点\",{\"0\":{\"349\":1}}],[\"消息队列不适合比较大数据的传输\",{\"1\":{\"726\":1}}],[\"消息队列会一直存在\",{\"1\":{\"726\":1}}],[\"消息队列生命周期随内核\",{\"1\":{\"726\":1}}],[\"消息队列是保存在内核中的消息链表\",{\"1\":{\"726\":1}}],[\"消息队列是大型网站必用中间件\",{\"1\":{\"381\":1}}],[\"消息队列\",{\"0\":{\"726\":1},\"1\":{\"730\":1}}],[\"消息系统\",{\"1\":{\"381\":1}}],[\"消息在消费失败后会进入重试队列\",{\"1\":{\"373\":1}}],[\"消息在传输过程中可能会乱序\",{\"1\":{\"9\":1}}],[\"消息也会被\",{\"1\":{\"364\":1}}],[\"消息将对一\",{\"1\":{\"364\":1}}],[\"消息消费者\",{\"1\":{\"363\":1}}],[\"消息生产者\",{\"1\":{\"363\":1}}],[\"消息回溯等\",{\"1\":{\"362\":1}}],[\"消息补偿机制\",{\"1\":{\"356\":1}}],[\"消息可靠性\",{\"1\":{\"350\":1}}],[\"消息的发送方和接收方要约定好消息体的数据类型\",{\"1\":{\"726\":1}}],[\"消息的消费即可\",{\"1\":{\"346\":1}}],[\"消息的生产者和消费者都跟这个\",{\"1\":{\"323\":1}}],[\"消息放到内存\",{\"1\":{\"337\":1}}],[\"消息时\",{\"1\":{\"337\":1}}],[\"消息丢失的原因以及解决办法\",{\"1\":{\"331\":1}}],[\"消息是采用\",{\"0\":{\"324\":1}}],[\"消息总线\",{\"1\":{\"310\":1}}],[\"消息类型\",{\"1\":{\"244\":1}}],[\"消息长度\",{\"1\":{\"244\":2}}],[\"消息体是用户自定义的数据类型\",{\"1\":{\"726\":1}}],[\"消息体\",{\"1\":{\"237\":1}}],[\"消息格式\",{\"1\":{\"223\":2,\"237\":1}}],[\"消除锁是虚拟机另外一种锁的优化\",{\"1\":{\"659\":1}}],[\"消除许多强制类型转换\",{\"1\":{\"510\":1}}],[\"消除强制类型转换\",{\"1\":{\"510\":1}}],[\"消除两边空格\",{\"1\":{\"201\":1}}],[\"消除了\",{\"1\":{\"179\":1}}],[\"消除了jdbc大量冗余的代码\",{\"1\":{\"173\":1}}],[\"消耗资源并不多\",{\"1\":{\"141\":1}}],[\"掉这些线程\",{\"1\":{\"141\":1}}],[\"情况2\",{\"1\":{\"476\":1}}],[\"情况1\",{\"1\":{\"476\":1}}],[\"情况\",{\"1\":{\"141\":1}}],[\"找不到类异常\",{\"1\":{\"534\":1}}],[\"找到该元素在数组中存储的下标\",{\"1\":{\"556\":1,\"580\":1}}],[\"找到对应元素\",{\"1\":{\"547\":1}}],[\"找到最优长度之后\",{\"1\":{\"155\":1}}],[\"找到索引也就找到了数据\",{\"1\":{\"151\":1}}],[\"找到匹配项\",{\"1\":{\"71\":2}}],[\"找出消耗高的\",{\"1\":{\"141\":1}}],[\"找出占用高的进程\",{\"1\":{\"141\":1}}],[\"冗余字段的值在一个表中修改了\",{\"1\":{\"140\":1}}],[\"合理的利用缓存不仅能够提升网站访问速度\",{\"1\":{\"381\":1}}],[\"合理的加入冗余字段可以提高查询速度\",{\"1\":{\"140\":1}}],[\"合并小的请求\",{\"1\":{\"329\":1}}],[\"合并内容\",{\"1\":{\"71\":1}}],[\"增量的数据以aof方式保存了\",{\"1\":{\"384\":1}}],[\"增加线程池监控\",{\"1\":{\"720\":1}}],[\"增加线程是通过线程池中的addworker方法\",{\"1\":{\"714\":1}}],[\"增加\",{\"1\":{\"598\":1}}],[\"增加一个master\",{\"1\":{\"429\":1}}],[\"增加程序复杂度的同时还会降低性能\",{\"1\":{\"399\":1}}],[\"增加了一些高级功能\",{\"1\":{\"648\":1,\"707\":1}}],[\"增加了key是否过期以及对主从库的判断\",{\"1\":{\"421\":1}}],[\"增加了\",{\"1\":{\"294\":1}}],[\"增加冗余字段\",{\"1\":{\"140\":1}}],[\"增加中间表\",{\"1\":{\"140\":1}}],[\"增删改\",{\"1\":{\"42\":1}}],[\"让一组线程到达一个屏障\",{\"1\":{\"681\":1}}],[\"让子类可以根据\",{\"1\":{\"677\":1}}],[\"让子类去实现\",{\"1\":{\"677\":1}}],[\"让其可以对\",{\"1\":{\"721\":1}}],[\"让其再次获取同步状态\",{\"1\":{\"679\":1}}],[\"让其持有偏向锁\",{\"1\":{\"652\":1}}],[\"让其它有相同优先级的线程执行\",{\"1\":{\"636\":1,\"705\":1}}],[\"让我们看看源码\",{\"1\":{\"558\":1,\"581\":1}}],[\"让cap\",{\"1\":{\"555\":1}}],[\"让缓存失效的时间尽量均匀\",{\"1\":{\"396\":1}}],[\"让某个键在某个时间点过期\",{\"1\":{\"387\":1}}],[\"让定时器在该过期时间到来时\",{\"1\":{\"386\":1}}],[\"让sendrequest里读取response\",{\"1\":{\"237\":1}}],[\"让所有人都能看懂并且写出一个rpc框架\",{\"1\":{\"206\":1}}],[\"让数据库设计看起来精致\",{\"1\":{\"140\":1}}],[\"让优化器可以以更优的方式执行查询\",{\"1\":{\"138\":1}}],[\"让还没轮到的分组进入窗口内\",{\"1\":{\"23\":1}}],[\"访问标志来辨别一个方法是否声明为同步方法\",{\"1\":{\"651\":1}}],[\"访问下一个entry链上的元素\",{\"1\":{\"558\":1,\"581\":1}}],[\"访问null对象的属性\",{\"1\":{\"534\":1}}],[\"访问类的私有成员\",{\"1\":{\"506\":1}}],[\"访问二级缓存\",{\"1\":{\"396\":1}}],[\"访问数据库\",{\"1\":{\"307\":1}}],[\"访问数据太多导致查询性能下降\",{\"1\":{\"138\":1}}],[\"访问的时候就访问一个库好了\",{\"1\":{\"121\":1}}],[\"条\",{\"1\":{\"348\":2}}],[\"条消息到\",{\"1\":{\"347\":1}}],[\"条件=false\",{\"1\":{\"732\":1}}],[\"条件队列的唤醒\",{\"1\":{\"677\":1}}],[\"条件队列的阻塞\",{\"1\":{\"677\":1}}],[\"条件队列是在一定场景下\",{\"1\":{\"677\":1}}],[\"条件队列联手组成\",{\"1\":{\"677\":1}}],[\"条件\",{\"1\":{\"136\":1,\"732\":1}}],[\"条当然比较慢\",{\"1\":{\"136\":1}}],[\"先到者先拿到锁\",{\"1\":{\"680\":1}}],[\"先将锁的持有者\",{\"1\":{\"653\":1}}],[\"先执行\",{\"1\":{\"565\":1}}],[\"先执行删除缓存\",{\"1\":{\"392\":1}}],[\"先是执行\",{\"1\":{\"564\":1}}],[\"先定位到相应的\",{\"1\":{\"547\":1}}],[\"先定义服务注册接口\",{\"1\":{\"251\":1}}],[\"先判断字符串常量是否在字符串常量池中\",{\"1\":{\"488\":2}}],[\"先来看jdk1\",{\"1\":{\"547\":2,\"585\":1}}],[\"先来看下jdk1\",{\"1\":{\"546\":1,\"558\":1,\"581\":1,\"584\":1}}],[\"先来看下官方的回答\",{\"1\":{\"399\":1}}],[\"先来认识下intern\",{\"1\":{\"488\":1}}],[\"先去字符串池中查看该字符串是否已经存在\",{\"1\":{\"487\":1}}],[\"先看看一下的treadlocal的引用示意图哈\",{\"1\":{\"665\":1}}],[\"先看读并发的数量级是多少\",{\"1\":{\"439\":1}}],[\"先看下\",{\"1\":{\"400\":1}}],[\"先查询数据库\",{\"1\":{\"397\":1}}],[\"先对数据库进行更新操作\",{\"1\":{\"393\":1}}],[\"先淘汰缓存\",{\"1\":{\"391\":1}}],[\"先删除缓存\",{\"0\":{\"390\":1},\"1\":{\"389\":1}}],[\"先更新缓存\",{\"1\":{\"389\":1}}],[\"先更新数据库\",{\"0\":{\"393\":1},\"1\":{\"389\":2}}],[\"先排好队\",{\"1\":{\"345\":1}}],[\"先说第一个\",{\"1\":{\"341\":1}}],[\"先读取消息类型\",{\"1\":{\"244\":1}}],[\"先通过type创建factory对象\",{\"1\":{\"194\":1}}],[\"先计算完整列的选择性\",{\"1\":{\"155\":1}}],[\"先按照name排序\",{\"1\":{\"153\":1}}],[\"先用操作系统命令\",{\"1\":{\"141\":1}}],[\"先快速定位需要获取的id段\",{\"1\":{\"136\":1}}],[\"先收藏再看吧~\",{\"1\":{\"26\":1}}],[\"先收藏再看~\",{\"1\":{\"7\":1}}],[\"效率上比直接取模要快得多\",{\"1\":{\"555\":1}}],[\"效率高的原因之一\",{\"1\":{\"547\":1}}],[\"效率优化\",{\"1\":{\"482\":1}}],[\"效率低下\",{\"1\":{\"261\":1}}],[\"效率就非常的低下\",{\"1\":{\"136\":1}}],[\"效率太差\",{\"1\":{\"110\":1}}],[\"利用率\",{\"1\":{\"622\":1,\"689\":1}}],[\"利用好多线程机制可以大大提高系统整体的并发能力以及性能\",{\"1\":{\"622\":1,\"689\":1}}],[\"利用自旋获取锁\",{\"1\":{\"585\":1}}],[\"利用对象序列化可以进行对象的\",{\"1\":{\"519\":1}}],[\"利用多核优势\",{\"1\":{\"401\":1}}],[\"利用lru算法移除设置过过期时间的key\",{\"1\":{\"388\":1}}],[\"利用数据库锁来控制资源的并发访问是不太理想的\",{\"1\":{\"381\":1}}],[\"利用\",{\"1\":{\"310\":1,\"505\":1}}],[\"利用java的反射极致调用对象的某个set方法\",{\"1\":{\"506\":1}}],[\"利用java反射机制\",{\"1\":{\"506\":1}}],[\"利用java\",{\"1\":{\"244\":1}}],[\"利用反射执行服务中的方法\",{\"1\":{\"230\":1}}],[\"利用延迟关联或者子查询优化超多分页场景\",{\"1\":{\"136\":1}}],[\"利用注释执行非法命令\",{\"1\":{\"45\":1}}],[\"水平切分\",{\"1\":{\"135\":1}}],[\"水平拆分的意义\",{\"1\":{\"128\":1}}],[\"水平拆分的意思\",{\"1\":{\"128\":1}}],[\"垂直拆分\",{\"1\":{\"135\":1}}],[\"垂直拆分的意思\",{\"1\":{\"128\":1}}],[\"内核也可以利用信号来通知用户空间的进程发生了哪些系统事件\",{\"1\":{\"731\":1}}],[\"内核提供了不少进程间通信的方式\",{\"1\":{\"731\":1}}],[\"内核中\",{\"1\":{\"726\":1}}],[\"内核就会把这个消息体删除\",{\"1\":{\"726\":1}}],[\"内存性能相对cpu要好很多\",{\"1\":{\"717\":1}}],[\"内存泄露问题吗\",{\"0\":{\"665\":1}}],[\"内存屏障指令保证了所有\",{\"1\":{\"646\":1}}],[\"内存屏障\",{\"1\":{\"646\":1}}],[\"内存分配\",{\"1\":{\"620\":1,\"687\":1}}],[\"内存空间占用\",{\"1\":{\"571\":1}}],[\"内存不足错误\",{\"1\":{\"534\":1}}],[\"内存不足\",{\"1\":{\"530\":1}}],[\"内存淘汰策略可以通过配置文件来修改\",{\"1\":{\"388\":1}}],[\"内存永远不会释放\",{\"1\":{\"386\":1}}],[\"内存操作\",{\"1\":{\"381\":1}}],[\"内存来做缓存\",{\"1\":{\"380\":1}}],[\"内存存储\",{\"1\":{\"377\":1}}],[\"内存\",{\"1\":{\"337\":1,\"382\":1,\"717\":1}}],[\"内部采用的是\",{\"1\":{\"673\":1}}],[\"内部元素可能会发生变化\",{\"1\":{\"548\":1,\"590\":1}}],[\"内部实现是通过\",{\"1\":{\"491\":1}}],[\"内部实现getmapper方法和crud方法\",{\"1\":{\"197\":1}}],[\"内部是有顺序的就可以保证消费也是有顺序的\",{\"1\":{\"337\":1}}],[\"内部还是单线程处理\",{\"1\":{\"337\":1}}],[\"内部消息是有序的\",{\"1\":{\"336\":1}}],[\"内部\",{\"1\":{\"277\":1}}],[\"内有效\",{\"1\":{\"272\":1}}],[\"内有sql信息\",{\"1\":{\"203\":1}}],[\"内有namespace\",{\"1\":{\"197\":1}}],[\"内含有sql信息\",{\"1\":{\"198\":1}}],[\"内容类型\",{\"1\":{\"291\":1}}],[\"内容\",{\"1\":{\"132\":1}}],[\"内不使用相同的序列号\",{\"1\":{\"18\":1}}],[\"某些情况下\",{\"1\":{\"447\":1}}],[\"某些语句和函数如\",{\"1\":{\"108\":1}}],[\"某一个字符串变量改变了其值\",{\"1\":{\"482\":1}}],[\"某一个线程刚执行setnx\",{\"1\":{\"435\":1}}],[\"某一时刻\",{\"1\":{\"342\":1}}],[\"某个线程从其他队列中窃取任务进行执行的过程\",{\"1\":{\"643\":1}}],[\"某个线程获取锁失败的后续流程是什么呢\",{\"1\":{\"614\":1}}],[\"某个master所在机器突然脱离了正常的网络\",{\"1\":{\"423\":1}}],[\"某个\",{\"1\":{\"334\":1}}],[\"某个表有近千万数据\",{\"1\":{\"142\":1}}],[\"某个数据库\",{\"1\":{\"129\":1}}],[\"坏处在于说扩容起来比较麻烦\",{\"1\":{\"128\":1}}],[\"好处在于说\",{\"1\":{\"128\":2}}],[\"好处是什么\",{\"0\":{\"472\":1}}],[\"好处是\",{\"1\":{\"46\":1}}],[\"年轻一些\",{\"1\":{\"127\":1}}],[\"年一直到现在\",{\"1\":{\"126\":1}}],[\"年前了\",{\"1\":{\"125\":1}}],[\"柔性事务\",{\"1\":{\"126\":1}}],[\"版本都支持\",{\"1\":{\"648\":1,\"707\":1}}],[\"版本的时候\",{\"1\":{\"510\":1}}],[\"版本的时候就已经引入了的多线程来做一些异步操作\",{\"1\":{\"400\":1}}],[\"版本每三个月发布一次\",{\"1\":{\"447\":1}}],[\"版本将每三年发布一次\",{\"1\":{\"447\":1}}],[\"版本在阿里云\",{\"1\":{\"402\":1}}],[\"版本之前\",{\"1\":{\"323\":1}}],[\"版本2\",{\"0\":{\"227\":1}}],[\"版本升级过程\",{\"0\":{\"223\":1,\"230\":1}}],[\"版本迭代过程\",{\"0\":{\"211\":1}}],[\"版本\",{\"1\":{\"126\":1}}],[\"版本+状态码+原因短语\",{\"1\":{\"32\":1}}],[\"淘宝团队开发的\",{\"1\":{\"124\":1}}],[\"跨域\",{\"1\":{\"319\":1}}],[\"跨语言的rpc通信\",{\"1\":{\"212\":1}}],[\"跨库\",{\"1\":{\"123\":1}}],[\"跨站脚本\",{\"1\":{\"44\":1}}],[\"差不多算是被抛弃的状态吧\",{\"1\":{\"123\":1}}],[\"早些年还可以用\",{\"1\":{\"123\":1}}],[\"早期有人将用户的登录名和密码存储在\",{\"1\":{\"41\":1}}],[\"团队开发和开源的\",{\"1\":{\"123\":1}}],[\"各个线程之间的变量互不干扰\",{\"1\":{\"704\":1}}],[\"各个方法定义如下\",{\"1\":{\"610\":1}}],[\"各个中间件的优缺点是啥\",{\"1\":{\"122\":1}}],[\"各自都包含大量子类\",{\"1\":{\"530\":1}}],[\"各实例共用一份缓存数据\",{\"1\":{\"380\":1}}],[\"各种序列化方式以及比较\",{\"1\":{\"242\":1}}],[\"各有优缺点\",{\"1\":{\"108\":1}}],[\"左右的性能提升\",{\"1\":{\"481\":1}}],[\"左右\",{\"1\":{\"121\":1,\"622\":1,\"689\":1}}],[\"万级\",{\"1\":{\"350\":3}}],[\"万以内\",{\"1\":{\"121\":1}}],[\"万一在这两个操作之间突然出现错误比如银行系统崩溃\",{\"1\":{\"100\":1}}],[\"绝对不行\",{\"1\":{\"121\":1}}],[\"你知道有什么方法对线程池进行预热吗\",{\"1\":{\"722\":1}}],[\"你咔一下设置为核心数\",{\"1\":{\"717\":1}}],[\"你就得考虑其他的应用的线程池配置情况\",{\"1\":{\"717\":1}}],[\"你就得分表了\",{\"1\":{\"121\":1}}],[\"你说下线程池核心参数\",{\"0\":{\"670\":1}}],[\"你加上catch编译器也觉得无可厚非\",{\"1\":{\"535\":1}}],[\"你可以使用该方法获取\",{\"1\":{\"503\":1}}],[\"你可以一站式集成\",{\"1\":{\"307\":1}}],[\"你会怎么设计\",{\"0\":{\"439\":1}}],[\"你需要将数据拿到客户端来进行类似的修改再set回去\",{\"1\":{\"378\":1}}],[\"你需要回答的是\",{\"1\":{\"340\":1}}],[\"你创建的queue\",{\"1\":{\"361\":1}}],[\"你如何理解\",{\"0\":{\"307\":1}}],[\"你能做什么来保护它\",{\"0\":{\"303\":1}}],[\"你应该记住这一点\",{\"1\":{\"302\":1}}],[\"你应该用0\",{\"1\":{\"160\":1}}],[\"你还可以实现\",{\"1\":{\"292\":1}}],[\"你只需要通过注解或者xml配置管理事务\",{\"1\":{\"287\":1}}],[\"你发送request\",{\"1\":{\"237\":1}}],[\"你访问频率高的行字段越少\",{\"1\":{\"128\":1}}],[\"你确定你能扛住么\",{\"1\":{\"121\":1}}],[\"你设置的uuid\",{\"1\":{\"69\":1}}],[\"你设置的自定义域名\",{\"1\":{\"69\":1}}],[\"给进程发送信号\",{\"1\":{\"729\":1}}],[\"给synchronized性能带来了很大的提升\",{\"1\":{\"654\":1}}],[\"给整个哈希表加了一把大锁\",{\"1\":{\"549\":1,\"593\":1}}],[\"给整个哈希表加了一把大锁从而实现线程安全\",{\"1\":{\"549\":1}}],[\"给一个integer对象赋一个int值的时候\",{\"1\":{\"499\":1}}],[\"给客户端\",{\"1\":{\"386\":1}}],[\"给多个消费者进行处理\",{\"1\":{\"355\":1}}],[\"给\",{\"1\":{\"323\":1,\"334\":1}}],[\"给服务器地址列表\",{\"1\":{\"258\":1}}],[\"给channel设计别名\",{\"1\":{\"237\":1}}],[\"给这个服务增加一个功能\",{\"1\":{\"223\":1}}],[\"给主库\",{\"1\":{\"133\":1}}],[\"给每个月都准备一个库就可以了\",{\"1\":{\"128\":1}}],[\"给记录显示加锁时\",{\"1\":{\"120\":1}}],[\"给用户提供仅仅能够满足其工作的最低权限\",{\"1\":{\"45\":1}}],[\"两者都是同一个线程每进入一次\",{\"1\":{\"648\":1,\"707\":1}}],[\"两者都是可重入锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"两者都可以暂停线程的执行\",{\"1\":{\"634\":1,\"702\":1}}],[\"两者的区别主要有如下\",{\"1\":{\"646\":1}}],[\"两者的钱加起来一共是\",{\"1\":{\"74\":1}}],[\"两者均可并发执行\",{\"1\":{\"620\":1,\"687\":1}}],[\"两者在内存中的地址不同\",{\"1\":{\"498\":1}}],[\"两者不能共存\",{\"1\":{\"356\":1}}],[\"两个变量之间互不干扰\",{\"1\":{\"712\":1}}],[\"两个线程通过对同一对象调用等待\",{\"1\":{\"732\":1}}],[\"两个线程都执行了\",{\"1\":{\"565\":1}}],[\"两个线程都会新建新的数组\",{\"1\":{\"564\":1}}],[\"两个线程发生并发显然是不被允许的\",{\"1\":{\"435\":1}}],[\"两个非new生成的integer对象的对比\",{\"0\":{\"499\":1},\"1\":{\"484\":1}}],[\"两个new生成的integer变量的对比\",{\"0\":{\"496\":1},\"1\":{\"484\":1}}],[\"两个对象有相同的hashcode值\",{\"1\":{\"479\":1}}],[\"两个对象相等\",{\"1\":{\"479\":1}}],[\"两个系统写库成功了\",{\"1\":{\"349\":1}}],[\"两个注解都用于方法参数\",{\"1\":{\"296\":1}}],[\"两个注解的区别\",{\"0\":{\"296\":1}}],[\"两大基本功能\",{\"1\":{\"251\":1}}],[\"两种\",{\"1\":{\"559\":2}}],[\"两种序列化的对比\",{\"0\":{\"523\":1},\"1\":{\"484\":1}}],[\"两种方法是什么关系\",{\"0\":{\"479\":1}}],[\"两种消息模式\",{\"1\":{\"362\":1}}],[\"两种实现方式\",{\"1\":{\"258\":1}}],[\"两种分库分表的方式\",{\"1\":{\"128\":1}}],[\"两种隔离级别\",{\"1\":{\"120\":1}}],[\"两种锁的使用场景\",{\"1\":{\"116\":1}}],[\"乐一般会使用版本号机制或cas算法实现\",{\"1\":{\"116\":1}}],[\"乐观锁来实现\",{\"1\":{\"381\":1}}],[\"乐观锁\",{\"1\":{\"116\":2}}],[\"乐观并发控制\",{\"1\":{\"116\":1}}],[\"悲观锁\",{\"1\":{\"116\":2}}],[\"怎样用通俗的语言解释\",{\"1\":{\"300\":1}}],[\"怎样处理\",{\"0\":{\"20\":1}}],[\"怎么办\",{\"0\":{\"527\":1},\"1\":{\"484\":1}}],[\"怎么处理\",{\"1\":{\"229\":1}}],[\"怎么完成一个rpc\",{\"1\":{\"215\":1}}],[\"怎么查看mysql语句有没有用到索引\",{\"0\":{\"157\":1}}],[\"怎么优化\",{\"0\":{\"135\":1}}],[\"怎么解决循环依赖问题\",{\"0\":{\"281\":1}}],[\"怎么解决\",{\"0\":{\"118\":1}}],[\"怎么实现的\",{\"0\":{\"116\":1}}],[\"他提供了检查计算是否完成的方法\",{\"1\":{\"676\":1}}],[\"他的功能是判断内存某个位置的值是否为预期值\",{\"1\":{\"644\":1}}],[\"他们共同消费该topic的数据\",{\"1\":{\"326\":1}}],[\"他们的原理知道么\",{\"1\":{\"142\":1}}],[\"他们的加锁开销从大到小\",{\"1\":{\"115\":1}}],[\"他和其他的排他锁\",{\"1\":{\"115\":1}}],[\"又可分为公平锁和非公平锁\",{\"1\":{\"680\":1}}],[\"又可以分为运行时异常\",{\"1\":{\"530\":1}}],[\"又暴露出子类锁需要扩展的地方\",{\"1\":{\"677\":1}}],[\"又叫受检查异常\",{\"1\":{\"530\":1}}],[\"又叫非受检查异常\",{\"1\":{\"530\":1}}],[\"又叫做写锁\",{\"1\":{\"115\":1}}],[\"又叫做读锁\",{\"1\":{\"115\":1}}],[\"又能调用子类的方法\",{\"1\":{\"465\":1}}],[\"又称动态多态\",{\"1\":{\"465\":1}}],[\"又称静态多态\",{\"1\":{\"465\":1}}],[\"又由于cow机制\",{\"1\":{\"415\":1}}],[\"又因为\",{\"1\":{\"399\":1}}],[\"又减小了需要传输的大小\",{\"1\":{\"34\":1}}],[\"页级锁是mysql中锁定粒度介于行级锁和表级锁中间的一种锁\",{\"1\":{\"114\":1}}],[\"页级锁\",{\"1\":{\"114\":1,\"115\":1}}],[\"页之间跳转时\",{\"1\":{\"39\":1}}],[\"极大地增加了\",{\"1\":{\"112\":1}}],[\"表明锁被释放\",{\"1\":{\"651\":1}}],[\"表长度为4\",{\"1\":{\"565\":1}}],[\"表的长度\",{\"1\":{\"564\":1,\"565\":1}}],[\"表的规范化程度越高\",{\"1\":{\"140\":1}}],[\"表和表之间的关系越多\",{\"1\":{\"140\":1}}],[\"表1\",{\"1\":{\"136\":2}}],[\"表结构也要改动\",{\"1\":{\"135\":1}}],[\"表级锁速度快\",{\"1\":{\"114\":1}}],[\"表级锁定分为表共享读锁\",{\"1\":{\"114\":1}}],[\"表级锁是mysql中锁定粒度最大的一种锁\",{\"1\":{\"114\":1}}],[\"表级锁\",{\"1\":{\"114\":2,\"115\":1}}],[\"表空间中\",{\"1\":{\"112\":1}}],[\"表示的是资源个数\",{\"1\":{\"731\":1}}],[\"表示停止该进程\",{\"1\":{\"729\":1}}],[\"表示终止该进程\",{\"1\":{\"729\":1}}],[\"表示当前线程正在执行任务中\",{\"1\":{\"714\":1}}],[\"表示异步计算的结果\",{\"1\":{\"621\":1,\"676\":1,\"688\":1}}],[\"表示锁完全释放\",{\"1\":{\"617\":1}}],[\"表示目前没有其他线程获得锁\",{\"1\":{\"617\":1}}],[\"表示能够获取到同步状态\",{\"1\":{\"612\":1}}],[\"表示获取成功也就正常退出了\",{\"1\":{\"605\":1}}],[\"表示节点在等待队列中\",{\"1\":{\"603\":1}}],[\"表示线程已经准备好了\",{\"1\":{\"603\":1}}],[\"表示线程获取锁的请求已经取消了\",{\"1\":{\"603\":1}}],[\"表示线程正在以独占的方式等待锁\",{\"1\":{\"603\":1}}],[\"表示线程以共享的模式等待锁\",{\"1\":{\"603\":1}}],[\"表示处于该节点的线程\",{\"1\":{\"603\":1}}],[\"表示扩容后\",{\"1\":{\"559\":1}}],[\"表示扩容前的\",{\"1\":{\"559\":1}}],[\"表示面试中出现的频率\",{\"1\":{\"545\":1}}],[\"表示数据库的连接对象\",{\"1\":{\"506\":1}}],[\"表示数据已经发送完毕\",{\"1\":{\"17\":1}}],[\"表示类的构造方法\",{\"1\":{\"504\":1}}],[\"表示类的方法\",{\"1\":{\"504\":1}}],[\"表示类的成员变量\",{\"1\":{\"504\":1}}],[\"表示\",{\"1\":{\"490\":1,\"531\":1}}],[\"表示一个哨兵认为master宕机即可认为master已宕机\",{\"1\":{\"428\":1}}],[\"表示没有自动装配\",{\"1\":{\"278\":1}}],[\"表示字段不重复的比例\",{\"1\":{\"161\":1}}],[\"表示额外信息\",{\"1\":{\"157\":1}}],[\"表示对当前操作的整张表加锁\",{\"1\":{\"114\":1}}],[\"表示只针对当前操作的行进行加锁\",{\"1\":{\"114\":1}}],[\"表示服务器上的某个资源被永久性的删除\",{\"1\":{\"33\":1}}],[\"表示请求的资源与资源的当前状态发生冲突\",{\"1\":{\"33\":1}}],[\"表示开启tcp连接中time\",{\"1\":{\"20\":1}}],[\"表示开启重用\",{\"1\":{\"20\":1}}],[\"表示关闭\",{\"1\":{\"20\":2}}],[\"表示层\",{\"1\":{\"8\":1}}],[\"隐藏的自增\",{\"1\":{\"112\":1}}],[\"隐私策略不同\",{\"1\":{\"41\":1}}],[\"聚簇索引与非聚簇索引的区别\",{\"1\":{\"151\":1}}],[\"聚簇索引\",{\"1\":{\"148\":1,\"151\":1}}],[\"聚簇索引记录中包含\",{\"1\":{\"112\":1}}],[\"聚集索引\",{\"1\":{\"79\":1,\"83\":1,\"148\":2}}],[\"同理另一进程读取内核中的消息数据时\",{\"1\":{\"726\":1}}],[\"同理\",{\"1\":{\"726\":1}}],[\"同意\",{\"1\":{\"425\":1}}],[\"同样\",{\"1\":{\"547\":1}}],[\"同样也会做过期检测\",{\"1\":{\"421\":1}}],[\"同样会压入队列然后被事件派发器取出交给相对应的命令回复处理器\",{\"1\":{\"403\":1}}],[\"同样的api\",{\"1\":{\"237\":1}}],[\"同\",{\"1\":{\"350\":3}}],[\"同步状态被释放并且同步器重新设置首节点\",{\"1\":{\"679\":1}}],[\"同步状态state\",{\"0\":{\"604\":1}}],[\"同步器唤醒等待队列中第一个节点\",{\"1\":{\"679\":1}}],[\"同步器重新设置尾节点\",{\"1\":{\"679\":1}}],[\"同步器将当前线程机等待状态等信息构造成一个node节点加入队列\",{\"1\":{\"679\":1}}],[\"同步队列管理着获取不到锁的线程的排队和释放\",{\"1\":{\"677\":1}}],[\"同步块或者同步方法执行时间较长的场景\",{\"1\":{\"658\":1}}],[\"同步代码块的实现是通过\",{\"1\":{\"651\":1}}],[\"同步原语\",{\"1\":{\"644\":1}}],[\"同步锁被其他线程占用\",{\"1\":{\"639\":1}}],[\"同步并非阻塞\",{\"1\":{\"542\":1}}],[\"同步并阻塞\",{\"1\":{\"542\":1}}],[\"同步配置的时候其他哨兵根据什么更新自己的配置呢\",{\"0\":{\"427\":1}}],[\"同步\",{\"1\":{\"401\":1,\"403\":1}}],[\"同步持久化\",{\"1\":{\"383\":1}}],[\"同步改变缓存中相应的数据\",{\"1\":{\"379\":1}}],[\"同步发消息\",{\"1\":{\"369\":1}}],[\"同步好数据了\",{\"1\":{\"323\":1}}],[\"同步阻塞\",{\"1\":{\"237\":1,\"623\":1,\"639\":1,\"690\":1}}],[\"同文件下\",{\"1\":{\"280\":1}}],[\"同文件中componentscan和\",{\"1\":{\"280\":1}}],[\"同一进程的线程共享本进程的地址空间和资源\",{\"1\":{\"620\":1,\"687\":1}}],[\"同一类线程共享代码和数据空间\",{\"1\":{\"620\":1,\"687\":1}}],[\"同一位置上新元素总会被放在链表的头部位置\",{\"1\":{\"558\":1,\"581\":1}}],[\"同一topic\",{\"1\":{\"368\":1}}],[\"同一个线程在没有释放锁之前无法再次获得该锁\",{\"1\":{\"432\":1}}],[\"同一个queue\",{\"1\":{\"368\":1}}],[\"同一个组下的每个实例都配置有相同的组id\",{\"1\":{\"326\":1}}],[\"同一个配置文件内同名的bean\",{\"1\":{\"280\":1}}],[\"同一时刻看到的数据可能是不一样的\",{\"1\":{\"111\":1}}],[\"同时通信数据都遵循先进先出原则\",{\"1\":{\"731\":1}}],[\"同时所有队列所包含的全部消息体的总长度也是有上限\",{\"1\":{\"726\":1}}],[\"同时为了减少锁竞争\",{\"1\":{\"643\":1}}],[\"同时可以多个线程运行\",{\"1\":{\"601\":1}}],[\"同时不会有太大的开销\",{\"1\":{\"555\":1}}],[\"同时会先判断是否需要扩容\",{\"1\":{\"585\":1}}],[\"同时会将\",{\"1\":{\"488\":1}}],[\"同时会逐步将数据缓存到查询缓存中\",{\"1\":{\"88\":1,\"99\":1}}],[\"同时也使得这个锁的线程的所有操作都\",{\"1\":{\"646\":1}}],[\"同时也会与其他已经加入的对象的\",{\"1\":{\"478\":1}}],[\"同时也是数据库索引索引所采用的存储结构\",{\"1\":{\"149\":1}}],[\"同时y\",{\"1\":{\"476\":1}}],[\"同时又保留了解释型语言可移植的特点\",{\"1\":{\"446\":1}}],[\"同时又不能被其他consumer消费的情况\",{\"1\":{\"366\":1}}],[\"同时还会将从客户端收到的所有写命令缓存在内存中\",{\"1\":{\"420\":1}}],[\"同时还有一些使用了函数之类的语句无法被记录复制\",{\"1\":{\"89\":1}}],[\"同时需要通知业务方变更配置\",{\"1\":{\"415\":1}}],[\"同时将这个\",{\"1\":{\"403\":1}}],[\"同时在数据库中也不存在\",{\"1\":{\"395\":1}}],[\"同时在索引表中保存指向每个数据行的指针\",{\"1\":{\"149\":1}}],[\"同时由于前部分是rdb格式\",{\"1\":{\"384\":1}}],[\"同时结合aof\",{\"1\":{\"384\":1}}],[\"同时b的某个field或者setter依赖了a的实例对象\",{\"1\":{\"281\":1}}],[\"同时装配\",{\"1\":{\"278\":1}}],[\"同时该\",{\"1\":{\"272\":1}}],[\"同时观察\",{\"1\":{\"141\":1}}],[\"同时我们还可以发现在a值相等的情况下\",{\"1\":{\"84\":1}}],[\"同时遇到范围查询\",{\"1\":{\"84\":1}}],[\"同时\",{\"1\":{\"40\":1,\"98\":1,\"345\":1}}],[\"同时缓存ip\",{\"1\":{\"38\":1}}],[\"同时等待\",{\"1\":{\"16\":1}}],[\"同时等待服务端的确认\",{\"1\":{\"16\":1}}],[\"同时选择一个随机数\",{\"1\":{\"11\":2}}],[\"后续对线程进行中断操作时\",{\"1\":{\"610\":1}}],[\"后继指针\",{\"1\":{\"602\":1,\"603\":1}}],[\"后者依赖于硬件的发展\",{\"1\":{\"401\":1}}],[\"后者相当于单线程执行\",{\"1\":{\"110\":1}}],[\"后面会专门写一篇文章讲解\",{\"1\":{\"561\":1}}],[\"后面再出现查询这个key的请求的时候\",{\"1\":{\"395\":1}}],[\"后面加负载均衡\",{\"1\":{\"251\":1}}],[\"后删除缓存\",{\"0\":{\"393\":1},\"1\":{\"389\":1}}],[\"后更新数据库\",{\"0\":{\"390\":1},\"1\":{\"389\":2}}],[\"后更新缓存\",{\"1\":{\"389\":1}}],[\"后\",{\"1\":{\"290\":1,\"454\":1}}],[\"后解析的配置文件会覆盖先解析的配置文件\",{\"1\":{\"280\":1}}],[\"后端\",{\"1\":{\"44\":1}}],[\"后端往往需要多台服务器共同来支撑前端用户请求\",{\"1\":{\"42\":1}}],[\"前驱结点是头结点\",{\"1\":{\"614\":1}}],[\"前驱节点\",{\"1\":{\"612\":1}}],[\"前驱是头结点\",{\"1\":{\"608\":1}}],[\"前驱指针\",{\"1\":{\"602\":1,\"603\":1}}],[\"前执行\",{\"1\":{\"536\":1}}],[\"前两者都需要显式地调用构造方法\",{\"1\":{\"471\":1}}],[\"前缀\",{\"1\":{\"293\":1}}],[\"前提是引入相关了jar包\",{\"1\":{\"506\":1}}],[\"前提处理\",{\"1\":{\"244\":1}}],[\"前提\",{\"1\":{\"237\":1,\"251\":1}}],[\"前面说到的通信机制\",{\"1\":{\"731\":1}}],[\"前面提到的管道\",{\"1\":{\"730\":1}}],[\"前面我们也讲到了\",{\"1\":{\"648\":1,\"707\":1}}],[\"前面服务端的代码中有sevicerprovide\",{\"1\":{\"230\":1}}],[\"前面都有检索的拼音和偏旁\",{\"1\":{\"146\":1}}],[\"前者不加锁限制\",{\"1\":{\"110\":1}}],[\"前端\",{\"1\":{\"44\":1}}],[\"尚有脏页未写入磁盘\",{\"1\":{\"106\":1}}],[\"说说broker服务节点\",{\"0\":{\"355\":1}}],[\"说一下\",{\"0\":{\"651\":1}}],[\"说一下hashtable的锁机制\",{\"0\":{\"593\":1}}],[\"说一下mysql\",{\"0\":{\"102\":1}}],[\"说一说什么是aqs\",{\"0\":{\"677\":1}}],[\"说一说arraylist\",{\"0\":{\"573\":1}}],[\"说一说索引的底层实现\",{\"0\":{\"149\":1}}],[\"说明有多余的worker线程\",{\"1\":{\"721\":1}}],[\"说明它没有在处理任务\",{\"1\":{\"714\":1}}],[\"说明当前设置线程池中线程已经处理不了了\",{\"1\":{\"671\":1}}],[\"说明锁已经被获取了\",{\"1\":{\"617\":1}}],[\"说明子类中无法重写它们\",{\"1\":{\"604\":1}}],[\"说明其他线程在扩容\",{\"1\":{\"547\":1,\"585\":1}}],[\"说明该字符串常量在堆中\",{\"1\":{\"488\":1}}],[\"说明key已经存在\",{\"1\":{\"434\":1}}],[\"说明key原本不存在\",{\"1\":{\"434\":1}}],[\"说明\",{\"1\":{\"136\":1,\"291\":1}}],[\"说明这个域名可以使用\",{\"1\":{\"62\":1}}],[\"持有adaptee类\",{\"1\":{\"543\":1}}],[\"持久化的优点\",{\"1\":{\"384\":1}}],[\"持久化消息等\",{\"1\":{\"363\":1}}],[\"持久化\",{\"1\":{\"356\":1,\"378\":1}}],[\"持久化日志\",{\"1\":{\"325\":1}}],[\"持久性是指一个事务一旦被提交\",{\"1\":{\"74\":1}}],[\"持久性\",{\"1\":{\"74\":1}}],[\"持续性\",{\"1\":{\"101\":1}}],[\"事实上\",{\"1\":{\"714\":1}}],[\"事实上使用这种方式性能是很低的\",{\"1\":{\"244\":1}}],[\"事件与命令回复处理器的关联关系\",{\"1\":{\"403\":1}}],[\"事件与命令回复处理器关联\",{\"1\":{\"403\":1}}],[\"事件与命令请求处理器关联起来\",{\"1\":{\"403\":1}}],[\"事件已经和命令请求处理器关联了\",{\"1\":{\"403\":1}}],[\"事件关联起来\",{\"1\":{\"403\":1}}],[\"事件处理器包括\",{\"1\":{\"403\":1}}],[\"事件处理器\",{\"1\":{\"403\":1}}],[\"事件\",{\"1\":{\"403\":7}}],[\"事件驱动方式是建立好长连接\",{\"1\":{\"366\":1}}],[\"事件驱动模型就是观察者模式很经典的一个应用\",{\"1\":{\"286\":1}}],[\"事后\",{\"1\":{\"396\":1}}],[\"事中\",{\"1\":{\"396\":1}}],[\"事前\",{\"1\":{\"396\":1}}],[\"事\",{\"1\":{\"101\":1}}],[\"事务可以运行直到执行完所有事务队列中的命令为止\",{\"1\":{\"410\":1}}],[\"事务可以理解为一个打包的批量执行脚本\",{\"1\":{\"407\":1}}],[\"事务提供\",{\"1\":{\"409\":1}}],[\"事务提交\",{\"1\":{\"112\":1}}],[\"事务执行过程中\",{\"1\":{\"408\":1}}],[\"事务将打断\",{\"1\":{\"408\":1}}],[\"事务在执行的过程中\",{\"1\":{\"407\":1}}],[\"事务机制和\",{\"1\":{\"356\":1}}],[\"事务机制和confirm机制\",{\"1\":{\"356\":1}}],[\"事务实现方式有哪些\",{\"0\":{\"287\":1}}],[\"事务管理\",{\"1\":{\"263\":1}}],[\"事务未提交之前\",{\"1\":{\"107\":1}}],[\"事务日志文件就能派上用场\",{\"1\":{\"105\":1}}],[\"事务日志的目的\",{\"1\":{\"105\":1}}],[\"事务日志包括\",{\"1\":{\"105\":1}}],[\"事务请求的锁越少\",{\"1\":{\"102\":1}}],[\"事务隔离机制的实现基于锁机制和并发调度\",{\"1\":{\"102\":1}}],[\"事务中包含的各操作要么都做\",{\"1\":{\"101\":1}}],[\"事务把数据库从一种一致性状态转换成另一种一致性状态\",{\"1\":{\"101\":1}}],[\"事务就是一组原子性的操作\",{\"1\":{\"101\":1}}],[\"事务就是保证这两个关键操作要么都成功\",{\"1\":{\"100\":1}}],[\"事务最经典也经常被拿出来说例子就是转账了\",{\"1\":{\"100\":1}}],[\"事务是由下层的存储引擎实现的\",{\"1\":{\"109\":1}}],[\"事务是基于重做日志文件\",{\"1\":{\"104\":1}}],[\"事务是数据库的逻辑工作单位\",{\"1\":{\"101\":1}}],[\"事务是逻辑上的一组操作\",{\"1\":{\"100\":1}}],[\"事务是一个不可分割的数据库操作序列\",{\"1\":{\"100\":1}}],[\"事务\",{\"0\":{\"90\":1},\"1\":{\"90\":2,\"103\":3,\"112\":2,\"126\":1,\"310\":1,\"405\":1}}],[\"事务的执行并不是原子性的\",{\"1\":{\"407\":1}}],[\"事务的最终结果将无法确定\",{\"1\":{\"109\":1}}],[\"事务的实现原理\",{\"0\":{\"104\":1}}],[\"事务的隔离级别\",{\"0\":{\"76\":1}}],[\"事务的特性\",{\"0\":{\"74\":1}}],[\"事务再次查询返回的结果不一样\",{\"1\":{\"75\":1}}],[\"事务插入了一条状态为\",{\"1\":{\"75\":1}}],[\"事务查询状态为\",{\"1\":{\"75\":1}}],[\"事务结束后两个用户的钱相加起来应该还得是\",{\"1\":{\"74\":1}}],[\"刷盘\",{\"1\":{\"99\":1}}],[\"写i\",{\"1\":{\"717\":1}}],[\"写和写之间才会互斥\",{\"1\":{\"667\":1}}],[\"写和读\",{\"1\":{\"667\":1}}],[\"写锁是独占的\",{\"1\":{\"667\":1}}],[\"写请求命令\",{\"1\":{\"403\":1}}],[\"写请求可以删除读请求造成的缓存脏数据\",{\"1\":{\"391\":1}}],[\"写数据的休眠时间则在读数据业务逻辑的耗时基础上\",{\"1\":{\"391\":1}}],[\"写数据的时候\",{\"1\":{\"323\":1}}],[\"写的速度是81000次\",{\"1\":{\"376\":1}}],[\"写的时候\",{\"1\":{\"323\":1}}],[\"写入之前需要将当前线程包装为一个\",{\"1\":{\"617\":1}}],[\"写入队列\",{\"1\":{\"617\":1}}],[\"写入序列化字节数组\",{\"1\":{\"244\":1}}],[\"写入序列化方式\",{\"1\":{\"244\":1}}],[\"写入长度\",{\"1\":{\"244\":1}}],[\"写入消息类型\",{\"1\":{\"244\":1}}],[\"写入到前4个字节中\",{\"1\":{\"237\":1}}],[\"写入到客户端\",{\"1\":{\"230\":1}}],[\"写入socket\",{\"1\":{\"230\":1}}],[\"写入response对象\",{\"1\":{\"223\":1}}],[\"写入user对象给客户端\",{\"1\":{\"216\":1}}],[\"写sql语句\",{\"1\":{\"193\":1}}],[\"写在\",{\"1\":{\"179\":1}}],[\"写分离\",{\"1\":{\"142\":1}}],[\"写\",{\"1\":{\"99\":1}}],[\"执行默认操作\",{\"1\":{\"729\":1,\"731\":1}}],[\"执行流程如下图所示\",{\"1\":{\"714\":1}}],[\"执行processworkerexit\",{\"1\":{\"714\":1}}],[\"执行任务流程\",{\"1\":{\"714\":1}}],[\"执行任务\",{\"1\":{\"714\":2}}],[\"执行效率大为提升\",{\"1\":{\"684\":1}}],[\"执行效率比较高\",{\"1\":{\"98\":1}}],[\"执行execute\",{\"0\":{\"669\":1}}],[\"执行清理任务的时候会触发尝试降级锁\",{\"1\":{\"662\":1}}],[\"执行一定次数之后\",{\"1\":{\"652\":1}}],[\"执行yield\",{\"1\":{\"636\":1,\"705\":1}}],[\"执行不同的tryacquire\",{\"1\":{\"615\":1}}],[\"执行相关内部类的lock方法\",{\"1\":{\"615\":1}}],[\"执行完相应逻辑后就需要释放同步状态\",{\"1\":{\"611\":1}}],[\"执行完成\",{\"1\":{\"435\":1}}],[\"执行add\",{\"1\":{\"571\":1}}],[\"执行tab\",{\"1\":{\"565\":1}}],[\"执行结果\",{\"1\":{\"536\":2}}],[\"执行\",{\"1\":{\"454\":1,\"672\":1}}],[\"执行时间超过了\",{\"1\":{\"435\":2}}],[\"执行时发生的异常\",{\"1\":{\"291\":1}}],[\"执行切换的那个哨兵\",{\"1\":{\"427\":1}}],[\"执行过程\",{\"1\":{\"620\":1,\"687\":1}}],[\"执行过程中如果部分命令运行错误\",{\"1\":{\"412\":1}}],[\"执行过的所有语句\",{\"1\":{\"108\":1}}],[\"执行所有事务块内的命令\",{\"1\":{\"409\":1}}],[\"执行主逻辑也是在\",{\"1\":{\"406\":1}}],[\"执行命令仍然是单线程顺序执行\",{\"1\":{\"405\":1}}],[\"执行速度是非常快的\",{\"1\":{\"399\":1}}],[\"执行约\",{\"1\":{\"348\":1}}],[\"执行服务方法\",{\"1\":{\"230\":1}}],[\"执行crud操作\",{\"1\":{\"198\":1}}],[\"执行sql\",{\"1\":{\"198\":1}}],[\"执行原理是根据表达式的值完成逻辑判断\",{\"1\":{\"184\":1}}],[\"执行原理是什么\",{\"0\":{\"184\":1}}],[\"执行性能\",{\"1\":{\"178\":1}}],[\"执行relay\",{\"1\":{\"132\":1}}],[\"执行查询的过程\",{\"0\":{\"99\":1}}],[\"项目时\",{\"1\":{\"304\":1}}],[\"项目使用maven搭建\",{\"1\":{\"214\":1}}],[\"项目的生命周期也比较短\",{\"1\":{\"98\":1}}],[\"项目给我一个star\",{\"1\":{\"70\":1}}],[\"我已经到达了屏障\",{\"1\":{\"681\":1}}],[\"我在系统内部维护n个内存队列\",{\"1\":{\"392\":1}}],[\"我的博客\",{\"1\":{\"230\":1}}],[\"我这里似乎不需要replace\",{\"1\":{\"196\":1}}],[\"我个人的理解是\",{\"1\":{\"98\":1}}],[\"我们实现了线程池参数的动态化\",{\"1\":{\"721\":1}}],[\"我们实现负载均衡的两种策略\",{\"1\":{\"260\":1}}],[\"我们来演示个例子\",{\"1\":{\"565\":1}}],[\"我们来举个例子\",{\"1\":{\"555\":1}}],[\"我们来追溯下作者在源码中的注释\",{\"1\":{\"554\":1,\"578\":1}}],[\"我们来先看下hashmap的默认构造函数\",{\"1\":{\"554\":1,\"578\":1}}],[\"我们来看下jdk\",{\"1\":{\"565\":1,\"566\":1}}],[\"我们来看下详细过程\",{\"1\":{\"555\":1,\"579\":1}}],[\"我们来看看多线程下的rehash\",{\"1\":{\"564\":1}}],[\"我们来看作者在源码中的注释\",{\"1\":{\"553\":1}}],[\"我们来看一下它的部分代码\",{\"1\":{\"714\":1}}],[\"我们来看一下\",{\"1\":{\"506\":1}}],[\"我们期望的结果是返回false\",{\"1\":{\"588\":1}}],[\"我们期望的结果是返回\",{\"1\":{\"548\":1}}],[\"我们用反证法来推理\",{\"1\":{\"548\":1,\"588\":1}}],[\"我们没办法通过\",{\"1\":{\"530\":1}}],[\"我们也不知道\",{\"1\":{\"511\":1}}],[\"我们定义了一个泛型类\",{\"1\":{\"511\":1}}],[\"我们不知道这个\",{\"1\":{\"548\":1,\"588\":1}}],[\"我们不希望每次创建method对象都要重新初始化\",{\"1\":{\"507\":1}}],[\"我们不去讨论它们\",{\"1\":{\"488\":2}}],[\"我们不去管它\",{\"1\":{\"386\":1}}],[\"我们通过图来一行行解释\",{\"1\":{\"488\":1}}],[\"我们通常所说的多态指的都是运行时多态\",{\"1\":{\"465\":1}}],[\"我们现在所说的就是全局字符串常量池\",{\"1\":{\"487\":1}}],[\"我们优先考虑哨兵模式\",{\"1\":{\"416\":1}}],[\"我们只需要维护threadpoolexecutor的实例\",{\"1\":{\"721\":1}}],[\"我们只需要通过简单的配置\",{\"1\":{\"270\":1}}],[\"我们只用一个线程的话\",{\"1\":{\"622\":1,\"689\":1}}],[\"我们只会在使用该键时才会进行过期检查\",{\"1\":{\"386\":1}}],[\"我们在检查其是否过期\",{\"1\":{\"386\":1}}],[\"我们创建一个定时器\",{\"1\":{\"386\":1}}],[\"我们一般会开启多线程消费机制\",{\"1\":{\"337\":1}}],[\"我们一般使用\",{\"1\":{\"271\":1}}],[\"我们需要创建两个管道才行\",{\"1\":{\"725\":1}}],[\"我们需要将redis中的数据写入到磁盘空间中\",{\"1\":{\"383\":1}}],[\"我们需要保证对于有逻辑关联的多条mq消息被按顺序处理\",{\"1\":{\"335\":1}}],[\"我们需要注意\",{\"1\":{\"155\":1}}],[\"我们的类会不断迭代\",{\"1\":{\"525\":1}}],[\"我们的项目需要连接多个数据库\",{\"1\":{\"286\":1}}],[\"我们的rpc总体框架已经有了\",{\"1\":{\"255\":1}}],[\"我们的request仅仅只发送了一个id参数过去\",{\"1\":{\"223\":1}}],[\"我们以类\",{\"1\":{\"283\":1}}],[\"我们开启两台服务提供者\",{\"1\":{\"259\":1}}],[\"我们返回的总是第一个ip\",{\"1\":{\"254\":1}}],[\"我们看做黑盒即可\",{\"1\":{\"250\":1}}],[\"我们自己创建使用\",{\"1\":{\"673\":1}}],[\"我们自己定义的消息格式\",{\"1\":{\"246\":1}}],[\"我们自己建的索引基本都是非聚簇索引\",{\"1\":{\"151\":1}}],[\"我们使用的是netty自带的编码器\",{\"1\":{\"244\":1}}],[\"我们都会在后面讲到\",{\"1\":{\"680\":1}}],[\"我们都会显示指定一个serialversionuid\",{\"1\":{\"525\":1}}],[\"我们都覆盖equals\",{\"1\":{\"476\":1}}],[\"我们都知道\",{\"1\":{\"407\":1,\"518\":1,\"563\":1}}],[\"我们都知道索引的底层是一颗b+树\",{\"1\":{\"84\":1}}],[\"我们都是使用的java自带的序列化的方式\",{\"1\":{\"244\":1}}],[\"我们先来说value\",{\"1\":{\"548\":1,\"588\":1}}],[\"我们先进行代码重构\",{\"1\":{\"237\":1}}],[\"我们先去把服务端代码松耦合\",{\"1\":{\"230\":1}}],[\"我们重构了服务端的代码\",{\"1\":{\"232\":1}}],[\"我们发现服务接口名是我们\",{\"1\":{\"230\":1}}],[\"我们还提供了线程池版的实现\",{\"1\":{\"230\":1}}],[\"我们就执行相应的信号处理函数\",{\"1\":{\"729\":1}}],[\"我们就有下面这几种\",{\"1\":{\"729\":1}}],[\"我们就要充分利用redis工具包中提供的redis\",{\"1\":{\"407\":1}}],[\"我们就把这个key保存到redis中\",{\"1\":{\"395\":1}}],[\"我们就对一些key进行检查\",{\"1\":{\"386\":1}}],[\"我们就删掉它\",{\"1\":{\"386\":1}}],[\"我们就能从map中取出对应的服务\",{\"1\":{\"229\":1}}],[\"我们就越倾向于使用全表扫描\",{\"1\":{\"151\":1}}],[\"我们将在接下来的版本更新中逐渐完善它\",{\"1\":{\"218\":1}}],[\"我们判断此次查询是\",{\"1\":{\"157\":1}}],[\"我们称为回表\",{\"1\":{\"151\":1}}],[\"我们要找到具体的数据\",{\"1\":{\"150\":1}}],[\"我们可以为信号定义一个信号处理函数\",{\"1\":{\"729\":1}}],[\"我们可以通过键盘输入某些组合键的时候\",{\"1\":{\"729\":1}}],[\"我们可以通过修改state字段表示的同步状态来实现多线程的独占模式和共享模式\",{\"1\":{\"604\":1}}],[\"我们可以再介绍下阻塞队列的成员\",{\"1\":{\"713\":1}}],[\"我们可以简单地说这两者的利用率目前都是\",{\"1\":{\"622\":1,\"689\":1}}],[\"我们可以用concurrenthashmap\",{\"1\":{\"588\":1}}],[\"我们可以用\",{\"1\":{\"548\":1}}],[\"我们可以采取降级措施\",{\"1\":{\"424\":1}}],[\"我们可以先对使用布隆过滤器方案进行过滤掉这些key\",{\"1\":{\"395\":1}}],[\"我们可以很方面的获得类似于最新回复这类的功能实现\",{\"1\":{\"382\":1}}],[\"我们可以控制在一个月的范围内\",{\"1\":{\"142\":1}}],[\"我们可以剔除一些不必要的拥塞报文\",{\"1\":{\"24\":1}}],[\"我们当用户在查询订单历史的时候\",{\"1\":{\"142\":1}}],[\"我们知道了最大线程数和核心线程数可以动态调整\",{\"1\":{\"721\":1}}],[\"我们知道对\",{\"1\":{\"393\":1}}],[\"我们知道接受到请求格式是rpcrequest\",{\"1\":{\"237\":1}}],[\"我们知道\",{\"1\":{\"134\":1}}],[\"我们知道两种锁各有优缺点\",{\"1\":{\"116\":1}}],[\"我们拿上面的例子\",{\"1\":{\"112\":1}}],[\"开放出\",{\"1\":{\"677\":1}}],[\"开放定址法也称为再散列法\",{\"1\":{\"576\":1}}],[\"开放定址法\",{\"1\":{\"576\":1}}],[\"开放封闭原则\",{\"1\":{\"230\":1}}],[\"开始引入了自动装箱\",{\"1\":{\"493\":1,\"494\":1}}],[\"开始\",{\"1\":{\"450\":2}}],[\"开始生成一份rdb快照文件\",{\"1\":{\"420\":1}}],[\"开始full\",{\"1\":{\"420\":1}}],[\"开始由\",{\"1\":{\"290\":1}}],[\"开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象\",{\"1\":{\"465\":1}}],[\"开发成本高\",{\"1\":{\"418\":1}}],[\"开发\",{\"1\":{\"350\":1}}],[\"开发语言\",{\"1\":{\"350\":1}}],[\"开发和运行spring应用\",{\"1\":{\"304\":1}}],[\"开发可以节省很多代码\",{\"1\":{\"178\":1}}],[\"开发难易程度和学习成本\",{\"1\":{\"175\":1}}],[\"开发工作量相对大些\",{\"1\":{\"175\":1}}],[\"开发者开发时只需要关注如何编写sql语句\",{\"1\":{\"172\":1}}],[\"开发手册\",{\"1\":{\"98\":1,\"493\":1}}],[\"开源的\",{\"1\":{\"125\":1}}],[\"开销比较大\",{\"1\":{\"463\":1}}],[\"开销和加锁时间界于表锁和行锁之间\",{\"1\":{\"114\":1}}],[\"开销小\",{\"1\":{\"114\":1}}],[\"开销大\",{\"1\":{\"114\":1}}],[\"开启数据持久化功能和配置合理的备份策略\",{\"1\":{\"415\":1}}],[\"开启事务\",{\"1\":{\"408\":1}}],[\"开启redis持久化机制\",{\"1\":{\"396\":1}}],[\"开启一个信道\",{\"1\":{\"357\":1,\"358\":1}}],[\"开启一个新线程去处理\",{\"1\":{\"230\":1}}],[\"开启一个线程去处理\",{\"1\":{\"216\":1,\"223\":1}}],[\"开启\",{\"1\":{\"69\":2}}],[\"三种特殊的数据类型\",{\"1\":{\"382\":1}}],[\"三个系统那里\",{\"1\":{\"349\":1}}],[\"三个系统分别写库要\",{\"1\":{\"347\":1}}],[\"三个系统写库\",{\"1\":{\"347\":1}}],[\"三个系统\",{\"1\":{\"346\":1}}],[\"三级缓存\",{\"1\":{\"281\":1}}],[\"三者都表示删除\",{\"1\":{\"97\":1}}],[\"三次握手连接阶段\",{\"0\":{\"15\":1}}],[\"三次握手才能让双方均确认自己和对方的发送和接收能力都正常\",{\"1\":{\"12\":1}}],[\"三次握手机制\",{\"1\":{\"11\":1}}],[\"约束\",{\"1\":{\"94\":1}}],[\"约束有哪几种\",{\"0\":{\"94\":1}}],[\"候选键\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"超过最大值就不再扩充了\",{\"1\":{\"559\":1}}],[\"超过最大容量\",{\"1\":{\"556\":1}}],[\"超类\",{\"1\":{\"464\":1}}],[\"超大分页怎么处理\",{\"0\":{\"136\":1}}],[\"超键包含候选键和主键\",{\"1\":{\"93\":1}}],[\"超键\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"超时后线程会自动苏醒\",{\"1\":{\"633\":1,\"701\":1}}],[\"超时的方法\",{\"1\":{\"612\":1}}],[\"超时解锁导致并发\",{\"1\":{\"435\":1}}],[\"超时都会失效\",{\"1\":{\"41\":1}}],[\"超时失效时会话结束\",{\"1\":{\"39\":1}}],[\"超时重传是指发送出去的数据包到接收到确认包之间的时间\",{\"1\":{\"22\":1}}],[\"超时重传\",{\"1\":{\"22\":2}}],[\"超时重试机制\",{\"1\":{\"19\":1}}],[\"超时\",{\"1\":{\"18\":1}}],[\"引起该异常的原因是\",{\"1\":{\"533\":1}}],[\"引起的\",{\"1\":{\"533\":1}}],[\"引起数据库压力剧增\",{\"1\":{\"394\":1}}],[\"引用类型原子类\",{\"1\":{\"683\":1}}],[\"引用类型\",{\"1\":{\"683\":1}}],[\"引用类型数组原子类\",{\"1\":{\"683\":1}}],[\"引用类型作为参数被传递时也是值传递\",{\"1\":{\"474\":1}}],[\"引用扩容前的entry数组\",{\"1\":{\"558\":1,\"581\":1}}],[\"引用地址\",{\"1\":{\"499\":1}}],[\"引用传递\",{\"1\":{\"474\":1}}],[\"引用数据类型是由用户自定义\",{\"1\":{\"449\":1}}],[\"引用数据类型建立在基本数据类型的基础上\",{\"1\":{\"449\":1}}],[\"引用进行装配\",{\"1\":{\"278\":1}}],[\"引入了红黑树\",{\"1\":{\"553\":1,\"575\":1}}],[\"引入的多线程\",{\"1\":{\"402\":1}}],[\"引入多线程处理异步任务\",{\"1\":{\"400\":1}}],[\"引入zookeeper作为注册中心\",{\"1\":{\"251\":1}}],[\"引入状态码和状态信息表示服务调用成功还是失败\",{\"1\":{\"223\":1}}],[\"引擎都是最合适的\",{\"1\":{\"92\":1}}],[\"引发重传机制\",{\"1\":{\"22\":1}}],[\"所能容纳的键值对个数越多\",{\"1\":{\"554\":1,\"578\":1}}],[\"所得即所需\",{\"1\":{\"510\":1}}],[\"所拥有的一切\",{\"1\":{\"444\":1}}],[\"所谓原子类说简单点就是具有原子\",{\"1\":{\"682\":1}}],[\"所谓编码就是具体使用哪种底层数据结构来实现\",{\"1\":{\"438\":1}}],[\"所谓的管道\",{\"1\":{\"725\":1}}],[\"所谓的公平锁就是先等待的线程先获得锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"所谓的preferred\",{\"1\":{\"340\":1}}],[\"所谓的分区上线\",{\"1\":{\"340\":1}}],[\"所谓完全\",{\"1\":{\"91\":1}}],[\"所在节点宕机了\",{\"1\":{\"323\":1}}],[\"所共享\",{\"1\":{\"272\":1}}],[\"所需的依赖项和服务在\",{\"1\":{\"268\":1}}],[\"所需实体类及mapper接口\",{\"0\":{\"205\":1}}],[\"所有任务的调度都是由execute方法完成的\",{\"1\":{\"713\":1}}],[\"所有被屏障拦截的线程才会继续干活\",{\"1\":{\"681\":1}}],[\"所有处理由aqs框架完成\",{\"1\":{\"615\":1}}],[\"所有工作都在编译器中完成\",{\"1\":{\"510\":1}}],[\"所有方法不能被重写\",{\"1\":{\"454\":1}}],[\"所有节点都持有一份元数据\",{\"1\":{\"430\":1}}],[\"所有master的容量总和就是redis\",{\"1\":{\"413\":1}}],[\"所有队列中的命令才会被执行\",{\"1\":{\"409\":1}}],[\"所有主要的编程语言均有与代理接口通讯的客户端库\",{\"1\":{\"351\":1}}],[\"所有副本\",{\"1\":{\"338\":1}}],[\"所有\",{\"1\":{\"323\":1}}],[\"所有需要查询字段的值\",{\"1\":{\"152\":1}}],[\"所有的在同步队列中的线程都会通过cas操作去竞争锁\",{\"1\":{\"614\":1}}],[\"所有的异常都有一个共同的祖先\",{\"1\":{\"530\":1}}],[\"所有的键根据哈希函数映射到0～16383个整数槽内\",{\"1\":{\"417\":1}}],[\"所有的对象都可以预加载\",{\"1\":{\"266\":1}}],[\"所有的bean在启动的时候都进行了加载\",{\"1\":{\"266\":1}}],[\"所有的非终端结点可以看成是索引部分\",{\"1\":{\"149\":1}}],[\"所有的叶子结点中包含了全部关键字的信息\",{\"1\":{\"149\":1}}],[\"所有库表的数据加起来就是全部数据\",{\"1\":{\"128\":1}}],[\"所有事务都可以看到其他未提交事务的执行结果\",{\"1\":{\"102\":1}}],[\"所以每个消息体都是固定大小的存储块\",{\"1\":{\"726\":1}}],[\"所以每次获取时都是最新值\",{\"1\":{\"547\":1}}],[\"所以volatile性能肯定比synchronized关键字要好\",{\"1\":{\"709\":1}}],[\"所以此时的最大线程数对线程池来说没有意义\",{\"1\":{\"673\":1}}],[\"所以线程没有像进程通信中的用于数据交换的通信机制\",{\"1\":{\"731\":1}}],[\"所以线程池只需要提供这三个关键参数的配置\",{\"1\":{\"720\":1}}],[\"所以线程池只会创建核心线程数量的线程\",{\"1\":{\"673\":1}}],[\"所以线程也被称为轻权进程或者轻量级进程\",{\"1\":{\"620\":1,\"687\":1}}],[\"所以没有办法增加特别多的线程来处理任务\",{\"1\":{\"673\":1}}],[\"所以要等到锁的计数器下降为0时才能释放锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"所以无法判断任务是否被线程池执行成功与否\",{\"1\":{\"669\":1,\"697\":1}}],[\"所以无法响应中断的任务可能永远无法终\",{\"1\":{\"630\":1,\"698\":1}}],[\"所以无论你限定\",{\"1\":{\"511\":1}}],[\"所以无论那个表大\",{\"1\":{\"96\":1}}],[\"所以非常适合多个相同线程来处理同一份资源的情况\",{\"1\":{\"621\":1,\"688\":1}}],[\"所以多进程要比多线程健壮\",{\"1\":{\"620\":1,\"687\":1}}],[\"所以有随机访问功能\",{\"1\":{\"571\":1}}],[\"所以有可能调用\",{\"1\":{\"454\":1}}],[\"所以插入\",{\"1\":{\"571\":1}}],[\"所以插入和删除元素的时间复杂度受元素位置的影响\",{\"1\":{\"571\":1}}],[\"所以原作者在选择链表元素个数时选择了\",{\"1\":{\"553\":1}}],[\"所以继续执行finally的内容\",{\"1\":{\"536\":1}}],[\"所以你即使对所有代码加上try\",{\"1\":{\"535\":1}}],[\"所以catch可以省略\",{\"1\":{\"535\":1}}],[\"所以需要保护机制\",{\"1\":{\"728\":1}}],[\"所以需要确保同步状态安全地成功释放\",{\"1\":{\"613\":1}}],[\"所以需要单独记住\",{\"1\":{\"506\":1}}],[\"所以需要额外指令\",{\"1\":{\"434\":1}}],[\"所以两个通过new生成的integer变量永远是不相等的\",{\"1\":{\"496\":1}}],[\"所以相比于其他对象更快\",{\"1\":{\"491\":1}}],[\"所以当创建字符串时\",{\"1\":{\"491\":1}}],[\"所以返回true\",{\"1\":{\"488\":1}}],[\"所以返回false\",{\"1\":{\"488\":3}}],[\"所以hashmap中的键往往都使用string\",{\"1\":{\"482\":1}}],[\"所以保证了多线程的安全\",{\"1\":{\"482\":1}}],[\"所以是线程安全的\",{\"1\":{\"481\":1}}],[\"所以是最终一致性\",{\"1\":{\"374\":1}}],[\"所以string对象是不可变的\",{\"1\":{\"481\":1}}],[\"所以概念上不适用\",{\"1\":{\"456\":1}}],[\"所以java程序运行时比较高效\",{\"1\":{\"446\":1}}],[\"所以为了实现预处理\",{\"1\":{\"443\":1}}],[\"所以数据量受单主的影响\",{\"1\":{\"439\":1}}],[\"所以如果一秒内无法获取锁\",{\"1\":{\"437\":1}}],[\"所以如果redis意外down掉的话\",{\"1\":{\"383\":1}}],[\"所以故障转移不会执行\",{\"1\":{\"428\":1}}],[\"所以可能有部分数据还没复制到slave\",{\"1\":{\"423\":1}}],[\"所以执行mset\",{\"1\":{\"417\":1}}],[\"所以在io密集型任务中使用多线程可以大大的加速程序运行\",{\"1\":{\"675\":1}}],[\"所以在遍历过程中对原集合所作的修改并不能被迭代器检测到\",{\"1\":{\"598\":1}}],[\"所以在它创建的时候\",{\"1\":{\"560\":1,\"582\":1}}],[\"所以在设计之初就不允许了\",{\"1\":{\"548\":1,\"588\":1}}],[\"所以在实际开发中\",{\"1\":{\"525\":1}}],[\"所以在\",{\"1\":{\"417\":1}}],[\"所以在日常开发中要对参数做好校验\",{\"1\":{\"395\":1}}],[\"所以适合操作命令简单\",{\"1\":{\"414\":1}}],[\"所以由连接应答处理器来处理该事件\",{\"1\":{\"403\":1}}],[\"所以只能在删除的节点上做标记\",{\"1\":{\"576\":1}}],[\"所以只能从前者下手\",{\"1\":{\"401\":1}}],[\"所以只要\",{\"1\":{\"179\":1}}],[\"所以只要jdbc支持的数据库mybatis都支持\",{\"1\":{\"173\":1}}],[\"所以尽量减少降级对于业务的影响程度\",{\"1\":{\"398\":1}}],[\"所以它给出的统计结果是有一定误差的\",{\"1\":{\"382\":1}}],[\"所以它是全自动的\",{\"1\":{\"174\":1}}],[\"所以速度相当快\",{\"1\":{\"379\":1}}],[\"所以速度会很快\",{\"1\":{\"136\":1}}],[\"所以我们不需要去考虑控制\",{\"1\":{\"405\":1}}],[\"所以我们可以考虑把数据库中的部分数据转移到缓存中去\",{\"1\":{\"379\":1}}],[\"所以我们就想\",{\"1\":{\"155\":1}}],[\"所以总结如下\",{\"1\":{\"368\":1}}],[\"所以采取了pull的方式\",{\"1\":{\"366\":1}}],[\"所以说redis的事务严格意义上来说是不具备原子性的\",{\"1\":{\"407\":1}}],[\"所以说\",{\"1\":{\"348\":1}}],[\"所以这并不是多线程工作\",{\"1\":{\"635\":1,\"703\":1}}],[\"所以这里看不出来\",{\"1\":{\"733\":1}}],[\"所以这里直接返回40\",{\"1\":{\"536\":1}}],[\"所以这里需要一个处理器适配器\",{\"1\":{\"291\":1}}],[\"所以这时会有一个优化的方案\",{\"1\":{\"393\":1}}],[\"所以这个版本之前\",{\"1\":{\"323\":1}}],[\"所以走create流程\",{\"1\":{\"281\":1}}],[\"所以deserialize需要\",{\"1\":{\"244\":1}}],[\"所以客户端代码结构很清晰了\",{\"1\":{\"237\":1}}],[\"所以调用selecctlist方法执行\",{\"1\":{\"197\":1}}],[\"所以比较适合对性能的要求很高\",{\"1\":{\"172\":1}}],[\"所以语句应该写成create\",{\"1\":{\"161\":1}}],[\"所以不能再继承其他父类\",{\"1\":{\"621\":1,\"688\":1}}],[\"所以不能马上关闭连接\",{\"1\":{\"17\":1}}],[\"所以不需要cas保证\",{\"1\":{\"608\":1}}],[\"所以不会触发concurrent\",{\"1\":{\"598\":1}}],[\"所以不会被序列化\",{\"1\":{\"528\":1}}],[\"所以不会再次调用\",{\"1\":{\"454\":1}}],[\"所以不支持部分索引列的匹配查找\",{\"1\":{\"150\":1}}],[\"所以通常b+树用于数据库索引\",{\"1\":{\"150\":1}}],[\"所以优化也是针对这三个方向来的\",{\"1\":{\"137\":1}}],[\"所以主从就能很好的解决这个问题\",{\"1\":{\"130\":1}}],[\"所以从服务器不需要一直连接着主服务器\",{\"1\":{\"129\":1}}],[\"所以一个哨兵完成一次新的切换之后\",{\"1\":{\"427\":1}}],[\"所以一般多写的场景下用悲观锁就比较合适\",{\"1\":{\"116\":1}}],[\"所以一张表上往往有多个辅助索引以此来提升数据库的性能\",{\"1\":{\"83\":1}}],[\"所以取了折衷的页级\",{\"1\":{\"114\":1}}],[\"所以大部分数据库系统的隔离级别都是read\",{\"1\":{\"102\":1}}],[\"所以同一\",{\"1\":{\"102\":1}}],[\"所以\",{\"1\":{\"88\":1,\"99\":1,\"109\":1,\"125\":1,\"130\":1,\"174\":1,\"301\":1,\"345\":1,\"378\":1,\"381\":1,\"395\":1,\"400\":1,\"403\":1,\"407\":1,\"411\":1,\"434\":1,\"470\":1,\"546\":1,\"564\":1,\"584\":1,\"673\":1,\"682\":1,\"727\":1}}],[\"所以最左匹配原则遇上范围查询就会停止\",{\"1\":{\"84\":1}}],[\"所以b现在hold住的a对象完成了初始化\",{\"1\":{\"281\":1}}],[\"所以b能够通过\",{\"1\":{\"281\":1}}],[\"所以b+树更加适合在区间查询的情况\",{\"1\":{\"150\":1}}],[\"所以b\",{\"1\":{\"84\":1}}],[\"所以引入流量控制机制\",{\"1\":{\"22\":1}}],[\"强一致性\",{\"1\":{\"432\":1}}],[\"强调leader和follower的消息序列在实际场景中不一致\",{\"1\":{\"339\":1}}],[\"强调follower副本也能对外提供读服务\",{\"1\":{\"339\":1}}],[\"强调的是列的原子性\",{\"1\":{\"91\":1}}],[\"强制转型就行\",{\"1\":{\"237\":1}}],[\"强制关闭\",{\"1\":{\"20\":1}}],[\"强转数组获取参数列表\",{\"1\":{\"202\":1}}],[\"强转为数组类型\",{\"1\":{\"202\":1}}],[\"强大\",{\"1\":{\"175\":1}}],[\"锁就会被升级成重量级锁\",{\"1\":{\"658\":1}}],[\"锁不存在多线程竞争\",{\"1\":{\"656\":1}}],[\"锁粗化是虚拟机对另一种极端情况的优化处理\",{\"1\":{\"660\":1}}],[\"锁粗化\",{\"1\":{\"654\":1}}],[\"锁升级是为了减低了锁带来的性能消耗\",{\"1\":{\"652\":1}}],[\"锁升级原理\",{\"1\":{\"652\":1}}],[\"锁升级的原理是什么\",{\"0\":{\"652\":1}}],[\"锁便是通过这种方式获取锁的\",{\"1\":{\"651\":1}}],[\"锁可以绑定多个条件\",{\"1\":{\"648\":1,\"707\":1}}],[\"锁池\",{\"1\":{\"639\":1}}],[\"锁排序法\",{\"1\":{\"627\":1,\"694\":1}}],[\"锁住\",{\"1\":{\"547\":1,\"585\":1}}],[\"锁过期自动释放\",{\"1\":{\"435\":2}}],[\"锁误解除\",{\"1\":{\"435\":1}}],[\"锁超时知道的是\",{\"1\":{\"434\":1}}],[\"锁超时\",{\"1\":{\"434\":1}}],[\"锁很健壮\",{\"1\":{\"432\":1}}],[\"锁的升级的目的\",{\"1\":{\"652\":1}}],[\"锁的升级\",{\"1\":{\"652\":1}}],[\"锁的计数器都自增1\",{\"1\":{\"648\":1,\"707\":1}}],[\"锁的粒度\",{\"1\":{\"549\":1,\"591\":1}}],[\"锁的粒度取决于具体的存储引擎\",{\"1\":{\"115\":1}}],[\"锁的实现引入了大量的优化\",{\"1\":{\"546\":1}}],[\"锁的不够健壮\",{\"1\":{\"432\":1}}],[\"锁实现简单\",{\"1\":{\"432\":1}}],[\"锁实现的\",{\"1\":{\"110\":1}}],[\"锁在程序中的作用就是同步工具\",{\"1\":{\"431\":1}}],[\"锁定粒度界于表锁和行锁之间\",{\"1\":{\"114\":1}}],[\"锁定粒度大\",{\"1\":{\"114\":1}}],[\"锁定粒度最小\",{\"1\":{\"114\":1}}],[\"锁\",{\"0\":{\"90\":1,\"600\":1},\"1\":{\"90\":2,\"600\":1}}],[\"普通异常如果选择捕获\",{\"1\":{\"535\":1}}],[\"普通代码块\",{\"1\":{\"461\":2}}],[\"普通的key\",{\"1\":{\"382\":1}}],[\"普通的⼆级索引列与常量进⾏等值匹配\",{\"1\":{\"157\":1}}],[\"普通集群模式\",{\"1\":{\"361\":2}}],[\"普通模式\",{\"1\":{\"356\":1}}],[\"普通操作使用statement记录\",{\"1\":{\"89\":1}}],[\"普通索引\",{\"1\":{\"79\":2,\"148\":2}}],[\"日志对缓存进行操作\",{\"1\":{\"393\":1}}],[\"日志中我们都能够找到相应的操作\",{\"1\":{\"393\":1}}],[\"日志采集等场景\",{\"1\":{\"350\":2}}],[\"日志不光要插入到数据库里\",{\"1\":{\"345\":1}}],[\"日志之后\",{\"1\":{\"133\":1}}],[\"日志量太大\",{\"1\":{\"89\":1}}],[\"日本\",{\"1\":{\"57\":1}}],[\"记录下所有改变了数据库数据的语句\",{\"1\":{\"132\":1}}],[\"记录最后一次修改该记录的事务\",{\"1\":{\"112\":1}}],[\"记录的是行的变化\",{\"1\":{\"108\":1}}],[\"记录单元为每一行的改动\",{\"1\":{\"89\":1}}],[\"记录单元为语句\",{\"1\":{\"89\":1}}],[\"记录此\",{\"1\":{\"40\":1}}],[\"语言中的\",{\"1\":{\"644\":1}}],[\"语言中不支持\",{\"1\":{\"449\":1}}],[\"语言更加安全\",{\"1\":{\"510\":1}}],[\"语言的反射机制\",{\"1\":{\"501\":1}}],[\"语言的数据类型分为两种\",{\"1\":{\"449\":1}}],[\"语言不仅支持网络编程而且很方便\",{\"1\":{\"442\":1}}],[\"语言诞生本身就是为简化网络编程设计的\",{\"1\":{\"442\":1}}],[\"语言却提供了多线程支持\",{\"1\":{\"442\":1}}],[\"语言没有内置的多线程机制\",{\"1\":{\"442\":1}}],[\"语言在不同的平台上运行不需要重新编译\",{\"1\":{\"442\":1}}],[\"语言编写的程序具有很好的可移植性\",{\"1\":{\"442\":1}}],[\"语法层面上的区别\",{\"1\":{\"469\":1}}],[\"语法支持也比较多\",{\"1\":{\"126\":1}}],[\"语法和读写分离\",{\"1\":{\"124\":1}}],[\"语法是否写错了\",{\"1\":{\"99\":1}}],[\"语法分析\",{\"1\":{\"88\":1,\"99\":1}}],[\"语句块来完成\",{\"1\":{\"648\":1,\"707\":1}}],[\"语句不会立马返回调用者\",{\"1\":{\"536\":1}}],[\"语句中\",{\"1\":{\"454\":1}}],[\"语句是\",{\"1\":{\"443\":1}}],[\"语句依赖于数据库\",{\"1\":{\"180\":1}}],[\"语句的功底有一定要求\",{\"1\":{\"180\":1}}],[\"语句的编写工作量较大\",{\"1\":{\"180\":1}}],[\"语句的模式\",{\"1\":{\"108\":1}}],[\"语句编程\",{\"1\":{\"179\":1}}],[\"语句向表\",{\"1\":{\"112\":1}}],[\"语句和客户端发送过来的其他原始信息\",{\"1\":{\"99\":1}}],[\"语句代码像一个方法一样实现一些功能\",{\"1\":{\"98\":1}}],[\"语句组成的代码块\",{\"1\":{\"98\":1}}],[\"语句而运行\",{\"1\":{\"45\":1}}],[\"语句就会被数据库服务器误认为是正常的\",{\"1\":{\"45\":1}}],[\"语句\",{\"0\":{\"52\":1},\"1\":{\"45\":1,\"98\":2,\"178\":1,\"179\":1,\"443\":1}}],[\"唯一的获取锁的\",{\"1\":{\"431\":1}}],[\"唯一\",{\"1\":{\"269\":1}}],[\"唯一键的区分度是1\",{\"1\":{\"161\":1}}],[\"唯一约束\",{\"1\":{\"87\":1}}],[\"唯一性\",{\"1\":{\"87\":2}}],[\"唯一索引\",{\"1\":{\"79\":2,\"148\":2}}],[\"经常被用在需要释放资源的情况下\",{\"1\":{\"454\":1}}],[\"经常需要作为条件查询的列上适合创建索引\",{\"1\":{\"85\":1}}],[\"经过前面两个方法的分析\",{\"1\":{\"721\":1}}],[\"经过精密的计算\",{\"1\":{\"717\":1}}],[\"经过处理之后将元素存储在数组elementdata的尾部\",{\"1\":{\"573\":1}}],[\"经过参数优化配置\",{\"1\":{\"350\":1}}],[\"经过leader成功接收消息的的确认\",{\"1\":{\"330\":1}}],[\"经过以上这些步骤\",{\"1\":{\"37\":1}}],[\"经典的数据库拆分方案\",{\"1\":{\"142\":1}}],[\"经历的锤炼少一些\",{\"1\":{\"127\":1}}],[\"例\",{\"1\":{\"117\":1}}],[\"例子\",{\"1\":{\"84\":1}}],[\"例如两个进程都同时写一个地址\",{\"1\":{\"728\":1}}],[\"例如已完成任务的数量\",{\"1\":{\"668\":1}}],[\"例如自旋\",{\"1\":{\"653\":1}}],[\"例如reentrantlock\",{\"1\":{\"601\":1}}],[\"例如二进制1000\",{\"1\":{\"555\":1}}],[\"例如商品有没有\",{\"1\":{\"382\":1}}],[\"例如安全和健康检查\",{\"1\":{\"304\":1}}],[\"例如会话\",{\"1\":{\"302\":1}}],[\"例如解析处理文件上传的请求\",{\"1\":{\"291\":1}}],[\"例如新增一个blogservice\",{\"1\":{\"229\":1}}],[\"例如innodb和myisam表\",{\"1\":{\"109\":1}}],[\"例如存储用户\",{\"1\":{\"95\":1}}],[\"例如空格\",{\"1\":{\"88\":1,\"99\":1}}],[\"例如a\",{\"1\":{\"84\":1}}],[\"例如\",{\"1\":{\"84\":1,\"108\":1,\"268\":3,\"269\":1,\"277\":1,\"297\":1,\"298\":1,\"300\":1,\"305\":1,\"482\":1,\"511\":1,\"530\":1,\"531\":1,\"729\":2}}],[\"例如客户端只是需要某个对象的一部分\",{\"1\":{\"33\":1}}],[\"例如文件传输\",{\"1\":{\"9\":1}}],[\"过多的键同样会消耗大量内存\",{\"1\":{\"438\":1}}],[\"过期key处理\",{\"1\":{\"420\":1}}],[\"过期键占用的内存不会及时得到释放\",{\"1\":{\"386\":1}}],[\"过期时间后\",{\"1\":{\"386\":1}}],[\"过期等特性\",{\"1\":{\"376\":1}}],[\"过程\",{\"0\":{\"216\":1}}],[\"过长的主索引会令辅助索引变得过大\",{\"1\":{\"83\":1}}],[\"过滤器\",{\"1\":{\"299\":1}}],[\"过滤掉空行或只包含空白字符的行\",{\"1\":{\"71\":1}}],[\"过滤\",{\"1\":{\"44\":1}}],[\"辅助索引的存在并不会影响聚集索引\",{\"1\":{\"83\":1}}],[\"域的值为地址读取相应的数据记录\",{\"1\":{\"82\":1}}],[\"域的值\",{\"1\":{\"82\":1}}],[\"域名服务\",{\"1\":{\"418\":1}}],[\"域名优选打包\",{\"1\":{\"64\":1}}],[\"域名在v2ray\",{\"1\":{\"61\":1}}],[\"域名\",{\"1\":{\"38\":1}}],[\"域名解析\",{\"1\":{\"38\":1}}],[\"物理不过期\",{\"1\":{\"394\":1,\"396\":1}}],[\"物理上可能很远\",{\"1\":{\"80\":1}}],[\"物理层\",{\"1\":{\"8\":1}}],[\"平均任务执行时间\",{\"1\":{\"720\":1}}],[\"平台都进行了定制\",{\"1\":{\"445\":1}}],[\"平台无关性的具体表现在于\",{\"1\":{\"442\":1}}],[\"平台无关性\",{\"1\":{\"442\":1}}],[\"平衡二叉树逻辑上很近的父子节点\",{\"1\":{\"80\":1}}],[\"平时讲的索引类型一般是指在应用层次的划分\",{\"1\":{\"79\":1}}],[\"虽然\",{\"1\":{\"443\":1}}],[\"虽然哨兵2知道master宕机了\",{\"1\":{\"428\":1}}],[\"虽然一定程度上增加了模型复杂度\",{\"1\":{\"406\":1}}],[\"虽然有push类\",{\"1\":{\"365\":1}}],[\"虽然a还没有初始化完全\",{\"1\":{\"281\":1}}],[\"虽然收效没那么大\",{\"1\":{\"136\":1}}],[\"虽然可以快速定位\",{\"1\":{\"80\":1,\"150\":1}}],[\"虽然不是绝对安全\",{\"1\":{\"36\":1}}],[\"指令和\",{\"1\":{\"651\":1}}],[\"指令后\",{\"1\":{\"651\":1}}],[\"指令时\",{\"1\":{\"651\":1}}],[\"指令则指明同步代码块的结束位置\",{\"1\":{\"651\":1}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"651\":1}}],[\"指令\",{\"1\":{\"651\":2}}],[\"指令用于强制类型转换\",{\"1\":{\"511\":1}}],[\"指向下一个处于condition状态的节点\",{\"1\":{\"603\":1}}],[\"指向了\",{\"1\":{\"564\":1}}],[\"指向节点b\",{\"1\":{\"564\":1}}],[\"指向\",{\"1\":{\"564\":1}}],[\"指向此new的integer对象\",{\"1\":{\"495\":1}}],[\"指向新的\",{\"1\":{\"416\":1}}],[\"指向这条记录的上一个版本\",{\"1\":{\"112\":1}}],[\"指使用\",{\"1\":{\"284\":1}}],[\"指定加锁对象\",{\"1\":{\"649\":1}}],[\"指定获取锁的顺序\",{\"1\":{\"627\":1,\"694\":1}}],[\"指定\",{\"1\":{\"443\":1}}],[\"指定需要实例化的java类\",{\"1\":{\"270\":1}}],[\"指定列名\",{\"1\":{\"138\":1}}],[\"指数时间重试\",{\"1\":{\"251\":1}}],[\"指的是系统的硬盘\",{\"1\":{\"717\":1}}],[\"指的是在方法调用时\",{\"1\":{\"474\":2}}],[\"指的是引用不可变\",{\"1\":{\"454\":1}}],[\"指的是ar中的第一个副本\",{\"1\":{\"340\":1}}],[\"指的是从库开启多个线程\",{\"1\":{\"133\":1}}],[\"指的就是主库写入\",{\"1\":{\"133\":1}}],[\"指事务中操作的任何数据\",{\"1\":{\"105\":1}}],[\"指事务开始之前\",{\"1\":{\"105\":1}}],[\"指事务必须使数据库从一个一致性状态变换成另一个一致性状态\",{\"1\":{\"74\":1}}],[\"指一个事务一旦提交\",{\"1\":{\"101\":1}}],[\"指针少的情况下要保存大量数据\",{\"1\":{\"80\":1}}],[\"树更小\",{\"1\":{\"150\":1}}],[\"树中\",{\"1\":{\"149\":1}}],[\"树是数据实际存储的形式\",{\"1\":{\"83\":1}}],[\"树以及若干辅助索引的构成的\",{\"1\":{\"83\":1}}],[\"树的高度随着数据量增加而增加\",{\"1\":{\"80\":1,\"150\":1}}],[\"树的高度\",{\"1\":{\"80\":1,\"150\":1}}],[\"树的高度不均匀\",{\"1\":{\"80\":1,\"150\":1}}],[\"树\",{\"0\":{\"80\":1},\"1\":{\"83\":1}}],[\"其值可以通过两个原子操作来控制\",{\"1\":{\"731\":1}}],[\"其生命周期转换如下入所示\",{\"1\":{\"712\":1}}],[\"其运行机制如下图所示\",{\"1\":{\"711\":1}}],[\"其参数表示屏障拦截的线程数量\",{\"1\":{\"681\":1}}],[\"其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定\",{\"1\":{\"661\":1}}],[\"其膨胀方向是\",{\"1\":{\"655\":1}}],[\"其内部包含一个计数器\",{\"1\":{\"651\":1}}],[\"其内存地址不同\",{\"1\":{\"496\":1}}],[\"其方法还是运行在主线程中\",{\"1\":{\"641\":1}}],[\"其在编译时才确定具体的参数\",{\"1\":{\"509\":1}}],[\"其解决方案是\",{\"1\":{\"502\":1}}],[\"其维护了一块特殊的内存空间\",{\"1\":{\"487\":1}}],[\"其不可变性可以保证连接的安全性\",{\"1\":{\"482\":1}}],[\"其基本的结构如下\",{\"1\":{\"479\":1}}],[\"其次在序列化工具选择上\",{\"1\":{\"438\":1}}],[\"其部署架构主要包括两部分\",{\"1\":{\"416\":1}}],[\"其同时也不提供事务运行错误的回滚\",{\"1\":{\"412\":1}}],[\"其后所有待执行的语句都将不会被服务器执行\",{\"1\":{\"407\":1}}],[\"其后的命令仍然会被继续执行\",{\"1\":{\"407\":1}}],[\"其核心网络模型使用的是单线程\",{\"1\":{\"400\":1}}],[\"其遵循fifo的原则\",{\"1\":{\"382\":1}}],[\"其它的服务\",{\"1\":{\"345\":1}}],[\"其它注册中心有eureka\",{\"1\":{\"250\":1}}],[\"其它方式需指定消息格式\",{\"1\":{\"244\":1}}],[\"其它事务此时需要查询时\",{\"1\":{\"112\":1}}],[\"其他阻塞\",{\"1\":{\"623\":1,\"639\":1,\"690\":1}}],[\"其他代码也会出现类似情况\",{\"1\":{\"565\":1}}],[\"其他段的数据也能被其他线程访问\",{\"1\":{\"546\":1,\"584\":1}}],[\"其他类型数据不行\",{\"1\":{\"541\":1}}],[\"其他类型未一一实现\",{\"1\":{\"203\":1}}],[\"其他线程被阻塞住\",{\"1\":{\"646\":1}}],[\"其他线程还在慢慢悠悠处理自己的任务\",{\"1\":{\"643\":1}}],[\"其他线程就可以继续执行setnx命令来获得锁\",{\"1\":{\"434\":1}}],[\"其他线程无法再获得到锁\",{\"1\":{\"432\":1}}],[\"其他线程等待\",{\"1\":{\"394\":1,\"396\":1}}],[\"其他的哨兵都是根据版本号的大小来更新自己的master配置的\",{\"1\":{\"427\":1}}],[\"其他的我都会在测试库上测试其耗时\",{\"1\":{\"137\":1}}],[\"其他从节点挂载到新的主节点上自动复制新主节点的数据\",{\"1\":{\"425\":1}}],[\"其他用户多刷新几次也能得到结果\",{\"1\":{\"396\":1}}],[\"其他实例会自动地承担起它负责消费的分区\",{\"1\":{\"326\":1}}],[\"其他\",{\"0\":{\"548\":1,\"560\":1},\"1\":{\"323\":1,\"327\":1}}],[\"其他组件则各自做分内之事\",{\"1\":{\"291\":1}}],[\"其他标签自己实现\",{\"1\":{\"204\":1}}],[\"其执行流程如下图所示\",{\"1\":{\"713\":1,\"714\":1}}],[\"其执行过程如下\",{\"1\":{\"713\":1}}],[\"其执行原理为\",{\"1\":{\"190\":1}}],[\"其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态\",{\"1\":{\"100\":1}}],[\"其存储作用域为session\",{\"1\":{\"188\":1}}],[\"其按照age字段严格有序\",{\"1\":{\"153\":1}}],[\"其实访问的是不同的物理内存地址\",{\"1\":{\"727\":1}}],[\"其实是通过java内存模型中的\",{\"1\":{\"650\":1}}],[\"其实是不太推荐存储过程的\",{\"1\":{\"98\":1}}],[\"其实aqs无论用来实现什么锁\",{\"1\":{\"614\":1}}],[\"其实也有限制的\",{\"1\":{\"672\":1}}],[\"其实也很简单\",{\"1\":{\"614\":1}}],[\"其实也是对\",{\"1\":{\"549\":1,\"594\":1}}],[\"其实也就是调用对象的构造方法实例化对象\",{\"1\":{\"281\":1}}],[\"其实serialversionuid属性并没有被序列化\",{\"1\":{\"528\":1}}],[\"其实都是创建一个新的对象\",{\"1\":{\"490\":1}}],[\"其实传递的是引用的地址\",{\"1\":{\"474\":1}}],[\"其实应该再减去时钟漂移\",{\"1\":{\"437\":1}}],[\"其实感觉上就是点个按钮\",{\"1\":{\"347\":1}}],[\"其实消费者才刚准备处理这条消息\",{\"1\":{\"332\":1}}],[\"其实包含两个概念\",{\"1\":{\"326\":1}}],[\"其实就是\",{\"1\":{\"308\":1}}],[\"其实主要是靠缓存\",{\"1\":{\"136\":1}}],[\"其实很简单\",{\"1\":{\"131\":1}}],[\"其余的服务器充当从服务器\",{\"1\":{\"129\":1}}],[\"其加锁粒度最小\",{\"1\":{\"114\":1}}],[\"其深度一般不会超过4\",{\"1\":{\"80\":1}}],[\"其效率大于索引合并\",{\"1\":{\"79\":1,\"148\":1}}],[\"其中最简单的方式就是管道\",{\"1\":{\"731\":1}}],[\"其中最大的一次优化就是在jdk6的时候\",{\"1\":{\"654\":1}}],[\"其中segment继承自reentrantlock\",{\"1\":{\"591\":1}}],[\"其中key为id值\",{\"1\":{\"506\":1}}],[\"其中主节点提供读写操作\",{\"1\":{\"417\":1}}],[\"其中redis\",{\"1\":{\"416\":1}}],[\"其中value既可以是数字也可以是字符串\",{\"1\":{\"382\":1}}],[\"其中hyperloglog\",{\"1\":{\"382\":1}}],[\"其中包含路由键\",{\"1\":{\"357\":1}}],[\"其中包含了是否使用索引\",{\"1\":{\"134\":1}}],[\"其中引用了\",{\"1\":{\"277\":1}}],[\"其中table\",{\"1\":{\"159\":1}}],[\"其中并发调度使用的是mvvc\",{\"1\":{\"102\":1}}],[\"其中默认的为\",{\"1\":{\"76\":1}}],[\"其中\",{\"1\":{\"53\":1,\"299\":1,\"305\":1,\"546\":1,\"549\":1,\"555\":1,\"559\":1,\"572\":1,\"579\":1,\"584\":1,\"651\":1}}],[\"专门用\",{\"1\":{\"545\":1}}],[\"专门用于组合搜索\",{\"1\":{\"79\":1,\"148\":1}}],[\"专门用来防范\",{\"1\":{\"14\":1}}],[\"非核心线程要限时获取任务\",{\"1\":{\"714\":1}}],[\"非核心线程空闲时间\",{\"1\":{\"712\":1}}],[\"非核心线程会消亡\",{\"1\":{\"670\":1}}],[\"非核心线程的心跳时间\",{\"1\":{\"670\":1}}],[\"非核心线程数量=maximumpoolsize\",{\"1\":{\"670\":1}}],[\"非持有锁的线程调用此方法直接抛出异常\",{\"1\":{\"617\":1}}],[\"非公平模式下每个线程都有2次机会\",{\"1\":{\"616\":1}}],[\"非公平锁是不需要判断队列中是否还有其他线程\",{\"1\":{\"616\":1}}],[\"非公平锁则没有这些规则\",{\"1\":{\"616\":1}}],[\"非公平锁\",{\"0\":{\"616\":1},\"1\":{\"680\":1}}],[\"非数据类型不能转换\",{\"1\":{\"532\":1}}],[\"非限定通配符\",{\"1\":{\"512\":1}}],[\"非指定类型的方法都不能调用成功\",{\"1\":{\"511\":1}}],[\"非受检查异常和受检查异常之间的区别\",{\"1\":{\"531\":1}}],[\"非受检查异常\",{\"0\":{\"531\":1},\"1\":{\"484\":1,\"531\":1}}],[\"非new生成的integer变量和new\",{\"0\":{\"498\":1},\"1\":{\"484\":1,\"498\":1}}],[\"非静态方法就是实例方法\",{\"1\":{\"460\":1}}],[\"非静态方法里面能不能引用静态资源\",{\"0\":{\"460\":1}}],[\"非原子性\",{\"1\":{\"435\":1}}],[\"非阻塞io\",{\"1\":{\"377\":1}}],[\"非常类似\",{\"1\":{\"681\":1}}],[\"非常适用于这些计数场景\",{\"1\":{\"381\":1}}],[\"非常适合上手\",{\"1\":{\"218\":1}}],[\"非常高\",{\"1\":{\"350\":2}}],[\"非常\",{\"1\":{\"178\":1}}],[\"非常重要的原则\",{\"1\":{\"161\":1}}],[\"非常多\",{\"1\":{\"52\":1}}],[\"非空字段\",{\"1\":{\"160\":1}}],[\"非空性\",{\"1\":{\"87\":1}}],[\"非事务型的表上的变更就无法撤销\",{\"1\":{\"109\":1}}],[\"非单调的主键会造成在插入新记录时数据文件为了维持b+tree的特性而频繁的分裂调整\",{\"1\":{\"83\":1}}],[\"非聚簇索引一定会回表查询吗\",{\"0\":{\"152\":1}}],[\"非聚簇索引\",{\"1\":{\"82\":1,\"148\":1,\"151\":1}}],[\"非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据\",{\"1\":{\"151\":1}}],[\"非聚集索引\",{\"1\":{\"79\":1,\"83\":1,\"148\":1}}],[\"顺序执行序列和程序出口\",{\"1\":{\"620\":1,\"687\":1}}],[\"顺序消息\",{\"1\":{\"362\":1}}],[\"顺序写\",{\"1\":{\"329\":1}}],[\"顺序的索引\",{\"1\":{\"84\":2,\"154\":1,\"161\":1}}],[\"顺序关系\",{\"1\":{\"79\":1,\"148\":1}}],[\"顺利到达服务器\",{\"1\":{\"12\":1}}],[\"复习起来花费精力很大\",{\"1\":{\"552\":1}}],[\"复用线程\",{\"1\":{\"711\":1}}],[\"复用指的是复用一个线程\",{\"1\":{\"403\":1}}],[\"复用模型\",{\"1\":{\"378\":1}}],[\"复用性也没有写在服务层那么好\",{\"1\":{\"98\":1}}],[\"复杂性增大\",{\"1\":{\"349\":1}}],[\"复杂\",{\"1\":{\"175\":1}}],[\"复合索引\",{\"1\":{\"79\":2,\"148\":2}}],[\"复制代码\",{\"1\":{\"638\":1}}],[\"复制offset\",{\"1\":{\"426\":1}}],[\"复制结构只支持一层\",{\"1\":{\"417\":1}}],[\"复制过程如下\",{\"1\":{\"132\":1}}],[\"复制\",{\"1\":{\"42\":1,\"133\":1}}],[\"总体设计\",{\"0\":{\"711\":1}}],[\"总体来说\",{\"1\":{\"482\":1}}],[\"总的来说就是将一个已经实例化的类转成文件存储\",{\"1\":{\"519\":1}}],[\"总的来说就是可以明显的提高查询效率\",{\"1\":{\"78\":1}}],[\"总而言之\",{\"1\":{\"399\":1}}],[\"总之先定位问题\",{\"1\":{\"370\":1}}],[\"总之就是减少分裂和移动的频率\",{\"1\":{\"158\":1}}],[\"总时长是\",{\"1\":{\"347\":1}}],[\"总是由同一线程多次获得\",{\"1\":{\"656\":1}}],[\"总是\",{\"1\":{\"555\":1}}],[\"总是喜欢使用明确的装配\",{\"1\":{\"279\":1}}],[\"总是匿名的\",{\"1\":{\"277\":1}}],[\"总是返回全部列\",{\"1\":{\"138\":1}}],[\"总结起来\",{\"1\":{\"401\":1}}],[\"总结一下\",{\"1\":{\"308\":1}}],[\"总结\",{\"0\":{\"218\":1,\"225\":1,\"232\":1,\"239\":1,\"246\":1,\"253\":1,\"260\":1,\"276\":1,\"731\":1},\"1\":{\"9\":1,\"175\":1,\"346\":1,\"407\":1}}],[\"索引计算\",{\"0\":{\"555\":1}}],[\"索引越界异常\",{\"1\":{\"534\":1}}],[\"索引都是基于mappedbytebuffer的\",{\"1\":{\"341\":1}}],[\"索引从1开始\",{\"1\":{\"202\":1}}],[\"索引失效\",{\"0\":{\"163\":1}}],[\"索引范围查询\",{\"1\":{\"162\":1}}],[\"索引本身也会被修改\",{\"1\":{\"162\":1}}],[\"索引需要空间来存储\",{\"1\":{\"162\":1}}],[\"索引需要占物理空间\",{\"1\":{\"86\":1,\"147\":1}}],[\"索引列不能参与计算\",{\"1\":{\"161\":1}}],[\"索引列的值必须唯一\",{\"1\":{\"79\":1,\"148\":1}}],[\"索引字段越小越好\",{\"1\":{\"160\":1}}],[\"索引名index\",{\"1\":{\"159\":1}}],[\"索引扫描\",{\"1\":{\"157\":1}}],[\"索引可以任意顺序\",{\"1\":{\"154\":1,\"161\":1}}],[\"索引可以大大提高mysql的检索速度\",{\"1\":{\"146\":1}}],[\"索引b+\",{\"1\":{\"151\":1}}],[\"索引有哪些优缺点\",{\"0\":{\"147\":1}}],[\"索引就相当于目录\",{\"1\":{\"146\":1}}],[\"索引连环18问\",{\"1\":{\"145\":1}}],[\"索引保存的是数据文件的指针\",{\"1\":{\"92\":1}}],[\"索引也要动态的维护\",{\"1\":{\"86\":1,\"147\":1}}],[\"索引这么多优点\",{\"0\":{\"86\":1}}],[\"索引的统计信息以及比较运算更加复杂\",{\"1\":{\"160\":1}}],[\"索引的缺点\",{\"1\":{\"147\":1}}],[\"索引的优点\",{\"1\":{\"147\":1}}],[\"索引的实现通常使用b树及其变种b+树\",{\"1\":{\"146\":1}}],[\"索引的\",{\"1\":{\"84\":1}}],[\"索引的种类有哪些\",{\"0\":{\"79\":1}}],[\"索引分为主索引\",{\"1\":{\"83\":1}}],[\"索引文件和数据文件是分离的\",{\"1\":{\"82\":1}}],[\"索引\",{\"0\":{\"145\":1},\"1\":{\"79\":1,\"148\":1,\"597\":1}}],[\"索引能够轻易将查询性能提高好几个数量级\",{\"1\":{\"78\":1}}],[\"索引能干什么\",{\"0\":{\"78\":1}}],[\"索引对于性能的影响愈发重要\",{\"1\":{\"78\":1}}],[\"索引是一种数据结构\",{\"1\":{\"146\":1}}],[\"索引是一种特殊的文件\",{\"1\":{\"146\":1}}],[\"索引是帮助mysql高效获取数据的数据结构\",{\"1\":{\"77\":1}}],[\"索引是表的目录\",{\"1\":{\"77\":1}}],[\"索引是什么\",{\"0\":{\"77\":1,\"146\":1}}],[\"以确保任何时刻只能有一个进程访问共享资源\",{\"1\":{\"731\":1}}],[\"以setcorepoolsize为方法例\",{\"1\":{\"721\":1}}],[\"以免发生任务数大于最大线程数时\",{\"1\":{\"673\":1}}],[\"以等待计算的完成\",{\"1\":{\"621\":1,\"676\":1,\"688\":1}}],[\"以下是公平锁的实现\",{\"1\":{\"617\":1}}],[\"以下是使用springboot的一些好处\",{\"1\":{\"304\":1}}],[\"以reentrantlock为例\",{\"1\":{\"605\":1}}],[\"以上fork\",{\"1\":{\"643\":1}}],[\"以上便是\",{\"1\":{\"561\":1}}],[\"以上的代码量\",{\"1\":{\"173\":1,\"179\":1}}],[\"以jdk1\",{\"1\":{\"555\":1,\"573\":1,\"579\":1}}],[\"以java为例\",{\"1\":{\"380\":1}}],[\"以减少搜索时间\",{\"1\":{\"553\":1,\"575\":1}}],[\"以调用myclass\",{\"1\":{\"507\":1}}],[\"以帮助开发者写出正确的代码\",{\"1\":{\"506\":1}}],[\"以\",{\"1\":{\"478\":1,\"555\":1}}],[\"以前\",{\"1\":{\"450\":1}}],[\"以前是有一些公司在用的\",{\"1\":{\"125\":1}}],[\"以保证测试代码覆盖率\",{\"1\":{\"506\":1}}],[\"以保证即使没有被显式释放\",{\"1\":{\"434\":1}}],[\"以保证redis服务器的正常运行\",{\"1\":{\"388\":1}}],[\"以有序\",{\"1\":{\"403\":1}}],[\"以秒或毫秒精度给数据库中的某个键设置过期时间\",{\"1\":{\"387\":1}}],[\"以日志的形式来记录每个写操作\",{\"1\":{\"383\":1}}],[\"以实现从多方面进行扩展\",{\"1\":{\"352\":1}}],[\"以内完成\",{\"1\":{\"347\":1}}],[\"以集群的方式运行\",{\"1\":{\"322\":1}}],[\"以非事务方式执行\",{\"1\":{\"289\":1}}],[\"以非事务方式执行操作\",{\"1\":{\"289\":1}}],[\"以最上面定义的为准\",{\"1\":{\"280\":1}}],[\"以最左边的为起点任何连续的索引都能匹配上\",{\"1\":{\"84\":1}}],[\"以后都冲突在table\",{\"1\":{\"565\":1}}],[\"以后要改的话直接改配置文件\",{\"1\":{\"506\":1}}],[\"以后引入的枚举类型也算是一种比较特殊的引用类型\",{\"1\":{\"489\":1}}],[\"以后别人拿到的是该字符串常量的引用\",{\"1\":{\"488\":1}}],[\"以后就直接返回了\",{\"1\":{\"347\":1}}],[\"以后\",{\"1\":{\"323\":1}}],[\"以后的服务端实现这个接口即可\",{\"1\":{\"230\":1}}],[\"以后代码重构中\",{\"1\":{\"223\":1}}],[\"以及安全性这三大方面\",{\"1\":{\"482\":1}}],[\"以及三种特殊的数据类型\",{\"1\":{\"382\":1}}],[\"以及其他一些管理类任务\",{\"1\":{\"327\":1}}],[\"以及\",{\"1\":{\"300\":1,\"378\":1,\"560\":1,\"582\":1}}],[\"以及容器应该如何使用依赖注入来将\",{\"1\":{\"278\":1}}],[\"以及设置bean属性\",{\"1\":{\"274\":1}}],[\"以及客户端代码的重构\",{\"1\":{\"212\":1}}],[\"以及表数据修改\",{\"1\":{\"108\":1}}],[\"以不到百行的代码完成一个rpc例子\",{\"1\":{\"212\":1}}],[\"以标签的形式编写动态sql\",{\"1\":{\"184\":1,\"190\":1}}],[\"以hashmap的形式传递到mapper中\",{\"1\":{\"183\":1}}],[\"以此来丰富多种数据使用场景\",{\"1\":{\"326\":1}}],[\"以此来完成动态sql的功能\",{\"1\":{\"190\":1}}],[\"以此类推\",{\"1\":{\"153\":1,\"183\":1,\"576\":1}}],[\"以此快速定位查询数据\",{\"1\":{\"77\":1}}],[\"以协助快速查询\",{\"1\":{\"146\":1}}],[\"以事件形式记录\",{\"1\":{\"108\":1}}],[\"以便在网络上传输或者保存在本地文件中\",{\"1\":{\"518\":1}}],[\"以便其他线程可以进入\",{\"1\":{\"434\":1}}],[\"以便它可以作为独立的应用程序运行\",{\"1\":{\"304\":1}}],[\"以便于需要时可以取消请求\",{\"1\":{\"71\":1}}],[\"以便客户端重新发送ack包\",{\"1\":{\"15\":1}}],[\"读和写\",{\"1\":{\"667\":1}}],[\"读和读之间不会互斥\",{\"1\":{\"667\":1}}],[\"读锁是共享的\",{\"1\":{\"667\":1}}],[\"读也是以某个threadlocal作为引用\",{\"1\":{\"664\":1}}],[\"读数据是不会改变数据的\",{\"1\":{\"667\":1}}],[\"读数据\",{\"1\":{\"403\":1}}],[\"读库更新缓存\",{\"1\":{\"392\":1}}],[\"读到了空的缓存\",{\"1\":{\"392\":1}}],[\"读操作去重\",{\"1\":{\"392\":1}}],[\"读操作不记录\",{\"1\":{\"383\":1}}],[\"读操作需要加共享锁\",{\"1\":{\"119\":2}}],[\"读的时候就直接读\",{\"1\":{\"323\":1}}],[\"读\",{\"1\":{\"142\":1,\"403\":1}}],[\"读写的时候字节流是按字节读写\",{\"1\":{\"541\":1}}],[\"读写负荷\",{\"1\":{\"401\":1}}],[\"读写\",{\"1\":{\"377\":1}}],[\"读写性能极高\",{\"1\":{\"376\":1}}],[\"读写分离策略\",{\"1\":{\"415\":1}}],[\"读写分离\",{\"1\":{\"126\":1,\"135\":1,\"417\":1,\"439\":1}}],[\"读写不冲突\",{\"1\":{\"112\":1}}],[\"读提交\",{\"1\":{\"120\":1}}],[\"读取指定的配置文件\",{\"1\":{\"506\":1}}],[\"读取序列化数组\",{\"1\":{\"244\":1}}],[\"读取序列化的类型\",{\"1\":{\"244\":1}}],[\"读取数据时先读取该标记变量判断是否事务执行完成\",{\"1\":{\"412\":1}}],[\"读取数据的时候\",{\"1\":{\"392\":1}}],[\"读取数据序列化后的字节长度\",{\"1\":{\"244\":1}}],[\"读取数据不需要加共享锁\",{\"1\":{\"119\":1}}],[\"读取消息类型\",{\"1\":{\"244\":1}}],[\"读取客户端传过来的request\",{\"1\":{\"223\":1,\"230\":1}}],[\"读取客户端传过来的id\",{\"1\":{\"216\":1}}],[\"读取文件内容\",{\"1\":{\"204\":1}}],[\"读取到的数据是脏数据\",{\"1\":{\"103\":1}}],[\"读取了事务\",{\"1\":{\"103\":1}}],[\"读取提交内容\",{\"1\":{\"102\":2}}],[\"读取未提交的数据\",{\"1\":{\"102\":1}}],[\"读取未提交内容\",{\"1\":{\"102\":1}}],[\"读未提交和串行化基本上是不需要考虑的隔离级别\",{\"1\":{\"110\":1}}],[\"读未提交\",{\"1\":{\"76\":1}}],[\"读已提交\",{\"1\":{\"76\":2}}],[\"串行化\",{\"1\":{\"76\":2}}],[\"幻读侧重于新增或删除\",{\"1\":{\"103\":1}}],[\"幻读发生在当两个完全相同的查询执行时\",{\"1\":{\"75\":1}}],[\"幻读\",{\"0\":{\"103\":1},\"1\":{\"75\":1,\"76\":1,\"102\":1,\"103\":1}}],[\"被垃圾回收器回收了\",{\"1\":{\"665\":1}}],[\"被通知的线程是由\",{\"1\":{\"648\":1,\"707\":1}}],[\"被后一个\",{\"1\":{\"565\":1,\"583\":1}}],[\"被调度回来执行\",{\"1\":{\"564\":1}}],[\"被调度挂起\",{\"1\":{\"564\":1}}],[\"被调用不一定会立即回收该对象\",{\"1\":{\"454\":1}}],[\"被缓存下来\",{\"1\":{\"491\":1}}],[\"被元空间取代了\",{\"1\":{\"487\":1}}],[\"被继承的类称为\",{\"1\":{\"464\":1}}],[\"被修饰的类不能被继承\",{\"1\":{\"454\":1}}],[\"被修饰的方法不允许任何子类重写\",{\"1\":{\"454\":1}}],[\"被修饰的变量不可变\",{\"1\":{\"454\":1}}],[\"被选举为master的标准是什么\",{\"0\":{\"426\":1}}],[\"被判断下线\",{\"1\":{\"417\":1}}],[\"被关注\",{\"1\":{\"381\":1}}],[\"被动地同步leader副本中的数据\",{\"1\":{\"339\":1}}],[\"被分配不同的订阅分区\",{\"1\":{\"326\":1}}],[\"被限定于全局\",{\"1\":{\"272\":1}}],[\"被称之为\",{\"1\":{\"152\":1}}],[\"被大部分mysql引擎支持\",{\"1\":{\"114\":1}}],[\"被另一个事务修改并提交了\",{\"1\":{\"75\":1}}],[\"被占满就会导致无法创建新的连接\",{\"1\":{\"20\":1}}],[\"脏读是一个事务回滚影响另外一个事务\",{\"1\":{\"103\":1}}],[\"脏读是指在一个事务处理过程中读取到了另外一个未提交事务中的数据\",{\"1\":{\"75\":1}}],[\"脏读\",{\"1\":{\"75\":1,\"103\":1}}],[\"赋值给path\",{\"1\":{\"71\":2}}],[\"跳出本次循环\",{\"1\":{\"452\":1}}],[\"跳出总上一层循环\",{\"1\":{\"452\":1}}],[\"跳出循环\",{\"1\":{\"71\":2}}],[\"跳过证书验证\",{\"1\":{\"69\":2}}],[\"遍历下一个元素之前\",{\"1\":{\"598\":1}}],[\"遍历下一条数据\",{\"1\":{\"203\":1}}],[\"遍历\",{\"1\":{\"597\":1}}],[\"遍历该\",{\"1\":{\"585\":1}}],[\"遍历该bean的property属性\",{\"1\":{\"506\":1}}],[\"遍历旧的entry数组\",{\"1\":{\"558\":1,\"581\":1}}],[\"遍历查找会非常慢\",{\"1\":{\"553\":1}}],[\"遍历插入\",{\"1\":{\"547\":1,\"585\":1}}],[\"遍历bean\",{\"1\":{\"506\":1}}],[\"遍历成员变量列表\",{\"1\":{\"203\":1}}],[\"遍历cmproxyips数组查找匹配项\",{\"1\":{\"71\":2}}],[\"遍历所有响应\",{\"1\":{\"71\":1}}],[\"یوآی‌دی\",{\"1\":{\"71\":1}}],[\"و\",{\"1\":{\"71\":1}}],[\"وارد\",{\"1\":{\"71\":1}}],[\"هاست\",{\"1\":{\"71\":1}}],[\"نشده\",{\"1\":{\"71\":1}}],[\"ضروری\",{\"1\":{\"71\":1}}],[\"پارامترهای\",{\"1\":{\"71\":1}}],[\"缺省时\",{\"1\":{\"159\":1}}],[\"缺少必填参数\",{\"1\":{\"71\":1}}],[\"缺点是删除过期键不及时\",{\"1\":{\"386\":1}}],[\"缺点是需要保持redis或memcached服务的高可用\",{\"1\":{\"380\":1}}],[\"缺点就是内存占用较大\",{\"1\":{\"266\":1}}],[\"缺点\",{\"1\":{\"36\":1,\"128\":1,\"173\":1,\"266\":2,\"376\":1,\"386\":3,\"414\":1,\"415\":1,\"416\":1,\"417\":1,\"418\":1,\"430\":1,\"432\":3,\"463\":2,\"502\":1,\"598\":1}}],[\"首先是参数合法性校验\",{\"1\":{\"721\":1}}],[\"首先检测线程池运行状态\",{\"1\":{\"713\":1}}],[\"首先reentrantlock某些时候有局限\",{\"1\":{\"667\":1}}],[\"首先必须处于就绪状态中\",{\"1\":{\"623\":1,\"690\":1}}],[\"首先看下获取锁的过程\",{\"1\":{\"617\":1}}],[\"首先看一下添加节点的场景\",{\"1\":{\"607\":1}}],[\"首先会判断当前线程是否为获得锁的线程\",{\"1\":{\"617\":1}}],[\"首先会判断\",{\"1\":{\"617\":1}}],[\"首先会调用\",{\"1\":{\"605\":1}}],[\"首先会尝试获取锁\",{\"1\":{\"547\":1}}],[\"首先根据\",{\"1\":{\"556\":1,\"580\":1}}],[\"首先根据key的值计算出hashcode的值\",{\"1\":{\"555\":1,\"579\":1}}],[\"首先将数据分为一段一段的存储\",{\"1\":{\"546\":1,\"584\":1}}],[\"首先将需操作的数据备份到一个地方\",{\"1\":{\"105\":1}}],[\"首先应该在业务上精简业务对象\",{\"1\":{\"438\":1}}],[\"首先要找到是什么原因导致的消息堆积\",{\"1\":{\"370\":1}}],[\"首先在如下三个部分都可能会出现丢失消息的情况\",{\"1\":{\"369\":1}}],[\"首先多个queue只能保证单个queue里的顺序\",{\"1\":{\"368\":1}}],[\"首先需要弄明白消息为什么会丢失\",{\"1\":{\"331\":1}}],[\"首先容器尝试通过构造函数使用\",{\"1\":{\"278\":1}}],[\"首先实例化bean\",{\"1\":{\"276\":1}}],[\"首先new\",{\"1\":{\"251\":1}}],[\"首先我们得有user对象\",{\"1\":{\"216\":1}}],[\"首先分析语句\",{\"1\":{\"137\":1}}],[\"首先\",{\"1\":{\"112\":1,\"547\":1,\"585\":1,\"713\":1}}],[\"首先按照b+tree搜索算法搜索索引\",{\"1\":{\"82\":1}}],[\"首页改成一个nginx伪装页\",{\"1\":{\"71\":2}}],[\"首部最小20字节\",{\"1\":{\"9\":1}}],[\"首部开销小\",{\"1\":{\"9\":1}}],[\"首部开销\",{\"1\":{\"9\":1}}],[\"错误\",{\"1\":{\"398\":1,\"530\":1}}],[\"错误检测和数据表示等\",{\"1\":{\"354\":1}}],[\"错误处理\",{\"1\":{\"71\":1}}],[\"错误通知的管理\",{\"1\":{\"33\":1}}],[\"进入\",{\"1\":{\"732\":1}}],[\"进入阻塞时\",{\"1\":{\"653\":1}}],[\"进入同步代码库前要获得给定对象的锁\",{\"1\":{\"649\":1}}],[\"进入同步代码前要获得当前类对象的锁\",{\"1\":{\"649\":1}}],[\"进入同步代码前要获得当前对象实例的锁\",{\"1\":{\"649\":1}}],[\"进入可运行状态\",{\"1\":{\"633\":1,\"701\":1}}],[\"进入下一个循环条件\",{\"1\":{\"452\":1}}],[\"进程有三种方式响应信号\",{\"1\":{\"731\":1}}],[\"进程写入的数据都是缓存在内核中\",{\"1\":{\"731\":1}}],[\"进程可正常继续执行\",{\"1\":{\"728\":1}}],[\"进程需阻塞等待\",{\"1\":{\"728\":1}}],[\"进程需要的时候再去读取数据就可以了\",{\"1\":{\"726\":1}}],[\"进程\",{\"1\":{\"727\":1}}],[\"进程把数据放在对应的消息队列后就可以正常返回了\",{\"1\":{\"726\":1}}],[\"进程发送消息也是如此\",{\"1\":{\"726\":1}}],[\"进程发送消息\",{\"1\":{\"726\":1}}],[\"进程要给\",{\"1\":{\"726\":2}}],[\"进程通信的几种方式\",{\"0\":{\"724\":1}}],[\"进程的上下文切换\",{\"1\":{\"661\":1}}],[\"进程是操作系统资源分配的基本单位\",{\"1\":{\"620\":1,\"687\":1}}],[\"进程重启后\",{\"1\":{\"414\":1}}],[\"进类加载\",{\"1\":{\"507\":1}}],[\"进而产生问题\",{\"1\":{\"454\":1}}],[\"进去的值\",{\"1\":{\"560\":1}}],[\"进去了一级缓存singletonobjects中\",{\"1\":{\"281\":1}}],[\"进去worker\",{\"1\":{\"61\":1}}],[\"进阶\",{\"1\":{\"145\":1}}],[\"进行原子更新时可能出现的\",{\"1\":{\"683\":1}}],[\"进行初始化\",{\"1\":{\"556\":1,\"580\":1}}],[\"进行全表锁\",{\"1\":{\"549\":1,\"594\":1}}],[\"进行类编译时\",{\"1\":{\"516\":1}}],[\"进行类型擦除\",{\"1\":{\"511\":1}}],[\"进行替换\",{\"1\":{\"511\":1}}],[\"进行擦除呢\",{\"1\":{\"511\":1}}],[\"进行比较时\",{\"1\":{\"499\":1}}],[\"进行计算时隐含的有自动拆箱\",{\"1\":{\"494\":1}}],[\"进行抽象\",{\"1\":{\"469\":1}}],[\"进行过测试\",{\"1\":{\"402\":1}}],[\"进行缓存的刷新\",{\"1\":{\"397\":1}}],[\"进行删除操作\",{\"1\":{\"393\":1}}],[\"进行删除操作的时候发现报错\",{\"1\":{\"393\":1}}],[\"进行填充数据的查询数据库操作\",{\"1\":{\"391\":1}}],[\"进行自动配置并将\",{\"1\":{\"308\":1}}],[\"进行了增\",{\"1\":{\"188\":1}}],[\"进行遍历即可\",{\"1\":{\"149\":1}}],[\"进行范围查找时只需要查找两个节点\",{\"1\":{\"149\":1}}],[\"进行重做\",{\"1\":{\"106\":1}}],[\"进行\",{\"1\":{\"71\":1,\"555\":1,\"622\":1,\"689\":1}}],[\"未resize前的table如下图\",{\"1\":{\"564\":1}}],[\"未测\",{\"1\":{\"232\":1}}],[\"未实现\",{\"1\":{\"198\":1}}],[\"未设置\",{\"1\":{\"71\":1}}],[\"未找到\",{\"1\":{\"27\":1}}],[\"空闲\",{\"1\":{\"622\":1,\"689\":1}}],[\"空指针异常\",{\"1\":{\"534\":1}}],[\"空指针\",{\"1\":{\"531\":1}}],[\"空间方面\",{\"1\":{\"147\":1}}],[\"空字段\",{\"1\":{\"71\":5}}],[\"空行\",{\"1\":{\"32\":2}}],[\"单工作线程最大的特点是可保证顺序地执行各个任务\",{\"1\":{\"672\":1}}],[\"单核时代\",{\"1\":{\"622\":1,\"689\":1}}],[\"单从这一点上来说\",{\"1\":{\"467\":1}}],[\"单引号\",{\"1\":{\"449\":1}}],[\"单引号和换行符替换为逗号\",{\"1\":{\"71\":1}}],[\"单精度浮点型\",{\"1\":{\"449\":1}}],[\"单实例可用性可以用supervisor或crontab保证\",{\"1\":{\"414\":1}}],[\"单线程是指的是在核心网络模型中\",{\"1\":{\"377\":1}}],[\"单线程实现\",{\"1\":{\"377\":1}}],[\"单机下的redis可以支持到16个数据库\",{\"1\":{\"417\":1}}],[\"单机足够了\",{\"1\":{\"413\":1}}],[\"单机模式\",{\"1\":{\"361\":2}}],[\"单机吞吐量\",{\"1\":{\"350\":1}}],[\"单例设计模式\",{\"1\":{\"286\":1}}],[\"单一职责原则\",{\"1\":{\"230\":1}}],[\"单表到几百万的时候\",{\"1\":{\"121\":1}}],[\"单表数据量太大\",{\"1\":{\"121\":1}}],[\"单个操作是原子性的\",{\"1\":{\"376\":1}}],[\"单个\",{\"1\":{\"41\":1,\"407\":1}}],[\"双重散列\",{\"1\":{\"576\":1}}],[\"双精度浮点型\",{\"1\":{\"449\":1}}],[\"双引号\",{\"1\":{\"71\":1,\"449\":1}}],[\"双方使用对称加密愉快地传输所有数据\",{\"1\":{\"37\":1}}],[\"双方都知道彼此已经准备好\",{\"1\":{\"13\":1}}],[\"双方建立连接并传输数据\",{\"1\":{\"12\":1}}],[\"节点线程等待唤醒\",{\"1\":{\"603\":1}}],[\"节点之间都有\",{\"1\":{\"602\":1}}],[\"节点之间通过gossip协议交换状态信息\",{\"1\":{\"417\":1}}],[\"节点b\",{\"1\":{\"564\":1}}],[\"节点a\",{\"1\":{\"564\":1}}],[\"节点key存在\",{\"1\":{\"556\":1}}],[\"节点流\",{\"1\":{\"539\":1}}],[\"节点存活\",{\"1\":{\"436\":1}}],[\"节点就挂掉了\",{\"1\":{\"435\":1}}],[\"节点互相之间不断通信\",{\"1\":{\"430\":1}}],[\"节点会因为某些原因发生阻塞\",{\"1\":{\"417\":1}}],[\"节点可动态添加或删除\",{\"1\":{\"417\":1}}],[\"节点间数据共享\",{\"1\":{\"417\":1}}],[\"节点间不通信\",{\"1\":{\"374\":1}}],[\"节点上存储不同的内容\",{\"1\":{\"417\":1}}],[\"节点挂掉后\",{\"1\":{\"413\":2}}],[\"节点的变化过程如下\",{\"1\":{\"608\":1}}],[\"节点的增加和移除\",{\"1\":{\"430\":1}}],[\"节点的数量一旦确定不能变化\",{\"1\":{\"385\":1}}],[\"节点的注册\",{\"1\":{\"327\":1}}],[\"节点去读取消息\",{\"1\":{\"323\":1}}],[\"节点\",{\"1\":{\"323\":1,\"334\":2,\"547\":1,\"585\":1}}],[\"节点备注\",{\"1\":{\"71\":3}}],[\"节点名备注内容\",{\"1\":{\"71\":1}}],[\"节点订阅连接<\",{\"1\":{\"70\":3}}],[\"始终返回notls节点\",{\"1\":{\"71\":1}}],[\"速度下限\",{\"1\":{\"71\":1}}],[\"设备空闲\",{\"1\":{\"622\":1,\"689\":1}}],[\"设备的综合利用率\",{\"1\":{\"622\":1,\"689\":1}}],[\"设置为其线程\",{\"1\":{\"652\":1}}],[\"设置prev节点以及修改当前节点的前置节点的next节点指向自己\",{\"1\":{\"607\":1}}],[\"设置state的值\",{\"1\":{\"604\":1}}],[\"设置sql的唯一id\",{\"1\":{\"204\":1}}],[\"设置初始大小时\",{\"1\":{\"554\":1,\"578\":1}}],[\"设置值的方法\",{\"1\":{\"506\":1}}],[\"设置获取锁最多用1s\",{\"1\":{\"437\":1}}],[\"设置键的过期时间为millisecond毫秒\",{\"1\":{\"435\":1}}],[\"设置键的过期时间为second秒\",{\"1\":{\"435\":1}}],[\"设置一个定时任务脚本\",{\"1\":{\"397\":1}}],[\"设置不同的过期时间\",{\"1\":{\"396\":1}}],[\"设置value=\",{\"1\":{\"395\":1}}],[\"设置该key\",{\"1\":{\"386\":1}}],[\"设置重试次数\",{\"1\":{\"369\":1}}],[\"设置\",{\"1\":{\"334\":1}}],[\"设置指定依赖项\",{\"1\":{\"279\":1}}],[\"设置依赖信息\",{\"1\":{\"276\":1}}],[\"设置变量值\",{\"1\":{\"203\":1}}],[\"设置访问权限\",{\"1\":{\"203\":1}}],[\"设置第几个参数\",{\"1\":{\"202\":2}}],[\"设置优选notls地址api接口\",{\"1\":{\"71\":1}}],[\"设置优选地址api接口\",{\"1\":{\"71\":1}}],[\"设置优选地址\",{\"1\":{\"71\":2}}],[\"设计了线程池内的工作线程worker\",{\"1\":{\"714\":1}}],[\"设计考虑\",{\"1\":{\"482\":1}}],[\"设计层面不同\",{\"1\":{\"469\":1}}],[\"设计层面上的区别\",{\"1\":{\"469\":1}}],[\"设计模式设计的\",{\"1\":{\"403\":1}}],[\"设计数据表时应尽量遵循范式理论的规约\",{\"1\":{\"140\":1}}],[\"设计索引\",{\"1\":{\"120\":1}}],[\"设有一个保活计时器\",{\"1\":{\"19\":1}}],[\"留空则不启动快速订阅\",{\"1\":{\"71\":1}}],[\"พอร์ต\",{\"1\":{\"70\":8}}],[\"พร็อกซีไอพี\",{\"1\":{\"70\":18}}],[\"พร็อกซีไอพีs\",{\"1\":{\"70\":5}}],[\"การกำหนดค่าhttps\",{\"1\":{\"70\":2}}],[\"การกำหนดค่าhttp\",{\"1\":{\"70\":2}}],[\"ผลลัพธ์\",{\"1\":{\"70\":2}}],[\"ส่วนurl\",{\"1\":{\"70\":6}}],[\"ส่วนurlทั่วไปhttps\",{\"1\":{\"70\":3}}],[\"ส่วนurlทั่วไปhttp\",{\"1\":{\"70\":3}}],[\"สร้างวเลสsub\",{\"1\":{\"70\":2}}],[\"อาร์เรย์ไอดีผู้ใช้\",{\"1\":{\"70\":2}}],[\"ชื่อโฮสต์\",{\"1\":{\"70\":9}}],[\"เส้นทาง\",{\"1\":{\"70\":4}}],[\"เซ็ตพอร์ตhttps\",{\"1\":{\"70\":2}}],[\"เซ็ตพอร์ตhttp\",{\"1\":{\"70\":2}}],[\"ไอดีผู้ใช้\",{\"1\":{\"70\":9}}],[\"วเลสรองhttps\",{\"1\":{\"70\":2}}],[\"วเลสรองhttp\",{\"1\":{\"70\":2}}],[\"วเลสหลักhttps\",{\"1\":{\"70\":2}}],[\"วเลสหลักhttp\",{\"1\":{\"70\":2}}],[\"วเลสsec<\",{\"1\":{\"70\":1}}],[\"วเลสsec\",{\"1\":{\"70\":3}}],[\"วเลสsubconfig\",{\"1\":{\"70\":2}}],[\"วเลสmain<\",{\"1\":{\"70\":1}}],[\"วเลสmain\",{\"1\":{\"70\":3}}],[\"วเลสheader\",{\"1\":{\"70\":4}}],[\"วเลสbuffer\",{\"1\":{\"70\":13}}],[\"วเลสresponseheader\",{\"1\":{\"70\":13}}],[\"วเลสversion\",{\"1\":{\"70\":4}}],[\"วเลส\",{\"1\":{\"70\":19}}],[\"วเลสoverwshandler\",{\"1\":{\"70\":2}}],[\"วเลสconfig\",{\"1\":{\"70\":2}}],[\"二者都是\",{\"1\":{\"530\":1}}],[\"二是因为无论在什么平台\",{\"1\":{\"445\":1}}],[\"二级缓存namespace\",{\"1\":{\"188\":1}}],[\"二级缓存与一级缓存机制相同\",{\"1\":{\"188\":1}}],[\"二级缓存\",{\"0\":{\"188\":1}}],[\"二级索引是非聚簇索引\",{\"1\":{\"151\":1}}],[\"二级索引\",{\"1\":{\"151\":1}}],[\"二叉树\",{\"0\":{\"150\":1},\"1\":{\"80\":1,\"150\":1}}],[\"二\",{\"1\":{\"69\":1}}],[\"二进制则不同\",{\"1\":{\"34\":1}}],[\"电信用户大概率可以直接使用tls模式\",{\"1\":{\"69\":1}}],[\"否则要保证当前线程不是中断状态\",{\"1\":{\"714\":1}}],[\"否则优先使用\",{\"1\":{\"648\":1,\"707\":1}}],[\"否则不会执行任何操作\",{\"1\":{\"644\":1}}],[\"否则返回false\",{\"1\":{\"610\":1}}],[\"否则返回nil\",{\"1\":{\"435\":1}}],[\"否则会\",{\"1\":{\"605\":1}}],[\"否则会导致编译错误\",{\"1\":{\"512\":1}}],[\"否则抛出异常\",{\"1\":{\"598\":1}}],[\"否则也要在方法签名中用\",{\"1\":{\"532\":1}}],[\"否则报错\",{\"1\":{\"525\":1}}],[\"否则所有变量的值都会变成默认值\",{\"1\":{\"522\":1}}],[\"否则将作为整型解析\",{\"1\":{\"449\":1}}],[\"否则影响其他client获取锁\",{\"1\":{\"437\":1}}],[\"否则影响线上业务的效率\",{\"1\":{\"421\":1}}],[\"否则如果是slave\",{\"1\":{\"420\":1}}],[\"否则的话\",{\"1\":{\"385\":1}}],[\"否则获取锁失败\",{\"1\":{\"381\":1}}],[\"否则就选择非受检查异常\",{\"1\":{\"531\":1}}],[\"否则就会出现序列化版本不一致的异常\",{\"1\":{\"524\":1}}],[\"否则就会导致数据不一致的问题\",{\"1\":{\"140\":1}}],[\"否则就可能影响线程安全\",{\"1\":{\"282\":1}}],[\"否则无法命中索引\",{\"1\":{\"153\":1}}],[\"否则应该尽量使用\",{\"1\":{\"95\":1}}],[\"否则\",{\"1\":{\"69\":1,\"556\":1,\"580\":1,\"672\":1}}],[\"请\",{\"1\":{\"391\":1}}],[\"请尽快绑定自定义域\",{\"1\":{\"71\":1}}],[\"请查看我们的\",{\"1\":{\"70\":1}}],[\"请确认使用的是workers还是pages=====\",{\"1\":{\"69\":1}}],[\"请在浏览器地址栏输入\",{\"1\":{\"69\":1}}],[\"请求时\",{\"1\":{\"639\":1}}],[\"请求与保持条件\",{\"1\":{\"626\":1,\"693\":1}}],[\"请求数据读取并解析完成\",{\"1\":{\"404\":1}}],[\"请求重复率比较低的数据\",{\"1\":{\"395\":1}}],[\"请求主库进行更新操作\",{\"1\":{\"391\":1}}],[\"请求主体\",{\"1\":{\"32\":2}}],[\"请求a将新值写入数据库\",{\"1\":{\"390\":1}}],[\"请求a进行写操作\",{\"1\":{\"390\":1}}],[\"请求b将旧值写入缓存\",{\"1\":{\"390\":1}}],[\"请求b去数据库查询得到旧值\",{\"1\":{\"390\":1}}],[\"请求b查询发现缓存不存在\",{\"1\":{\"390\":1}}],[\"请求方式\",{\"1\":{\"319\":1}}],[\"请求方法的特例\",{\"1\":{\"295\":1}}],[\"请求方法\",{\"1\":{\"293\":1}}],[\"请求方法+uri协议+版本\",{\"1\":{\"32\":1}}],[\"请求头来决定\",{\"1\":{\"294\":1}}],[\"请求头部\",{\"1\":{\"32\":2}}],[\"请求都会产生一个新的\",{\"1\":{\"272\":1}}],[\"请求都会产生一个新的实例\",{\"1\":{\"272\":1}}],[\"请求内有效\",{\"1\":{\"272\":1}}],[\"请求会自动判断此域名下是否存在\",{\"1\":{\"40\":1}}],[\"请求返回时将此\",{\"1\":{\"40\":1}}],[\"请求后\",{\"1\":{\"38\":1}}],[\"请求消息中的url并没有传递主机名\",{\"1\":{\"33\":1}}],[\"请求行\",{\"1\":{\"32\":2}}],[\"请求报文格式\",{\"1\":{\"32\":1}}],[\"请求的处理器匹配器\",{\"1\":{\"291\":1}}],[\"请求的响应\",{\"1\":{\"27\":1}}],[\"请求的网页已永久移动到新位置\",{\"1\":{\"27\":1}}],[\"请求\",{\"1\":{\"21\":1,\"38\":2,\"390\":1,\"391\":2,\"393\":1}}],[\"请求关闭连接\",{\"1\":{\"17\":1}}],[\"路由键等都是遵循的\",{\"1\":{\"353\":1}}],[\"路由器等过滤网关防护\",{\"1\":{\"14\":1}}],[\"路径地址\",{\"1\":{\"251\":1}}],[\"路径\",{\"1\":{\"69\":4}}],[\"必须要同步到主内存中\",{\"1\":{\"650\":1}}],[\"必须要有主键\",{\"1\":{\"92\":1}}],[\"必须与synchronized关键字一起使用\",{\"1\":{\"633\":1,\"701\":1}}],[\"必须回答出来的点\",{\"1\":{\"627\":1,\"694\":1}}],[\"必须依存在应用程序中\",{\"1\":{\"620\":1,\"687\":1}}],[\"必须实现接口内的两个方法\",{\"1\":{\"523\":1}}],[\"必须由程序显式进行强制类型转换\",{\"1\":{\"443\":1}}],[\"必须释放\",{\"1\":{\"437\":1}}],[\"必须使用可以在运行时进行数据再平衡的一套系统\",{\"1\":{\"385\":1}}],[\"必须使用固定的keys\",{\"1\":{\"385\":1}}],[\"必须是写入所有\",{\"1\":{\"334\":1}}],[\"必须有至少\",{\"1\":{\"334\":1}}],[\"必须设置自定义域名后才能使用workers方式的tls模式\",{\"1\":{\"69\":1}}],[\"必须改为你在cf解析完成的自定义域名\",{\"1\":{\"69\":2}}],[\"必须经过\",{\"1\":{\"16\":1}}],[\"^=\",{\"1\":{\"555\":2,\"579\":2}}],[\"^\",{\"1\":{\"69\":1,\"70\":1,\"71\":1,\"201\":1,\"555\":6,\"579\":5}}],[\"|=\",{\"1\":{\"555\":5}}],[\"|\",{\"1\":{\"69\":5,\"70\":6,\"71\":2,\"216\":1,\"223\":5,\"230\":3,\"237\":3,\"244\":2,\"251\":1,\"521\":1,\"522\":1,\"555\":1,\"731\":1}}],[\"||\",{\"1\":{\"69\":9,\"70\":10,\"71\":34,\"556\":5,\"714\":1}}],[\"q\",{\"1\":{\"614\":5}}],[\"qdhxhz\",{\"1\":{\"537\":1}}],[\"qlsessionfactory\",{\"1\":{\"194\":1}}],[\"quyaoya\",{\"1\":{\"70\":2}}],[\"queue是队列集合\",{\"1\":{\"569\":1}}],[\"queue是典型的fifo\",{\"1\":{\"368\":1}}],[\"queue分布到多broker中\",{\"1\":{\"371\":1}}],[\"queue的数量是堆积的几倍\",{\"1\":{\"371\":1}}],[\"queue等\",{\"1\":{\"362\":1}}],[\"queue队列\",{\"0\":{\"355\":1},\"1\":{\"603\":1}}],[\"queue\",{\"1\":{\"337\":5,\"355\":1,\"569\":2,\"639\":1}}],[\"queries\",{\"1\":{\"70\":2}}],[\"query\",{\"1\":{\"70\":2,\"175\":1,\"198\":1,\"201\":3}}],[\"question\",{\"1\":{\"48\":1,\"70\":1}}],[\"qidian\",{\"1\":{\"70\":2}}],[\"qqgongyi\",{\"1\":{\"70\":1}}],[\"qq\",{\"1\":{\"70\":3,\"483\":1,\"544\":1,\"599\":1}}],[\"qr\",{\"1\":{\"70\":1}}],[\"qrserver\",{\"1\":{\"70\":1}}],[\"qa==\",{\"1\":{\"70\":1}}],[\"q=edtunnel\",{\"1\":{\"69\":1,\"70\":1}}],[\"$\",{\"1\":{\"69\":35,\"70\":46,\"71\":44,\"181\":4}}],[\"`name`\",{\"1\":{\"168\":1,\"169\":1}}],[\"`attachment\",{\"1\":{\"71\":3}}],[\"`addressvalue\",{\"1\":{\"69\":1,\"70\":1}}],[\"`user`\",{\"1\":{\"166\":1,\"167\":1,\"168\":1,\"169\":1}}],[\"`userid\",{\"1\":{\"70\":1}}],[\"`upload=$\",{\"1\":{\"71\":3}}],[\"`ua\",{\"1\":{\"71\":1}}],[\"`error\",{\"1\":{\"71\":5}}],[\"`http\",{\"1\":{\"71\":1}}],[\"`https\",{\"1\":{\"70\":5,\"71\":2}}],[\"`วเลส\",{\"1\":{\"70\":1}}],[\"`<h2>uuid\",{\"1\":{\"70\":1}}],[\"`vless\",{\"1\":{\"69\":2,\"71\":2}}],[\"`doh\",{\"1\":{\"69\":1,\"70\":1}}],[\"`invild\",{\"1\":{\"69\":1,\"70\":1}}],[\"`command\",{\"1\":{\"69\":1,\"70\":1}}],[\"`connected\",{\"1\":{\"69\":1,\"70\":1}}],[\"`checkuuidinapi\",{\"1\":{\"69\":1}}],[\"`retry`\",{\"1\":{\"69\":1,\"70\":1}}],[\"`remotesockettows\",{\"1\":{\"69\":1,\"70\":2}}],[\"`remoteconnection\",{\"1\":{\"69\":2,\"70\":2}}],[\"`readablestream\",{\"1\":{\"69\":1,\"70\":1}}],[\"`readablewebsocketstream\",{\"1\":{\"69\":2,\"70\":2}}],[\"`redirects\",{\"1\":{\"69\":1,\"70\":1}}],[\"`$\",{\"1\":{\"69\":2,\"70\":5,\"71\":7}}],[\"`\",{\"1\":{\"69\":23,\"70\":38,\"71\":38,\"488\":1}}],[\">重量级锁\",{\"1\":{\"655\":1}}],[\">轻量级锁\",{\"1\":{\"655\":1}}],[\">偏向锁\",{\"1\":{\"655\":1}}],[\">=\",{\"1\":{\"499\":2,\"555\":1,\"556\":1,\"559\":2,\"612\":3,\"713\":3,\"728\":1}}],[\">子类构造器\",{\"1\":{\"461\":1}}],[\">子类代码块\",{\"1\":{\"461\":1}}],[\">子类静态块\",{\"1\":{\"461\":1}}],[\">父类构造器\",{\"1\":{\"461\":1}}],[\">父类代码块\",{\"1\":{\"461\":1}}],[\">master\",{\"1\":{\"427\":1}}],[\">编码\",{\"1\":{\"210\":1}}],[\">nginx\",{\"1\":{\"71\":2}}],[\">nekobox优选ip自动<\",{\"1\":{\"70\":1}}],[\">$\",{\"1\":{\"70\":1}}],[\">v2rayng优选ip自动<\",{\"1\":{\"70\":1}}],[\">version\",{\"1\":{\"69\":1}}],[\">singbox优选ip自动<\",{\"1\":{\"70\":1}}],[\">优选ip自动节点订阅<\",{\"1\":{\"70\":1}}],[\">clash优选ip自动<\",{\"1\":{\"70\":1}}],[\">clash\",{\"1\":{\"70\":2}}],[\">วเลส\",{\"1\":{\"70\":1}}],[\">edtunnel\",{\"1\":{\"70\":1}}],[\">欢迎\",{\"1\":{\"70\":1}}],[\">welcome\",{\"1\":{\"70\":1}}],[\"><\",{\"1\":{\"70\":3,\"268\":1,\"277\":2}}],[\"><img\",{\"1\":{\"70\":1}}],[\"><i\",{\"1\":{\"70\":2}}],[\">>>\",{\"1\":{\"555\":12,\"579\":6}}],[\">>\",{\"1\":{\"69\":1,\"70\":1,\"194\":2,\"200\":1,\"573\":1}}],[\">\",{\"1\":{\"69\":10,\"70\":26,\"71\":4,\"84\":2,\"95\":1,\"136\":2,\"152\":1,\"154\":2,\"161\":2,\"194\":3,\"200\":2,\"203\":3,\"204\":4,\"205\":5,\"210\":8,\"216\":1,\"223\":2,\"230\":2,\"237\":1,\"244\":5,\"251\":3,\"268\":4,\"277\":4,\"310\":3,\"313\":4,\"423\":1,\"461\":3,\"512\":1,\"546\":3,\"556\":1,\"559\":2,\"573\":2,\"639\":2,\"728\":1}}],[\"德国ip段可直接导入ip\",{\"1\":{\"65\":1}}],[\"法国\",{\"1\":{\"65\":1}}],[\"众多tls节点无法使用\",{\"1\":{\"63\":1}}],[\"特别适用于各个线程依赖不通的变量值完成操作的场景\",{\"1\":{\"704\":1}}],[\"特别适合用于存储对象\",{\"1\":{\"382\":1}}],[\"特别注意\",{\"1\":{\"649\":1}}],[\"特别是源\",{\"1\":{\"14\":1}}],[\"特点\",{\"1\":{\"362\":1}}],[\"特殊的类加载器实现\",{\"1\":{\"284\":1}}],[\"特殊编译器实现\",{\"1\":{\"284\":1}}],[\"特性对性能提升至少是一倍以上\",{\"1\":{\"402\":1}}],[\"特性整合了开源行业中优秀的组件\",{\"1\":{\"310\":1}}],[\"特性\",{\"1\":{\"112\":1,\"350\":1}}],[\"特定国家ip段\",{\"1\":{\"63\":1}}],[\"看美团技术团队的实践\",{\"1\":{\"675\":1}}],[\"看一下这个acquire是怎么写的\",{\"1\":{\"605\":1}}],[\"看一看object类中equals方法的源码\",{\"1\":{\"476\":1}}],[\"看下图\",{\"1\":{\"555\":1}}],[\"看下本期的目录\",{\"1\":{\"26\":1}}],[\"看下本期的目录吧\",{\"1\":{\"7\":1}}],[\"看这一篇就够了\",{\"1\":{\"545\":1,\"585\":1}}],[\"看到这个结论\",{\"1\":{\"528\":1}}],[\"看getmapper方法\",{\"1\":{\"194\":1}}],[\"看看源码的实现\",{\"1\":{\"555\":1,\"579\":1}}],[\"看看系统是不是可以丢卒保帅\",{\"1\":{\"398\":1}}],[\"看看执行计划是否准确\",{\"1\":{\"141\":1}}],[\"看看里面跑的\",{\"1\":{\"141\":1}}],[\"看看是否load了额外的数据\",{\"1\":{\"137\":1}}],[\"看地图上自己所属省份是否能使用\",{\"1\":{\"62\":1}}],[\"挑选下方任意一个域名\",{\"1\":{\"62\":1}}],[\"把它理解为一个备份的线程就行了\",{\"1\":{\"717\":1}}],[\"把数据进行隔离\",{\"1\":{\"704\":1}}],[\"把大任务拆分成小任务\",{\"1\":{\"643\":1}}],[\"把字节码解释为机器语言发送给处理器\",{\"1\":{\"637\":1,\"708\":1}}],[\"把哈希桶切分成小数组\",{\"1\":{\"584\":1}}],[\"把哈希桶数组切分成小数组\",{\"1\":{\"546\":1}}],[\"把节点b摘下来\",{\"1\":{\"564\":1}}],[\"把每个bucket都移动到新的buckets中\",{\"1\":{\"559\":1}}],[\"把一个类的接口变换成客户端所期待的另一种接口\",{\"1\":{\"543\":1}}],[\"把java对象序列化成可存储或传输的形式\",{\"1\":{\"518\":1}}],[\"把json字串转化成对应的对象\",{\"1\":{\"244\":1}}],[\"把包装类型转换成基本类型的过程叫做拆箱\",{\"1\":{\"493\":1}}],[\"把基本类型转换成包装类型的过程叫做装箱\",{\"1\":{\"493\":1}}],[\"把redis当成memcached使用\",{\"1\":{\"438\":1}}],[\"把rpcserver抽象成接口\",{\"1\":{\"230\":1}}],[\"把处理逻辑交还给\",{\"1\":{\"406\":1}}],[\"把过期时间存在key对应的value里\",{\"1\":{\"394\":1,\"396\":1}}],[\"把原来topic中的消息挪到新的topic里\",{\"1\":{\"371\":1}}],[\"把返回的\",{\"1\":{\"290\":1}}],[\"把当前事务挂起\",{\"1\":{\"289\":1}}],[\"把费时的操作放到系统启动中完成\",{\"1\":{\"266\":1}}],[\"把对象序列化成字节数组\",{\"1\":{\"244\":1}}],[\"把这个客户端传入代理客户端\",{\"1\":{\"237\":1}}],[\"把不同的service方法封装成统一的request对象格式\",{\"1\":{\"223\":1}}],[\"把\",{\"1\":{\"181\":1,\"290\":1,\"555\":1,\"721\":1}}],[\"把所有的列都放到索引中\",{\"1\":{\"138\":1}}],[\"把端口改为\",{\"1\":{\"61\":1}}],[\"把ssthresh门限减半\",{\"1\":{\"24\":1}}],[\"填充属性\",{\"1\":{\"281\":1}}],[\"填优选ip处填写\",{\"1\":{\"61\":1}}],[\"填1个二级域名\",{\"1\":{\"61\":1}}],[\"没办法把任务放到队列中也没有足够线程来执行任务的情况\",{\"1\":{\"673\":1}}],[\"没超过最大值\",{\"1\":{\"559\":1}}],[\"没人生产用单机模式\",{\"1\":{\"361\":1}}],[\"没掉队\",{\"1\":{\"334\":1}}],[\"没tls加密\",{\"1\":{\"61\":1}}],[\"没有存在于文件系统中\",{\"1\":{\"731\":1}}],[\"没有什么任务应该被缓存下来\",{\"1\":{\"720\":1}}],[\"没有什么高可用性可言\",{\"1\":{\"323\":1}}],[\"没有使用可重入锁reentrantlock\",{\"1\":{\"714\":1}}],[\"没有任务执行时\",{\"1\":{\"712\":1}}],[\"没有必要加锁\",{\"1\":{\"667\":1}}],[\"没有起到多线程效果\",{\"1\":{\"641\":1}}],[\"没有的话抛出npe\",{\"1\":{\"603\":1}}],[\"没有位运算快\",{\"1\":{\"555\":1}}],[\"没有关系\",{\"1\":{\"547\":1,\"587\":1}}],[\"没有找到可以处理该异常的代码块\",{\"1\":{\"537\":1}}],[\"没有发现\",{\"1\":{\"488\":2}}],[\"没有面向对象易维护\",{\"1\":{\"463\":1}}],[\"没有指针的概念\",{\"1\":{\"443\":1}}],[\"没有获得锁的线程并不会进入排队队列\",{\"1\":{\"432\":1}}],[\"没有备用节点实时同步数据\",{\"1\":{\"414\":1}}],[\"没有在事务上增加任何维持原子性的机制\",{\"1\":{\"407\":1}}],[\"没有多线程切换的场景\",{\"1\":{\"399\":1}}],[\"没有人使用的\",{\"1\":{\"389\":1}}],[\"没有磁盘io上的开销\",{\"1\":{\"377\":1}}],[\"没有\",{\"1\":{\"367\":1,\"616\":1}}],[\"没有部分注入\",{\"1\":{\"267\":1}}],[\"没有预编译处理\",{\"1\":{\"181\":1}}],[\"没有太多限制\",{\"1\":{\"126\":1}}],[\"没有用到索引\",{\"1\":{\"96\":1}}],[\"没有成功地在\",{\"1\":{\"18\":1}}],[\"没有实际应用\",{\"1\":{\"8\":1}}],[\"添加元素\",{\"1\":{\"597\":1}}],[\"添加内部分页拦截器\",{\"1\":{\"315\":1}}],[\"添加线程池版的服务端的实现\",{\"1\":{\"232\":1}}],[\"添加多个服务的实现类\",{\"1\":{\"230\":1}}],[\"添加自定义域\",{\"1\":{\"61\":1}}],[\"添加额外条件\",{\"1\":{\"45\":1}}],[\"下午3\",{\"1\":{\"718\":1}}],[\"下\",{\"1\":{\"682\":1}}],[\"下图中展示了线程1往阻塞队列中添加元素\",{\"1\":{\"713\":1}}],[\"下图为\",{\"1\":{\"559\":1}}],[\"下图是客户端与\",{\"1\":{\"403\":1}}],[\"下一个节点\",{\"1\":{\"546\":1}}],[\"下一次再访问这些数据的时候就可以直接从缓存中获取了\",{\"1\":{\"379\":1}}],[\"下一次的数据从哪里发\",{\"1\":{\"22\":1}}],[\"下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态\",{\"1\":{\"519\":1}}],[\"下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中\",{\"1\":{\"519\":1}}],[\"下次直接读取缓存\",{\"1\":{\"138\":1}}],[\"下的各个\",{\"1\":{\"364\":1}}],[\"下的文件\",{\"1\":{\"195\":1}}],[\"下面提供了几个访问这个字段的方法\",{\"1\":{\"604\":1}}],[\"下面来看看异常情况\",{\"1\":{\"565\":1}}],[\"下面的例子\",{\"1\":{\"565\":1}}],[\"下面是resize\",{\"1\":{\"564\":1}}],[\"下面是我的初步对我的自定义格式的设计了\",{\"1\":{\"244\":1}}],[\"下面看看多线程情况下\",{\"1\":{\"564\":1}}],[\"下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题\",{\"1\":{\"447\":1}}],[\"下面介绍的是redis\",{\"1\":{\"403\":1}}],[\"下面附场景解释\",{\"1\":{\"345\":1}}],[\"下面分析单例模式下的setter循环依赖如何解决\",{\"1\":{\"281\":1}}],[\"下载解压zookeeper\",{\"1\":{\"251\":1}}],[\"下载\",{\"1\":{\"64\":1}}],[\"下载地址>>\",{\"1\":{\"60\":1}}],[\"付费域名注册和解析点击查看这个视频>>跳转到4分17秒处\",{\"1\":{\"60\":1,\"66\":1}}],[\"付费域名注册\",{\"1\":{\"60\":1}}],[\"免费域名注册\",{\"1\":{\"60\":1}}],[\"免费节点\",{\"0\":{\"56\":1}}],[\"生产和消费者\",{\"1\":{\"374\":1}}],[\"生产者是往队列里添加元素的线程\",{\"1\":{\"713\":1}}],[\"生产者如何将消息可靠投递到rabbitmq\",{\"0\":{\"359\":1}}],[\"生产者消息运转的流程\",{\"0\":{\"357\":1}}],[\"生产者到rabbitmq\",{\"1\":{\"356\":1}}],[\"生产者将消息发送到交换器\",{\"1\":{\"355\":1}}],[\"生产者将消息发送给交换器\",{\"1\":{\"353\":1}}],[\"生产者将数据发送出去就不管了\",{\"1\":{\"330\":1}}],[\"生产者写入消息\",{\"1\":{\"342\":1}}],[\"生产者在写数据的时候\",{\"1\":{\"336\":1}}],[\"生产者会自动不断的重试\",{\"1\":{\"333\":1}}],[\"生产者数据传输导致的消息丢失\",{\"0\":{\"333\":1}}],[\"生产者\",{\"1\":{\"331\":1}}],[\"生产者使用push模式将消息发布到broker\",{\"1\":{\"324\":1}}],[\"生产者只将数据写入\",{\"1\":{\"323\":1}}],[\"生产订阅链接\",{\"0\":{\"56\":1}}],[\"生命周期管理\",{\"0\":{\"712\":1}}],[\"生命周期随着jvm的销毁而结束\",{\"1\":{\"380\":1}}],[\"生命周期\",{\"0\":{\"273\":1}}],[\"生成出的methodaccessorimpl字节码翻译成java代码大致如下\",{\"1\":{\"507\":1}}],[\"生成实例并返回\",{\"1\":{\"507\":1}}],[\"生成的变量指向堆中新建的对象\",{\"1\":{\"498\":1}}],[\"生成的变量比较时\",{\"1\":{\"498\":1}}],[\"生成变量的对比\",{\"0\":{\"498\":1},\"1\":{\"484\":1}}],[\"生成\",{\"1\":{\"126\":1,\"194\":1,\"284\":1}}],[\"生成执行计划\",{\"1\":{\"88\":1,\"99\":1}}],[\"生成器地址\",{\"1\":{\"58\":1}}],[\"推荐\",{\"1\":{\"61\":1,\"136\":1}}],[\"推荐api地址\",{\"1\":{\"58\":1}}],[\"推荐订阅器\",{\"1\":{\"57\":1}}],[\"优先级\",{\"1\":{\"672\":1}}],[\"优先级就越高\",{\"1\":{\"426\":2}}],[\"优先保证热点数据进行提前加载到缓存\",{\"1\":{\"397\":1}}],[\"优先使用第二种方案直接过滤掉\",{\"1\":{\"395\":1}}],[\"优势是\",{\"1\":{\"621\":2,\"688\":2}}],[\"优势\",{\"1\":{\"383\":2,\"384\":1}}],[\"优雅\",{\"1\":{\"140\":1}}],[\"优化了高位运算的算法\",{\"1\":{\"555\":1}}],[\"优化网络\",{\"1\":{\"401\":1}}],[\"优化的数据结构\",{\"1\":{\"377\":1}}],[\"优化shema\",{\"1\":{\"135\":1}}],[\"优化事务性能\",{\"1\":{\"120\":1}}],[\"优化锁方面的意见\",{\"0\":{\"120\":1}}],[\"优化\",{\"0\":{\"90\":1},\"1\":{\"88\":1,\"90\":2,\"99\":1}}],[\"优选官方线路\",{\"1\":{\"71\":1}}],[\"优选域名\",{\"1\":{\"69\":4}}],[\"优选域名推荐\",{\"1\":{\"58\":1}}],[\"优选ip\",{\"1\":{\"64\":1,\"69\":4}}],[\"优点\",{\"1\":{\"36\":1,\"84\":1,\"173\":1,\"266\":2,\"270\":1,\"376\":1,\"386\":3,\"414\":1,\"415\":1,\"416\":1,\"417\":1,\"418\":1,\"432\":2,\"463\":2,\"502\":1}}],[\"数目为interger\",{\"1\":{\"672\":1}}],[\"数字格式异常\",{\"1\":{\"534\":1}}],[\"数\",{\"1\":{\"382\":1}}],[\"数组类型\",{\"1\":{\"683\":1}}],[\"数组的长度总是\",{\"1\":{\"555\":1}}],[\"数组的初始容量\",{\"1\":{\"555\":1}}],[\"数组的下标在bitmap中叫做偏移量\",{\"1\":{\"382\":1}}],[\"数组是\",{\"1\":{\"553\":1,\"575\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"553\":1,\"575\":1}}],[\"数组+链表\",{\"1\":{\"553\":1,\"575\":1}}],[\"数组扩容或者将链表转换为红黑树\",{\"1\":{\"547\":1,\"585\":1}}],[\"数组结构组成\",{\"1\":{\"546\":1,\"584\":1}}],[\"数组结构和\",{\"1\":{\"546\":1,\"584\":1}}],[\"数组索引越界异常\",{\"1\":{\"534\":1}}],[\"数组越界\",{\"1\":{\"531\":1}}],[\"数组中的每个单元只能存0或者1\",{\"1\":{\"382\":1}}],[\"数组不为空\",{\"1\":{\"204\":1,\"313\":1}}],[\"数量不要过多\",{\"1\":{\"350\":1}}],[\"数量对吞吐量的影响\",{\"1\":{\"350\":1}}],[\"数据只能在一个方向上流动\",{\"1\":{\"731\":1}}],[\"数据块\",{\"1\":{\"726\":1}}],[\"数据不共享\",{\"1\":{\"704\":1}}],[\"数据不需要复制到用户态空间\",{\"1\":{\"341\":1}}],[\"数据即使成功修改\",{\"1\":{\"645\":1}}],[\"数据\",{\"1\":{\"519\":1}}],[\"数据存储异常\",{\"1\":{\"531\":1}}],[\"数据存储空间才被分配\",{\"1\":{\"455\":1}}],[\"数据存在内存中\",{\"1\":{\"377\":1}}],[\"数据复制和同步的延迟都超过了10秒钟\",{\"1\":{\"424\":1}}],[\"数据复制和同步的延迟不能超过10秒\",{\"1\":{\"424\":1}}],[\"数据通过异步复制\",{\"1\":{\"417\":1}}],[\"数据按照slot存储分布在多个节点\",{\"1\":{\"417\":1}}],[\"数据丢失的问题是不可避免的\",{\"1\":{\"424\":1}}],[\"数据丢失\",{\"1\":{\"414\":1}}],[\"数据结构\",{\"1\":{\"399\":1,\"549\":1,\"591\":1}}],[\"数据结构丰富\",{\"1\":{\"376\":1}}],[\"数据量不是很多\",{\"1\":{\"413\":1}}],[\"数据量不大的时候\",{\"1\":{\"397\":1}}],[\"数据量太大的时候\",{\"1\":{\"397\":1}}],[\"数据量大的时候\",{\"1\":{\"397\":1}}],[\"数据更少的丢失\",{\"1\":{\"384\":1}}],[\"数据就够大了\",{\"1\":{\"380\":1}}],[\"数据类型\",{\"1\":{\"378\":1,\"382\":2}}],[\"数据从写入主节点到同步至从节点中的过程需要经历网络→主节点内存→网络→从节点内存这几个阶段\",{\"1\":{\"342\":1}}],[\"数据从主节点转到从节点必然会有一个延时的时间窗口\",{\"1\":{\"342\":1}}],[\"数据的值并不为最新的\",{\"1\":{\"342\":1}}],[\"数据的值都为\",{\"1\":{\"342\":1}}],[\"数据一致性问题\",{\"1\":{\"342\":1}}],[\"数据发送到kafka后\",{\"1\":{\"330\":1}}],[\"数据监控等\",{\"1\":{\"310\":1}}],[\"数据格式\",{\"1\":{\"294\":1}}],[\"数据传输\",{\"1\":{\"223\":1}}],[\"数据对象的插入和删除仅在叶节点上进行\",{\"1\":{\"149\":1}}],[\"数据都在叶子节点上\",{\"1\":{\"149\":1}}],[\"数据分布在各个节点之中\",{\"1\":{\"149\":1}}],[\"数据然后基本上全部丢弃\",{\"1\":{\"136\":1}}],[\"数据备份\",{\"1\":{\"130\":1}}],[\"数据查询的时候不是必要\",{\"1\":{\"120\":1}}],[\"数据文件是分离的\",{\"1\":{\"92\":1}}],[\"数据文件是和索引绑在一起的\",{\"1\":{\"92\":1}}],[\"数据库连接池\",{\"1\":{\"663\":1}}],[\"数据库是一个单点\",{\"1\":{\"432\":1}}],[\"数据库也查不到数据的情况\",{\"1\":{\"395\":1}}],[\"数据库更新操作后再\",{\"1\":{\"393\":1}}],[\"数据库容量受到物理内存的限制\",{\"1\":{\"376\":1}}],[\"数据库\",{\"1\":{\"376\":1}}],[\"数据库无关性好\",{\"1\":{\"178\":1}}],[\"数据库无关性支持好\",{\"1\":{\"175\":1}}],[\"数据库链接创建\",{\"1\":{\"176\":1}}],[\"数据库索引\",{\"1\":{\"146\":1}}],[\"数据库结构优化\",{\"0\":{\"140\":1}}],[\"数据库层面\",{\"1\":{\"136\":1}}],[\"数据库管理系统\",{\"1\":{\"116\":1}}],[\"数据库的查询结果可能是\",{\"1\":{\"493\":1}}],[\"数据库的\",{\"1\":{\"393\":1}}],[\"数据库的修改\",{\"1\":{\"392\":1}}],[\"数据库的数据存储以页为单位一页存储的数据越多一次io操作获取的数据越大效率越高\",{\"1\":{\"160\":1}}],[\"数据库的crud性能会明显下降\",{\"1\":{\"142\":1}}],[\"数据库的乐观锁和悲观锁是什么\",{\"0\":{\"116\":1}}],[\"数据库的三范式是什么\",{\"0\":{\"91\":1}}],[\"数据库会先对满足\",{\"1\":{\"112\":1}}],[\"数据库就可以通过重做日志来保证事务的原子性和持久性\",{\"1\":{\"104\":1}}],[\"数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合\",{\"1\":{\"93\":1}}],[\"数据库中\",{\"1\":{\"76\":2}}],[\"数据页的分裂与合并\",{\"1\":{\"85\":1}}],[\"数据表为每个用户开启的事务\",{\"1\":{\"74\":1}}],[\"数据中心是\",{\"1\":{\"71\":1}}],[\"数据链路层通常简称为链路层\",{\"1\":{\"8\":1}}],[\"数据链路层\",{\"1\":{\"8\":1}}],[\"数码海\",{\"1\":{\"57\":1}}],[\"甲骨文\",{\"1\":{\"57\":1}}],[\"香港\",{\"1\":{\"57\":1}}],[\"新值对所有线程会立即更新\",{\"1\":{\"637\":1,\"708\":1}}],[\"新建线程工厂\",{\"1\":{\"670\":1}}],[\"新建状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"新建一个更大尺寸的hash表\",{\"1\":{\"564\":1}}],[\"新建一个\",{\"1\":{\"499\":1}}],[\"新建事务\",{\"1\":{\"289\":1}}],[\"新写入操作会报错\",{\"1\":{\"388\":1}}],[\"新加入的follower也会先存放在osr中\",{\"1\":{\"338\":1}}],[\"新加坡\",{\"1\":{\"57\":1}}],[\"新增了两个锁状态\",{\"1\":{\"654\":1}}],[\"新增了重写机制\",{\"1\":{\"383\":1}}],[\"新增效率又比较慢\",{\"1\":{\"553\":1,\"577\":1}}],[\"新增\",{\"1\":{\"335\":1}}],[\"新的获得锁的节点\",{\"1\":{\"608\":1}}],[\"新的线程封装成node节点追加到同步队列中\",{\"1\":{\"607\":1}}],[\"新的容量会是原容量的1\",{\"1\":{\"573\":1}}],[\"新的master配置是跟着新的version号的\",{\"1\":{\"427\":1}}],[\"新的aof文件前半段是rdb格式的全量数据后半段是aof格式的增量数据\",{\"1\":{\"384\":1}}],[\"新的服务接口\",{\"1\":{\"230\":1}}],[\"新的二进制格式\",{\"1\":{\"34\":1}}],[\"新版的mysql中对row级别也做了一些优化\",{\"1\":{\"89\":1}}],[\"新版\",{\"1\":{\"63\":1}}],[\"次幂\",{\"1\":{\"555\":2}}],[\"次幂有助于减少碰撞的几率\",{\"1\":{\"555\":1}}],[\"次方\",{\"1\":{\"555\":2}}],[\"次的磁盘i\",{\"1\":{\"162\":1}}],[\"次\",{\"1\":{\"57\":7,\"555\":1,\"585\":1}}],[\"变色这些操作来保持平衡\",{\"1\":{\"553\":1,\"577\":1}}],[\"变成遍历红黑树o\",{\"1\":{\"549\":1,\"591\":1}}],[\"变得可写时\",{\"1\":{\"403\":1}}],[\"变得可读时或者有新的可以应答的\",{\"1\":{\"403\":1}}],[\"变量的读写都直接写入主存\",{\"1\":{\"646\":1}}],[\"变量的值被设为初始值\",{\"1\":{\"527\":1}}],[\"变量替换后\",{\"1\":{\"181\":2}}],[\"变量各个取值之间的差异程度\",{\"1\":{\"160\":1}}],[\"变量自动\",{\"1\":{\"58\":1}}],[\"变量\",{\"1\":{\"57\":1,\"451\":5,\"454\":1,\"598\":1,\"646\":1}}],[\"变为\",{\"1\":{\"38\":1,\"559\":1}}],[\"任务粒度的transaction监控\",{\"1\":{\"720\":1}}],[\"任务监控\",{\"1\":{\"720\":1}}],[\"任务缓冲模块是线程池能够管理任务的核心部分\",{\"1\":{\"713\":1}}],[\"任务缓冲\",{\"1\":{\"713\":1}}],[\"任务调度流程\",{\"1\":{\"713\":1}}],[\"任务调度是线程池的主要入口\",{\"1\":{\"713\":1}}],[\"任务执行机制\",{\"0\":{\"713\":1}}],[\"任务管理部分充当生产者的角色\",{\"1\":{\"711\":1}}],[\"任务管理\",{\"1\":{\"711\":1}}],[\"任务可以不需要的等到线程创建就能立即执行\",{\"1\":{\"668\":1}}],[\"任意一个超过阈值都会把follower剔除出isr\",{\"1\":{\"338\":1}}],[\"任意一个节点\",{\"0\":{\"56\":1}}],[\"任意修改不会创建一个新实例\",{\"1\":{\"267\":1}}],[\"任意修改都会创建一个新实例\",{\"1\":{\"267\":1}}],[\"任何修改都会创建一个新的对象\",{\"1\":{\"472\":1}}],[\"任何非主属性不依赖于其它非主属性\",{\"1\":{\"91\":1}}],[\"任何字符上的不同\",{\"1\":{\"88\":1,\"99\":1}}],[\"任何情况都无法保证\",{\"1\":{\"76\":1}}],[\"任何一个服务器上的\",{\"1\":{\"42\":1}}],[\"订阅锁释放消息\",{\"1\":{\"435\":1}}],[\"订阅及阻塞队列功能\",{\"1\":{\"381\":1}}],[\"订阅模型\",{\"1\":{\"326\":1}}],[\"订阅转换配置文件\",{\"1\":{\"71\":1}}],[\"订阅器内置节点\",{\"1\":{\"71\":1}}],[\"订阅器\",{\"1\":{\"70\":1}}],[\"订阅器部署\",{\"0\":{\"58\":1}}],[\"订阅器https\",{\"1\":{\"53\":2}}],[\"订阅动态更新\",{\"0\":{\"56\":1}}],[\"源代码如下\",{\"1\":{\"547\":4}}],[\"源角色\",{\"1\":{\"543\":2}}],[\"源码中threadpoolexecutor中有个内置对象worker\",{\"1\":{\"674\":1}}],[\"源码中线程池是怎么复用线程的\",{\"0\":{\"674\":1}}],[\"源码中是在sqlsourcebuilder类中解析的\",{\"1\":{\"201\":1}}],[\"源码分析可看这篇文章\",{\"1\":{\"585\":1}}],[\"源码\",{\"1\":{\"559\":1}}],[\"源码就是这样写的\",{\"1\":{\"548\":1,\"588\":1}}],[\"源码如下\",{\"1\":{\"481\":3,\"499\":2,\"555\":1}}],[\"源\",{\"1\":{\"55\":1,\"59\":1,\"63\":1}}],[\"vsshutdownnow\",{\"0\":{\"698\":1}}],[\"vs\",{\"0\":{\"629\":1,\"630\":1,\"631\":1,\"696\":1,\"697\":1,\"699\":1}}],[\"v相同时\",{\"1\":{\"595\":1}}],[\"vector是扩展1倍\",{\"1\":{\"572\":1}}],[\"vector是线程安全的\",{\"1\":{\"572\":1}}],[\"vector在关键性的方法前面都加了synchronized关键字\",{\"1\":{\"572\":1}}],[\"vector\",{\"0\":{\"572\":1},\"1\":{\"570\":1,\"572\":1}}],[\"very\",{\"1\":{\"399\":1}}],[\"verdana\",{\"1\":{\"71\":1}}],[\"version>\",{\"1\":{\"237\":1,\"251\":1}}],[\"version8版本\",{\"1\":{\"212\":1}}],[\"version7版本\",{\"1\":{\"212\":1}}],[\"version6版本\",{\"1\":{\"212\":1}}],[\"version5版本\",{\"1\":{\"212\":1}}],[\"version4版本\",{\"1\":{\"212\":1}}],[\"version3版本\",{\"1\":{\"212\":1}}],[\"version2版本\",{\"1\":{\"212\":1}}],[\"version1版本\",{\"1\":{\"212\":1}}],[\"version0版本\",{\"1\":{\"212\":1}}],[\"version=\",{\"1\":{\"205\":1}}],[\"version\",{\"1\":{\"69\":3,\"70\":3}}],[\"verge\",{\"1\":{\"68\":5}}],[\"v>\",{\"1\":{\"556\":6,\"558\":2,\"559\":9,\"564\":1,\"581\":2,\"586\":3,\"587\":2,\"594\":5}}],[\"v\",{\"1\":{\"556\":5,\"586\":1,\"644\":3,\"728\":1,\"731\":1}}],[\"v4\",{\"1\":{\"400\":1}}],[\"volatile关键字主要用于解决变量在多个线程之间的可见性\",{\"1\":{\"709\":1}}],[\"volatile关键字能保证数据的可见性\",{\"1\":{\"709\":1}}],[\"volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块\",{\"1\":{\"709\":1}}],[\"volatile关键字是线程同步的轻量级实现\",{\"1\":{\"709\":1}}],[\"volatile的原理\",{\"1\":{\"637\":1,\"708\":1}}],[\"volatile的两层语义\",{\"1\":{\"637\":1,\"708\":1}}],[\"volatile保证变量对所有线程的可见性\",{\"1\":{\"637\":1,\"708\":1}}],[\"volatile\",{\"0\":{\"646\":1,\"709\":1,\"734\":1},\"1\":{\"388\":4,\"546\":1,\"547\":5,\"586\":3,\"587\":1,\"604\":1,\"646\":7,\"684\":2}}],[\"void\",{\"1\":{\"69\":2,\"70\":4,\"193\":1,\"194\":2,\"196\":1,\"197\":4,\"198\":3,\"199\":5,\"200\":1,\"201\":2,\"202\":2,\"204\":1,\"216\":2,\"223\":2,\"230\":10,\"237\":7,\"244\":2,\"245\":1,\"251\":3,\"317\":2,\"318\":1,\"319\":1,\"391\":1,\"488\":1,\"494\":2,\"505\":2,\"506\":2,\"521\":2,\"522\":4,\"532\":3,\"556\":1,\"558\":2,\"573\":3,\"581\":2,\"604\":1,\"605\":2,\"610\":1,\"612\":2,\"616\":1,\"617\":3,\"638\":2}}],[\"vm\",{\"1\":{\"377\":1,\"499\":1}}],[\"vmess\",{\"1\":{\"57\":1}}],[\"v数据库中\",{\"1\":{\"136\":1}}],[\"vultr\",{\"1\":{\"71\":1}}],[\"vue\",{\"1\":{\"3\":2}}],[\"vuepress\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":3,\"5\":2}}],[\"visitor\",{\"1\":{\"382\":1}}],[\"visakorea\",{\"1\":{\"62\":1}}],[\"visa\",{\"1\":{\"62\":5,\"69\":2,\"71\":1}}],[\"viewresolver\",{\"1\":{\"290\":1,\"291\":1}}],[\"view\",{\"1\":{\"282\":1,\"290\":6,\"291\":1,\"483\":1}}],[\"viewport\",{\"1\":{\"70\":1}}],[\"video\",{\"0\":{\"742\":1},\"1\":{\"70\":8}}],[\"variance\",{\"1\":{\"553\":2}}],[\"variables\",{\"1\":{\"69\":1}}],[\"varchar\",{\"0\":{\"95\":1},\"1\":{\"95\":3,\"159\":3}}],[\"var\",{\"1\":{\"71\":1}}],[\"val\",{\"1\":{\"586\":2}}],[\"value还在\",{\"1\":{\"665\":1}}],[\"value是threadlocal的泛型值\",{\"1\":{\"664\":2}}],[\"value对的集合\",{\"1\":{\"569\":1}}],[\"value为对象\",{\"1\":{\"506\":1}}],[\"value长度\",{\"1\":{\"438\":1}}],[\"value获取所有redis服务的锁\",{\"1\":{\"437\":1}}],[\"value这里设置为test\",{\"1\":{\"434\":1}}],[\"value缓存应用\",{\"1\":{\"382\":1}}],[\"value类型的内存数据库\",{\"1\":{\"376\":1}}],[\"value=\",{\"1\":{\"268\":1,\"277\":2}}],[\"valueoffset\",{\"1\":{\"684\":2}}],[\"valueof\",{\"1\":{\"237\":2,\"494\":1,\"499\":3}}],[\"value\",{\"0\":{\"588\":1},\"1\":{\"69\":5,\"70\":5,\"71\":1,\"204\":8,\"237\":1,\"376\":1,\"382\":3,\"396\":1,\"399\":1,\"435\":1,\"438\":1,\"474\":1,\"477\":1,\"481\":2,\"491\":1,\"499\":3,\"506\":4,\"546\":1,\"547\":2,\"548\":2,\"556\":11,\"558\":1,\"559\":2,\"565\":2,\"580\":2,\"581\":1,\"585\":1,\"672\":1,\"673\":1,\"684\":2}}],[\"values\",{\"1\":{\"69\":1,\"70\":1,\"553\":1,\"554\":1,\"578\":1}}],[\"validatetoken\",{\"1\":{\"316\":1,\"317\":1}}],[\"validate\",{\"1\":{\"70\":2}}],[\"validator\",{\"1\":{\"70\":3}}],[\"validation\",{\"1\":{\"69\":1,\"70\":1}}],[\"valid\",{\"1\":{\"69\":1,\"70\":3}}],[\"v1\",{\"1\":{\"68\":3,\"70\":2,\"71\":1,\"403\":1}}],[\"v2ray\",{\"1\":{\"61\":1,\"69\":1,\"70\":2}}],[\"v2rayng\",{\"1\":{\"70\":1}}],[\"v2rayn\",{\"1\":{\"60\":1}}],[\"vlesslink\",{\"1\":{\"71\":4}}],[\"vless+ws+tls\",{\"1\":{\"69\":1}}],[\"vless+ws+tls节点配置信息\",{\"1\":{\"69\":1}}],[\"vless+ws+tls节点\",{\"1\":{\"69\":2}}],[\"vless+ws节点\",{\"1\":{\"69\":2}}],[\"vlessheader\",{\"1\":{\"69\":4}}],[\"vlessbuffer\",{\"1\":{\"69\":13}}],[\"vlessresponseheader\",{\"1\":{\"69\":13}}],[\"vlessversion\",{\"1\":{\"69\":3}}],[\"vlessoverwshandler\",{\"1\":{\"69\":2}}],[\"vlessconfig\",{\"1\":{\"69\":2}}],[\"vless节点怎么在clash当中分流使用\",{\"1\":{\"63\":1}}],[\"vless\",{\"1\":{\"53\":1,\"57\":1,\"60\":1,\"63\":1,\"69\":5}}],[\"且线程池内的阻塞队列已满\",{\"1\":{\"713\":1}}],[\"且线程池内的阻塞队列未满\",{\"1\":{\"713\":1}}],[\"且有剩余资源\",{\"1\":{\"678\":1}}],[\"且\",{\"1\":{\"556\":1,\"580\":1}}],[\"且最近的2次幂作为\",{\"1\":{\"555\":1}}],[\"且数据总量超过\",{\"1\":{\"553\":1,\"575\":1}}],[\"且数据总量大于等于\",{\"1\":{\"549\":1}}],[\"且执行的是只读命令也返回null\",{\"1\":{\"421\":1}}],[\"且redis6\",{\"1\":{\"400\":1}}],[\"且可以承受数分钟的数据丢失\",{\"1\":{\"384\":1}}],[\"且可以从其他地方重新生成补回的\",{\"1\":{\"384\":1}}],[\"且以它保存的数据为权威\",{\"1\":{\"327\":1}}],[\"且解析前需要遍历\",{\"1\":{\"176\":1}}],[\"且叶子结点本身依关键字的大小自小而大顺序链接\",{\"1\":{\"149\":1}}],[\"且主键的取值不能缺失\",{\"1\":{\"93\":1}}],[\"且速度大于dls\",{\"1\":{\"71\":1}}],[\"且都不可用\",{\"1\":{\"52\":1}}],[\"且请求消息中如果没有host头域会报告一个错误\",{\"1\":{\"33\":1}}],[\"相加后如果信号量\",{\"1\":{\"728\":2}}],[\"相减后如果信号量\",{\"1\":{\"728\":2}}],[\"相等则覆盖旧的\",{\"1\":{\"585\":1}}],[\"相等的对象是否真的相同\",{\"1\":{\"478\":1}}],[\"相关的异常\",{\"1\":{\"531\":1}}],[\"相应的在执行\",{\"1\":{\"651\":1}}],[\"相应的交换器根据接收到的路由键查找匹配的队列\",{\"1\":{\"357\":1}}],[\"相应就大大提高了执行速度\",{\"1\":{\"478\":1}}],[\"相较于单副本而言最大的特点就是主从实例间数据实时同步\",{\"1\":{\"415\":1}}],[\"相反必须一开始调用父类的构造函数\",{\"1\":{\"468\":1}}],[\"相反\",{\"1\":{\"341\":1,\"554\":1,\"578\":1}}],[\"相辅相成\",{\"1\":{\"283\":1}}],[\"相当于创建了两个对象\",{\"1\":{\"488\":1}}],[\"相当于对象\",{\"1\":{\"486\":1}}],[\"相当于访问了该key\",{\"1\":{\"421\":1}}],[\"相当于jdbc中的statement编译\",{\"1\":{\"181\":1}}],[\"相当灵活\",{\"1\":{\"173\":1,\"179\":1}}],[\"相对io读写次数就降低了\",{\"1\":{\"150\":1}}],[\"相同的数组+链表+红黑树结构\",{\"1\":{\"584\":1}}],[\"相同的node数组+链表+红黑树结构\",{\"1\":{\"546\":1}}],[\"相同的情况下再根据equals\",{\"1\":{\"480\":1}}],[\"相同情况下使用stirngbuilder\",{\"1\":{\"481\":1}}],[\"相同数据集的数据而言aof文件要远大于rdb文件\",{\"1\":{\"383\":1}}],[\"相同点\",{\"1\":{\"175\":1,\"406\":1}}],[\"相同\",{\"0\":{\"634\":1,\"702\":1},\"1\":{\"52\":1}}],[\"相比synchronized\",{\"1\":{\"648\":1,\"707\":1}}],[\"相比较于基本类型而言\",{\"1\":{\"493\":1}}],[\"相比使用stringbuffer\",{\"1\":{\"481\":1}}],[\"相比提供了更好的性能\",{\"1\":{\"447\":1}}],[\"相比之下b+tree效率更高\",{\"1\":{\"149\":1}}],[\"相比b\",{\"1\":{\"149\":1}}],[\"相比\",{\"1\":{\"36\":1,\"179\":1}}],[\"附近的人\",{\"1\":{\"382\":1}}],[\"附加信息长度\",{\"1\":{\"69\":1,\"70\":1}}],[\"附\",{\"1\":{\"52\":1,\"386\":1}}],[\"附一张形象的图片\",{\"1\":{\"38\":1}}],[\"自适应自旋锁\",{\"1\":{\"661\":1}}],[\"自旋锁\",{\"1\":{\"661\":1}}],[\"自旋锁等方法使用各种场景\",{\"1\":{\"654\":1}}],[\"自旋cas\",{\"1\":{\"645\":1}}],[\"自旋方式获取同步状态\",{\"1\":{\"612\":1}}],[\"自旋获取同步状态\",{\"1\":{\"612\":1}}],[\"自旋获取锁\",{\"1\":{\"547\":1}}],[\"自旋\",{\"1\":{\"610\":1}}],[\"自反性\",{\"1\":{\"476\":1}}],[\"自主可控性高\",{\"1\":{\"418\":1}}],[\"自行评估自己的项目的读数据业务逻辑的耗时\",{\"1\":{\"391\":1}}],[\"自行搭建\",{\"1\":{\"71\":3}}],[\"自kafka\",{\"1\":{\"339\":1}}],[\"自动拆箱\",{\"1\":{\"494\":1}}],[\"自动将基本数据类型转化为对应的封装类型\",{\"1\":{\"494\":1}}],[\"自动装箱\",{\"1\":{\"494\":1}}],[\"自动装配有什么局限\",{\"0\":{\"279\":1}}],[\"自动装配\",{\"1\":{\"278\":1}}],[\"自动装配的不同模式\",{\"1\":{\"278\":1}}],[\"自动进行无用内存回收操作\",{\"1\":{\"443\":1}}],[\"自动配置\",{\"1\":{\"304\":1}}],[\"自动解析\",{\"1\":{\"278\":1}}],[\"自动添加优选域名和优选ip\",{\"0\":{\"56\":1}}],[\"自定义同步器在实现时只需要实现共享资源\",{\"1\":{\"680\":1}}],[\"自定义同步器时需要重写下面几个aqs提供的模板方法\",{\"1\":{\"678\":1}}],[\"自定义线程池就需要我们自己配置最大线程数\",{\"1\":{\"675\":1}}],[\"自定义子类使用aqs提供的模板方法就可以实现自己的同步语义\",{\"1\":{\"609\":1}}],[\"自定义工具类\",{\"0\":{\"312\":1}}],[\"自定义编解码器\",{\"1\":{\"244\":1}}],[\"自定义协议\",{\"1\":{\"242\":1}}],[\"自定义消息格式\",{\"1\":{\"212\":1}}],[\"自定义的域名\",{\"1\":{\"69\":4}}],[\"自然就没有线程安全方面的问题了\",{\"1\":{\"704\":1}}],[\"自然的想到用一个map来保存\",{\"1\":{\"229\":1}}],[\"自然id就可以重复\",{\"1\":{\"185\":1,\"191\":1}}],[\"自然而然\",{\"1\":{\"128\":1}}],[\"自增主键是连续的\",{\"1\":{\"158\":1}}],[\"自制\",{\"1\":{\"52\":1}}],[\"自己的数据会清空\",{\"1\":{\"423\":1}}],[\"自己本地写库要\",{\"1\":{\"347\":1}}],[\"自己实现encode与decode\",{\"1\":{\"243\":1}}],[\"自己发\",{\"1\":{\"13\":2}}],[\"自己收\",{\"1\":{\"13\":2}}],[\"腾讯\",{\"1\":{\"52\":1}}],[\"z55887\",{\"1\":{\"723\":1}}],[\"zycxnanwang\",{\"1\":{\"685\":1}}],[\"zl1zl2zl3\",{\"1\":{\"618\":1}}],[\"z\",{\"1\":{\"476\":2}}],[\"zset\",{\"1\":{\"376\":1,\"438\":1}}],[\"zet等类型\",{\"1\":{\"438\":1}}],[\"zeroingtoone\",{\"1\":{\"599\":1}}],[\"zero\",{\"0\":{\"341\":1},\"1\":{\"329\":1,\"559\":1}}],[\"zen\",{\"1\":{\"52\":1}}],[\"zk\",{\"1\":{\"432\":1}}],[\"zk是cp\",{\"1\":{\"374\":1}}],[\"zk还会根据minsessiontimeout与maxsessiontimeout两个参数重新调整最后的超时值\",{\"1\":{\"251\":1}}],[\"zkserviceregister\",{\"1\":{\"251\":4}}],[\"zkserver\",{\"1\":{\"251\":1}}],[\"zoo\",{\"1\":{\"251\":2}}],[\"zookeeper是有状态的\",{\"1\":{\"363\":1}}],[\"zookeeper的作用是什么\",{\"0\":{\"327\":1}}],[\"zookeeper的地址固定\",{\"1\":{\"251\":1}}],[\"zookeeper根路径节点\",{\"1\":{\"251\":1}}],[\"zookeeper服务注册接口的实现类\",{\"1\":{\"251\":1}}],[\"zookeeper客户端测试如下\",{\"1\":{\"251\":1}}],[\"zookeeper\",{\"1\":{\"251\":2,\"327\":1,\"431\":1,\"432\":2}}],[\"zookeeper我们可以近似看作一个树形目录文件系统\",{\"1\":{\"250\":1}}],[\"zookeeper安装\",{\"1\":{\"249\":1}}],[\"zookeeper监听服务提供者状态\",{\"1\":{\"212\":1}}],[\"zookeeper作为注册中心\",{\"1\":{\"212\":1}}],[\"zol\",{\"1\":{\"70\":2}}],[\"zipcode=\",{\"1\":{\"156\":1}}],[\"zipcode\",{\"1\":{\"156\":1}}],[\"zishi\",{\"1\":{\"70\":1}}],[\"zizifn\",{\"1\":{\"69\":1,\"70\":1}}],[\"zzzgydi\",{\"1\":{\"68\":3}}],[\"zhenai\",{\"1\":{\"505\":1}}],[\"zhaopin\",{\"1\":{\"70\":2}}],[\"zhang\",{\"1\":{\"70\":1}}],[\"zhangzishi\",{\"1\":{\"70\":2}}],[\"zhibo8\",{\"1\":{\"70\":2}}],[\"zhihu\",{\"1\":{\"70\":2}}],[\"zh\",{\"1\":{\"32\":1}}],[\"阿里巴巴java开发手册\",{\"1\":{\"526\":1}}],[\"阿里巴巴\",{\"1\":{\"493\":1}}],[\"阿里云\",{\"1\":{\"57\":1}}],[\"阿里\",{\"1\":{\"52\":1,\"123\":1}}],[\"八股二\",{\"0\":{\"50\":1}}],[\"八股一\",{\"0\":{\"49\":1}}],[\"面试官\",{\"1\":{\"583\":1}}],[\"面试官可以扩展提问\",{\"1\":{\"445\":1}}],[\"面试\",{\"1\":{\"545\":1,\"585\":1}}],[\"面试题\",{\"0\":{\"320\":1,\"344\":1,\"375\":1,\"545\":1,\"722\":1},\"1\":{\"545\":1}}],[\"面对突然到来的高并发\",{\"1\":{\"345\":1}}],[\"面经\",{\"1\":{\"49\":1,\"50\":1}}],[\"面向过程\",{\"1\":{\"463\":1}}],[\"面向对象和面向过程的区别\",{\"0\":{\"463\":1}}],[\"面向对象\",{\"0\":{\"462\":1},\"1\":{\"442\":1,\"463\":1}}],[\"面向对象编程\",{\"1\":{\"283\":1}}],[\"面向切面编程\",{\"1\":{\"283\":1}}],[\"面向切面的编程\",{\"1\":{\"263\":1}}],[\"面向无连接\",{\"1\":{\"10\":1}}],[\"面向字节流\",{\"1\":{\"9\":1}}],[\"面向报文\",{\"1\":{\"9\":1}}],[\"面向连接\",{\"1\":{\"9\":1}}],[\"备注秋招\",{\"1\":{\"47\":1}}],[\"秋招求职交流群持续开放\",{\"1\":{\"47\":1}}],[\"还可获取执行结果\",{\"1\":{\"621\":1,\"688\":1}}],[\"还可以用于本地主机进程间通信\",{\"1\":{\"731\":1}}],[\"还可以实现进程间的同步\",{\"1\":{\"731\":1}}],[\"还可以继承其他类\",{\"1\":{\"621\":1,\"688\":1}}],[\"还可以使用collections\",{\"1\":{\"549\":1,\"594\":1}}],[\"还可以使用\",{\"1\":{\"435\":1}}],[\"还知道哪些hash算法\",{\"1\":{\"560\":1}}],[\"还包括声明异常和拋出异常\",{\"1\":{\"532\":1}}],[\"还包含语句所执行的消耗的时间\",{\"1\":{\"108\":1}}],[\"还没有跟任何实例关联上\",{\"1\":{\"457\":1}}],[\"还没提交\",{\"1\":{\"332\":1}}],[\"还未来得及执行expire命令\",{\"1\":{\"435\":1}}],[\"还未处理\",{\"1\":{\"332\":1}}],[\"还继续写向旧master的数据可能也丢失了\",{\"1\":{\"423\":1}}],[\"还会占用一定的系统资源\",{\"1\":{\"672\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"668\":1}}],[\"还会进行一项称为自旋锁的优化手段\",{\"1\":{\"661\":1}}],[\"还会创建一个\",{\"1\":{\"646\":1}}],[\"还会发现空间浪费非常大\",{\"1\":{\"555\":1}}],[\"还会执行吗\",{\"0\":{\"536\":1},\"1\":{\"484\":1}}],[\"还会造成一段时间内服务不可用\",{\"1\":{\"416\":1}}],[\"还会产生\",{\"1\":{\"104\":1}}],[\"还能大大降低数据库的压力\",{\"1\":{\"381\":1}}],[\"还支持hash\",{\"1\":{\"376\":1}}],[\"还支持\",{\"1\":{\"353\":1}}],[\"还支持stomp\",{\"1\":{\"352\":1}}],[\"还支持objectserializer\",{\"1\":{\"245\":1}}],[\"还需要在\",{\"1\":{\"347\":1}}],[\"还要加上日志文件的存储和日志邮件的发送\",{\"1\":{\"345\":1}}],[\"还要在硬盘中增加文件类型的日志\",{\"1\":{\"345\":1}}],[\"还跟自己保持联系\",{\"1\":{\"334\":1}}],[\"还算是比较活跃\",{\"1\":{\"126\":1}}],[\"还是在主线程里执行\",{\"1\":{\"635\":1,\"703\":1}}],[\"还是有别的策略来解决这一问题\",{\"1\":{\"614\":1}}],[\"还是存的值就是\",{\"1\":{\"548\":1,\"588\":1}}],[\"还是没有找到对应的key而为\",{\"1\":{\"548\":1,\"588\":1}}],[\"还是解释执行的语言\",{\"1\":{\"445\":1}}],[\"还是queue里的消息都会存在于多个实例上\",{\"1\":{\"361\":1}}],[\"还是分布式的\",{\"1\":{\"350\":1}}],[\"还是需要配合相应的支持\",{\"1\":{\"297\":1}}],[\"还是使用java自带的序列化方式\",{\"1\":{\"223\":1}}],[\"还是数据量太大\",{\"1\":{\"137\":1}}],[\"还是\",{\"0\":{\"324\":1},\"1\":{\"108\":1,\"157\":1,\"516\":1}}],[\"还是客户端的状态\",{\"0\":{\"21\":1}}],[\"还有一次机会\",{\"1\":{\"616\":1}}],[\"还有一个master\",{\"1\":{\"422\":1}}],[\"还有这些问题吗\",{\"1\":{\"563\":1}}],[\"还有编译器\",{\"1\":{\"444\":1}}],[\"还有就是用多个库的存储容量来进行扩容\",{\"1\":{\"128\":1}}],[\"还有\",{\"1\":{\"47\":1,\"399\":1}}],[\"更改与线程\",{\"1\":{\"732\":1}}],[\"更深入的面试问题\",{\"1\":{\"553\":1}}],[\"更重要的\",{\"1\":{\"548\":1,\"590\":1}}],[\"更为严格的说法其实是\",{\"1\":{\"535\":1}}],[\"更稳定\",{\"1\":{\"447\":1}}],[\"更多网络\",{\"1\":{\"401\":1}}],[\"更省空间\",{\"1\":{\"382\":1}}],[\"更加复杂和强大\",{\"1\":{\"681\":1}}],[\"更加易于维护\",{\"1\":{\"463\":1}}],[\"更加耗时\",{\"1\":{\"342\":1}}],[\"更加适合目前前后端分离的架构下\",{\"1\":{\"294\":1}}],[\"更加直白的理解\",{\"1\":{\"98\":1}}],[\"更通俗的说\",{\"1\":{\"146\":1}}],[\"更新请求会陆陆续续\",{\"1\":{\"430\":1}}],[\"更新数据的时候\",{\"1\":{\"392\":1}}],[\"更新数据库表中数据\",{\"1\":{\"146\":1}}],[\"更新操作时提供\",{\"1\":{\"684\":1}}],[\"更新操作\",{\"1\":{\"390\":1,\"391\":2}}],[\"更新\",{\"1\":{\"335\":2}}],[\"更新客户端得到服务器的方式\",{\"1\":{\"251\":1}}],[\"更新客户端缓存\",{\"1\":{\"212\":1}}],[\"更新一个新的服务接口样例和pojo类\",{\"1\":{\"230\":1}}],[\"更新前的工作\",{\"1\":{\"230\":1}}],[\"更新4\",{\"1\":{\"223\":1}}],[\"更新3\",{\"1\":{\"223\":1,\"230\":1}}],[\"更新2\",{\"1\":{\"223\":1,\"230\":1,\"251\":1}}],[\"更新1\",{\"1\":{\"223\":1,\"230\":1,\"251\":1}}],[\"更新少的数据可以考虑\",{\"1\":{\"142\":1}}],[\"更新的数据\",{\"1\":{\"103\":1}}],[\"更新语句执行会复杂一点\",{\"1\":{\"99\":1}}],[\"更文不易\",{\"1\":{\"47\":1}}],[\"更无法进入\",{\"1\":{\"12\":1}}],[\"加入队列后\",{\"1\":{\"679\":1}}],[\"加入队列的时机\",{\"0\":{\"606\":1}}],[\"加入等待队列\",{\"1\":{\"607\":1}}],[\"加入了消息队列\",{\"1\":{\"349\":1}}],[\"加快字符串处理速度\",{\"1\":{\"482\":1}}],[\"加的锁\",{\"1\":{\"435\":1}}],[\"加的锁还没有执行完成\",{\"1\":{\"435\":1}}],[\"加几百ms即可\",{\"1\":{\"391\":1}}],[\"加分点\",{\"1\":{\"339\":1}}],[\"加载类则是回调\",{\"1\":{\"507\":1}}],[\"加载类路径\",{\"1\":{\"195\":1}}],[\"加载\",{\"1\":{\"506\":1}}],[\"加载数据库的驱动程序\",{\"1\":{\"506\":1}}],[\"加载mysql的驱动类\",{\"1\":{\"502\":1}}],[\"加载速度快\",{\"1\":{\"384\":1}}],[\"加载后才可以调用getproperties\",{\"1\":{\"195\":1}}],[\"加载配置文件\",{\"1\":{\"195\":1}}],[\"加载stream流\",{\"1\":{\"195\":1}}],[\"加载驱动\",{\"1\":{\"172\":1}}],[\"加大了系统的整个吞吐量\",{\"1\":{\"116\":1}}],[\"加锁过程\",{\"1\":{\"604\":1}}],[\"加锁时加\",{\"1\":{\"435\":1}}],[\"加锁\",{\"1\":{\"434\":1,\"549\":1,\"615\":1}}],[\"加锁解锁必须由同一台服务器进行\",{\"1\":{\"431\":1}}],[\"加锁更加精确\",{\"1\":{\"120\":1}}],[\"加锁快\",{\"1\":{\"114\":1}}],[\"加锁慢\",{\"1\":{\"114\":1}}],[\"加密后的密码\",{\"1\":{\"95\":1}}],[\"加密流程按图中的序号分为\",{\"1\":{\"37\":1}}],[\"加上消息长度\",{\"1\":{\"244\":1}}],[\"加上\",{\"1\":{\"61\":1}}],[\"加权轮询\",{\"1\":{\"46\":1}}],[\"能和\",{\"1\":{\"718\":1}}],[\"能根据\",{\"1\":{\"477\":1}}],[\"能否创建一个包含可变对象的不可变对象\",{\"0\":{\"473\":1}}],[\"能拿到锁\",{\"1\":{\"436\":1}}],[\"能有效的解决数据误操作和数据异常丢失的问题\",{\"1\":{\"415\":1}}],[\"能实现一个简单的消息队列系统\",{\"1\":{\"381\":1}}],[\"能够实现真正的并发访问\",{\"1\":{\"584\":1}}],[\"能够实现故障自动failover\",{\"1\":{\"417\":1}}],[\"能够运行时动态获取类的实例\",{\"1\":{\"502\":1}}],[\"能够解决redis主从模式下的高可用切换问题\",{\"1\":{\"416\":1}}],[\"能够在主库出现故障时自动进行主备切换\",{\"1\":{\"415\":1}}],[\"能够保存内存的key一旦过期就能立即从内存中删除\",{\"1\":{\"386\":1}}],[\"能够保证严格的消息顺序\",{\"1\":{\"362\":1}}],[\"能够提供高可用服务\",{\"1\":{\"378\":1}}],[\"能够与\",{\"1\":{\"179\":1}}],[\"能够与spring很好的集成\",{\"1\":{\"173\":1}}],[\"能很好地利用session或者cookie\",{\"1\":{\"46\":1}}],[\"能互相分担负载\",{\"1\":{\"46\":1}}],[\"能保证数据的可靠性交付\",{\"1\":{\"10\":1}}],[\"负数表示失败\",{\"1\":{\"678\":1}}],[\"负载告警\",{\"1\":{\"720\":1}}],[\"负载因子是\",{\"1\":{\"564\":1}}],[\"负载因子越大\",{\"1\":{\"554\":1,\"578\":1}}],[\"负载因子\",{\"1\":{\"554\":1,\"578\":1}}],[\"负载均衡选择了\",{\"1\":{\"258\":1}}],[\"负载均衡接口\",{\"1\":{\"258\":1}}],[\"负载均衡的策略的实现\",{\"1\":{\"212\":1}}],[\"负载均衡\",{\"1\":{\"209\":1,\"256\":1,\"310\":1}}],[\"负载均衡算法有哪些\",{\"0\":{\"46\":1}}],[\"负责构造自己这部分的构造\",{\"1\":{\"468\":1}}],[\"负责监控redis\",{\"1\":{\"419\":1}}],[\"负责监听与发送数据\",{\"1\":{\"237\":1}}],[\"负责从broker上拉取消息进行消费\",{\"1\":{\"363\":1}}],[\"负责从master上拉取\",{\"1\":{\"132\":1}}],[\"负责收发消息\",{\"1\":{\"363\":1}}],[\"负责发消息到broker\",{\"1\":{\"363\":1}}],[\"负责均匀的将一个\",{\"1\":{\"323\":1}}],[\"负责协调\",{\"1\":{\"291\":1}}],[\"负责协调各个组件工作\",{\"1\":{\"291\":1}}],[\"负责重定向时\",{\"1\":{\"291\":1}}],[\"负责为请求找到合适的\",{\"1\":{\"291\":1}}],[\"负责将传入的对象序列化成字节数组\",{\"1\":{\"244\":1}}],[\"负责与服务端的通信\",{\"1\":{\"237\":1}}],[\"负责在网络中的两节点之间建立\",{\"1\":{\"8\":1}}],[\"尖括号\",{\"1\":{\"45\":1}}],[\"避免资源浪费就应该要退出\",{\"1\":{\"712\":1}}],[\"避免反复加锁和释放锁\",{\"1\":{\"660\":1}}],[\"避免字符的重复创建\",{\"1\":{\"487\":1}}],[\"避免安全问题\",{\"1\":{\"482\":1}}],[\"避免死锁\",{\"1\":{\"436\":1}}],[\"避免产生big\",{\"1\":{\"417\":1}}],[\"避免产生hot\",{\"1\":{\"417\":1}}],[\"避免阻塞单线程的事件循环\",{\"1\":{\"400\":1}}],[\"避免同步机制的开销\",{\"1\":{\"399\":1}}],[\"避免过多的上下文切换开销\",{\"1\":{\"399\":1}}],[\"避免在用户请求的时候\",{\"1\":{\"397\":1}}],[\"避免相同的过期时间导致缓存雪崩\",{\"1\":{\"396\":1}}],[\"避免中间的多次拷贝\",{\"1\":{\"341\":1}}],[\"避免了线程安全问题\",{\"1\":{\"663\":1}}],[\"避免了多个线程之间线程切换和锁资源争用的开销\",{\"1\":{\"377\":1}}],[\"避免了几乎所有的\",{\"1\":{\"172\":1}}],[\"避免了在服务器\",{\"1\":{\"42\":1}}],[\"避免使用select\",{\"1\":{\"138\":1}}],[\"避免sql注入的一些方法\",{\"1\":{\"45\":1}}],[\"传来传去\",{\"1\":{\"727\":1}}],[\"传递请求\",{\"1\":{\"543\":1}}],[\"传递给一个接受list\",{\"0\":{\"514\":1}}],[\"传递性\",{\"1\":{\"476\":1}}],[\"传递的是值的引用\",{\"1\":{\"474\":1}}],[\"传递的是值的拷贝\",{\"1\":{\"474\":1}}],[\"传递的参数是按引用进行传递\",{\"1\":{\"474\":1}}],[\"传递的参数是按值的拷贝传递\",{\"1\":{\"474\":1}}],[\"传递参数是通过类的属性\",{\"1\":{\"299\":1}}],[\"传递参数是通过方法形参\",{\"1\":{\"299\":1}}],[\"传递下去\",{\"1\":{\"194\":1}}],[\"传给\",{\"1\":{\"290\":1}}],[\"传给服务器id\",{\"1\":{\"216\":1}}],[\"传统的bio与线程池网络传输性能低\",{\"1\":{\"233\":1}}],[\"传一个id给服务端\",{\"1\":{\"215\":1}}],[\"传\",{\"1\":{\"181\":1}}],[\"传入新的容量\",{\"1\":{\"558\":1,\"581\":1}}],[\"传入beanfactory对象的实例\",{\"1\":{\"274\":1}}],[\"传入bean的名字\",{\"1\":{\"274\":1}}],[\"传入classloader对象的实例\",{\"1\":{\"274\":1}}],[\"传入connection对象\",{\"1\":{\"201\":1}}],[\"传入的数据为request或者response\",{\"1\":{\"244\":1}}],[\"传入不同的client\",{\"1\":{\"237\":1}}],[\"传入参数service接口的class对象\",{\"1\":{\"223\":1}}],[\"传入参数是以字符串传入\",{\"1\":{\"181\":1}}],[\"传入sql语句\",{\"1\":{\"201\":1}}],[\"传入sqlsession与mapperinferface\",{\"1\":{\"200\":1}}],[\"传入preparedstatement对象\",{\"1\":{\"201\":1}}],[\"传入非法参数\",{\"1\":{\"45\":1}}],[\"传输结束以后\",{\"1\":{\"519\":1}}],[\"传输确认及发布确认等\",{\"1\":{\"352\":1}}],[\"传输的消息分为request与response\",{\"1\":{\"244\":1}}],[\"传输id给服务端\",{\"1\":{\"216\":1}}],[\"传输安全\",{\"1\":{\"69\":2}}],[\"传输协议\",{\"1\":{\"69\":4}}],[\"传输数据\",{\"1\":{\"29\":1}}],[\"传输实体主体\",{\"1\":{\"29\":1}}],[\"传输\",{\"1\":{\"18\":1}}],[\"传输方式\",{\"1\":{\"9\":1}}],[\"传输速度\",{\"1\":{\"9\":1}}],[\"恶意拼接查询\",{\"1\":{\"45\":1}}],[\"点左右午饭时的流量比吗\",{\"1\":{\"718\":1}}],[\"点赞\",{\"1\":{\"381\":1}}],[\"点赞鼓励下呗~我将持续输出干货\",{\"1\":{\"47\":1}}],[\"点击下载>>\",{\"1\":{\"64\":1,\"65\":1}}],[\"点击自定义域\",{\"1\":{\"61\":1}}],[\"点\",{\"1\":{\"45\":1}}],[\"注销以及属性变更\",{\"1\":{\"327\":1}}],[\"注册到注册中心\",{\"1\":{\"251\":1}}],[\"注册\",{\"1\":{\"251\":1}}],[\"注册中心\",{\"1\":{\"250\":1,\"253\":1}}],[\"注册mapper时调用传入\",{\"1\":{\"200\":1}}],[\"注册类\",{\"1\":{\"200\":1}}],[\"注解从请求的\",{\"1\":{\"296\":1}}],[\"注解的条件\",{\"1\":{\"308\":1}}],[\"注解的\",{\"1\":{\"297\":1}}],[\"注解的参数从请求携带的参数中获取\",{\"1\":{\"296\":1}}],[\"注解的不同之处在哪里\",{\"0\":{\"295\":1}}],[\"注解的方法\",{\"1\":{\"292\":1}}],[\"注解\",{\"1\":{\"293\":1,\"294\":2,\"297\":2,\"306\":1}}],[\"注解这种方式以外\",{\"1\":{\"292\":1}}],[\"注解标记一个类为\",{\"1\":{\"292\":1}}],[\"注解标注\",{\"1\":{\"271\":1}}],[\"注解有什么用\",{\"0\":{\"292\":1,\"293\":1}}],[\"注解将方法作为一个处理器等\",{\"1\":{\"291\":1}}],[\"注解自动装配的\",{\"1\":{\"271\":1}}],[\"注解自动装配\",{\"1\":{\"271\":1}}],[\"注解扮演与\",{\"1\":{\"268\":1}}],[\"注解或\",{\"1\":{\"264\":1}}],[\"注解内的参数名为传递到mapper中的参数名\",{\"1\":{\"183\":1}}],[\"注解等都会导致缓存的不命中\",{\"1\":{\"88\":1,\"99\":1}}],[\"注入\",{\"0\":{\"267\":1},\"1\":{\"181\":1,\"265\":2,\"267\":1,\"308\":1}}],[\"注入就是在用户输入的字符串中加入\",{\"1\":{\"45\":1}}],[\"注意这里的第二个线程只是申请锁\",{\"1\":{\"657\":1}}],[\"注意此时实例变量table是空的\",{\"1\":{\"566\":1}}],[\"注意此时客户端到\",{\"1\":{\"16\":1}}],[\"注意\",{\"1\":{\"69\":4,\"140\":1,\"151\":1,\"202\":1,\"284\":1,\"339\":1,\"356\":1,\"377\":1,\"449\":1,\"451\":2,\"486\":1,\"569\":1,\"598\":1,\"617\":1,\"717\":1}}],[\"注\",{\"1\":{\"69\":2,\"70\":4,\"71\":2,\"565\":1,\"623\":1,\"690\":1}}],[\"转化为二进制必定是11111\",{\"1\":{\"555\":1}}],[\"转化为中文描述就是\",{\"1\":{\"391\":1}}],[\"转化为一致的unchecked\",{\"1\":{\"263\":1}}],[\"转换\",{\"1\":{\"291\":1}}],[\"转换翻译\",{\"1\":{\"8\":1}}],[\"转而执行mappedstatement所代表的sql\",{\"1\":{\"182\":1}}],[\"转几次账\",{\"1\":{\"74\":1}}],[\"转义处理\",{\"1\":{\"45\":1}}],[\"转义\",{\"1\":{\"44\":1}}],[\"导致线程异常结束\",{\"1\":{\"640\":1}}],[\"导致插入失败\",{\"1\":{\"595\":1}}],[\"导致a\",{\"1\":{\"564\":1}}],[\"导致了e指向了节点b\",{\"1\":{\"564\":1}}],[\"导致\",{\"1\":{\"560\":1}}],[\"导致网卡撑爆\",{\"1\":{\"417\":1}}],[\"导致主库节点成为系统的短板\",{\"1\":{\"417\":1}}],[\"导致极端情况下的主库内存溢出\",{\"1\":{\"415\":1}}],[\"导致数据库压力巨大\",{\"1\":{\"396\":1}}],[\"导致数据库移植性差\",{\"1\":{\"173\":1,\"180\":1}}],[\"导致用户每次请求该数据都要去数据库中查询一遍\",{\"1\":{\"395\":1}}],[\"导致的数据丢失一个常见的场景就是\",{\"1\":{\"334\":1}}],[\"导致的消息丢失\",{\"0\":{\"334\":1}}],[\"导致这个提供者压力巨大\",{\"1\":{\"254\":1}}],[\"导致索引失效\",{\"0\":{\"164\":1}}],[\"导致事务\",{\"1\":{\"103\":1}}],[\"导致小明余额减少而小红的余额没有增加\",{\"1\":{\"100\":1}}],[\"导致io操作变多\",{\"1\":{\"80\":1}}],[\"导致恶意代码的执行\",{\"1\":{\"44\":1}}],[\"导致目标系统运行缓慢\",{\"1\":{\"14\":1}}],[\"肉鸡\",{\"1\":{\"43\":1}}],[\"建索引的原则有哪些\",{\"0\":{\"161\":1}}],[\"建议选择\",{\"1\":{\"447\":1}}],[\"建议升级到最新版本\",{\"1\":{\"415\":1}}],[\"建议是rdb和aof都开启\",{\"1\":{\"384\":1}}],[\"建议先掌握其相关概念再上手代码\",{\"1\":{\"206\":1}}],[\"建议只使用vless+ws节点即可\",{\"1\":{\"69\":1}}],[\"建议采用共享\",{\"1\":{\"42\":1}}],[\"建立公共溢出区\",{\"1\":{\"576\":2}}],[\"建立连接connection\",{\"1\":{\"357\":1,\"358\":1}}],[\"建立连接\",{\"1\":{\"251\":1}}],[\"建立socket连接\",{\"1\":{\"216\":1}}],[\"建立\",{\"1\":{\"38\":2,\"154\":1,\"161\":1,\"198\":1}}],[\"保持整个集群所有节点的数据是完整的\",{\"1\":{\"430\":1}}],[\"保持列\",{\"1\":{\"161\":1}}],[\"保护\",{\"0\":{\"309\":1}}],[\"保证顺序执行\",{\"1\":{\"672\":1}}],[\"保证所有任务按照指定顺序\",{\"1\":{\"672\":1}}],[\"保证共享变量的修改能够及时可见\",{\"1\":{\"650\":1}}],[\"保证共享资源在同一时刻只能被一个线程访问\",{\"1\":{\"431\":1}}],[\"保证变量的修改可见性和原子性\",{\"1\":{\"646\":1}}],[\"保证操作的内存可见性\",{\"1\":{\"646\":1}}],[\"保证的是对一个变量执行操作的原子性\",{\"1\":{\"645\":1}}],[\"保证线程安全\",{\"1\":{\"549\":1}}],[\"保证线程安全机制\",{\"1\":{\"549\":1,\"591\":1}}],[\"保证能获取成功\",{\"1\":{\"547\":1}}],[\"保证了变量的可见性\",{\"1\":{\"646\":1}}],[\"保证了多线程环境下数据获取时的可见性\",{\"1\":{\"546\":1}}],[\"保证了hashcode的唯一性\",{\"1\":{\"482\":1}}],[\"保证了事务\",{\"1\":{\"112\":1}}],[\"保证服务平稳运行\",{\"1\":{\"415\":1}}],[\"保证redis缓存的高可用\",{\"1\":{\"396\":1}}],[\"保证数据不会在同一时间大面积失效\",{\"1\":{\"396\":1}}],[\"保证数据的安全\",{\"1\":{\"130\":1}}],[\"保证多用户环境下保证数据库完整性和一致性\",{\"1\":{\"113\":1}}],[\"保障分发到每一个服务器的响应结果都一致\",{\"1\":{\"42\":1}}],[\"保存参数至临时存储\",{\"1\":{\"291\":1}}],[\"保存服务与地址\",{\"1\":{\"251\":1}}],[\"保存了未提交之前的版本数据\",{\"1\":{\"107\":1}}],[\"保存的数据不能超过\",{\"1\":{\"41\":1}}],[\"保存在服务器端\",{\"1\":{\"41\":1}}],[\"保存在客户端\",{\"1\":{\"41\":1}}],[\"来满足业务的需求\",{\"1\":{\"676\":1}}],[\"来保证的\",{\"1\":{\"650\":1}}],[\"来保证线程的安全性\",{\"1\":{\"572\":1}}],[\"来更新\",{\"1\":{\"644\":1}}],[\"来申请锁\",{\"1\":{\"627\":1,\"694\":1}}],[\"来唤醒被挂起的线程\",{\"1\":{\"617\":1}}],[\"来将\",{\"1\":{\"617\":1}}],[\"来验证我们的假设是否成立\",{\"1\":{\"548\":1,\"588\":1}}],[\"来获得同步支持\",{\"1\":{\"546\":1}}],[\"来进行捕获\",{\"1\":{\"530\":2}}],[\"来代替\",{\"1\":{\"515\":1}}],[\"来操作这些信息\",{\"1\":{\"505\":1}}],[\"来确定\",{\"1\":{\"491\":1}}],[\"来定义\",{\"1\":{\"490\":1}}],[\"来不及显式地释放锁\",{\"1\":{\"434\":1}}],[\"来hold连接\",{\"1\":{\"367\":1}}],[\"来修复高水位值的弊端\",{\"1\":{\"339\":1}}],[\"来尽量避免消息丢失\",{\"1\":{\"334\":1}}],[\"来处理\",{\"1\":{\"333\":1}}],[\"来拉取数据\",{\"1\":{\"323\":1}}],[\"来动态代理目标类\",{\"1\":{\"284\":1}}],[\"来实现这个机制\",{\"1\":{\"648\":1,\"707\":1}}],[\"来实现通用\",{\"1\":{\"510\":1}}],[\"来实现的\",{\"1\":{\"443\":1,\"617\":1}}],[\"来实现\",{\"1\":{\"268\":1,\"661\":1}}],[\"来描述\",{\"1\":{\"268\":1}}],[\"来一个任务\",{\"1\":{\"230\":1}}],[\"来连接数据库\",{\"1\":{\"179\":1}}],[\"来判断索引是否符合条件\",{\"1\":{\"156\":1}}],[\"来判断数据是否符合条件\",{\"1\":{\"156\":1}}],[\"来分\",{\"1\":{\"128\":2}}],[\"来分表\",{\"1\":{\"121\":1}}],[\"来说明反射机制的强大之处\",{\"1\":{\"506\":1}}],[\"来说\",{\"1\":{\"127\":1,\"399\":1}}],[\"来使域名使用tls节点\",{\"1\":{\"67\":1}}],[\"来使主机a控制发送的数据量\",{\"1\":{\"22\":1}}],[\"来统一管理\",{\"1\":{\"42\":1}}],[\"共用的判断条件\",{\"1\":{\"732\":1}}],[\"共\",{\"1\":{\"449\":1}}],[\"共有四种方案\",{\"1\":{\"389\":1}}],[\"共同完成的\",{\"1\":{\"620\":1,\"687\":1}}],[\"共同关注什么的功能实现特别方便\",{\"1\":{\"382\":1}}],[\"共同好友等是社交网站的基本功能\",{\"1\":{\"381\":1}}],[\"共同点\",{\"1\":{\"28\":1}}],[\"共性抽取出来\",{\"1\":{\"237\":1}}],[\"共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销\",{\"1\":{\"731\":1}}],[\"共享内存的机制\",{\"1\":{\"727\":1}}],[\"共享内存\",{\"0\":{\"727\":1,\"734\":1},\"1\":{\"730\":1}}],[\"共享方式\",{\"1\":{\"678\":2}}],[\"共享数据的锁定状态持续时间较短\",{\"1\":{\"661\":1}}],[\"共享式同步状态释放\",{\"0\":{\"613\":1}}],[\"共享式同步状态获取\",{\"0\":{\"612\":1}}],[\"共享式节点\",{\"1\":{\"612\":1}}],[\"共享式获取同步状态的标志是返回\",{\"1\":{\"612\":1}}],[\"共享式获取和释放同步状态\",{\"1\":{\"609\":1}}],[\"共享变量state\",{\"1\":{\"602\":1}}],[\"共享锁都相斥\",{\"1\":{\"115\":1}}],[\"共享锁可以同时加上多个\",{\"1\":{\"115\":1}}],[\"共享锁\",{\"1\":{\"114\":1,\"115\":1,\"601\":2}}],[\"共享\",{\"1\":{\"42\":1,\"680\":1}}],[\"该值默认为\",{\"1\":{\"722\":1}}],[\"该参数可以为空\",{\"1\":{\"714\":1}}],[\"该步骤仅仅完成增加线程\",{\"1\":{\"714\":1}}],[\"该标识指明了该方法是一个同步方法\",{\"1\":{\"651\":1}}],[\"该资源任意一个时刻只由一个线程占用\",{\"1\":{\"626\":1,\"693\":1}}],[\"该链为链表\",{\"1\":{\"556\":1}}],[\"该异常对象包含异常名称\",{\"1\":{\"537\":1}}],[\"该异常经常被称为强制类型转换异常\",{\"1\":{\"534\":1}}],[\"该动作发生在运行期间\",{\"1\":{\"533\":1}}],[\"该接口中定义了两个抽象方法\",{\"1\":{\"522\":1}}],[\"该成员的类型是一个泛型类型\",{\"1\":{\"511\":1}}],[\"该字段才会使用\",{\"1\":{\"603\":1}}],[\"该字段都占用\",{\"1\":{\"95\":1}}],[\"该字符串在内存中存放位置\",{\"1\":{\"486\":1}}],[\"该对象又不需要被回收了\",{\"1\":{\"454\":1}}],[\"该对象被回收的时候被调用\",{\"1\":{\"454\":1}}],[\"该线程会退出\",{\"1\":{\"712\":1}}],[\"该线程会执行以下两个重要操作\",{\"1\":{\"653\":1}}],[\"该线程是否正在独占资源\",{\"1\":{\"678\":1}}],[\"该线程结束生命周期\",{\"1\":{\"623\":1,\"690\":1}}],[\"该线程抢锁失败\",{\"1\":{\"434\":1}}],[\"该线程成功得到了锁\",{\"1\":{\"434\":1}}],[\"该线程在master打开一个普通连接\",{\"1\":{\"132\":1}}],[\"该工具可以帮助我们定位到数据不一致的错误\",{\"1\":{\"407\":1}}],[\"该设计有如下特点\",{\"1\":{\"404\":1}}],[\"该数据永远都是脏数据\",{\"1\":{\"390\":1}}],[\"该数据的默认值\",{\"1\":{\"87\":1}}],[\"该方法不考虑线程池是在哪个阶段增加的该线程\",{\"1\":{\"714\":1}}],[\"该方法的功能就是增加一个线程\",{\"1\":{\"714\":1}}],[\"该方法中又调用了另一个需要相同锁的方法\",{\"1\":{\"648\":1,\"707\":1}}],[\"该方法继承于aqs\",{\"1\":{\"615\":1}}],[\"该方法同样是先调用自定义同步器自定义的tryrelease\",{\"1\":{\"611\":1}}],[\"该方法必须要保证线程安全的获取同步状态\",{\"1\":{\"610\":1}}],[\"该方法自定义同步组件自己实现\",{\"1\":{\"610\":1}}],[\"该方法为独占式获取同步状态\",{\"1\":{\"610\":1}}],[\"该方法保证线程安全的获取同步状态\",{\"1\":{\"605\":1}}],[\"该方法底层使用sendfile实现了zero\",{\"1\":{\"341\":1}}],[\"该方案也会出问题\",{\"1\":{\"390\":1}}],[\"该broker上的所有leader副本都会下线\",{\"1\":{\"340\":1}}],[\"该bean仅在当前http\",{\"1\":{\"269\":1}}],[\"该username\",{\"1\":{\"316\":1}}],[\"该作用域仅在基于web的spring\",{\"1\":{\"269\":1}}],[\"该元数据可以通过\",{\"1\":{\"264\":1}}],[\"该类将整型数值与引用关联起来\",{\"1\":{\"683\":1}}],[\"该类的构造函数可以传入\",{\"1\":{\"540\":2}}],[\"该类就不能被继承\",{\"1\":{\"470\":1}}],[\"该类策略被激活\",{\"1\":{\"340\":1}}],[\"该类也与其他类不耦合\",{\"1\":{\"203\":1}}],[\"该类与其他类不耦合\",{\"1\":{\"202\":1}}],[\"该类无接口\",{\"1\":{\"200\":1}}],[\"该session中的所有cache就将清空\",{\"1\":{\"188\":1}}],[\"该asn香港节点\",{\"1\":{\"52\":1}}],[\"该节点会把这个\",{\"1\":{\"42\":1}}],[\"该层主要有以下两种协议\",{\"1\":{\"8\":1}}],[\"创建线程实例一般有两种方法\",{\"1\":{\"638\":1}}],[\"创建线程的三种方式的对比\",{\"0\":{\"621\":1,\"688\":1}}],[\"创建异常对象并转交给\",{\"1\":{\"537\":1}}],[\"创建机制采用了一种名为inflation的方式\",{\"1\":{\"507\":1}}],[\"创建了两个对象\",{\"1\":{\"488\":4}}],[\"创建了几个字符串对象\",{\"0\":{\"488\":1},\"1\":{\"484\":1}}],[\"创建了sqlsessionfactory\",{\"1\":{\"194\":1}}],[\"创建对象有哪几种方式\",{\"0\":{\"471\":1}}],[\"创建对应的\",{\"1\":{\"40\":1}}],[\"创建客户端响应的\",{\"1\":{\"403\":1}}],[\"创建过程\",{\"0\":{\"274\":1},\"1\":{\"276\":1}}],[\"创建实现类\",{\"1\":{\"203\":1}}],[\"创建preparedstatement对象执行后续crud\",{\"1\":{\"201\":1}}],[\"创建被代理方法的具体实现\",{\"1\":{\"200\":1}}],[\"创建一个定长的线程池\",{\"1\":{\"672\":1}}],[\"创建一个单线程化的executor\",{\"1\":{\"672\":1}}],[\"创建一个指定工作线程数量的线程池\",{\"1\":{\"672\":1}}],[\"创建一个可缓存线程池\",{\"1\":{\"672\":1}}],[\"创建一个threadlocal变量\",{\"1\":{\"663\":1}}],[\"创建一个外部比较器\",{\"1\":{\"596\":1}}],[\"创建一个对象\",{\"1\":{\"499\":1,\"506\":1}}],[\"创建一个读取器\",{\"1\":{\"204\":1}}],[\"创建一个mapperproxyfactory作为值\",{\"1\":{\"200\":1}}],[\"创建一个abortcontroller对象\",{\"1\":{\"71\":1}}],[\"创建spring\",{\"1\":{\"304\":1}}],[\"创建sqlsessionfactory\",{\"1\":{\"177\":1}}],[\"创建statement等繁杂的过程\",{\"1\":{\"172\":1}}],[\"创建连接\",{\"1\":{\"172\":1}}],[\"创建前缀索引\",{\"1\":{\"155\":1}}],[\"创建索引时需要注意什么\",{\"0\":{\"160\":1}}],[\"创建索引有三种方式\",{\"1\":{\"159\":1}}],[\"创建索引有哪些开销\",{\"0\":{\"85\":1}}],[\"创建索引和维护索引要耗费时间\",{\"1\":{\"86\":1,\"147\":1}}],[\"创建索引需要维护\",{\"1\":{\"85\":1}}],[\"创建\",{\"1\":{\"42\":1,\"286\":1,\"638\":1,\"720\":1}}],[\"固定访问一个后台服务器\",{\"1\":{\"42\":1}}],[\"策略\",{\"1\":{\"42\":1}}],[\"分为三种常见的通信方式\",{\"1\":{\"731\":1}}],[\"分\",{\"1\":{\"716\":1}}],[\"分而治之\",{\"1\":{\"643\":2}}],[\"分析见get方法的源码\",{\"1\":{\"564\":1}}],[\"分析语句的执行计划\",{\"1\":{\"137\":1}}],[\"分段锁的数据结构\",{\"1\":{\"549\":1}}],[\"分段锁\",{\"1\":{\"546\":1,\"584\":1}}],[\"分享时曾提到\",{\"1\":{\"402\":1}}],[\"分享链接如下\",{\"1\":{\"69\":4}}],[\"分级缓存\",{\"1\":{\"396\":1}}],[\"分别定义了一条消息的最大长度和一个队列的最大长度\",{\"1\":{\"726\":1}}],[\"分别为\",{\"1\":{\"712\":1}}],[\"分别对应着\",{\"1\":{\"677\":1}}],[\"分别是\",{\"1\":{\"601\":1,\"612\":1,\"677\":1,\"731\":1}}],[\"分别是arraylist\",{\"1\":{\"569\":1}}],[\"分别是缓存和数据库的数据不一致\",{\"1\":{\"388\":1}}],[\"分别由四个抽象类来表示\",{\"1\":{\"539\":1}}],[\"分别称为泛型类\",{\"1\":{\"509\":1}}],[\"分别有什么区别\",{\"0\":{\"89\":1}}],[\"分三点\",{\"1\":{\"356\":1}}],[\"分区的leader副本选举对用户是完全透明的\",{\"1\":{\"340\":1}}],[\"分区leader选举策略有几种\",{\"0\":{\"340\":1}}],[\"分布在不同的机器上\",{\"1\":{\"323\":1}}],[\"分布式集群环境就无能为力了\",{\"1\":{\"431\":1}}],[\"分布式技术带来的技术挑战是对同一个资源的并发访问\",{\"1\":{\"381\":1}}],[\"分布式锁的三个核心要素\",{\"0\":{\"434\":1}}],[\"分布式锁需要满足的特性有这么几点\",{\"1\":{\"431\":1}}],[\"分布式锁\",{\"1\":{\"381\":1,\"431\":1}}],[\"分布式会话\",{\"1\":{\"381\":1}}],[\"分布式等特点\",{\"1\":{\"362\":1}}],[\"分布式架构\",{\"1\":{\"350\":1}}],[\"分布式事务\",{\"1\":{\"102\":1}}],[\"分布式拒绝服务攻击\",{\"1\":{\"43\":1}}],[\"分布式\",{\"1\":{\"42\":1,\"126\":1,\"350\":1}}],[\"分页拦截器配置类\",{\"0\":{\"315\":1}}],[\"分支结点均为索引\",{\"1\":{\"150\":1}}],[\"分发\",{\"1\":{\"128\":1}}],[\"分库就是你一个库一般我们经验而言\",{\"1\":{\"121\":1}}],[\"分库\",{\"1\":{\"121\":1}}],[\"分库分表了是怎么做的\",{\"1\":{\"142\":1}}],[\"分库分表\",{\"0\":{\"90\":1},\"1\":{\"90\":2}}],[\"分表分库了有什么问题\",{\"1\":{\"142\":1}}],[\"分表就是把一个表的数据放到多个表中\",{\"1\":{\"121\":1}}],[\"分表\",{\"1\":{\"121\":1}}],[\"分配\",{\"1\":{\"42\":1}}],[\"分钟发送一个探测报文段\",{\"1\":{\"19\":1}}],[\"那要想跨网络与不同主机上的进程之间通信\",{\"1\":{\"730\":1}}],[\"那先写的那个进程会发现内容被别人覆盖了\",{\"1\":{\"728\":1}}],[\"那共享内存的方式\",{\"1\":{\"727\":1}}],[\"那aqs只能用来实现独占且公平锁吗\",{\"1\":{\"614\":1}}],[\"那最好是使用\",{\"1\":{\"572\":1}}],[\"那会造成前一个\",{\"1\":{\"565\":1,\"583\":1}}],[\"那\",{\"1\":{\"563\":1}}],[\"那扩容的具体步骤是什么\",{\"1\":{\"558\":1,\"581\":1}}],[\"那其他线程只能阻塞等待需要的锁被释放\",{\"1\":{\"549\":1,\"593\":1}}],[\"那旧对象反序列化就会报错\",{\"1\":{\"525\":1}}],[\"那当前线程就要阻塞等待\",{\"1\":{\"651\":1}}],[\"那当然不会有问题\",{\"1\":{\"525\":1}}],[\"那当offset特别大的时候\",{\"1\":{\"136\":1}}],[\"那它们声明时指定的\",{\"1\":{\"516\":1}}],[\"那就是如果多个进程同时修改同一个共享内存\",{\"1\":{\"728\":1}}],[\"那就是使用到了extends和super语法的有界类型\",{\"1\":{\"511\":1}}],[\"那就会将线程在操作系统层面挂起\",{\"1\":{\"661\":1}}],[\"那就必须得有多主了\",{\"1\":{\"439\":1}}],[\"那时候是没有泛型的概念的\",{\"1\":{\"510\":1}}],[\"那为什么\",{\"1\":{\"493\":1}}],[\"那将会造成极大的空间资源的浪费\",{\"1\":{\"482\":1}}],[\"那是new之后才产生的\",{\"1\":{\"460\":1}}],[\"那只需要n\",{\"1\":{\"439\":1}}],[\"那哨兵1和master都宕机了\",{\"1\":{\"428\":1}}],[\"那里得到一个configuration\",{\"1\":{\"427\":1}}],[\"那存进redis也没有意义\",{\"1\":{\"395\":1}}],[\"那至少可以减少这个情况发生\",{\"1\":{\"392\":1}}],[\"那又和惰性删除一样了\",{\"1\":{\"386\":1}}],[\"那如果\",{\"1\":{\"346\":1}}],[\"那如果用户在\",{\"1\":{\"42\":1}}],[\"那这条消息就丢失了\",{\"1\":{\"332\":1}}],[\"那些不必要的索引反而会使查询反应时间变慢\",{\"1\":{\"162\":1}}],[\"那可能有人会问\",{\"1\":{\"161\":1}}],[\"那么毫无关系的进程就可以通过这个设备文件进行通信\",{\"1\":{\"731\":1}}],[\"那么要保证当前线程是中断状态\",{\"1\":{\"714\":1}}],[\"那么线程就会在启动初期立即执行这个任务\",{\"1\":{\"714\":1}}],[\"那么访问这个变量的每个线程都会有这个变量的一个本地拷贝\",{\"1\":{\"663\":1}}],[\"那么锁就进入偏向模式\",{\"1\":{\"656\":1}}],[\"那么非公平锁是如何实现的呢\",{\"1\":{\"614\":1}}],[\"那么设置tail的值为update的值\",{\"1\":{\"607\":1}}],[\"那么在hashset中执行这一句话始终会返回一个false\",{\"1\":{\"595\":1}}],[\"那么在这个变更通知到从节点之前\",{\"1\":{\"342\":1}}],[\"那么table会变成如下状态\",{\"1\":{\"565\":1}}],[\"那么键对象正确的重写这两个方法是非常重要的\",{\"1\":{\"560\":1,\"582\":1}}],[\"那么实际并发度是32\",{\"1\":{\"548\":1,\"589\":1}}],[\"那么每个节点都需要通过继承\",{\"1\":{\"546\":1}}],[\"那么当强制将o构造为类b的实例时抛出该异常\",{\"1\":{\"534\":1}}],[\"那么当进行select\",{\"1\":{\"152\":1}}],[\"那么编译器将标记该实例并关注该实例后续所有方法的调用\",{\"1\":{\"511\":1}}],[\"那么是不是所有的泛型类型都以\",{\"1\":{\"511\":1}}],[\"那么x\",{\"1\":{\"476\":1}}],[\"那么比较的是两个对象的引用\",{\"1\":{\"476\":1}}],[\"那么比较的是两个基本数据类型的值是否相等\",{\"1\":{\"476\":1}}],[\"那么属于类的内容它都认识\",{\"1\":{\"460\":1}}],[\"那么可能每个master持有5000多个hash\",{\"1\":{\"429\":1}}],[\"那么可以接着上次复制的地方\",{\"1\":{\"420\":1}}],[\"那么可以先将缓存更新的请求发送到队列中\",{\"1\":{\"392\":1}}],[\"那么可以只使用rdb\",{\"1\":{\"384\":1}}],[\"那么可以关闭持久化\",{\"1\":{\"384\":1}}],[\"那么选择一个run\",{\"1\":{\"426\":1}}],[\"那么看replica\",{\"1\":{\"426\":1}}],[\"那么slave就被认为不适合选举为master\",{\"1\":{\"426\":1}}],[\"那么某个哨兵就会执行主备切换操作\",{\"1\":{\"426\":1}}],[\"那么对象也就跟着消失了\",{\"1\":{\"518\":1}}],[\"那么对于client\",{\"1\":{\"424\":1}}],[\"那么对数据库中的数据的改变就是永久的\",{\"1\":{\"74\":1}}],[\"那么会选择先进行数组扩容\",{\"1\":{\"553\":1,\"575\":1}}],[\"那么会引起很严重的安全问题\",{\"1\":{\"482\":1}}],[\"那么会模拟一条del命令发送给slave\",{\"1\":{\"420\":1}}],[\"那么会触发一次full\",{\"1\":{\"420\":1}}],[\"那么会为\",{\"1\":{\"403\":3}}],[\"那么master\",{\"1\":{\"420\":1}}],[\"那么哨兵负责发送消息作为报警通知给管理员\",{\"1\":{\"419\":1}}],[\"那么建议就用redis\",{\"1\":{\"413\":1}}],[\"那么该事务中的所有命令都会被服务器执行\",{\"1\":{\"407\":1}}],[\"那么该键就会一直存在内存中\",{\"1\":{\"386\":1}}],[\"那么所有的底层数据结构都必须实现成线程安全的\",{\"1\":{\"399\":1}}],[\"那么势必涉及到底层数据同步的问题\",{\"1\":{\"399\":1}}],[\"那么我们调用containskey方法返回的就是true了\",{\"1\":{\"588\":1}}],[\"那么我们调用containskey方法返回的就是\",{\"1\":{\"548\":1}}],[\"那么我们采用第一种方案就会缓存大量不存在key的数据\",{\"1\":{\"395\":1}}],[\"那么我们可以订阅\",{\"1\":{\"393\":1}}],[\"那么很大可能是存在\",{\"1\":{\"395\":1}}],[\"那么大量的请求打在数据库上是很致命的问题\",{\"1\":{\"395\":1}}],[\"那么此时就是偏向锁\",{\"1\":{\"656\":1}}],[\"那么此时也许只有部分数据被写入到磁盘\",{\"1\":{\"407\":1}}],[\"那么此时再读取缓存的时候每次都是错误的数据了\",{\"1\":{\"393\":1}}],[\"那么此时会从其\",{\"1\":{\"323\":1}}],[\"那么将重新读取数据+更新缓存的操作\",{\"1\":{\"392\":1}}],[\"那么redis初始状态数据为空\",{\"1\":{\"397\":1}}],[\"那么redis内存不够用的时候是怎么处理的呢\",{\"1\":{\"388\":1}}],[\"那么redis会是不错的选择\",{\"1\":{\"378\":1}}],[\"那么client会重复消息\",{\"1\":{\"360\":1}}],[\"那么client在等待超时后\",{\"1\":{\"359\":1}}],[\"那么如何保证消息在多个线程之间是被顺序处理的呢\",{\"1\":{\"337\":1}}],[\"那么其指向的变量的值也会改变\",{\"1\":{\"482\":1}}],[\"那么其他哨兵\",{\"1\":{\"427\":1}}],[\"那么其实主从同步之间也会有时间差\",{\"1\":{\"391\":1}}],[\"那么其实只要保证消息在\",{\"1\":{\"337\":1}}],[\"那么其对应的xml中\",{\"1\":{\"183\":1}}],[\"那么相同订单\",{\"1\":{\"336\":1}}],[\"那么只要关闭自动提交\",{\"1\":{\"332\":1}}],[\"那么只需要修改原来的索引即可\",{\"1\":{\"161\":1}}],[\"那么接下来就简单介绍一下\",{\"1\":{\"291\":1}}],[\"那么它往该集合存取数据的时候就会对数据进行判断\",{\"1\":{\"516\":1}}],[\"那么它是无法使用\",{\"1\":{\"284\":1}}],[\"那么它们两者的共性是啥\",{\"1\":{\"237\":1}}],[\"那么它的索引树是这样的可以看到a的值是有顺序的\",{\"1\":{\"84\":1}}],[\"那么id重复会导致数据互相覆盖\",{\"1\":{\"185\":1}}],[\"那么id不能重复\",{\"1\":{\"185\":1,\"191\":1}}],[\"那么id可以重复\",{\"1\":{\"185\":1,\"191\":1}}],[\"那么这些元素是存储于堆中\",{\"1\":{\"499\":1}}],[\"那么这些注入进去的\",{\"1\":{\"45\":1}}],[\"那么这个锁就是可重入的\",{\"1\":{\"435\":1}}],[\"那么这个时候\",{\"1\":{\"424\":1}}],[\"那么这个dao接口的工作原理是什么\",{\"0\":{\"182\":1}}],[\"那么这种方案就不合适了\",{\"1\":{\"395\":1}}],[\"那么这一次直接从数据库中读取当前的旧值\",{\"1\":{\"392\":1}}],[\"那么索引不会失效\",{\"1\":{\"168\":1}}],[\"那么索引的排序为\",{\"1\":{\"153\":1}}],[\"那么都将不会走索引\",{\"1\":{\"167\":1}}],[\"那么就需要\",{\"1\":{\"731\":1}}],[\"那么就需要创建一个线程去执行任务列表\",{\"1\":{\"714\":1}}],[\"那么就需要注意设置最大线程数要尽可能大一些\",{\"1\":{\"673\":1}}],[\"那么就一定会有某种队列形成\",{\"1\":{\"614\":1}}],[\"那么就一定不存在\",{\"1\":{\"395\":1}}],[\"那么就将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"602\":1}}],[\"那么就使用受检查异常\",{\"1\":{\"531\":1}}],[\"那么就直接返回\",{\"1\":{\"392\":1}}],[\"那么就不用再放进去了\",{\"1\":{\"392\":1}}],[\"那么就不必再进行回表查询\",{\"1\":{\"152\":1}}],[\"那么就强制将其指向主库进行查询\",{\"1\":{\"391\":1}}],[\"那么就会执行一次resynchronization全量复制\",{\"1\":{\"422\":1}}],[\"那么就会执行一次resynchronization\",{\"1\":{\"420\":1}}],[\"那么就会导致大量的请求打在了数据库上面\",{\"1\":{\"396\":1}}],[\"那么就会存在数据同步的问题\",{\"1\":{\"389\":1}}],[\"那么就会返回这个键的值\",{\"1\":{\"386\":1}}],[\"那么就会造成消息在consumer端堆积过多\",{\"1\":{\"366\":1}}],[\"那么就无法响应服务端的二次请求\",{\"1\":{\"18\":1}}],[\"那么盘块所能容纳的关键字数量也越多\",{\"1\":{\"150\":1}}],[\"那么你可以将一个库的数据拆分到多个库中\",{\"1\":{\"121\":1}}],[\"那么\",{\"1\":{\"103\":1,\"191\":1,\"272\":1,\"284\":1,\"340\":1,\"341\":2,\"345\":2,\"347\":1,\"548\":1,\"559\":1,\"564\":1,\"588\":1,\"731\":1}}],[\"那么内外表都进行全表扫描\",{\"1\":{\"96\":1}}],[\"那么用in和exists差别不大\",{\"1\":{\"96\":1}}],[\"那么无论实际存储多少内容\",{\"1\":{\"95\":1}}],[\"那么需要的空间就会更大\",{\"1\":{\"86\":1}}],[\"那么联合索引当然还是一颗b+树\",{\"1\":{\"84\":1}}],[\"那么不管\",{\"1\":{\"74\":1}}],[\"那么服务器就认为连接已经断开了\",{\"1\":{\"19\":1}}],[\"那么服务端该tcp连接的状态为syn\",{\"1\":{\"15\":1}}],[\"那么一段时间后\",{\"1\":{\"15\":1}}],[\"问题二\",{\"1\":{\"722\":1}}],[\"问题一\",{\"1\":{\"722\":1}}],[\"问题5\",{\"1\":{\"63\":1}}],[\"问题4\",{\"1\":{\"63\":1}}],[\"问题3\",{\"1\":{\"63\":1}}],[\"问题2\",{\"1\":{\"63\":1}}],[\"问题1\",{\"1\":{\"63\":1}}],[\"问题\",{\"0\":{\"42\":1},\"1\":{\"645\":1,\"683\":1}}],[\"等价于通过\",{\"1\":{\"476\":1}}],[\"等结构\",{\"1\":{\"438\":1}}],[\"等持久化方案\",{\"1\":{\"399\":1}}],[\"等协议\",{\"1\":{\"353\":1}}],[\"等kip\",{\"1\":{\"327\":1}}],[\"等一系列伟大的产品\",{\"1\":{\"310\":1}}],[\"等请求方法\",{\"1\":{\"295\":1}}],[\"等以\",{\"1\":{\"286\":1}}],[\"等特性\",{\"1\":{\"175\":1}}],[\"等进行相应的调整\",{\"1\":{\"141\":1}}],[\"等在复制过程可能导致数据不一致甚至出错\",{\"1\":{\"108\":1}}],[\"等级\",{\"1\":{\"103\":1}}],[\"等等的并发及线程安全问题\",{\"1\":{\"405\":1}}],[\"等等其他丰富的数据结构\",{\"1\":{\"399\":1}}],[\"等等\",{\"1\":{\"92\":1,\"327\":1,\"574\":1}}],[\"等信息使用缓存中间件\",{\"1\":{\"42\":1}}],[\"等\",{\"1\":{\"41\":1,\"45\":1,\"157\":1,\"352\":1,\"362\":1,\"378\":1,\"531\":1}}],[\"等待通知有着一个经典范式\",{\"1\":{\"732\":1}}],[\"等待通知机制\",{\"0\":{\"732\":1}}],[\"等待唤醒\",{\"1\":{\"666\":1}}],[\"等待后续使用\",{\"1\":{\"662\":1}}],[\"等待可中断\",{\"1\":{\"648\":1,\"707\":1}}],[\"等待线程终止或超时\",{\"1\":{\"639\":1}}],[\"等待线程终止或者超时\",{\"1\":{\"623\":1,\"690\":1}}],[\"等待队列\",{\"1\":{\"639\":1}}],[\"等待队列中线程出队列时机\",{\"0\":{\"608\":1}}],[\"等待cpu的到来\",{\"1\":{\"633\":1,\"701\":1}}],[\"等待阻塞\",{\"1\":{\"623\":1,\"639\":1,\"690\":1}}],[\"等待被唤醒或被中断\",{\"1\":{\"602\":1}}],[\"等待一段时间重新获取锁\",{\"1\":{\"435\":1}}],[\"等待一定时长再开始复制\",{\"1\":{\"420\":1}}],[\"等待下次consumer的请求\",{\"1\":{\"367\":1}}],[\"等待broker回应并投递相应队列中的消息\",{\"1\":{\"358\":1}}],[\"等待个\",{\"1\":{\"347\":1}}],[\"等待客户端响应\",{\"1\":{\"14\":1}}],[\"等待服务器确认\",{\"1\":{\"11\":1}}],[\"大于\",{\"1\":{\"617\":1}}],[\"大于等于配置文件指定的值\",{\"1\":{\"425\":1}}],[\"大概可以总结出reentrantlock加锁解锁时api层核心方法的映射关系\",{\"1\":{\"615\":1}}],[\"大概第75行\",{\"1\":{\"70\":1}}],[\"大小是固定的\",{\"1\":{\"574\":1}}],[\"大致可以分为以下步骤\",{\"1\":{\"547\":2,\"585\":1}}],[\"大致步骤如下\",{\"1\":{\"112\":1}}],[\"大大提高了通信的速度\",{\"1\":{\"731\":1}}],[\"大大提高了进程间通信的速度\",{\"1\":{\"727\":1}}],[\"大大提高了并发度\",{\"1\":{\"546\":1,\"584\":1}}],[\"大大影响了数据库的性能\",{\"1\":{\"381\":1}}],[\"大部分线程都阻塞\",{\"1\":{\"675\":1}}],[\"大部分情况下\",{\"1\":{\"511\":1}}],[\"大部分系统也是根据此原理来验证用户登录状态\",{\"1\":{\"40\":1}}],[\"大家相互都认识\",{\"1\":{\"459\":1}}],[\"大并发集中对其进行请求\",{\"1\":{\"394\":1}}],[\"大数据领域的实时计算\",{\"1\":{\"350\":1}}],[\"大型公司\",{\"1\":{\"350\":1}}],[\"大型的项目\",{\"1\":{\"175\":1}}],[\"大量使用get\",{\"1\":{\"438\":1}}],[\"大量指令入队\",{\"1\":{\"408\":1}}],[\"大量的请求涌入\",{\"1\":{\"348\":1}}],[\"大量的流量都打在最新的数据上了\",{\"1\":{\"128\":1}}],[\"大量冗余的代码\",{\"1\":{\"179\":1}}],[\"大表怎么优化\",{\"0\":{\"142\":1}}],[\"大表数据查询\",{\"0\":{\"135\":1}}],[\"大锅饭\",{\"1\":{\"46\":1}}],[\"大而全\",{\"1\":{\"8\":1}}],[\"证明用户已经登录可执行后面操作\",{\"1\":{\"40\":1}}],[\"证书包含公钥和大量其他信息\",{\"1\":{\"37\":1}}],[\"证书本身也附带一个证书电子签名\",{\"1\":{\"37\":1}}],[\"证书\",{\"1\":{\"37\":1}}],[\"查看cpu核数\",{\"1\":{\"675\":1}}],[\"查看cf\",{\"1\":{\"69\":1}}],[\"查一次即可\",{\"1\":{\"151\":1}}],[\"查缓存\",{\"1\":{\"88\":1,\"99\":1}}],[\"查找\",{\"1\":{\"576\":1}}],[\"查找无参构造器\",{\"1\":{\"507\":1}}],[\"查找实际的\",{\"1\":{\"290\":1}}],[\"查找效率跟数据有关\",{\"1\":{\"80\":1,\"150\":1}}],[\"查找对应的\",{\"1\":{\"40\":1}}],[\"查询同步队列中的等待线程情况\",{\"1\":{\"609\":1}}],[\"查询时间复杂度\",{\"1\":{\"549\":1,\"591\":1}}],[\"查询操作\",{\"1\":{\"390\":1,\"391\":2}}],[\"查询\",{\"1\":{\"251\":1}}],[\"查询优化器根据统计信息\",{\"1\":{\"157\":1}}],[\"查询器预测满足下一次查询条件的百分比\",{\"1\":{\"157\":1}}],[\"查询中可能用到的索引\",{\"1\":{\"157\":1}}],[\"查询是select\",{\"1\":{\"156\":1}}],[\"查询只会查一次\",{\"1\":{\"151\":1}}],[\"查询和更新的速度\",{\"1\":{\"140\":1}}],[\"查询不需要的数据\",{\"1\":{\"138\":1}}],[\"查询的结果是\",{\"1\":{\"112\":1}}],[\"查询效率上\",{\"1\":{\"92\":1}}],[\"查询性能变低\",{\"1\":{\"80\":1}}],[\"查询服务器资源\",{\"1\":{\"29\":1}}],[\"查询指定的url支持的方法\",{\"1\":{\"29\":1}}],[\"存入osr\",{\"1\":{\"338\":1}}],[\"存放数据的桶\",{\"1\":{\"587\":1}}],[\"存放元素的\",{\"1\":{\"546\":1}}],[\"存放元数据\",{\"1\":{\"327\":1}}],[\"存放服务接口名与服务端对应的实现类\",{\"1\":{\"230\":1}}],[\"存取\",{\"0\":{\"547\":1}}],[\"存取数据\",{\"1\":{\"299\":1}}],[\"存取方式的不同\",{\"1\":{\"41\":1}}],[\"存着服务接口名\",{\"1\":{\"230\":1}}],[\"存在用户态与内核态之间的数据拷贝开销\",{\"1\":{\"726\":1}}],[\"存在某种排队等候机制\",{\"1\":{\"614\":1}}],[\"存在一定的误判率\",{\"1\":{\"395\":1}}],[\"存在一些浪费带宽的现象\",{\"1\":{\"33\":1}}],[\"存在\",{\"1\":{\"395\":1,\"548\":1,\"556\":1,\"580\":1}}],[\"存在的痛点\",{\"0\":{\"226\":1}}],[\"存储元素的线程会等待队列可用\",{\"1\":{\"713\":1}}],[\"存储元数据信息的数据库等\",{\"1\":{\"418\":1}}],[\"存储的位置是相同的\",{\"1\":{\"555\":1}}],[\"存储结构\",{\"0\":{\"553\":1}}],[\"存储都可以归为此类\",{\"1\":{\"382\":1}}],[\"存储\",{\"1\":{\"377\":1}}],[\"存储引擎都会对所有的索引列计算一个哈希码\",{\"1\":{\"149\":1}}],[\"存储引擎中用来实现多版本并发控制\",{\"1\":{\"107\":1}}],[\"存储引擎在\",{\"1\":{\"102\":1}}],[\"存储引擎默认使用\",{\"1\":{\"102\":1}}],[\"存储过程\",{\"1\":{\"123\":1}}],[\"存储过程的管理确实是没有那么方便\",{\"1\":{\"98\":1}}],[\"存储过程是一个预编译的代码块\",{\"1\":{\"98\":1}}],[\"存储过程是一些预编译的\",{\"1\":{\"98\":1}}],[\"存储过程可以说是一个记录集\",{\"1\":{\"98\":1}}],[\"存储大小不同\",{\"1\":{\"41\":1}}],[\"存储在服务端\",{\"1\":{\"41\":1}}],[\"存储在客户端\",{\"1\":{\"41\":1}}],[\"存储在\",{\"1\":{\"39\":1}}],[\"代表一个线程的实例\",{\"1\":{\"638\":1}}],[\"代表一个节点\",{\"1\":{\"251\":1}}],[\"代表越高频\",{\"1\":{\"545\":1}}],[\"代表着抽象状态转移\",{\"1\":{\"300\":1}}],[\"代表着什么\",{\"0\":{\"300\":1}}],[\"代表着json序列化方式\",{\"1\":{\"244\":1}}],[\"代表着服务器和客户端一次会话的过程\",{\"1\":{\"39\":1}}],[\"代表java原生序列化器\",{\"1\":{\"244\":1}}],[\"代表dao中的第二个参数\",{\"1\":{\"183\":1}}],[\"代表接收的是dao层中的第一个参数\",{\"1\":{\"183\":1}}],[\"代理设计模式\",{\"1\":{\"286\":1}}],[\"代理客户端根据不同的服务\",{\"1\":{\"237\":1}}],[\"代理对象增强的公共行为\",{\"1\":{\"223\":1}}],[\"代理对象proxy会拦截接口方法\",{\"1\":{\"182\":1}}],[\"代理类\",{\"1\":{\"200\":1,\"284\":1}}],[\"代理\",{\"1\":{\"42\":1}}],[\"代码和数据分开\",{\"1\":{\"621\":1,\"688\":1}}],[\"代码和手动设置参数以及获取结果集\",{\"1\":{\"172\":1}}],[\"代码设计\",{\"0\":{\"609\":1}}],[\"代码示例2\",{\"1\":{\"536\":1}}],[\"代码示例1\",{\"1\":{\"536\":1}}],[\"代码在运行期时也只不过是在正常运行的基础上加一层皮\",{\"1\":{\"535\":1}}],[\"代码维护起来就很方便了\",{\"1\":{\"506\":1}}],[\"代码块上都是是给\",{\"1\":{\"649\":1}}],[\"代码块加锁\",{\"1\":{\"647\":1}}],[\"代码块执行完毕之后再向调用者返回其值\",{\"1\":{\"536\":1}}],[\"代码块执行顺序静态代码块\",{\"1\":{\"461\":1}}],[\"代码块\",{\"0\":{\"461\":1},\"1\":{\"536\":1}}],[\"代码提供\",{\"1\":{\"264\":1}}],[\"代码更加简洁\",{\"1\":{\"232\":1}}],[\"代码解耦\",{\"1\":{\"228\":1}}],[\"代码简洁\",{\"1\":{\"223\":1}}],[\"代码开发量少\",{\"1\":{\"175\":1}}],[\"代码日志\",{\"1\":{\"69\":1,\"70\":1,\"71\":1}}],[\"代码如下\",{\"1\":{\"65\":1,\"610\":1}}],[\"代码地址\",{\"1\":{\"57\":1,\"58\":1}}],[\"代码\",{\"1\":{\"38\":2,\"70\":1,\"206\":1}}],[\"个操作数\",{\"1\":{\"644\":1}}],[\"个元素都要执行向后位\",{\"1\":{\"571\":1}}],[\"个元素之后的\",{\"1\":{\"571\":1}}],[\"个的时候\",{\"1\":{\"553\":2,\"577\":2}}],[\"个条件\",{\"1\":{\"465\":1}}],[\"个必要条件\",{\"1\":{\"465\":1}}],[\"个不同元素的基\",{\"1\":{\"382\":1}}],[\"个consumer\",{\"1\":{\"364\":1}}],[\"个小时\",{\"1\":{\"348\":1}}],[\"个请求的速度在处理\",{\"1\":{\"348\":1}}],[\"个请求进\",{\"1\":{\"348\":1}}],[\"个请求进来\",{\"1\":{\"348\":1}}],[\"个请求出去\",{\"1\":{\"348\":1}}],[\"个请求\",{\"1\":{\"348\":2}}],[\"个请求写入\",{\"1\":{\"348\":1}}],[\"个\",{\"1\":{\"348\":2,\"489\":1,\"546\":1,\"584\":1}}],[\"个很明\",{\"1\":{\"342\":1}}],[\"个线程\",{\"1\":{\"337\":1}}],[\"个内存\",{\"1\":{\"337\":1}}],[\"个副本\",{\"1\":{\"334\":1}}],[\"个参数\",{\"1\":{\"334\":1}}],[\"个注解\",{\"1\":{\"306\":1}}],[\"个人认为算是一个现在也可以选择的方案\",{\"1\":{\"126\":1}}],[\"个隐藏的列\",{\"1\":{\"112\":1}}],[\"个字符\",{\"1\":{\"95\":1}}],[\"个性化设置\",{\"1\":{\"39\":1}}],[\"个探测报文后客户端依然没有回应\",{\"1\":{\"19\":1}}],[\"游戏分数或其它需要记录的信息\",{\"1\":{\"39\":1}}],[\"购物车\",{\"1\":{\"39\":1}}],[\"使两者良好的结合从而执行并行任务\",{\"1\":{\"711\":1}}],[\"使该线程阻塞\",{\"1\":{\"677\":1}}],[\"使本线程进入到等待阻塞状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"使应用程序可以继续正常运行\",{\"1\":{\"530\":1}}],[\"使多线程安全\",{\"1\":{\"482\":1}}],[\"使系统更加灵活\",{\"1\":{\"463\":1}}],[\"使编译程序更加简洁\",{\"1\":{\"443\":1}}],[\"使热数据仍在内存中\",{\"1\":{\"377\":1}}],[\"使得共享的资源\",{\"1\":{\"728\":1}}],[\"使得lock指令后的指令不能重排序到内存屏障前的位置\",{\"1\":{\"637\":1,\"708\":1}}],[\"使得数据容易保存\",{\"1\":{\"560\":1}}],[\"使得二者可以相互转换\",{\"1\":{\"493\":1}}],[\"使得用户可以监控和管理消息\",{\"1\":{\"352\":1}}],[\"使得在部分节点出现问题的情况下队\",{\"1\":{\"352\":1}}],[\"使得语句可以尽可能的命中索引\",{\"1\":{\"137\":1}}],[\"使之支持多种消息类型\",{\"1\":{\"246\":1}}],[\"使之能够支持多种版本客户端的扩展\",{\"1\":{\"239\":1}}],[\"使之不同方式网络连接的客户端有着同样的结构\",{\"1\":{\"237\":1}}],[\"使之不可能相互冲突\",{\"1\":{\"102\":1}}],[\"使基于无状态的\",{\"1\":{\"39\":1}}],[\"使用队列去缓冲大批量的任务\",{\"1\":{\"720\":1}}],[\"使用aqs来实现独占锁这个功能\",{\"1\":{\"714\":1}}],[\"使用alter\",{\"1\":{\"159\":1}}],[\"使用不同的队列可以实现不一样的任务存取策略\",{\"1\":{\"713\":1}}],[\"使用原子的方式更新引用类型\",{\"1\":{\"683\":1}}],[\"使用原子的方式更新数组里的某个元素\",{\"1\":{\"683\":1}}],[\"使用原子的方式更新基本类型\",{\"1\":{\"683\":1}}],[\"使用者继承abstractqueuedsynchronizer并重写指定的方法\",{\"1\":{\"678\":1}}],[\"使用线程池可以进行统一的分配\",{\"1\":{\"668\":1}}],[\"使用线程池的好处\",{\"1\":{\"668\":1}}],[\"使用完threadlocal后\",{\"1\":{\"665\":1}}],[\"使用重量级锁就不划算了\",{\"1\":{\"661\":1}}],[\"使用选择\",{\"1\":{\"648\":1,\"707\":1}}],[\"使用简单\",{\"1\":{\"647\":1}}],[\"使用互斥锁来保证原子性\",{\"1\":{\"645\":1}}],[\"使用权后\",{\"1\":{\"639\":1}}],[\"使用显式锁中的reentrantlock\",{\"1\":{\"627\":1,\"694\":1}}],[\"使用继承thread类的方式创建多线程\",{\"1\":{\"621\":1,\"688\":1}}],[\"使用listiterator\",{\"1\":{\"597\":2}}],[\"使用limit解决\",{\"1\":{\"138\":1}}],[\"使用iterator\",{\"1\":{\"597\":1}}],[\"使用尾插法\",{\"1\":{\"559\":1}}],[\"使用头插法插入元素\",{\"1\":{\"557\":1,\"564\":1,\"583\":1}}],[\"使用链表+红黑树\",{\"1\":{\"557\":1}}],[\"使用threadpoolexecutor\",{\"1\":{\"676\":1}}],[\"使用throw语句抛出null等等\",{\"1\":{\"534\":1}}],[\"使用tablesizefor\",{\"1\":{\"555\":1}}],[\"使用泛型的时候加上的类型参数\",{\"1\":{\"511\":1}}],[\"使用泛型的好处有以下几点\",{\"1\":{\"510\":1}}],[\"使用泛型的好处是什么\",{\"0\":{\"510\":1},\"1\":{\"484\":1}}],[\"使用时直接得到目标类型\",{\"1\":{\"510\":1}}],[\"使用反射机制\",{\"1\":{\"506\":1}}],[\"使用反射调用\",{\"1\":{\"505\":1}}],[\"使用反射\",{\"1\":{\"505\":1}}],[\"使用反射性能较低\",{\"1\":{\"502\":1}}],[\"使用字面量创建\",{\"1\":{\"488\":4}}],[\"使用对象\",{\"1\":{\"451\":4}}],[\"使用哨兵集群主要是提高缓存架构的可用性\",{\"1\":{\"439\":1}}],[\"使用一主多从+哨兵集群的缓存架构来承载每秒10w+的读并发\",{\"1\":{\"439\":1}}],[\"使用一致性哈希实现动态扩容缩容\",{\"1\":{\"385\":1}}],[\"使用redis时不要进入一个误区\",{\"1\":{\"438\":1}}],[\"使用redis或memcached之类的称为分布式缓存\",{\"1\":{\"380\":1}}],[\"使用官方推荐的哨兵\",{\"1\":{\"419\":1}}],[\"使用单线程保持代码的简单和可维护性\",{\"1\":{\"399\":1}}],[\"使用熔断机制\",{\"1\":{\"396\":1}}],[\"使用布隆过滤器\",{\"1\":{\"395\":1}}],[\"使用伪代码如下\",{\"1\":{\"391\":1}}],[\"使用到缓存\",{\"1\":{\"389\":1}}],[\"使用到了适配器模式\",{\"1\":{\"286\":1}}],[\"使用bitmap实现统计功能\",{\"1\":{\"382\":1}}],[\"使用场景\",{\"1\":{\"382\":1,\"413\":1}}],[\"使用场景不同\",{\"1\":{\"161\":1}}],[\"使用自带的map或者guava实现的是本地缓存\",{\"1\":{\"380\":1}}],[\"使用自定义的编解码器\",{\"1\":{\"245\":1}}],[\"使用底层模型不同\",{\"1\":{\"377\":1}}],[\"使用cas方式更新state\",{\"1\":{\"604\":1}}],[\"使用class\",{\"1\":{\"506\":1}}],[\"使用consumer的offset\",{\"1\":{\"367\":1}}],[\"使用create\",{\"1\":{\"159\":1}}],[\"使用mq的场景很多\",{\"1\":{\"345\":1}}],[\"使用mybatis的mapper接口调用时有哪些要求\",{\"0\":{\"189\":1}}],[\"使用mysql的缓存\",{\"1\":{\"142\":1}}],[\"使用拉模式进行消息的获取消费\",{\"1\":{\"329\":1}}],[\"使用内容安全策略防止xss攻击\",{\"1\":{\"309\":1}}],[\"使用过程中直接注入对应\",{\"1\":{\"308\":1}}],[\"使用基于类路径和应用程序上下文的智能默认值\",{\"1\":{\"304\":1}}],[\"使用string\",{\"1\":{\"488\":2}}],[\"使用snyk检查你的依赖关系\",{\"1\":{\"309\":1}}],[\"使用spring框架的好处是什么\",{\"0\":{\"263\":1}}],[\"使用setnx来加锁\",{\"1\":{\"434\":1}}],[\"使用set\",{\"1\":{\"156\":1}}],[\"使用set对象去重\",{\"1\":{\"71\":2}}],[\"使用心跳监听状态\",{\"1\":{\"251\":1}}],[\"使用消息头加长度的方式解决粘包问题\",{\"1\":{\"246\":1}}],[\"使用netty方式传输数据\",{\"1\":{\"237\":1}}],[\"使用netty进行网络传输\",{\"1\":{\"237\":1}}],[\"使用java自带序列化方式不用messagetype也能得到相应的对象\",{\"1\":{\"244\":1}}],[\"使用java\",{\"1\":{\"237\":1}}],[\"使用了偏向锁升级为轻量级锁再升级到重量级锁的方式\",{\"1\":{\"652\":1}}],[\"使用了适配器模式和装饰器模式\",{\"1\":{\"543\":1}}],[\"使用了动态代理进行不同服务方法的request的封装\",{\"1\":{\"225\":1}}],[\"使用了lombok中的builder\",{\"1\":{\"223\":1}}],[\"使用高性能网络框架netty的实现网络通信\",{\"1\":{\"212\":1}}],[\"使用ognl从sql参数对象中计算表达式的值\",{\"1\":{\"190\":1}}],[\"使用二级缓存属性类需要实现serializable序列化接口\",{\"1\":{\"188\":1}}],[\"使用连接池管理数据库链接\",{\"1\":{\"176\":1}}],[\"使用hibernate查询关联对象或者关联集合对象时\",{\"1\":{\"174\":1}}],[\"使用https协议可认证用户和服务器\",{\"1\":{\"36\":1}}],[\"使用\",{\"0\":{\"164\":1},\"1\":{\"179\":1,\"183\":1,\"348\":1,\"435\":1,\"490\":1,\"505\":1,\"527\":1}}],[\"使用索引查询不一定能提高查询性能\",{\"1\":{\"162\":1}}],[\"使用索引查询一定能提高查询的性能吗\",{\"0\":{\"162\":1}}],[\"使用索引覆盖扫描\",{\"1\":{\"138\":1}}],[\"使用优化隐藏器\",{\"1\":{\"147\":1}}],[\"使用率是否下降\",{\"1\":{\"141\":1}}],[\"使用explain进行分析\",{\"1\":{\"138\":1}}],[\"使用的索引的相关信息等\",{\"1\":{\"134\":1}}],[\"使用什么索引\",{\"1\":{\"134\":1}}],[\"使用较低的隔离级别\",{\"1\":{\"120\":1}}],[\"使用数据库中的锁机制\",{\"1\":{\"116\":1}}],[\"使用正确的字符编码解析文本内容\",{\"1\":{\"71\":1}}],[\"使用promise\",{\"1\":{\"71\":1}}],[\"使用pages方式部署\",{\"1\":{\"69\":1}}],[\"使用域名用tls\",{\"1\":{\"67\":1}}],[\"使用长连接的http协议\",{\"1\":{\"31\":1}}],[\"使用上的区别\",{\"1\":{\"30\":1}}],[\"使用流量控制和拥塞控制\",{\"1\":{\"9\":1}}],[\"文件还是文件\",{\"1\":{\"519\":1}}],[\"文件路径path\",{\"1\":{\"482\":1}}],[\"文件事件分派器\",{\"1\":{\"403\":1}}],[\"文件事件处理器的结构包含了四个部分\",{\"1\":{\"403\":1}}],[\"文件会越来越大\",{\"1\":{\"383\":1}}],[\"文件中\",{\"1\":{\"511\":1}}],[\"文件中的一个\",{\"1\":{\"278\":1}}],[\"文件中由相同名称定义的\",{\"1\":{\"278\":1}}],[\"文件不对\",{\"1\":{\"204\":1}}],[\"文件或注解的方式将要执行的各种\",{\"1\":{\"172\":1}}],[\"文件\",{\"1\":{\"38\":1,\"308\":1,\"519\":1}}],[\"文本的表现形式有多样性\",{\"1\":{\"34\":1}}],[\"程序之间的切换会有较大的开销\",{\"1\":{\"620\":1,\"687\":1}}],[\"程序上下文\",{\"1\":{\"620\":1,\"687\":1}}],[\"程序本身可以处理的异常\",{\"1\":{\"530\":1}}],[\"程序员决定存储哪些信息\",{\"1\":{\"523\":1}}],[\"程序员自己编写\",{\"1\":{\"178\":1}}],[\"程序的类型安全\",{\"1\":{\"510\":1}}],[\"程序都会在堆内存中开辟一片新空间存放新对象\",{\"1\":{\"488\":1}}],[\"程序会在堆内存中开辟一片新空间存放新对象\",{\"1\":{\"488\":1}}],[\"程序运行时会在常量池中查找\",{\"1\":{\"488\":1}}],[\"程序返回\",{\"1\":{\"452\":1}}],[\"程序所需的所有内容的集合\",{\"1\":{\"444\":1}}],[\"程序中使用\",{\"1\":{\"443\":1}}],[\"程序异常退出或宕机\",{\"1\":{\"415\":1}}],[\"程序一重启数据就没了\",{\"1\":{\"380\":1}}],[\"程序\",{\"1\":{\"38\":1}}],[\"发消息的时候一个线程去发送消息\",{\"1\":{\"368\":1}}],[\"发布订阅消息这么一个模型\",{\"1\":{\"346\":1}}],[\"发布消息的程序成为\",{\"1\":{\"322\":1}}],[\"发布于\",{\"0\":{\"55\":1,\"59\":1,\"63\":1}}],[\"发明\",{\"1\":{\"310\":1}}],[\"发现还有其他的应用在和你抢\",{\"1\":{\"717\":1}}],[\"发现是a就会执行修改\",{\"1\":{\"645\":1}}],[\"发现volatile多加了lock\",{\"1\":{\"637\":1,\"708\":1}}],[\"发现该节点是红黑树\",{\"1\":{\"556\":1,\"580\":1}}],[\"发现可以处理异常的代码时\",{\"1\":{\"537\":1}}],[\"发现编译器擦除\",{\"1\":{\"511\":1}}],[\"发现有\",{\"1\":{\"488\":4}}],[\"发现已经存在内容相同对象\",{\"1\":{\"488\":2}}],[\"发现\",{\"1\":{\"391\":1}}],[\"发现b还没有被create\",{\"1\":{\"281\":1}}],[\"发现自己依赖对象b\",{\"1\":{\"281\":1}}],[\"发出锁冲突的概率最高\",{\"1\":{\"114\":1}}],[\"发生异常会自动释放锁\",{\"1\":{\"647\":1}}],[\"发生冲突时\",{\"1\":{\"576\":1}}],[\"发生宕机\",{\"1\":{\"337\":1}}],[\"发生锁冲突的概率最低\",{\"1\":{\"114\":1}}],[\"发生改变\",{\"1\":{\"42\":1}}],[\"发起连接\",{\"1\":{\"403\":1}}],[\"发起一次socket连接请求\",{\"1\":{\"237\":1}}],[\"发起请求request\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"发起\",{\"1\":{\"38\":1}}],[\"发送锁释放消息\",{\"1\":{\"435\":1}}],[\"发送数gb大小的备份文件导致服务器出口带宽暴增\",{\"1\":{\"415\":1}}],[\"发送数据时\",{\"1\":{\"731\":1}}],[\"发送数据\",{\"1\":{\"237\":1,\"366\":1}}],[\"发送一个命令\",{\"1\":{\"403\":1}}],[\"发送失败后可以重试\",{\"1\":{\"369\":1}}],[\"发送结果是同步感知的\",{\"1\":{\"369\":1}}],[\"发送ack消息给client\",{\"1\":{\"359\":1}}],[\"发送到其中一个jvm内部的内存队列中\",{\"1\":{\"392\":1}}],[\"发送到\",{\"1\":{\"346\":1}}],[\"发送请求\",{\"1\":{\"237\":1,\"290\":1}}],[\"发送请求与得到response是共性\",{\"1\":{\"237\":1}}],[\"发送的request\",{\"1\":{\"223\":1}}],[\"发送给服务器\",{\"1\":{\"37\":1}}],[\"发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段\",{\"1\":{\"24\":1}}],[\"发送方维持一个叫做拥塞窗口cwnd\",{\"1\":{\"24\":1}}],[\"发送包的速率\",{\"1\":{\"23\":1}}],[\"发送\",{\"1\":{\"20\":1,\"425\":1}}],[\"本篇的\",{\"1\":{\"550\":1}}],[\"本文将对该问题进行解密\",{\"1\":{\"563\":1}}],[\"本文并没有讲到\",{\"1\":{\"561\":1}}],[\"本文汇总了常考的\",{\"1\":{\"545\":1}}],[\"本文档与代码都是本人第一次手写rpc的心路历程\",{\"1\":{\"206\":1}}],[\"本质是在告诉\",{\"1\":{\"646\":1}}],[\"本质上都会执行aqs的acquire方法\",{\"1\":{\"615\":1}}],[\"本质上多态分两种\",{\"1\":{\"465\":1}}],[\"本质也是对\",{\"1\":{\"549\":1,\"594\":1}}],[\"本质区别\",{\"1\":{\"30\":1}}],[\"本身无此功能\",{\"1\":{\"380\":1}}],[\"本机的映射表\",{\"1\":{\"251\":1}}],[\"本节问题\",{\"0\":{\"215\":1,\"222\":1,\"229\":1,\"236\":1,\"243\":1,\"250\":1,\"257\":1}}],[\"本隔离级别很少用于实际应用\",{\"1\":{\"102\":1}}],[\"本地内存无法共享\",{\"1\":{\"380\":1}}],[\"本地化\",{\"1\":{\"291\":1}}],[\"本地代理域名池\",{\"1\":{\"71\":1}}],[\"本地域名服务器查询自己的dns缓存\",{\"1\":{\"38\":1}}],[\"递归查询\",{\"1\":{\"38\":1}}],[\"维护成本高\",{\"1\":{\"418\":1}}],[\"维护了一个score的参数来实现\",{\"1\":{\"382\":1}}],[\"维护着一个\",{\"1\":{\"200\":1}}],[\"维护频率\",{\"1\":{\"57\":7}}],[\"维护一张域名与ip的对应表\",{\"1\":{\"38\":3}}],[\"维持和终止通信\",{\"1\":{\"8\":1}}],[\"随进程的结束而销毁\",{\"1\":{\"726\":1}}],[\"随时等待cpu调度执行\",{\"1\":{\"623\":1,\"690\":1}}],[\"随时准备应聘leader副本\",{\"1\":{\"339\":1}}],[\"随后\",{\"1\":{\"435\":1}}],[\"随着进程终止而消失\",{\"1\":{\"731\":1}}],[\"随着类的加载而加载\",{\"1\":{\"528\":1}}],[\"随着互联网的飞速发展\",{\"1\":{\"401\":1}}],[\"随着已发送的分组不断被确认\",{\"1\":{\"23\":1}}],[\"随机与轮询\",{\"1\":{\"260\":1}}],[\"随机负载均衡\",{\"1\":{\"258\":1}}],[\"随机选择一个proxyip\",{\"1\":{\"71\":2}}],[\"随机获取一台\",{\"1\":{\"46\":1}}],[\"随机法\",{\"1\":{\"46\":1}}],[\"随机码\",{\"1\":{\"37\":2}}],[\"完毕\",{\"1\":{\"404\":2}}],[\"完全消费正常后在进行手动ack确认\",{\"1\":{\"369\":1}}],[\"完全初始化之后将自己放入到一级缓存singletonobjects中\",{\"1\":{\"281\":1}}],[\"完善通用消息格式\",{\"1\":{\"212\":1}}],[\"完成尾节点的设置\",{\"1\":{\"607\":1}}],[\"完成initial前的自定义逻辑\",{\"1\":{\"276\":1}}],[\"完成以上创建之后就可以在应用里使用这个bean了\",{\"1\":{\"274\":1}}],[\"完成自身的业务逻辑\",{\"1\":{\"270\":1}}],[\"完成逻辑判断和动态拼接sql的功能\",{\"1\":{\"190\":1}}],[\"完成三次握手\",{\"1\":{\"11\":1}}],[\"完美解决了对称加密的密钥泄露问题\",{\"1\":{\"37\":1}}],[\"公式为\",{\"1\":{\"675\":1}}],[\"公平锁和非公平锁的释放流程都是一样的\",{\"1\":{\"617\":1}}],[\"公平锁\",{\"0\":{\"617\":1},\"1\":{\"680\":1}}],[\"公司为了使\",{\"1\":{\"510\":1}}],[\"公司信息和证书有效期等\",{\"1\":{\"37\":1}}],[\"公钥则是附带在证书的信息中\",{\"1\":{\"37\":1}}],[\"将线程池的配置放置在平台侧\",{\"1\":{\"720\":1}}],[\"将线程引用移出线程池就已经结束了线程销毁的部分\",{\"1\":{\"714\":1}}],[\"将线程和任务两者解耦\",{\"1\":{\"711\":1}}],[\"将任务的运行逻辑提交到执行器\",{\"1\":{\"711\":1}}],[\"将任务提交和任务执行进行解耦\",{\"1\":{\"711\":1}}],[\"将最新线程任务重新加入队列执行\",{\"1\":{\"670\":1}}],[\"将最新的数据备份到一个地方\",{\"1\":{\"105\":1}}],[\"将workqueue队首任务丢弃\",{\"1\":{\"670\":1}}],[\"将锁计数器设为0\",{\"1\":{\"651\":1}}],[\"将锁的级别控制在了更细粒度的哈希桶元素级别\",{\"1\":{\"584\":1}}],[\"将锁的级别控制在了更细粒度的哈希桶数组元素级别\",{\"1\":{\"546\":1}}],[\"将多个变量封装成对象\",{\"1\":{\"645\":1}}],[\"将prev的指针指向null\",{\"1\":{\"608\":1}}],[\"将new中node的prev指针指向pred\",{\"1\":{\"607\":1}}],[\"将暂时获取不到锁的线程加入到队列中\",{\"1\":{\"602\":1}}],[\"将共享资源设置为锁定状态\",{\"1\":{\"602\":1}}],[\"将当前进程的运行状态保存在文件里面\",{\"1\":{\"729\":1}}],[\"将当前线程写入队列中\",{\"1\":{\"617\":1}}],[\"将当前\",{\"1\":{\"585\":1}}],[\"将所有溢出数据统一放到溢出区\",{\"1\":{\"576\":1}}],[\"将哈希表分为公共表和溢出表\",{\"1\":{\"576\":1}}],[\"将哈希值相同的元素构成一个同义词的单链表\",{\"1\":{\"576\":1}}],[\"将e添加到数组末尾\",{\"1\":{\"573\":1}}],[\"将epoll作为i\",{\"1\":{\"377\":1}}],[\"将元素放在数组上\",{\"1\":{\"558\":1,\"581\":1}}],[\"将得到答案10000\",{\"1\":{\"555\":1}}],[\"将链表转换成红黑树前会判断\",{\"1\":{\"553\":1,\"575\":1}}],[\"将某个类序列化后存为文件\",{\"1\":{\"519\":1}}],[\"将程序内所有\",{\"1\":{\"506\":1}}],[\"将内存中的对象进行解析\",{\"1\":{\"502\":1}}],[\"将对象放入beanmap中\",{\"1\":{\"506\":1}}],[\"将对象重新转化为基本数据类型\",{\"1\":{\"494\":1}}],[\"将对象交给重载的方法去进行代理\",{\"1\":{\"200\":1}}],[\"将基本数据类型重新转化为对象\",{\"1\":{\"494\":1}}],[\"将包装类型转为基本类型\",{\"1\":{\"493\":1}}],[\"将s3对应的stringobject对象的地址保存到常量池中\",{\"1\":{\"488\":1}}],[\"将sql语句中的\",{\"1\":{\"201\":1}}],[\"将sql语句中\",{\"1\":{\"198\":1}}],[\"将sql语句配置在xxxxmapper\",{\"1\":{\"176\":1}}],[\"将找到的\",{\"1\":{\"488\":1}}],[\"将过期时间设置足够长\",{\"1\":{\"435\":1}}],[\"将其他slave切换成了master\",{\"1\":{\"423\":1}}],[\"将会把请求放入队列中排队\",{\"1\":{\"408\":1}}],[\"将这些连接分配给这些\",{\"1\":{\"404\":1}}],[\"将无效的key存放进redis中\",{\"1\":{\"395\":1}}],[\"将redis执行过的所有写指令记录下来\",{\"1\":{\"383\":1}}],[\"将该线程放入锁池\",{\"1\":{\"639\":1}}],[\"将该操作路由之后\",{\"1\":{\"392\":1}}],[\"将该操作记录串行地写入到binlog文件中\",{\"1\":{\"132\":1}}],[\"将该用户访问的数据存在缓存中\",{\"1\":{\"379\":1}}],[\"将消息存入对应的队列\",{\"1\":{\"357\":1}}],[\"将消息以\",{\"1\":{\"322\":1}}],[\"将预订\",{\"1\":{\"322\":1}}],[\"将向\",{\"1\":{\"322\":1}}],[\"将响应数据和页面封装成\",{\"1\":{\"299\":1}}],[\"将处理器\",{\"1\":{\"291\":1}}],[\"将它们装配在一起\",{\"1\":{\"264\":1}}],[\"将结果返回给客户端\",{\"1\":{\"216\":1}}],[\"将填充好变量值的类添加到结果集中\",{\"1\":{\"203\":1}}],[\"将已经封装sql语句的preparedstatememnt传入\",{\"1\":{\"198\":1}}],[\"将语句中的\",{\"1\":{\"198\":1}}],[\"将\",{\"1\":{\"172\":1,\"268\":1}}],[\"将查询需求频繁或者字段选择性高的列放在前面\",{\"1\":{\"153\":1}}],[\"将需要通过联合查询的数据插入到中间表中\",{\"1\":{\"140\":1}}],[\"将字段很多的表分解成多个表\",{\"1\":{\"140\":1}}],[\"将一个类声明为spring的\",{\"0\":{\"271\":1}}],[\"将一个大的系统分为多个小的系统\",{\"1\":{\"135\":1}}],[\"将一个用户的数据就放在一个表中\",{\"1\":{\"121\":1}}],[\"将数据转移到新的entry数组里\",{\"1\":{\"558\":1,\"581\":1}}],[\"将数据暂时写入本地缓存和磁盘中\",{\"1\":{\"424\":1}}],[\"将数据库中的所有key都存储在布隆过滤器中\",{\"1\":{\"395\":1}}],[\"将数据库中所有学生的成绩从具体分数改为\",{\"1\":{\"103\":1}}],[\"将数据定位到限定的表上去查\",{\"1\":{\"135\":1}}],[\"将数据保存到结果集中\",{\"1\":{\"88\":1,\"99\":1}}],[\"将小红的余额增加1000元\",{\"1\":{\"100\":1}}],[\"将小明的余额减少1000元\",{\"1\":{\"100\":1}}],[\"将aqs组合在自定义同步组件的实现中\",{\"1\":{\"678\":1}}],[\"将addressid转换为小写\",{\"1\":{\"71\":2}}],[\"将abortcontroller的信号量添加到fetch请求中\",{\"1\":{\"71\":1}}],[\"将空格\",{\"1\":{\"71\":1}}],[\"将不做域名判断\",{\"1\":{\"71\":1}}],[\"将请求按照顺序轮流的分配到服务器上\",{\"1\":{\"46\":1}}],[\"将用户的\",{\"1\":{\"42\":1}}],[\"将本地dns服务器将ip返回给操作系统\",{\"1\":{\"38\":1}}],[\"将证书传递给客户端\",{\"1\":{\"37\":1}}],[\"将网络层传下来的ip数据包组装成帧\",{\"1\":{\"8\":1}}],[\"私钥由服务端自己保存\",{\"1\":{\"37\":1}}],[\"颁发证书的同时会产生一个私钥和公钥\",{\"1\":{\"37\":1}}],[\"中垃圾回收线程就是特殊的守护线程\",{\"1\":{\"642\":1}}],[\"中引入\",{\"1\":{\"629\":1,\"696\":1}}],[\"中引入了枚举类型\",{\"1\":{\"450\":1}}],[\"中都存在\",{\"1\":{\"565\":1,\"566\":1,\"583\":2}}],[\"中扰动了\",{\"1\":{\"555\":1}}],[\"中有所差别\",{\"1\":{\"553\":1,\"575\":1}}],[\"中有以下规定\",{\"1\":{\"526\":1}}],[\"中采用cas+synchronized实现线程安全\",{\"1\":{\"549\":1,\"592\":1}}],[\"中采用分段锁实现线程安全\",{\"1\":{\"549\":1}}],[\"中concurrenthashmap\",{\"0\":{\"549\":1,\"591\":1}}],[\"中为什么使用内置锁\",{\"1\":{\"546\":1}}],[\"中也可以通过提升编译器的语法检查级别来产生警告或错误\",{\"1\":{\"536\":1}}],[\"中也是用到了适配器模式适配controller\",{\"1\":{\"286\":1}}],[\"中返回或者修改返回值会对程序造成很大的困扰\",{\"1\":{\"536\":1}}],[\"中修改了返回值\",{\"1\":{\"536\":1}}],[\"中改变返回值的做法是不好的\",{\"1\":{\"536\":1}}],[\"中除\",{\"1\":{\"531\":1}}],[\"中哪个部分可以省略\",{\"0\":{\"535\":1},\"1\":{\"484\":1}}],[\"中字符串是用类对象\",{\"1\":{\"443\":1}}],[\"中必须由程序释放内存资源\",{\"1\":{\"443\":1}}],[\"中没有数据\",{\"1\":{\"391\":1}}],[\"中挑选最不经常使用的数据淘汰\",{\"1\":{\"388\":1}}],[\"中挑选将要过期的数据淘汰\",{\"1\":{\"388\":1}}],[\"中任意选择数据淘汰\",{\"1\":{\"388\":2}}],[\"中间件\",{\"0\":{\"753\":1}}],[\"中间件协议\",{\"1\":{\"352\":1}}],[\"中间可能发生了a变b\",{\"1\":{\"645\":1}}],[\"中间还有2个匿名的new\",{\"1\":{\"488\":2}}],[\"中间某条指令的失败不会导致前面已做指令的回滚\",{\"1\":{\"407\":1}}],[\"中间层\",{\"1\":{\"354\":1}}],[\"中间人攻击依然有可能发生\",{\"1\":{\"36\":1}}],[\"中小型公司\",{\"1\":{\"350\":1}}],[\"中小型的项目\",{\"1\":{\"175\":1}}],[\"中慢慢拉取请求\",{\"1\":{\"348\":1}}],[\"中去\",{\"1\":{\"336\":1}}],[\"中我们可以指定订单\",{\"1\":{\"336\":1}}],[\"中顺序性\",{\"0\":{\"336\":1},\"1\":{\"335\":1}}],[\"中重新选举一个新的\",{\"1\":{\"323\":1}}],[\"中取出来数据的时候\",{\"1\":{\"336\":1}}],[\"中取出\",{\"1\":{\"316\":1}}],[\"中提供了\",{\"1\":{\"277\":1}}],[\"中使用它\",{\"1\":{\"277\":1}}],[\"中使用\",{\"1\":{\"272\":1,\"661\":1}}],[\"中添加解码器中使用自己定义的解码器\",{\"1\":{\"245\":1}}],[\"中不同库的日志\",{\"1\":{\"133\":1}}],[\"中这行数据的最后一个历史版本\",{\"1\":{\"112\":1}}],[\"中插入了一条数据\",{\"1\":{\"112\":1}}],[\"中会生成很多条语句\",{\"1\":{\"108\":1}}],[\"中禁止使用存储过程\",{\"1\":{\"98\":1}}],[\"中的任务\",{\"1\":{\"714\":1}}],[\"中的值是不确定的\",{\"1\":{\"646\":1}}],[\"中的key为什么也不能为\",{\"1\":{\"588\":1}}],[\"中的键往往都使用字符串的原因\",{\"1\":{\"560\":1,\"582\":1}}],[\"中的concurrenthashmap\",{\"1\":{\"546\":1,\"584\":1}}],[\"中的异常处理除了包括捕获异常和处理异常之外\",{\"1\":{\"532\":1}}],[\"中的描述\",{\"1\":{\"510\":1}}],[\"中的类\",{\"1\":{\"504\":1}}],[\"中的基本数据类型只有\",{\"1\":{\"489\":1}}],[\"中的基本单元是\",{\"1\":{\"283\":1}}],[\"中的自动强制类型转换\",{\"1\":{\"443\":1}}],[\"中的结构和联合\",{\"1\":{\"443\":1}}],[\"中的该\",{\"1\":{\"403\":1}}],[\"中的每个\",{\"1\":{\"364\":1}}],[\"中的交换器\",{\"1\":{\"353\":1}}],[\"中的领导者副本\",{\"0\":{\"339\":1}}],[\"中的数据会全部丢失\",{\"1\":{\"337\":1}}],[\"中的数据一定是有顺序的\",{\"1\":{\"336\":1}}],[\"中的数据可作为数据旧版本快照供其他并发事务进行快照读\",{\"1\":{\"107\":1}}],[\"中的请求应该包含处理它所需的所有细节\",{\"1\":{\"302\":1}}],[\"中的处理器的实现多变\",{\"1\":{\"291\":1}}],[\"中的单例\",{\"0\":{\"282\":1}}],[\"中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性\",{\"1\":{\"116\":1}}],[\"中的原记录\",{\"1\":{\"112\":1}}],[\"中的历史记录\",{\"1\":{\"112\":1}}],[\"中的\",{\"0\":{\"95\":1,\"269\":1,\"273\":1,\"307\":1},\"1\":{\"112\":1,\"269\":1,\"286\":1,\"546\":1,\"548\":1,\"585\":1,\"617\":3}}],[\"中的资源\",{\"1\":{\"38\":1}}],[\"中国移动用户注意\",{\"1\":{\"69\":1}}],[\"中导致信息被窃取\",{\"1\":{\"41\":1}}],[\"中保持一些常用变量信息\",{\"1\":{\"41\":1}}],[\"中获取\",{\"1\":{\"40\":1,\"296\":1}}],[\"中\",{\"0\":{\"536\":2,\"579\":1},\"1\":{\"40\":1,\"106\":1,\"112\":3,\"136\":1,\"181\":1,\"265\":1,\"283\":1,\"286\":1,\"327\":1,\"337\":2,\"342\":2,\"348\":1,\"403\":1,\"450\":1,\"484\":2,\"487\":1,\"493\":1,\"530\":1,\"546\":1,\"553\":2,\"555\":1,\"559\":1,\"565\":1,\"566\":1,\"575\":2,\"585\":1,\"639\":1,\"662\":1,\"711\":1}}],[\"中设定这个时间\",{\"1\":{\"31\":1}}],[\"比arraylist多了个同步化机制\",{\"1\":{\"570\":1}}],[\"比hashmap多了个线程安全\",{\"1\":{\"570\":1}}],[\"比\",{\"1\":{\"350\":1,\"447\":1,\"555\":1,\"648\":1,\"707\":1}}],[\"比对失败\",{\"1\":{\"316\":1}}],[\"比对成功\",{\"1\":{\"316\":1}}],[\"比例越大我们扫描的记录数越少\",{\"1\":{\"161\":1}}],[\"比较并替换\",{\"1\":{\"684\":1}}],[\"比较出名的有murmurhash\",{\"1\":{\"560\":1}}],[\"比较出名的就是阿里的\",{\"1\":{\"98\":1}}],[\"比较小的时候\",{\"1\":{\"555\":1}}],[\"比较这两个对象\",{\"1\":{\"476\":1}}],[\"比较该类的两个对象时\",{\"1\":{\"476\":1}}],[\"比较消耗资源\",{\"1\":{\"463\":1}}],[\"比较消耗性能\",{\"1\":{\"432\":1}}],[\"比较繁琐\",{\"1\":{\"412\":1,\"415\":1}}],[\"比较类\",{\"0\":{\"313\":1}}],[\"比较有优势\",{\"1\":{\"266\":1}}],[\"比较常见的包括\",{\"1\":{\"122\":1}}],[\"比较容易遭到不法获取\",{\"1\":{\"41\":1}}],[\"比如获得锁的线程从空队列中拿数据\",{\"1\":{\"677\":1}}],[\"比如下面method3经过锁粗化优化之后就和method4执行效率一样了\",{\"1\":{\"660\":1}}],[\"比如下面代码的method1和method2的执行效率是一样的\",{\"1\":{\"659\":1}}],[\"比如规定\",{\"1\":{\"627\":1,\"694\":1}}],[\"比如某个线程只有获得a锁和b锁\",{\"1\":{\"627\":1,\"694\":1}}],[\"比如某个key只允许一个线程查询数据和写缓存\",{\"1\":{\"394\":1,\"396\":1}}],[\"比如hashmap\",{\"1\":{\"598\":1}}],[\"比如比较特定字符\",{\"1\":{\"541\":1}}],[\"比如保存在文件中\",{\"1\":{\"518\":1}}],[\"比如final\",{\"1\":{\"473\":1}}],[\"比如from\",{\"1\":{\"161\":1}}],[\"比如单片机\",{\"1\":{\"463\":1}}],[\"比如主键和唯一索引等\",{\"1\":{\"432\":1}}],[\"比如有专门处理数据上送的线程池\",{\"1\":{\"718\":1}}],[\"比如有3个master\",{\"1\":{\"429\":1}}],[\"比如有些服务偶尔因为网络抖动或者服务正在上线而超时\",{\"1\":{\"398\":1}}],[\"比如常见的\",{\"1\":{\"417\":1}}],[\"比如缓存一般就几个g的话\",{\"1\":{\"413\":1}}],[\"比如缓存等\",{\"1\":{\"384\":1}}],[\"比如锁\",{\"1\":{\"399\":1}}],[\"比如因为特殊原因数据错误了\",{\"1\":{\"398\":1}}],[\"比如可用率低于90\",{\"1\":{\"398\":1}}],[\"比如可以参考日志级别设置预案\",{\"1\":{\"398\":1}}],[\"比如更新数据库成功了\",{\"1\":{\"393\":1}}],[\"比如发送失败了的原因可能是当前broker宕机了\",{\"1\":{\"369\":1}}],[\"比如程序问题\",{\"1\":{\"339\":1}}],[\"比如在订单\",{\"1\":{\"336\":1}}],[\"比如对于某一条数据\",{\"1\":{\"335\":1}}],[\"比如消费者刚处理完\",{\"1\":{\"332\":1}}],[\"比如用户处理器可以实现\",{\"1\":{\"291\":1}}],[\"比如beannameaware接口\",{\"1\":{\"274\":1}}],[\"比如由jdbc\",{\"1\":{\"263\":1}}],[\"比如表中已经有a的索引\",{\"1\":{\"161\":1}}],[\"比如ar是\",{\"1\":{\"340\":1}}],[\"比如a\",{\"1\":{\"154\":2,\"161\":2}}],[\"比如alter\",{\"1\":{\"89\":1}}],[\"比如我们在\",{\"1\":{\"677\":1}}],[\"比如我们在查字典的时候\",{\"1\":{\"146\":1}}],[\"比如我们经常使用的默认登录功能\",{\"1\":{\"41\":1}}],[\"比如每个表就固定在\",{\"1\":{\"121\":1}}],[\"比如按照用户\",{\"1\":{\"121\":1}}],[\"比如你单表都几千万数据了\",{\"1\":{\"121\":1}}],[\"比如\",{\"0\":{\"80\":1},\"1\":{\"92\":1,\"104\":1,\"142\":1,\"175\":2,\"230\":1,\"282\":1,\"349\":1,\"352\":1,\"417\":1,\"437\":2,\"519\":1,\"571\":1,\"574\":1,\"598\":1,\"648\":1,\"707\":1,\"726\":1}}],[\"比如两个事务操作\",{\"1\":{\"75\":1}}],[\"比如操作同一张表时\",{\"1\":{\"74\":1}}],[\"比如德国\",{\"1\":{\"65\":1}}],[\"比如go自带的处理器就具有转义功能\",{\"1\":{\"44\":1}}],[\"比如一个存在xss漏洞的论坛\",{\"1\":{\"44\":1}}],[\"比如说一定时间后执行任务或是每隔一定的时间执行一次任务\",{\"1\":{\"673\":1}}],[\"比如说把\",{\"1\":{\"493\":1}}],[\"比如说限制连接数等\",{\"1\":{\"141\":1}}],[\"比如说加索引\",{\"1\":{\"141\":1}}],[\"比如说\",{\"1\":{\"41\":1}}],[\"比如证书颁发机构信息\",{\"1\":{\"37\":1}}],[\"比如接收方在收到一个失序的报文段后就立即发出重复确认\",{\"1\":{\"24\":1}}],[\"比起同等http网站\",{\"1\":{\"36\":1}}],[\"谷歌曾在2014年8月份调整搜索引擎算法\",{\"1\":{\"36\":1}}],[\"改bug\",{\"1\":{\"371\":1}}],[\"改操作后\",{\"1\":{\"188\":1}}],[\"改内存参数\",{\"1\":{\"141\":1}}],[\"改\",{\"1\":{\"141\":1,\"147\":1}}],[\"改造的\",{\"1\":{\"127\":1}}],[\"改结束后发现还有一条记录没有改过来\",{\"1\":{\"103\":1}}],[\"改为处理其他事情\",{\"1\":{\"648\":1,\"707\":1}}],[\"改为\",{\"1\":{\"71\":1}}],[\"改变条件\",{\"1\":{\"732\":1}}],[\"改变数据库和表的结构\",{\"1\":{\"138\":1}}],[\"改变\",{\"1\":{\"36\":1}}],[\"改用拥塞避免算法\",{\"1\":{\"24\":1}}],[\"身份认证的网络协议\",{\"1\":{\"36\":1}}],[\"运算时\",{\"1\":{\"555\":1}}],[\"运算等价于对length取模\",{\"1\":{\"555\":1}}],[\"运算符导致的索引失效\",{\"0\":{\"167\":1}}],[\"运行策略\",{\"1\":{\"713\":1}}],[\"运行线程数\",{\"1\":{\"713\":1}}],[\"运行其run方法起到线程置换的效果\",{\"1\":{\"674\":1}}],[\"运行状态中的线程执行wait\",{\"1\":{\"623\":1,\"690\":1}}],[\"运行状态\",{\"1\":{\"623\":1,\"690\":1,\"712\":1}}],[\"运行callable任务可以拿到一个future对象\",{\"1\":{\"621\":1,\"688\":1}}],[\"运行结果\",{\"1\":{\"488\":1}}],[\"运行时才知道\",{\"1\":{\"510\":1}}],[\"运行时常量池\",{\"1\":{\"487\":1}}],[\"运行时异常\",{\"0\":{\"531\":1},\"1\":{\"484\":1}}],[\"运行时多态\",{\"1\":{\"465\":1}}],[\"运行的时候调用的是确定的方法\",{\"1\":{\"465\":1}}],[\"运行速度会相对来说慢一些\",{\"1\":{\"266\":1}}],[\"运行中发生故障\",{\"1\":{\"101\":1}}],[\"运行在\",{\"1\":{\"729\":1}}],[\"运行在ssl协议之上\",{\"1\":{\"35\":1}}],[\"运行在tcp协议之上\",{\"1\":{\"35\":1}}],[\"运输层\",{\"1\":{\"8\":1}}],[\"与信号量名字很相似的叫信号\",{\"1\":{\"731\":1}}],[\"与自定义同步器无关\",{\"1\":{\"615\":1}}],[\"与独占式相似\",{\"1\":{\"612\":1}}],[\"与hashmap迭代器是强一致性不同\",{\"1\":{\"590\":1}}],[\"与readexternal\",{\"1\":{\"522\":2}}],[\"与response格式\",{\"1\":{\"225\":1}}],[\"与equals\",{\"1\":{\"479\":1}}],[\"与expire和pexpire命令类似\",{\"1\":{\"387\":1}}],[\"与方法返回值和访问修饰符无关\",{\"1\":{\"466\":1}}],[\"与消费端处理能力相符\",{\"1\":{\"329\":1}}],[\"与传统消息系统之间的区别\",{\"0\":{\"325\":1}}],[\"与参数token比较\",{\"1\":{\"316\":1}}],[\"与服务端一致\",{\"1\":{\"237\":1}}],[\"与返回各种类型的数据\",{\"1\":{\"225\":1}}],[\"与调用的方法都特定\",{\"1\":{\"219\":1}}],[\"与sqltype枚举类比对\",{\"1\":{\"204\":1}}],[\"与程序代码的耦合\",{\"1\":{\"179\":1}}],[\"与jdbc相比\",{\"1\":{\"173\":1}}],[\"与表独占写锁\",{\"1\":{\"114\":1}}],[\"与你共同成长～\",{\"1\":{\"47\":1}}],[\"与\",{\"0\":{\"35\":1,\"406\":1,\"488\":1,\"516\":1,\"549\":1,\"572\":1},\"1\":{\"179\":1,\"251\":1,\"269\":1,\"447\":1,\"484\":1,\"548\":1}}],[\"与第二次挥手相同\",{\"1\":{\"16\":1}}],[\"既然说到了排队等候机制\",{\"1\":{\"614\":1}}],[\"既就是反射的使用阶段\",{\"1\":{\"505\":1}}],[\"既避免了重复header的传输\",{\"1\":{\"34\":1}}],[\"既简洁又能将概念阐述清楚\",{\"1\":{\"8\":1}}],[\"带来新的问题\",{\"1\":{\"728\":1,\"731\":1}}],[\"带着问题去写代码\",{\"1\":{\"206\":1}}],[\"带有大量信息\",{\"1\":{\"34\":1}}],[\"带宽优化及网络连接的使用\",{\"1\":{\"33\":1}}],[\"多进程竞争同个共享资源会造成数据的错乱\",{\"1\":{\"731\":1}}],[\"多余的worker在下次idel的时候也会被回收\",{\"1\":{\"721\":1}}],[\"多核时代多线程主要是为了提高\",{\"1\":{\"622\":1,\"689\":1}}],[\"多核时代\",{\"1\":{\"622\":1,\"689\":1}}],[\"多核\",{\"1\":{\"622\":1,\"689\":1}}],[\"多重散列\",{\"1\":{\"576\":1}}],[\"多次创建一个类的实例时\",{\"1\":{\"502\":1}}],[\"多次调用时x\",{\"1\":{\"476\":1}}],[\"多次读取的过程中\",{\"1\":{\"103\":1}}],[\"多次读取同一数据时\",{\"1\":{\"103\":1}}],[\"多次读取同一数据\",{\"1\":{\"103\":1}}],[\"多态性\",{\"1\":{\"464\":1}}],[\"多态性的特性\",{\"1\":{\"463\":1}}],[\"多态\",{\"1\":{\"442\":1}}],[\"多线程访问volatile关键字不会发生阻塞\",{\"1\":{\"709\":1}}],[\"多线程访问时候\",{\"1\":{\"549\":1,\"593\":1}}],[\"多线程基础\",{\"0\":{\"686\":1},\"1\":{\"686\":1}}],[\"多线程中\",{\"0\":{\"652\":1}}],[\"多线程总结\",{\"0\":{\"619\":1},\"1\":{\"619\":1}}],[\"多线程竞争的时候\",{\"1\":{\"602\":1}}],[\"多线程同时执行\",{\"1\":{\"565\":1,\"583\":1}}],[\"多线程的put可能导致元素的丢失\",{\"0\":{\"565\":1},\"1\":{\"583\":1}}],[\"多线程的实现机制\",{\"0\":{\"404\":1}}],[\"多线程下扩容死循环\",{\"0\":{\"564\":1},\"1\":{\"583\":1}}],[\"多线程下安全的操作\",{\"0\":{\"594\":1},\"1\":{\"549\":1}}],[\"多线程模型的对比\",{\"0\":{\"406\":1}}],[\"多线程任务可以分摊\",{\"1\":{\"401\":1}}],[\"多路指的是多个\",{\"1\":{\"403\":1}}],[\"多路复用器轮询到有连接io请求时才会启动一个线程进行处理\",{\"1\":{\"542\":1}}],[\"多路复用程序会将该事件压入队列中\",{\"1\":{\"403\":1}}],[\"多路复用程序会将这些事件放到一个队列中\",{\"1\":{\"403\":1}}],[\"多路复用程序才会继续向文件分派器传送下一个事件\",{\"1\":{\"403\":1}}],[\"多路复用程序监听着这些\",{\"1\":{\"403\":1}}],[\"多路复用程序\",{\"1\":{\"403\":1}}],[\"多路复用主要有三种技术\",{\"1\":{\"403\":1}}],[\"多路复用机制同时监听多个\",{\"1\":{\"403\":1}}],[\"多路复用来实现它的核心网络模型\",{\"1\":{\"399\":1}}],[\"多路复用\",{\"1\":{\"34\":1}}],[\"多语言客户端\",{\"1\":{\"352\":1}}],[\"多种协议\",{\"1\":{\"352\":1}}],[\"多列时各列之间用逗号分隔\",{\"1\":{\"159\":1}}],[\"多列值组成一个索引\",{\"1\":{\"79\":1,\"148\":1}}],[\"多表关联关系配置复杂\",{\"1\":{\"175\":1}}],[\"多表关联关系配置简单\",{\"1\":{\"175\":1}}],[\"多表关联返回全部列\",{\"1\":{\"138\":1}}],[\"多表查询等语法\",{\"1\":{\"124\":1}}],[\"多读场景\",{\"1\":{\"116\":1}}],[\"多了或少量行\",{\"1\":{\"103\":1}}],[\"多版本并发控制\",{\"1\":{\"102\":1}}],[\"多个线程可同时执行\",{\"1\":{\"680\":1}}],[\"多个线程可以共享同一个target对象\",{\"1\":{\"621\":1,\"688\":1}}],[\"多个线程对加锁时\",{\"1\":{\"666\":1}}],[\"多个线程操作这个变量的时候\",{\"1\":{\"663\":1}}],[\"多个线程同时被阻塞\",{\"1\":{\"625\":1,\"692\":1}}],[\"多个线程同时读一个资源\",{\"1\":{\"482\":1}}],[\"多个slave的数据和master的完全一样\",{\"1\":{\"439\":1}}],[\"多个从库负责读\",{\"1\":{\"439\":1}}],[\"多个业务使用同一套集群时\",{\"1\":{\"417\":1}}],[\"多个\",{\"1\":{\"403\":2}}],[\"多个读库更新缓存的请求串在同一个队列中是没意义的\",{\"1\":{\"392\":1}}],[\"多个项目之间可以共享\",{\"1\":{\"380\":1}}],[\"多个操作也支持事务\",{\"1\":{\"376\":1}}],[\"多个queue同时消费是无法绝对保证消息的有序性的\",{\"1\":{\"368\":1}}],[\"多个group同时消费一个topic时\",{\"1\":{\"364\":1}}],[\"多个消费者可以订阅同一队列\",{\"1\":{\"355\":1}}],[\"多个rabbitmq节点可以组成一个集群\",{\"1\":{\"352\":1}}],[\"多个实例共同订阅若干个主题\",{\"1\":{\"326\":1}}],[\"多个服务的注册\",{\"1\":{\"226\":1}}],[\"多个参数封装成map\",{\"1\":{\"183\":1}}],[\"多个用户一起看房是可以接受的\",{\"1\":{\"115\":1}}],[\"多个属性组合在一起也可以作为一个超键\",{\"1\":{\"93\":1}}],[\"多个并发事务之间要相互隔离\",{\"1\":{\"74\":1}}],[\"多台服务器以对称的方式组成一个服务器集合\",{\"1\":{\"46\":1}}],[\"多对一和多对多交互通信\",{\"1\":{\"9\":1}}],[\"要修改的更新值\",{\"1\":{\"644\":1}}],[\"要再次使用\",{\"1\":{\"519\":1}}],[\"要利用对象序列化运行远程主机上的服务\",{\"1\":{\"519\":1}}],[\"要弄清楚这两种方法的关系\",{\"1\":{\"479\":1}}],[\"要想再次获得锁就要再次触发获得锁操作\",{\"1\":{\"432\":1}}],[\"要想把类标识成可用于\",{\"1\":{\"271\":1}}],[\"要以每秒一次的频率确认master的确进入了主观下线状态\",{\"1\":{\"425\":1}}],[\"要提升\",{\"1\":{\"401\":1}}],[\"要使用redis的持久化\",{\"1\":{\"384\":1}}],[\"要注意\",{\"1\":{\"382\":1}}],[\"要是\",{\"1\":{\"349\":1}}],[\"要多考虑很多方面的问题\",{\"1\":{\"349\":1}}],[\"要不要把消息存起来\",{\"1\":{\"346\":1}}],[\"要不要重发\",{\"1\":{\"346\":1}}],[\"要开启二级缓存\",{\"1\":{\"188\":1}}],[\"要查找到结果集需要扫描读取的数据行数\",{\"1\":{\"157\":1}}],[\"要查询的所有字段都在索引中\",{\"1\":{\"136\":1}}],[\"要根据业务需求\",{\"1\":{\"154\":1}}],[\"要选择一个合理的sharding\",{\"1\":{\"135\":1}}],[\"要看场景\",{\"1\":{\"128\":1}}],[\"要么一致地返回true要么一致地返回false\",{\"1\":{\"476\":1}}],[\"要么同时在写\",{\"1\":{\"404\":1}}],[\"要么对超过特定阈值的页数进行sql改写\",{\"1\":{\"136\":1}}],[\"要么控制返回的总页数\",{\"1\":{\"136\":1}}],[\"要么全部不发生\",{\"1\":{\"101\":1}}],[\"要么全部失败回滚\",{\"1\":{\"74\":1}}],[\"要么都不做\",{\"1\":{\"101\":1}}],[\"要么都不执行\",{\"1\":{\"100\":1}}],[\"要么都要失败\",{\"1\":{\"100\":1}}],[\"要么都执行\",{\"1\":{\"100\":1}}],[\"要高\",{\"1\":{\"92\":1}}],[\"要好一些\",{\"1\":{\"41\":1}}],[\"要比http协议安全\",{\"1\":{\"36\":1}}],[\"要做到健壮性考虑的场景必然很多\",{\"1\":{\"34\":1}}],[\"要求每个\",{\"1\":{\"334\":1}}],[\"要求实体的属性完全依赖于主关键字\",{\"1\":{\"91\":1}}],[\"要求用隧道协议连接代理\",{\"1\":{\"29\":1}}],[\"要求在\",{\"1\":{\"18\":1}}],[\"基类\",{\"1\":{\"464\":1}}],[\"基本思想就是\",{\"1\":{\"576\":1}}],[\"基本上代码块分为三种\",{\"1\":{\"461\":1}}],[\"基本上可以断定这是一次\",{\"1\":{\"14\":1}}],[\"基本类型在栈中直接存储的具体数值\",{\"1\":{\"493\":1}}],[\"基本类型比包装类型更高效\",{\"1\":{\"493\":1}}],[\"基本类型是个特例\",{\"1\":{\"493\":1}}],[\"基本类型和包装类型的区别主要有以下\",{\"1\":{\"493\":1}}],[\"基本类型和包装类型有什么区别\",{\"0\":{\"493\":1},\"1\":{\"484\":1}}],[\"基本类型作为参数被传递时肯定是值传递\",{\"1\":{\"474\":1}}],[\"基本类型\",{\"1\":{\"449\":1,\"683\":1}}],[\"基本数据类型包括\",{\"1\":{\"449\":1}}],[\"基本数据类型和引用数据类型\",{\"1\":{\"449\":1}}],[\"基本不用\",{\"1\":{\"413\":1}}],[\"基本不丢\",{\"1\":{\"350\":1}}],[\"基本元数据类型\",{\"1\":{\"279\":1}}],[\"基本的版本大约2mb\",{\"1\":{\"263\":1}}],[\"基本概念\",{\"1\":{\"249\":1}}],[\"基本原理流程\",{\"1\":{\"132\":1}}],[\"基本没啥人用\",{\"1\":{\"123\":1}}],[\"基本是可以全部记下来但是由于很多操作\",{\"1\":{\"89\":1}}],[\"基础二\",{\"0\":{\"484\":1},\"1\":{\"484\":1}}],[\"基础语法\",{\"0\":{\"448\":1}}],[\"基础一\",{\"0\":{\"440\":1},\"1\":{\"440\":1}}],[\"基础架构研发实力较强\",{\"1\":{\"350\":1}}],[\"基础上\",{\"1\":{\"294\":1}}],[\"基础\",{\"0\":{\"72\":1,\"90\":1,\"171\":1},\"1\":{\"72\":1,\"90\":1,\"171\":1}}],[\"基于以上的思路\",{\"1\":{\"721\":1}}],[\"基于拷贝内容的优点是避免了concurrent\",{\"1\":{\"598\":1}}],[\"基于zookeeper\",{\"1\":{\"432\":1}}],[\"基于redis实现\",{\"1\":{\"432\":1}}],[\"基于关系型数据库实现分布式锁\",{\"1\":{\"432\":1}}],[\"基于关系型数据库\",{\"1\":{\"432\":1}}],[\"基于中间标记变量\",{\"1\":{\"412\":1}}],[\"基于lua脚本\",{\"1\":{\"412\":1}}],[\"基于主从架构实现高可用\",{\"1\":{\"350\":1}}],[\"基于mmap的索引和日志文件读写所用的transportlayer\",{\"1\":{\"341\":1}}],[\"基于静态代理方式实现\",{\"1\":{\"285\":1}}],[\"基于动态代理方式实现\",{\"1\":{\"285\":1}}],[\"基于注解配置\",{\"1\":{\"268\":1}}],[\"基于接口方法的透明远程过程调用\",{\"1\":{\"209\":1}}],[\"基于perpetualcache的hashmap本地缓存\",{\"1\":{\"188\":1}}],[\"基于sql语句编程\",{\"1\":{\"173\":1}}],[\"基于非唯一性索引的检索\",{\"1\":{\"162\":1}}],[\"基于一个范围的检索\",{\"1\":{\"162\":1}}],[\"基于hash表实现\",{\"1\":{\"150\":1}}],[\"基于哈希表实现\",{\"1\":{\"149\":1}}],[\"基于行的模式\",{\"1\":{\"108\":1}}],[\"基于\",{\"1\":{\"108\":1,\"127\":1,\"179\":1,\"268\":2,\"350\":1}}],[\"基于这种考虑http2\",{\"1\":{\"34\":1}}],[\"基于文本协议的格式解析存在天然缺陷\",{\"1\":{\"34\":1}}],[\"处理完毕时\",{\"1\":{\"639\":1}}],[\"处理某一行数据的时候一般会选择字符流\",{\"1\":{\"541\":1}}],[\"处理速度要快过其它的键对象\",{\"1\":{\"482\":1}}],[\"处理顺序可能是删除\",{\"1\":{\"335\":1}}],[\"处理器异常解析器\",{\"1\":{\"291\":1}}],[\"处理器的适配器\",{\"1\":{\"291\":1}}],[\"处理器执行链\",{\"1\":{\"291\":1}}],[\"处理器处理完业务后\",{\"1\":{\"290\":1}}],[\"处理循环依赖\",{\"1\":{\"281\":1}}],[\"处理任务的工作见workthread中\",{\"1\":{\"230\":1}}],[\"处理sql语句\",{\"1\":{\"198\":1}}],[\"处理列表\",{\"1\":{\"175\":1}}],[\"处理之后就返回给浏览器\",{\"1\":{\"38\":1}}],[\"处理\",{\"1\":{\"33\":1,\"226\":1,\"535\":1}}],[\"处于运行状态中的线程由于某种原因\",{\"1\":{\"623\":1,\"690\":1}}],[\"处于就绪状态的线程\",{\"1\":{\"623\":1,\"690\":1}}],[\"处于排队等候机制中的线程\",{\"1\":{\"614\":1}}],[\"处于\",{\"1\":{\"20\":1}}],[\"<<\",{\"1\":{\"559\":2}}],[\"<=\",{\"1\":{\"499\":1,\"728\":1}}],[\"<=>\",{\"1\":{\"150\":1}}],[\"<constructor\",{\"1\":{\"277\":1,\"279\":1}}],[\"<context\",{\"1\":{\"268\":1}}],[\"<version>5\",{\"1\":{\"251\":1}}],[\"<version>4\",{\"1\":{\"237\":1}}],[\"<groupid>org\",{\"1\":{\"251\":1}}],[\"<groupid>io\",{\"1\":{\"237\":1}}],[\"<dependency>\",{\"1\":{\"237\":1,\"251\":1}}],[\"<interfacename\",{\"1\":{\"229\":1}}],[\"<iframe\",{\"1\":{\"70\":1}}],[\"<update\",{\"1\":{\"205\":1}}],[\"<mapper\",{\"1\":{\"205\":1}}],[\"<meta\",{\"1\":{\"70\":16}}],[\"<e>\",{\"1\":{\"197\":2,\"198\":2,\"203\":2}}],[\"<t>t\",{\"1\":{\"223\":1}}],[\"<t>\",{\"1\":{\"194\":2,\"197\":4,\"200\":2}}],[\"<title>welcome\",{\"1\":{\"71\":1}}],[\"<title>edtunnel\",{\"1\":{\"70\":1}}],[\"<title>http响应示例<title>\",{\"1\":{\"32\":1}}],[\"<>\",{\"0\":{\"164\":1}}],[\"<size>选项控制\",{\"1\":{\"499\":1}}],[\"<select\",{\"1\":{\"205\":2}}],[\"<script>\",{\"1\":{\"70\":1}}],[\"<style>\",{\"1\":{\"70\":1,\"71\":1}}],[\"<link\",{\"1\":{\"70\":1}}],[\"<artifactid>curator\",{\"1\":{\"251\":1}}],[\"<artifactid>netty\",{\"1\":{\"237\":1}}],[\"<a\",{\"1\":{\"70\":9,\"71\":2}}],[\"<property>\",{\"1\":{\"277\":1,\"279\":1}}],[\"<property\",{\"1\":{\"268\":1,\"277\":3}}],[\"<pre>$\",{\"1\":{\"70\":1}}],[\"<pre\",{\"1\":{\"70\":1}}],[\"<p><em>thank\",{\"1\":{\"71\":1}}],[\"<p>for\",{\"1\":{\"71\":1}}],[\"<p>if\",{\"1\":{\"71\":1}}],[\"<p\",{\"1\":{\"70\":1}}],[\"<bean>\",{\"1\":{\"277\":1}}],[\"<beans>\",{\"1\":{\"268\":1}}],[\"<bean\",{\"1\":{\"268\":2,\"277\":2}}],[\"<br\",{\"1\":{\"71\":1}}],[\"<b\",{\"1\":{\"70\":2}}],[\"<button\",{\"1\":{\"70\":2}}],[\"<body>\",{\"1\":{\"32\":1,\"70\":2,\"71\":1}}],[\"<\",{\"0\":{\"513\":1},\"1\":{\"32\":3,\"69\":5,\"70\":15,\"71\":13,\"84\":1,\"154\":1,\"157\":6,\"161\":1,\"202\":1,\"205\":5,\"237\":1,\"244\":1,\"251\":2,\"268\":3,\"277\":4,\"484\":1,\"499\":1,\"506\":1,\"555\":1,\"556\":1,\"558\":1,\"559\":4,\"573\":1,\"581\":1,\"612\":1,\"616\":1,\"617\":1,\"713\":2,\"728\":1}}],[\"<h1>welcome\",{\"1\":{\"71\":1}}],[\"<head>\",{\"1\":{\"32\":1,\"70\":1,\"71\":1}}],[\"<html>\",{\"1\":{\"32\":1,\"70\":2,\"71\":1}}],[\"lseek\",{\"1\":{\"731\":1}}],[\"l\",{\"1\":{\"449\":1}}],[\"lpop\",{\"1\":{\"405\":1}}],[\"lpush\",{\"1\":{\"405\":1}}],[\"lpush可以在列表头部插入一个内容id作为关键字\",{\"1\":{\"381\":1}}],[\"lua\",{\"1\":{\"405\":1,\"435\":1}}],[\"luxury\",{\"1\":{\"70\":1}}],[\"lfu\",{\"1\":{\"388\":3}}],[\"lru\",{\"1\":{\"388\":3}}],[\"ltrim可用来限制列表的数量\",{\"1\":{\"381\":1}}],[\"lgn\",{\"1\":{\"80\":1}}],[\"lzurl\",{\"1\":{\"71\":1}}],[\"less\",{\"1\":{\"553\":1,\"720\":1}}],[\"least\",{\"1\":{\"388\":2}}],[\"leader就是3\",{\"1\":{\"340\":1}}],[\"leader必须要变更\",{\"1\":{\"340\":1}}],[\"leader是1\",{\"1\":{\"340\":1}}],[\"leader选举时\",{\"1\":{\"340\":1}}],[\"leader选举\",{\"1\":{\"340\":5}}],[\"leader才commit\",{\"1\":{\"330\":1}}],[\"leader\",{\"0\":{\"339\":1},\"1\":{\"323\":13,\"333\":1,\"334\":7,\"340\":1,\"342\":1}}],[\"leading\",{\"1\":{\"70\":2}}],[\"len\",{\"1\":{\"157\":1}}],[\"length=15\",{\"1\":{\"555\":1}}],[\"lengthfieldprepender\",{\"1\":{\"237\":1}}],[\"lengthfieldbasedframedecoder\",{\"1\":{\"237\":1}}],[\"lengthbuffer\",{\"1\":{\"69\":2,\"70\":2}}],[\"length\",{\"1\":{\"32\":1,\"69\":5,\"70\":6,\"71\":12,\"202\":1,\"204\":2,\"244\":5,\"313\":2,\"499\":1,\"506\":1,\"554\":1,\"555\":10,\"556\":3,\"558\":3,\"559\":1,\"573\":2,\"578\":1,\"579\":3,\"581\":3}}],[\"left\",{\"1\":{\"155\":1}}],[\"level\",{\"1\":{\"92\":2,\"110\":1,\"114\":2}}],[\"let\",{\"1\":{\"69\":24,\"70\":29,\"71\":55}}],[\"leilei223\",{\"1\":{\"60\":1}}],[\"lifo\",{\"1\":{\"672\":1}}],[\"light\",{\"1\":{\"620\":1,\"687\":1}}],[\"lixuwu\",{\"1\":{\"544\":1}}],[\"listiteror可以向集合添加元素\",{\"1\":{\"597\":1}}],[\"listiterator可以使用set\",{\"1\":{\"597\":1}}],[\"listiterator\",{\"0\":{\"597\":1}}],[\"list代表了有序可重复集合\",{\"1\":{\"569\":1}}],[\"list等映射到不同的节点\",{\"1\":{\"417\":1}}],[\"list等数据结构\",{\"1\":{\"376\":1}}],[\"list是一个有序可重复的集合\",{\"1\":{\"382\":1}}],[\"list<integer>\",{\"1\":{\"493\":1}}],[\"list<int>\",{\"1\":{\"493\":1}}],[\"list<\",{\"0\":{\"513\":1},\"1\":{\"484\":1,\"513\":1}}],[\"list<string>\",{\"1\":{\"251\":1,\"258\":4,\"514\":1,\"560\":1}}],[\"list<object>\",{\"1\":{\"244\":1,\"514\":1}}],[\"list<mapperstatement>\",{\"1\":{\"204\":1}}],[\"list<t>\",{\"1\":{\"197\":1}}],[\"list<e>\",{\"1\":{\"197\":2,\"198\":2,\"203\":3}}],[\"list<book>\",{\"1\":{\"193\":1,\"205\":1}}],[\"listfiles\",{\"1\":{\"196\":1}}],[\"list指出对哪些列进行索引\",{\"1\":{\"159\":1}}],[\"list\",{\"1\":{\"159\":2,\"194\":2,\"197\":3,\"203\":1,\"204\":1,\"313\":1,\"378\":1,\"382\":2,\"399\":1,\"438\":2,\"493\":2,\"510\":6,\"515\":2,\"553\":1,\"560\":6,\"569\":1,\"597\":1,\"630\":1,\"698\":1}}],[\"list=false\",{\"1\":{\"70\":1,\"71\":2}}],[\"like\",{\"1\":{\"84\":1,\"154\":1,\"156\":6,\"161\":1,\"169\":1}}],[\"liepin\",{\"1\":{\"70\":2}}],[\"live\",{\"1\":{\"70\":3}}],[\"libs\",{\"1\":{\"70\":1}}],[\"library\",{\"1\":{\"70\":2,\"284\":1}}],[\"linux\",{\"1\":{\"399\":1,\"401\":1,\"463\":1,\"661\":1,\"726\":1,\"729\":1,\"731\":1}}],[\"lines\",{\"1\":{\"71\":8}}],[\"line\",{\"1\":{\"70\":2,\"71\":2}}],[\"linkedblockingqueue\",{\"1\":{\"673\":3,\"721\":1}}],[\"linkedblockingqueue等\",{\"1\":{\"670\":1}}],[\"linkedlist\",{\"0\":{\"571\":1},\"1\":{\"569\":1,\"570\":1,\"571\":4}}],[\"links\",{\"1\":{\"71\":2}}],[\"link\",{\"1\":{\"60\":1,\"61\":1,\"64\":1,\"70\":2,\"71\":11}}],[\"linshiyouxiang\",{\"1\":{\"60\":1,\"65\":1}}],[\"limit\",{\"1\":{\"52\":1,\"69\":1,\"70\":1,\"136\":3}}],[\"lotail\",{\"1\":{\"559\":6}}],[\"lohead\",{\"1\":{\"559\":3}}],[\"lookup\",{\"1\":{\"554\":1,\"578\":1}}],[\"low\",{\"1\":{\"499\":6}}],[\"loweraddressid\",{\"1\":{\"71\":4}}],[\"longpollingenable\",{\"1\":{\"365\":1}}],[\"long\",{\"0\":{\"450\":1},\"1\":{\"200\":1,\"230\":1,\"449\":3,\"450\":1,\"489\":1,\"493\":2,\"594\":1,\"612\":1,\"616\":1,\"627\":1,\"633\":1,\"639\":1,\"669\":1,\"684\":1,\"694\":1,\"697\":1,\"701\":1}}],[\"loading\",{\"1\":{\"717\":2}}],[\"loadfactor\",{\"1\":{\"554\":1,\"558\":1,\"559\":1,\"578\":1,\"581\":1}}],[\"loadclass\",{\"1\":{\"533\":1}}],[\"loadbalance\",{\"1\":{\"258\":3}}],[\"loadmappersinfo\",{\"1\":{\"194\":1,\"196\":4}}],[\"load1000000\",{\"1\":{\"136\":1}}],[\"load\",{\"1\":{\"108\":1,\"136\":1,\"195\":2,\"554\":5,\"559\":1,\"578\":5}}],[\"lock方法一旦获取了独占锁\",{\"1\":{\"714\":1}}],[\"lockinterruptibly\",{\"1\":{\"648\":1,\"707\":1}}],[\"locking\",{\"1\":{\"92\":2,\"114\":2}}],[\"lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主内存中\",{\"1\":{\"637\":1,\"708\":1}}],[\"lock是抽象方法\",{\"1\":{\"615\":1}}],[\"lock函数通过acquire方法进行加锁\",{\"1\":{\"614\":1}}],[\"locks\",{\"1\":{\"604\":1,\"605\":3,\"607\":1}}],[\"lock\",{\"0\":{\"647\":1},\"1\":{\"435\":1,\"436\":1,\"601\":1,\"605\":1,\"616\":2,\"617\":4,\"639\":2,\"647\":3,\"648\":1,\"677\":2,\"707\":1}}],[\"lock都是我们经常使用的\",{\"1\":{\"431\":1}}],[\"location=com\",{\"1\":{\"205\":1}}],[\"location\",{\"1\":{\"196\":2,\"204\":2}}],[\"localvariable\",{\"1\":{\"663\":1}}],[\"localeresolver\",{\"1\":{\"291\":1}}],[\"local\",{\"1\":{\"70\":2}}],[\"localhost\",{\"1\":{\"32\":1,\"205\":1,\"506\":1}}],[\"logn\",{\"1\":{\"549\":1,\"553\":2,\"575\":1,\"577\":1,\"591\":1}}],[\"login\",{\"1\":{\"318\":2}}],[\"log中的语句\",{\"1\":{\"132\":1}}],[\"log中\",{\"1\":{\"132\":1}}],[\"logging\",{\"1\":{\"69\":1,\"70\":4}}],[\"log\",{\"0\":{\"106\":1,\"107\":1},\"1\":{\"53\":1,\"69\":28,\"70\":30,\"71\":8,\"80\":1,\"104\":5,\"105\":4,\"106\":2,\"107\":1,\"112\":5,\"132\":2,\"133\":2,\"399\":1}}],[\"layer\",{\"1\":{\"354\":2}}],[\"layout\",{\"1\":{\"5\":1}}],[\"layouts\",{\"0\":{\"5\":1}}],[\"lag参数的值\",{\"1\":{\"424\":1}}],[\"lag默认情况下是10\",{\"1\":{\"424\":1}}],[\"lag\",{\"1\":{\"338\":3,\"424\":1}}],[\"label\",{\"1\":{\"204\":2}}],[\"last\",{\"1\":{\"159\":2}}],[\"lastname\",{\"1\":{\"156\":2}}],[\"largest\",{\"1\":{\"70\":2}}],[\"large\",{\"1\":{\"70\":1,\"553\":1}}],[\"landin\",{\"1\":{\"602\":1}}],[\"lanzhupi\",{\"1\":{\"544\":1}}],[\"lanzouw\",{\"1\":{\"64\":1,\"68\":2}}],[\"lang\",{\"1\":{\"454\":1,\"499\":2,\"503\":1,\"504\":3,\"507\":1,\"530\":1,\"534\":15,\"560\":1}}],[\"lang=zh\",{\"1\":{\"71\":1}}],[\"language\",{\"1\":{\"32\":1,\"175\":1}}],[\"gc\",{\"1\":{\"454\":1,\"612\":1}}],[\"gplv2\",{\"1\":{\"447\":1}}],[\"globalcorsconfig\",{\"0\":{\"319\":1},\"1\":{\"319\":1}}],[\"global\",{\"1\":{\"269\":1,\"272\":3}}],[\"glassdoor\",{\"1\":{\"62\":1}}],[\"grow\",{\"1\":{\"573\":3}}],[\"groupid>\",{\"1\":{\"237\":1,\"251\":1}}],[\"group\",{\"1\":{\"70\":3,\"237\":2,\"326\":1,\"364\":3}}],[\"greater\",{\"1\":{\"554\":1,\"578\":1}}],[\"granularity\",{\"1\":{\"553\":1}}],[\"grpc都是使用netty底层进行通信的\",{\"1\":{\"236\":1}}],[\"guava\",{\"0\":{\"380\":1}}],[\"guancha\",{\"1\":{\"70\":2}}],[\"guid\",{\"1\":{\"69\":1,\"70\":1}}],[\"ganghuan\",{\"1\":{\"230\":4}}],[\"gadgets\",{\"1\":{\"70\":1}}],[\"game\",{\"1\":{\"70\":2}}],[\"gamer\",{\"1\":{\"62\":2}}],[\"gamfc\",{\"1\":{\"69\":2}}],[\"ghbtns\",{\"1\":{\"70\":1}}],[\"g\",{\"1\":{\"69\":2,\"70\":2,\"71\":2,\"380\":2}}],[\"geospatial\",{\"1\":{\"382\":3}}],[\"general\",{\"1\":{\"554\":1,\"578\":1}}],[\"generation\",{\"1\":{\"284\":1}}],[\"generating\",{\"1\":{\"70\":1}}],[\"generatedmethodaccessor1\",{\"1\":{\"507\":1}}],[\"generatetoken\",{\"1\":{\"316\":1}}],[\"generates\",{\"1\":{\"70\":1}}],[\"generate\",{\"1\":{\"69\":1,\"70\":1}}],[\"genericjackson2jsonredisserializer\",{\"1\":{\"314\":1}}],[\"getexclusiveownerthread\",{\"1\":{\"616\":1,\"617\":2}}],[\"get方法不需要加锁与volatile修饰的哈希桶有关吗\",{\"0\":{\"587\":1}}],[\"get方式提交的数据有长度限制\",{\"1\":{\"30\":1}}],[\"getwritemethod\",{\"1\":{\"506\":1}}],[\"getwriter\",{\"1\":{\"69\":3,\"70\":3}}],[\"getheader\",{\"1\":{\"317\":2}}],[\"gethostname\",{\"1\":{\"251\":2}}],[\"getvalueserializer\",{\"1\":{\"314\":1}}],[\"getvlessconfig\",{\"1\":{\"69\":2}}],[\"getbody\",{\"1\":{\"316\":1}}],[\"getbeaninfo\",{\"1\":{\"506\":1}}],[\"getbean\",{\"1\":{\"270\":1}}],[\"getblogbyid\",{\"1\":{\"230\":2,\"231\":1}}],[\"getpricemethod\",{\"1\":{\"505\":2}}],[\"getprice\",{\"1\":{\"505\":4}}],[\"getproxy\",{\"1\":{\"223\":2,\"231\":1,\"237\":1}}],[\"getpropertydescriptors\",{\"1\":{\"506\":1}}],[\"getproperty\",{\"1\":{\"196\":2,\"198\":4}}],[\"getport\",{\"1\":{\"251\":2}}],[\"getparametertypes\",{\"1\":{\"223\":1}}],[\"getparams\",{\"1\":{\"223\":1,\"230\":1,\"237\":1,\"244\":4}}],[\"getparamstypes\",{\"1\":{\"223\":1,\"230\":1,\"237\":1,\"244\":2}}],[\"getinputstream\",{\"1\":{\"216\":2,\"223\":2,\"230\":1,\"237\":1,\"251\":1}}],[\"getinterfaces\",{\"1\":{\"230\":1,\"251\":1}}],[\"getinterfacename\",{\"1\":{\"229\":1,\"230\":1,\"237\":1,\"251\":1}}],[\"getint\",{\"1\":{\"203\":1,\"536\":2}}],[\"getoutputstream\",{\"1\":{\"216\":2,\"223\":2,\"230\":1,\"237\":1,\"251\":1}}],[\"getobject拿到a对象\",{\"1\":{\"281\":1}}],[\"getobject\",{\"1\":{\"203\":1}}],[\"getunsafe\",{\"1\":{\"684\":1}}],[\"getusernamefromtoken\",{\"1\":{\"316\":2}}],[\"getuserbyuserid\",{\"1\":{\"215\":1,\"216\":3,\"223\":2,\"237\":1}}],[\"getuint16\",{\"1\":{\"69\":3,\"70\":3}}],[\"gettask\",{\"1\":{\"714\":2}}],[\"gettext\",{\"1\":{\"506\":4}}],[\"getters\",{\"1\":{\"277\":2}}],[\"getter\",{\"1\":{\"205\":1}}],[\"gettype\",{\"1\":{\"203\":2,\"244\":4}}],[\"getruntime\",{\"1\":{\"230\":1,\"675\":1}}],[\"getrootelement\",{\"1\":{\"204\":1,\"506\":1}}],[\"getreturntype\",{\"1\":{\"200\":1}}],[\"getresponse\",{\"1\":{\"230\":2,\"237\":2}}],[\"getresulttype\",{\"1\":{\"199\":1,\"203\":2}}],[\"getresource\",{\"1\":{\"196\":1}}],[\"getresourceasstream\",{\"1\":{\"195\":2,\"506\":1}}],[\"getstate\",{\"1\":{\"604\":1,\"616\":1,\"617\":2}}],[\"getstringvalue\",{\"1\":{\"204\":1}}],[\"getstring\",{\"1\":{\"203\":2}}],[\"getsavedproperty\",{\"1\":{\"499\":1}}],[\"getsubject\",{\"1\":{\"316\":1}}],[\"getserializerbycode\",{\"1\":{\"244\":2}}],[\"getserviceaddress\",{\"1\":{\"251\":2}}],[\"getservice\",{\"1\":{\"230\":1,\"237\":1,\"251\":1}}],[\"getsqltype\",{\"1\":{\"199\":1,\"200\":1}}],[\"getsql\",{\"1\":{\"199\":1,\"201\":1}}],[\"getsqlid\",{\"1\":{\"198\":2,\"199\":1}}],[\"getdatatype\",{\"1\":{\"244\":1}}],[\"getdata\",{\"1\":{\"223\":1,\"237\":1,\"244\":2,\"251\":1}}],[\"getdate\",{\"1\":{\"70\":1}}],[\"getdeclaredfield\",{\"1\":{\"684\":1}}],[\"getdeclaredfields\",{\"1\":{\"203\":2}}],[\"getdeclaringclass\",{\"1\":{\"200\":1,\"223\":1}}],[\"getchildren\",{\"1\":{\"251\":1,\"258\":1}}],[\"getcode\",{\"1\":{\"244\":4}}],[\"getcontextclassloader\",{\"1\":{\"506\":1}}],[\"getconstructor\",{\"1\":{\"505\":2}}],[\"getconnectionfactory\",{\"1\":{\"314\":1}}],[\"getconnection\",{\"1\":{\"198\":3,\"506\":1}}],[\"getconfiguration\",{\"1\":{\"197\":2,\"200\":1}}],[\"getclass\",{\"1\":{\"202\":3,\"203\":2,\"223\":1,\"230\":3,\"237\":1,\"244\":3,\"251\":1,\"503\":2,\"516\":2}}],[\"getclassloader\",{\"1\":{\"196\":1,\"200\":1,\"223\":1}}],[\"getnamespace\",{\"1\":{\"199\":1}}],[\"getname\",{\"1\":{\"196\":5,\"200\":2,\"203\":4,\"204\":2,\"223\":2,\"230\":2,\"251\":2,\"506\":1,\"521\":1,\"522\":1}}],[\"getfile\",{\"1\":{\"196\":1}}],[\"getfullyear\",{\"1\":{\"70\":1}}],[\"getmapping\",{\"0\":{\"295\":1},\"1\":{\"295\":2}}],[\"getmapper方法\",{\"1\":{\"197\":1}}],[\"getmapperstatement\",{\"1\":{\"197\":3,\"198\":2,\"200\":1}}],[\"getmapper时需注意\",{\"1\":{\"194\":1}}],[\"getmapper\",{\"1\":{\"193\":1,\"194\":3,\"197\":3,\"200\":1}}],[\"getmethodname\",{\"1\":{\"223\":1,\"230\":1,\"237\":1}}],[\"getmethod\",{\"1\":{\"223\":1,\"230\":1,\"237\":1,\"505\":3,\"507\":1}}],[\"getmonth\",{\"1\":{\"70\":1}}],[\"getaddressescsv\",{\"1\":{\"71\":3}}],[\"getaddressesapi\",{\"1\":{\"71\":3}}],[\"getapiresponse\",{\"1\":{\"69\":1}}],[\"getวเลสconfig\",{\"1\":{\"70\":2}}],[\"get和post最大的区别主要是get请求是幂等性的\",{\"1\":{\"30\":1}}],[\"get使用url或cookie传参\",{\"1\":{\"30\":1}}],[\"get请求和post请求的区别\",{\"0\":{\"30\":1}}],[\"get理解为客户端对服务端的增删改查\",{\"1\":{\"29\":1}}],[\"get\",{\"0\":{\"1\":1,\"586\":1},\"1\":{\"27\":1,\"29\":2,\"32\":1,\"69\":3,\"70\":6,\"71\":12,\"194\":1,\"197\":1,\"200\":1,\"229\":1,\"230\":2,\"237\":1,\"251\":2,\"258\":2,\"295\":2,\"301\":1,\"316\":1,\"317\":1,\"319\":1,\"402\":1,\"510\":2,\"547\":4,\"548\":3,\"554\":1,\"560\":3,\"564\":1,\"578\":1,\"586\":1,\"588\":3,\"669\":2,\"697\":3,\"721\":1}}],[\"gitee\",{\"1\":{\"682\":1}}],[\"github\",{\"1\":{\"60\":1,\"68\":3,\"69\":2,\"70\":10,\"71\":2,\"343\":1,\"435\":1,\"685\":1}}],[\"githubusercontent\",{\"1\":{\"57\":1,\"58\":2,\"71\":6}}],[\"give\",{\"1\":{\"70\":1}}],[\"given\",{\"1\":{\"69\":1,\"70\":2}}],[\"gif\",{\"1\":{\"32\":1}}],[\"good\",{\"1\":{\"554\":1,\"578\":1}}],[\"google\",{\"1\":{\"52\":1,\"69\":1,\"70\":2}}],[\"goto\",{\"1\":{\"443\":3}}],[\"going\",{\"1\":{\"399\":1}}],[\"gongyi\",{\"1\":{\"70\":1}}],[\"gone\",{\"1\":{\"33\":1}}],[\"go\",{\"1\":{\"69\":1,\"70\":1,\"268\":1}}],[\"gov\",{\"1\":{\"62\":1}}],[\"godns\",{\"1\":{\"57\":1}}],[\"gmt\",{\"1\":{\"32\":1}}],[\"gzip\",{\"1\":{\"32\":1,\"71\":1}}],[\"实时的消息订阅机制\",{\"1\":{\"362\":1}}],[\"实体类实现comparable接口\",{\"1\":{\"596\":1}}],[\"实体类\",{\"0\":{\"199\":1},\"1\":{\"203\":1}}],[\"实例的时候只能限定\",{\"1\":{\"511\":1}}],[\"实例发送一个\",{\"1\":{\"425\":1}}],[\"实例都消费一遍\",{\"1\":{\"364\":1}}],[\"实例平均消费这个\",{\"1\":{\"362\":1}}],[\"实例消费这个\",{\"1\":{\"362\":1}}],[\"实例\",{\"1\":{\"269\":2}}],[\"实例化异常\",{\"1\":{\"534\":1}}],[\"实例化错误\",{\"1\":{\"534\":1}}],[\"实例化\",{\"1\":{\"281\":1}}],[\"实例化bean对象\",{\"1\":{\"274\":1}}],[\"实例化resultsethandler\",{\"1\":{\"198\":1}}],[\"实例化parameterhandler\",{\"1\":{\"198\":1}}],[\"实例化statementhandler对象\",{\"1\":{\"198\":1}}],[\"实例或者介质失败\",{\"1\":{\"105\":1}}],[\"实际开发中使用\",{\"1\":{\"709\":1}}],[\"实际是操作自己本地内存里面的变量\",{\"1\":{\"663\":1}}],[\"实际存在堆中\",{\"1\":{\"488\":1}}],[\"实际释放的线程\",{\"1\":{\"435\":1}}],[\"实际生产中\",{\"1\":{\"416\":1}}],[\"实际生产用\",{\"1\":{\"128\":1}}],[\"实际应用中要考虑的细节要更多\",{\"1\":{\"381\":1}}],[\"实际应用sql变化的可能较大\",{\"1\":{\"176\":1}}],[\"实际上不仅用于不同的主机进程间通信\",{\"1\":{\"731\":1}}],[\"实际上不应通过阻塞\",{\"1\":{\"237\":1}}],[\"实际上是缓存在内核中的\",{\"1\":{\"725\":1}}],[\"实际上就是concurrenthashmap中的分段锁个数\",{\"1\":{\"548\":1}}],[\"实际上就变为两个int变量的比较\",{\"1\":{\"497\":1}}],[\"实际上编译器不仅关注一个泛型方法的调用\",{\"1\":{\"511\":1}}],[\"实际上编译器会正常的将使用泛型的地方编译并进行类型擦除\",{\"1\":{\"511\":1}}],[\"实际上更加具体的选择单线程的原因如下\",{\"1\":{\"399\":1}}],[\"实际上在有两个同步机制\",{\"1\":{\"133\":1}}],[\"实质上是tcp协议的长连接和短连接\",{\"1\":{\"31\":1}}],[\"实现中调用\",{\"1\":{\"733\":1}}],[\"实现线程池参数可动态配置和即时生效\",{\"1\":{\"719\":1}}],[\"实现它的抽象方法来管理同步状态\",{\"1\":{\"609\":1}}],[\"实现原理\",{\"0\":{\"546\":1}}],[\"实现相同的conponent\",{\"1\":{\"543\":1}}],[\"实现相邻节点间比特流的透明传输\",{\"1\":{\"8\":1}}],[\"实现target接口\",{\"1\":{\"543\":2}}],[\"实现externalizable接口\",{\"1\":{\"523\":1}}],[\"实现serializable接口\",{\"1\":{\"523\":1}}],[\"实现serializable接口或者externalizable接口\",{\"1\":{\"520\":1}}],[\"实现serialize接口\",{\"1\":{\"246\":1}}],[\"实现一些扩展的功能\",{\"1\":{\"506\":1}}],[\"实现分布式锁目前有三种流行方案\",{\"1\":{\"432\":1}}],[\"实现高可用性\",{\"1\":{\"419\":1}}],[\"实现复杂\",{\"1\":{\"418\":1}}],[\"实现起来相对复杂\",{\"1\":{\"416\":1}}],[\"实现controller自选举\",{\"1\":{\"327\":1}}],[\"实现共同消费\",{\"1\":{\"326\":1}}],[\"实现配置文件的功能\",{\"1\":{\"306\":1}}],[\"实现\",{\"1\":{\"284\":1,\"540\":2,\"638\":1}}],[\"实现这个接口即可\",{\"1\":{\"244\":1}}],[\"实现rpcclient接口\",{\"1\":{\"237\":1,\"239\":1}}],[\"实现rpcserver接口\",{\"1\":{\"237\":1}}],[\"实现nettyrpcserver\",{\"1\":{\"237\":1}}],[\"实现了runnable接口\",{\"1\":{\"714\":1}}],[\"实现了randmoaccess\",{\"1\":{\"571\":1}}],[\"实现了读写的分离\",{\"1\":{\"667\":1}}],[\"实现了有序性\",{\"1\":{\"637\":1,\"708\":1}}],[\"实现了真正的并发访问\",{\"1\":{\"546\":1}}],[\"实现了真正的线程隔离\",{\"1\":{\"406\":1}}],[\"实现了\",{\"1\":{\"417\":1}}],[\"实现了objectserializer与jsonserializer两种序列化器\",{\"1\":{\"246\":1}}],[\"实现了客户端与服务端的一个远程过程调用\",{\"1\":{\"218\":1}}],[\"实现了userservice接口\",{\"1\":{\"215\":1}}],[\"实现了可靠的数据传输\",{\"1\":{\"12\":1}}],[\"实现invoke方法\",{\"1\":{\"200\":1}}],[\"实现代理方法\",{\"1\":{\"200\":1}}],[\"实现代理\",{\"1\":{\"200\":1}}],[\"实现类\",{\"1\":{\"196\":1,\"197\":1,\"198\":1,\"201\":1,\"202\":1,\"297\":1}}],[\"实现方式\",{\"1\":{\"116\":2}}],[\"实现方便且健壮\",{\"1\":{\"34\":1}}],[\"实现的一种锁机制\",{\"1\":{\"648\":1,\"707\":1}}],[\"实现的原理大致是\",{\"1\":{\"112\":1}}],[\"实现的\",{\"1\":{\"104\":1,\"601\":1,\"648\":1,\"707\":1}}],[\"实现长连接要客户端和服务端都支持长连接\",{\"1\":{\"31\":1}}],[\"图17\",{\"1\":{\"720\":1}}],[\"图11\",{\"1\":{\"714\":1}}],[\"图10\",{\"1\":{\"714\":1}}],[\"图9\",{\"1\":{\"714\":1}}],[\"图7\",{\"1\":{\"714\":1}}],[\"图5\",{\"1\":{\"713\":1}}],[\"图4\",{\"1\":{\"713\":1}}],[\"图3\",{\"1\":{\"712\":1}}],[\"图中\",{\"1\":{\"569\":1}}],[\"图\",{\"1\":{\"559\":2}}],[\"图片描述\",{\"1\":{\"70\":1}}],[\"图片来源\",{\"1\":{\"16\":1,\"37\":1,\"149\":1}}],[\"图片来自\",{\"1\":{\"11\":1,\"158\":1}}],[\"图像文件\",{\"1\":{\"31\":1}}],[\"浏览器\",{\"1\":{\"41\":1,\"290\":2}}],[\"浏览器接收到服务器返回的\",{\"1\":{\"40\":1}}],[\"浏览器行为跟踪\",{\"1\":{\"39\":1}}],[\"浏览器对页面进行渲染\",{\"1\":{\"38\":1}}],[\"浏览器解析\",{\"1\":{\"38\":1}}],[\"浏览器会以一个随机端口\",{\"1\":{\"38\":1}}],[\"浏览器搜索自己的dns缓存\",{\"1\":{\"38\":1}}],[\"浏览器和服务器每进行一次http操作\",{\"1\":{\"31\":1}}],[\"浏览器重用一个\",{\"1\":{\"21\":1}}],[\"默认饱和策略\",{\"1\":{\"670\":1}}],[\"默认负载因子\",{\"1\":{\"554\":1,\"578\":1}}],[\"默认加载因子是多少\",{\"1\":{\"554\":1}}],[\"默认是16\",{\"1\":{\"548\":1}}],[\"默认是noeviction\",{\"1\":{\"388\":1}}],[\"默认异常处理器打印出异常信息并终止应用程序\",{\"1\":{\"537\":1}}],[\"默认处理器为\",{\"1\":{\"537\":1}}],[\"默认值是0\",{\"1\":{\"554\":1,\"578\":1}}],[\"默认值是16\",{\"1\":{\"554\":1,\"578\":1}}],[\"默认值\",{\"1\":{\"449\":1}}],[\"默认18次\",{\"1\":{\"373\":1}}],[\"默认3次\",{\"1\":{\"369\":1}}],[\"默认有三个\",{\"1\":{\"336\":1}}],[\"默认\",{\"1\":{\"291\":1,\"330\":1}}],[\"默认都是单例的\",{\"1\":{\"269\":1,\"286\":1}}],[\"默认情况下是异步刷盘的\",{\"1\":{\"369\":1}}],[\"默认情况下\",{\"1\":{\"268\":1,\"573\":1}}],[\"默认分别为ticktime\",{\"1\":{\"251\":1}}],[\"默认该作用域下所有select中的缓存将被clear\",{\"1\":{\"188\":1}}],[\"默认打不开二级缓存\",{\"1\":{\"188\":1}}],[\"默认打开一级缓存\",{\"1\":{\"188\":1}}],[\"默认也是采用perpetualcache\",{\"1\":{\"188\":1}}],[\"默认开启\",{\"1\":{\"156\":1,\"365\":1}}],[\"默认采用的\",{\"1\":{\"102\":2}}],[\"默认的处理方式是直接抛异常\",{\"1\":{\"713\":1}}],[\"默认的loadfactor是0\",{\"1\":{\"554\":1,\"578\":1}}],[\"默认的\",{\"1\":{\"102\":1}}],[\"默认的为\",{\"1\":{\"76\":1}}],[\"默认为1分钟\",{\"1\":{\"672\":1}}],[\"默认为\",{\"1\":{\"546\":1,\"564\":1}}],[\"默认为行级锁\",{\"1\":{\"92\":1,\"114\":1}}],[\"默认为0\",{\"1\":{\"20\":2}}],[\"默认约束\",{\"1\":{\"87\":1}}],[\"默认端口2181\",{\"1\":{\"251\":1}}],[\"默认端口\",{\"1\":{\"37\":1}}],[\"默认使用\",{\"1\":{\"297\":1,\"299\":1}}],[\"默认使用长连接\",{\"1\":{\"31\":1}}],[\"默认使用的是短连接\",{\"1\":{\"31\":1}}],[\"0表示成功\",{\"1\":{\"678\":1}}],[\"0d\",{\"1\":{\"449\":1}}],[\"0db8\",{\"1\":{\"69\":1,\"70\":1}}],[\"0f\",{\"1\":{\"449\":1}}],[\"0l\",{\"1\":{\"449\":1}}],[\"0开启多线程后\",{\"0\":{\"405\":1}}],[\"0为何引入多线程\",{\"0\":{\"401\":1}}],[\"0引入多线程i\",{\"1\":{\"400\":1}}],[\"0之前和redis\",{\"1\":{\"403\":1}}],[\"0之前\",{\"1\":{\"400\":1,\"403\":1}}],[\"0之前版本都不识别该aof文件\",{\"1\":{\"384\":1}}],[\"0后增加以下两种\",{\"1\":{\"388\":1}}],[\"0前提供\",{\"1\":{\"388\":1}}],[\"0添加了新的混合持久化方式\",{\"1\":{\"384\":1}}],[\"0相对与3\",{\"1\":{\"384\":1}}],[\"0相比http1\",{\"1\":{\"34\":1}}],[\"0以前\",{\"1\":{\"377\":1,\"399\":1}}],[\"0011\",{\"1\":{\"555\":1}}],[\"00157952\",{\"1\":{\"553\":1}}],[\"0001\",{\"1\":{\"555\":1}}],[\"00015795\",{\"1\":{\"553\":1}}],[\"00000006\",{\"1\":{\"553\":1}}],[\"00000094\",{\"1\":{\"553\":1}}],[\"00001316\",{\"1\":{\"553\":1}}],[\"0000\",{\"1\":{\"69\":2,\"70\":2}}],[\"00\",{\"1\":{\"348\":4}}],[\"0<\",{\"1\":{\"251\":1}}],[\"09\",{\"1\":{\"166\":1,\"483\":1}}],[\"090227\",{\"1\":{\"58\":1}}],[\"0xff\",{\"1\":{\"69\":2,\"70\":2}}],[\"0x005d\",{\"1\":{\"69\":1,\"70\":1}}],[\"0x03\",{\"1\":{\"69\":1,\"70\":1}}],[\"0x02\",{\"1\":{\"69\":1,\"70\":1}}],[\"0x01\",{\"1\":{\"69\":1,\"70\":1}}],[\"0rtt\",{\"1\":{\"69\":3}}],[\"06\",{\"1\":{\"69\":1,\"157\":1,\"567\":1}}],[\"08\",{\"1\":{\"63\":1}}],[\"05da0fc0950e\",{\"1\":{\"144\":1}}],[\"055500\",{\"1\":{\"71\":1}}],[\"05\",{\"0\":{\"63\":1},\"1\":{\"63\":1,\"69\":1,\"70\":1,\"71\":1,\"161\":2,\"483\":1,\"618\":1}}],[\"04\",{\"0\":{\"55\":1},\"1\":{\"675\":1,\"723\":1}}],[\"02日更新\",{\"1\":{\"69\":1,\"70\":1,\"71\":1}}],[\"02\",{\"0\":{\"55\":1},\"1\":{\"48\":1,\"69\":2,\"70\":1,\"675\":1,\"723\":1}}],[\"0370\",{\"1\":{\"69\":1,\"70\":1}}],[\"03\",{\"1\":{\"48\":1,\"69\":1,\"70\":1,\"166\":1,\"343\":1,\"483\":1,\"737\":1}}],[\"0使用encoder来减少需要传输的header大小\",{\"1\":{\"34\":1}}],[\"0的协议解析决定采用二进制格式\",{\"1\":{\"34\":1}}],[\"0的区别\",{\"0\":{\"34\":1}}],[\"0每次请求都要创建连接的缺点\",{\"1\":{\"33\":1}}],[\"0和http1\",{\"0\":{\"33\":1}}],[\"0111\",{\"1\":{\"555\":1}}],[\"0101\",{\"1\":{\"555\":1}}],[\"01263606\",{\"1\":{\"553\":1}}],[\"01\",{\"1\":{\"32\":1,\"69\":1,\"70\":1}}],[\"0\",{\"0\":{\"213\":1,\"402\":1,\"404\":1,\"406\":1,\"578\":3},\"1\":{\"32\":3,\"69\":25,\"70\":41,\"71\":22,\"126\":1,\"183\":1,\"197\":1,\"202\":1,\"204\":2,\"205\":1,\"216\":2,\"223\":2,\"237\":4,\"244\":6,\"251\":6,\"313\":2,\"323\":2,\"330\":1,\"348\":1,\"350\":1,\"353\":1,\"382\":2,\"384\":1,\"400\":4,\"403\":1,\"417\":2,\"435\":1,\"449\":3,\"454\":1,\"499\":1,\"506\":1,\"507\":1,\"510\":1,\"527\":1,\"536\":2,\"553\":14,\"554\":5,\"555\":3,\"556\":2,\"558\":1,\"559\":7,\"564\":1,\"573\":3,\"578\":2,\"579\":2,\"581\":1,\"603\":1,\"605\":1,\"611\":1,\"612\":4,\"616\":4,\"617\":8,\"712\":1,\"728\":4}}],[\"0中认为每台服务器都绑定一个唯一的ip地址\",{\"1\":{\"33\":1}}],[\"0中主要使用header里的if\",{\"1\":{\"33\":1}}],[\"0中\",{\"1\":{\"31\":1,\"33\":1}}],[\"07581633\",{\"1\":{\"553\":1}}],[\"07\",{\"0\":{\"59\":1},\"1\":{\"25\":2,\"59\":1,\"311\":1}}],[\"解锁时减\",{\"1\":{\"435\":1}}],[\"解锁\",{\"1\":{\"434\":1,\"615\":1}}],[\"解耦\",{\"0\":{\"346\":1},\"1\":{\"345\":2}}],[\"解释\",{\"1\":{\"555\":1}}],[\"解释一下几个方法和属性值的含义\",{\"1\":{\"603\":1}}],[\"解释一下自动装箱和自动拆箱\",{\"0\":{\"494\":1},\"1\":{\"484\":1}}],[\"解释一下http长连接和短连接\",{\"0\":{\"31\":1}}],[\"解释下kafka中位移\",{\"0\":{\"328\":1}}],[\"解析为\",{\"1\":{\"494\":1}}],[\"解析命令\",{\"1\":{\"404\":1}}],[\"解析器\",{\"1\":{\"291\":1}}],[\"解析\",{\"1\":{\"291\":1}}],[\"解析到对应的\",{\"1\":{\"290\":1}}],[\"解析请求对应的\",{\"1\":{\"290\":1}}],[\"解析字段封装结果类后\",{\"1\":{\"203\":1}}],[\"解析xml设置mapperstatement时\",{\"1\":{\"203\":1}}],[\"解析参数再次封装preparedstatememnt\",{\"1\":{\"198\":1}}],[\"解析别名看是否存在歧义\",{\"1\":{\"88\":1,\"99\":1}}],[\"解除\",{\"1\":{\"179\":1}}],[\"解除sql与程序代码的耦合\",{\"1\":{\"173\":1}}],[\"解码编码速度\",{\"1\":{\"244\":1}}],[\"解码\",{\"1\":{\"71\":1}}],[\"解决内存泄漏问题\",{\"1\":{\"665\":1}}],[\"解决的事执行控制的问题\",{\"1\":{\"646\":1}}],[\"解决的是内存可见性问题\",{\"1\":{\"646\":1}}],[\"解决hash冲突方法有\",{\"1\":{\"576\":1}}],[\"解决hash冲突的办法有哪些\",{\"0\":{\"576\":1}}],[\"解决哈希冲突时\",{\"1\":{\"557\":1}}],[\"解决单点故障问题\",{\"1\":{\"439\":1}}],[\"解决措施\",{\"1\":{\"435\":1}}],[\"解决方法\",{\"1\":{\"395\":1}}],[\"解决方案\",{\"1\":{\"394\":1,\"396\":1}}],[\"解决方式\",{\"1\":{\"242\":1}}],[\"解决粘包问题\",{\"1\":{\"237\":1}}],[\"解决\",{\"1\":{\"176\":4}}],[\"解决超大分页\",{\"1\":{\"136\":1}}],[\"解决主从同步延时问题\",{\"1\":{\"133\":1}}],[\"解决主库数据丢失问题\",{\"1\":{\"133\":1}}],[\"解决10011\",{\"1\":{\"69\":1,\"70\":1}}],[\"解决办法\",{\"1\":{\"20\":1,\"138\":5,\"435\":1}}],[\"解密数据\",{\"1\":{\"37\":1}}],[\"简化线程池配置\",{\"1\":{\"720\":1}}],[\"简化服务端代码\",{\"1\":{\"230\":1}}],[\"简称为aqs\",{\"1\":{\"601\":1}}],[\"简介\",{\"0\":{\"601\":1}}],[\"简要流程如下\",{\"1\":{\"556\":1,\"580\":1}}],[\"简要描述\",{\"1\":{\"519\":1}}],[\"简述它的优缺点\",{\"0\":{\"376\":1}}],[\"简单说threadlocal就是一种以空间换时间的做法\",{\"1\":{\"704\":1}}],[\"简单可维护\",{\"1\":{\"399\":1}}],[\"简单介绍一下\",{\"0\":{\"684\":1}}],[\"简单介绍\",{\"0\":{\"291\":1}}],[\"简单属性\",{\"1\":{\"279\":1}}],[\"简单的说\",{\"1\":{\"384\":1}}],[\"简单的实现以及较少的干扰机制使得松耦合得以实现\",{\"1\":{\"270\":1}}],[\"简单的传输了一个\",{\"1\":{\"244\":1}}],[\"简单\",{\"1\":{\"175\":1}}],[\"简单来说\",{\"1\":{\"131\":1}}],[\"简单来说意味着对同一url的多个请求应该返回同样的结果\",{\"1\":{\"30\":1}}],[\"简言之\",{\"1\":{\"102\":1}}],[\"简写\",{\"1\":{\"65\":1}}],[\"简而言之\",{\"1\":{\"19\":1}}],[\"幂等性是指一次和多次请求某一个资源应该具有同样的副作用\",{\"1\":{\"30\":1}}],[\"作者\",{\"1\":{\"402\":1}}],[\"作\",{\"1\":{\"200\":1}}],[\"作key\",{\"1\":{\"200\":1}}],[\"作mapper类型\",{\"1\":{\"193\":1}}],[\"作为生产者\",{\"1\":{\"732\":1}}],[\"作为消费者\",{\"1\":{\"732\":1}}],[\"作为消息体发送到消息队列中\",{\"1\":{\"393\":1}}],[\"作为一般规则\",{\"1\":{\"554\":1,\"578\":1}}],[\"作为一个半orm框架\",{\"1\":{\"172\":1}}],[\"作为异常处理的一部分\",{\"1\":{\"454\":1}}],[\"作为关键字\",{\"1\":{\"443\":1}}],[\"作为新的version号\",{\"1\":{\"427\":1}}],[\"作为新leader\",{\"1\":{\"340\":1}}],[\"作为发布\",{\"1\":{\"326\":1}}],[\"作为队列\",{\"1\":{\"326\":1}}],[\"作为\",{\"1\":{\"323\":1,\"336\":1}}],[\"作为我们的基本单元\",{\"1\":{\"283\":1}}],[\"作为优选ip到v2rayn中替换使用\",{\"1\":{\"62\":1}}],[\"作为后面对称加密的密钥\",{\"1\":{\"37\":1}}],[\"作为初始序列号\",{\"1\":{\"11\":2}}],[\"作用于当前类\",{\"1\":{\"649\":1}}],[\"作用于当前对象实例\",{\"1\":{\"649\":1}}],[\"作用域来标识\",{\"1\":{\"272\":1}}],[\"作用域中定义的\",{\"1\":{\"272\":1}}],[\"作用域\",{\"1\":{\"272\":1}}],[\"作用范围不同\",{\"1\":{\"41\":1}}],[\"作用\",{\"1\":{\"29\":1,\"363\":1}}],[\"常量池优化\",{\"1\":{\"490\":1}}],[\"常量池存储的就是引用了\",{\"1\":{\"487\":1}}],[\"常量池的位置在堆中\",{\"1\":{\"487\":1}}],[\"常量池的位置在永久代\",{\"1\":{\"487\":1}}],[\"常规设置\",{\"0\":{\"716\":1}}],[\"常规计数\",{\"1\":{\"382\":1}}],[\"常规key\",{\"1\":{\"382\":1}}],[\"常用的java线程池有哪几种类型\",{\"0\":{\"672\":1}}],[\"常用的请求方式\",{\"0\":{\"29\":1}}],[\"常用工具类\",{\"1\":{\"312\":1}}],[\"常见需求是把业务对象序列化成二进制数组放入redis\",{\"1\":{\"438\":1}}],[\"常见的对比\",{\"0\":{\"628\":1,\"695\":1}}],[\"常见的集合有哪些\",{\"0\":{\"569\":1}}],[\"常见的受检查异常有\",{\"1\":{\"531\":1}}],[\"常见的分布式锁有哪些解决方案\",{\"0\":{\"432\":1}}],[\"常见的rpc框架\",{\"1\":{\"208\":1}}],[\"常见的解决死锁的方法\",{\"1\":{\"118\":1}}],[\"常见状态码\",{\"1\":{\"27\":1}}],[\"网上所有文章都说是16次\",{\"1\":{\"373\":1}}],[\"网址\",{\"1\":{\"37\":1}}],[\"网页扩展名改变\",{\"1\":{\"28\":1}}],[\"网页被移到一个新地址\",{\"1\":{\"28\":1}}],[\"网站调整\",{\"1\":{\"28\":1}}],[\"网络连接地址url\",{\"1\":{\"482\":1}}],[\"网络连接断掉了\",{\"1\":{\"420\":1}}],[\"网络\",{\"1\":{\"401\":1}}],[\"网络上说的redis是单线程\",{\"1\":{\"400\":1}}],[\"网络io模型\",{\"1\":{\"378\":1}}],[\"网络请求模块使用一个线程来处理\",{\"1\":{\"377\":1}}],[\"网络问题\",{\"1\":{\"339\":1}}],[\"网络传输方式的客户端分别实现这个接口\",{\"1\":{\"237\":1}}],[\"网络传输从bio到nio\",{\"1\":{\"236\":1}}],[\"网络传输\",{\"1\":{\"210\":1}}],[\"网络测速\",{\"1\":{\"60\":1}}],[\"网络堵塞甚至系统瘫痪\",{\"1\":{\"14\":1}}],[\"网络层\",{\"1\":{\"8\":1}}],[\"重点是基于这几个public方法\",{\"1\":{\"721\":1}}],[\"重点看黄色部分\",{\"1\":{\"565\":1,\"566\":1}}],[\"重点看下transfer方法\",{\"1\":{\"564\":1}}],[\"重置\",{\"1\":{\"662\":1}}],[\"重量级锁底层依赖于系统的同步函数来实现\",{\"1\":{\"661\":1}}],[\"重量级锁一般使用场景会在追求吞吐量\",{\"1\":{\"658\":1}}],[\"重量级锁一步步转换\",{\"1\":{\"546\":1}}],[\"重量级锁是由轻量级锁升级而来\",{\"1\":{\"658\":1}}],[\"重入锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"重操作\",{\"1\":{\"542\":1}}],[\"重载的方法能否根据返回值类型进行区分\",{\"0\":{\"467\":1}}],[\"重载\",{\"0\":{\"466\":1},\"1\":{\"465\":1,\"466\":1}}],[\"重试时间应该大于cluster\",{\"1\":{\"417\":1}}],[\"重试的时候会发送到其他broker上\",{\"1\":{\"369\":1}}],[\"重启的时候可以再次加载进行使用\",{\"1\":{\"378\":1}}],[\"重写方法返回值和形参都不能改变\",{\"1\":{\"466\":1}}],[\"重写发生在子类与父类之间\",{\"1\":{\"466\":1}}],[\"重写\",{\"1\":{\"465\":1,\"621\":2,\"688\":2}}],[\"重写和向上转型\",{\"1\":{\"465\":1}}],[\"重写父类提供的跨域请求处理的接口\",{\"1\":{\"319\":1}}],[\"重写sql语句\",{\"1\":{\"138\":1}}],[\"重要的区别是在尝试获取锁时tryacquire\",{\"1\":{\"616\":1}}],[\"重要\",{\"1\":{\"290\":1}}],[\"重复率比较高的\",{\"1\":{\"395\":1}}],[\"重复使用\",{\"1\":{\"237\":1}}],[\"重复查询相同的数据\",{\"1\":{\"138\":1}}],[\"重构客户端代码\",{\"1\":{\"237\":1}}],[\"重新分配线程\",{\"1\":{\"714\":1}}],[\"重新尝试加锁\",{\"1\":{\"666\":1}}],[\"重新计算每个元素在数组中的位置\",{\"1\":{\"558\":1,\"581\":1}}],[\"重新向\",{\"1\":{\"425\":1}}],[\"重新从新的master复制数据\",{\"1\":{\"423\":1}}],[\"重新进行\",{\"1\":{\"71\":1}}],[\"重新发送\",{\"1\":{\"22\":1}}],[\"重定向原因\",{\"1\":{\"28\":1}}],[\"补充hashset的实现\",{\"1\":{\"595\":1}}],[\"补充数组容量计算的小奥秘\",{\"1\":{\"555\":1}}],[\"补充\",{\"1\":{\"28\":1,\"384\":1}}],[\"搜索引擎会抓取新的内容而保存旧的网址\",{\"1\":{\"28\":1}}],[\"搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址\",{\"1\":{\"28\":1}}],[\"仍然保留获取锁的可能\",{\"1\":{\"614\":1}}],[\"仍然是线程不安全的\",{\"1\":{\"557\":1}}],[\"仍然能释放锁\",{\"1\":{\"436\":1}}],[\"仍然可以访问\",{\"1\":{\"28\":1}}],[\"仍然未收到\",{\"1\":{\"15\":1}}],[\"用了共享内存通信方式\",{\"1\":{\"728\":1}}],[\"用reentrantlock类结合condition实例可以实现\",{\"1\":{\"648\":1,\"707\":1}}],[\"用redis来抗住大部分读请求\",{\"0\":{\"439\":1}}],[\"用新计算的容量new了一个新的hash表\",{\"1\":{\"566\":1}}],[\"用可变类当\",{\"1\":{\"560\":1}}],[\"用二叉查找树可以么\",{\"1\":{\"553\":1}}],[\"用到了自动的装箱\",{\"1\":{\"494\":1}}],[\"用equals方法判断是否为相同的对象\",{\"1\":{\"479\":1}}],[\"用new创建类的对象时\",{\"1\":{\"455\":1}}],[\"用not\",{\"1\":{\"96\":1}}],[\"用法如下\",{\"1\":{\"435\":1}}],[\"用投票机制完成slave到master的角色提升\",{\"1\":{\"417\":1}}],[\"用\",{\"0\":{\"491\":1},\"1\":{\"350\":3,\"484\":1,\"546\":1,\"547\":1,\"586\":1}}],[\"用一个变量去存储两个值\",{\"1\":{\"712\":1}}],[\"用一个变量保存了整个表的行数\",{\"1\":{\"92\":1}}],[\"用一份数据服务所有slave\",{\"1\":{\"420\":1,\"422\":1}}],[\"用一组不太合理的包含关系来表达它们之间的关系\",{\"1\":{\"310\":1}}],[\"用作另一个\",{\"1\":{\"277\":1}}],[\"用spring提供的方法\",{\"1\":{\"270\":1}}],[\"用对应的序列化器解码字节数组\",{\"1\":{\"244\":1}}],[\"用以替换\",{\"1\":{\"201\":1}}],[\"用以保持连接特性\",{\"1\":{\"31\":1}}],[\"用来协调多个线程之间的同步\",{\"1\":{\"681\":1}}],[\"用来存放线程任务\",{\"1\":{\"670\":1}}],[\"用来标识该方法可能抛出的异常列表\",{\"1\":{\"532\":1}}],[\"用来抛出方法或代码块中的异常\",{\"1\":{\"532\":1}}],[\"用来表明类的不同版本间的兼容性\",{\"1\":{\"524\":1}}],[\"用来帮助程序员实现本不可能实现的功能\",{\"1\":{\"506\":1}}],[\"用来生成\",{\"1\":{\"504\":1}}],[\"用来限制其他数据的类型\",{\"1\":{\"449\":1}}],[\"用来\",{\"1\":{\"133\":2}}],[\"用来回滚行记录到某个版本\",{\"1\":{\"107\":1}}],[\"用过哪些分库分表中间件\",{\"0\":{\"122\":1}}],[\"用上面的例子来说就是用户的行为有两种\",{\"1\":{\"115\":1}}],[\"用非单调的字段作为主键在innodb中不是个好主意\",{\"1\":{\"83\":1}}],[\"用多台计算机发起攻击\",{\"1\":{\"43\":1}}],[\"用户进程对信号的处理方式\",{\"1\":{\"729\":1}}],[\"用户只需提供runnable对象\",{\"1\":{\"711\":1}}],[\"用户无需关注如何创建线程\",{\"1\":{\"711\":1}}],[\"用户名\",{\"1\":{\"506\":1}}],[\"用户每次都必须通过更新到最新版本获得支持来获取最新版本\",{\"1\":{\"447\":1}}],[\"用户直接查询事先被预热的缓存数据\",{\"1\":{\"397\":1}}],[\"用户在不在等\",{\"1\":{\"382\":1}}],[\"用户第一次访问数据库中的某些数据\",{\"1\":{\"379\":1}}],[\"用户第一次请求服务器的时候\",{\"1\":{\"40\":1}}],[\"用户通过浏览器发起请求\",{\"1\":{\"347\":1}}],[\"用户感觉搞个什么东西\",{\"1\":{\"347\":1}}],[\"用户id\",{\"1\":{\"69\":4}}],[\"用户发帖时就可以引入带有＜script＞标签的代码\",{\"1\":{\"44\":1}}],[\"用户看到的效果就是他输入的地址a瞬间变成了另一个地址b\",{\"1\":{\"28\":1}}],[\"用于完成某个功能的一个过程\",{\"1\":{\"644\":1}}],[\"用于管理对共享数据的并发访问\",{\"1\":{\"644\":1}}],[\"用于展示当前临界资源的获锁情况\",{\"1\":{\"604\":1}}],[\"用于存储键值对数据\",{\"1\":{\"584\":1}}],[\"用于存储消息\",{\"1\":{\"355\":1}}],[\"用于修饰变量\",{\"1\":{\"454\":1}}],[\"用于标识它在分区中的位置\",{\"1\":{\"328\":1}}],[\"用于实时构建流处理应用\",{\"1\":{\"321\":1}}],[\"用于解析出请求的默认视图名\",{\"1\":{\"291\":1}}],[\"用于指向该行修改前的最后一个历史版本\",{\"1\":{\"112\":1}}],[\"用于预防破坏表之间连接的动作\",{\"1\":{\"94\":1}}],[\"用于控制字段的值范围\",{\"1\":{\"94\":1}}],[\"用于控制字段的内容一定不能为空\",{\"1\":{\"94\":1}}],[\"用于控制fetch请求的取消\",{\"1\":{\"71\":1}}],[\"用于异常的关闭连接\",{\"1\":{\"15\":1}}],[\"用于对高速传输和实时性有较高要求的通信\",{\"1\":{\"9\":1}}],[\"用于在传输层有必要实现可靠传输的情况\",{\"1\":{\"9\":1}}],[\"时被阻塞\",{\"1\":{\"681\":1}}],[\"时锁的内部机制\",{\"1\":{\"677\":1}}],[\"时代意味着多个线程可以同时运行\",{\"1\":{\"622\":1,\"689\":1}}],[\"时的概率已经非常小\",{\"1\":{\"553\":1}}],[\"时所写的代码几乎一致\",{\"1\":{\"510\":1}}],[\"时无法确定调用的是哪个\",{\"1\":{\"467\":1}}],[\"时释放锁\",{\"1\":{\"435\":1}}],[\"时性能相比单线程是几乎是翻倍了\",{\"1\":{\"402\":1}}],[\"时效性\",{\"1\":{\"350\":1}}],[\"时\",{\"1\":{\"27\":1,\"112\":1,\"141\":1,\"181\":2,\"272\":1,\"299\":1,\"302\":1,\"323\":1,\"382\":1,\"478\":1,\"549\":1,\"564\":1,\"606\":1,\"612\":1,\"617\":1,\"644\":1}}],[\"时间片转入\",{\"1\":{\"639\":1}}],[\"时间片\",{\"1\":{\"639\":1}}],[\"时间片用完了\",{\"1\":{\"564\":1}}],[\"时间复杂度就为\",{\"1\":{\"571\":1}}],[\"时间的消耗和\",{\"1\":{\"401\":1}}],[\"时间在网络\",{\"1\":{\"401\":1}}],[\"时间方面\",{\"1\":{\"147\":1}}],[\"时间通常是设置为\",{\"1\":{\"19\":1}}],[\"时间里传给客户端\",{\"1\":{\"18\":1}}],[\"时间\",{\"1\":{\"18\":1,\"386\":1}}],[\"或是缓冲到队列中执行\",{\"1\":{\"713\":1}}],[\"或是命令用在了错误类型的键上面\",{\"1\":{\"411\":1}}],[\"或发出\",{\"1\":{\"639\":1}}],[\"或发出了i\",{\"1\":{\"623\":1,\"690\":1}}],[\"或join\",{\"1\":{\"623\":1,\"690\":1}}],[\"或进程元\",{\"1\":{\"620\":1,\"687\":1}}],[\"或在方法签名中用\",{\"1\":{\"533\":1}}],[\"或类文件更改\",{\"1\":{\"510\":1}}],[\"或删除\",{\"1\":{\"409\":1}}],[\"或client来pull消息\",{\"1\":{\"360\":1}}],[\"或返回给生产者或直接丢弃\",{\"1\":{\"355\":1}}],[\"或自动触发了preferred\",{\"1\":{\"340\":1}}],[\"或注解来配置和映射原生信息\",{\"1\":{\"172\":1}}],[\"或最小\",{\"1\":{\"149\":1}}],[\"或\",{\"1\":{\"27\":1,\"277\":1,\"300\":1,\"382\":1,\"464\":2,\"506\":1,\"533\":2,\"629\":1,\"639\":1,\"640\":1,\"696\":1}}],[\"或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的\",{\"1\":{\"637\":1,\"708\":1}}],[\"或者可以使用\",{\"1\":{\"633\":1,\"701\":1}}],[\"或者i\",{\"1\":{\"623\":1,\"690\":1}}],[\"或者原来的位置\",{\"1\":{\"559\":1}}],[\"或者新增节点的时候是对线程b可见的\",{\"1\":{\"547\":1}}],[\"或者加上catch捕获以便进一步处理\",{\"1\":{\"535\":1}}],[\"或者调用其方法\",{\"1\":{\"534\":1}}],[\"或者在方法内部通过\",{\"1\":{\"532\":1}}],[\"或者list<c>等等\",{\"1\":{\"512\":1}}],[\"或者构造函数\",{\"1\":{\"466\":1}}],[\"或者通过lru淘汰了一个key\",{\"1\":{\"420\":1}}],[\"或者访问量突然猛增到系统能承受的最大阀值\",{\"1\":{\"398\":1}}],[\"或者数据库连接池被打爆了\",{\"1\":{\"398\":1}}],[\"或者定期执行bgsave做快照备份\",{\"1\":{\"384\":1}}],[\"或者防止系统故障\",{\"1\":{\"383\":1}}],[\"或者叫偏移量\",{\"1\":{\"328\":1}}],[\"或者使用包含\",{\"1\":{\"297\":1}}],[\"或者使用解析出来的ip\",{\"1\":{\"62\":1}}],[\"或者需求变化较多的项目\",{\"1\":{\"172\":1}}],[\"或者实在是数据量太大造成\",{\"1\":{\"141\":1}}],[\"或者是多个线程交替获取锁\",{\"1\":{\"661\":1}}],[\"或者是多个库上去\",{\"1\":{\"128\":1}}],[\"或者是调用admin的alterpartitionreassignments方法执行分区副本重分配时\",{\"1\":{\"340\":1}}],[\"或者是哪种数据库引擎\",{\"1\":{\"134\":1}}],[\"或者是按照某个字段hash一下均匀分散\",{\"1\":{\"128\":1}}],[\"或者\",{\"0\":{\"164\":1,\"578\":1,\"588\":1},\"1\":{\"39\":1,\"69\":13,\"292\":1,\"511\":2,\"548\":1,\"554\":1,\"633\":1,\"639\":1,\"640\":1,\"701\":1}}],[\"或者证书已经过期\",{\"1\":{\"37\":1}}],[\"或者证书中的域名与实际域名不一致\",{\"1\":{\"37\":1}}],[\"或者说是\",{\"1\":{\"101\":1}}],[\"或者说\",{\"1\":{\"19\":1}}],[\"或者即使收到这些过时的报文\",{\"1\":{\"18\":1}}],[\"通信的方式是单向的\",{\"1\":{\"731\":1}}],[\"通信的数据是无格式的流并且大小受限\",{\"1\":{\"731\":1}}],[\"通信的一次完整的流程\",{\"1\":{\"403\":1}}],[\"通信了\",{\"1\":{\"730\":1,\"731\":1}}],[\"通信\",{\"1\":{\"633\":1,\"701\":1,\"724\":1}}],[\"通知client客户端新的master地址\",{\"1\":{\"419\":1}}],[\"通知\",{\"1\":{\"376\":1}}],[\"通知mq删除该消息\",{\"1\":{\"360\":1}}],[\"通用的注解\",{\"1\":{\"271\":1}}],[\"通俗的说就是我们不用自己创建实例对象\",{\"1\":{\"270\":1}}],[\"通讯双方各自cache一份header\",{\"1\":{\"34\":1}}],[\"通常使用双端队列\",{\"1\":{\"643\":1}}],[\"通常被用于线程间交互\",{\"1\":{\"633\":1,\"701\":1}}],[\"通常被用于暂停执行wait\",{\"1\":{\"633\":1,\"701\":1}}],[\"通常一个进程都有若干个线程\",{\"1\":{\"620\":1,\"687\":1}}],[\"通常一个xml映射文件\",{\"0\":{\"182\":1}}],[\"通常应用程序会被终止\",{\"1\":{\"530\":1}}],[\"通常遇到这种错误\",{\"1\":{\"530\":1}}],[\"通常称被修饰的变量为常量\",{\"1\":{\"454\":1}}],[\"通常会存在大量键\",{\"1\":{\"438\":1}}],[\"通常需要根据企业业务的实际线上环境来定制化\",{\"1\":{\"418\":1}}],[\"通常是指在redis\",{\"1\":{\"400\":1}}],[\"通常不会是瓶颈\",{\"1\":{\"399\":1}}],[\"通常不是安全的\",{\"1\":{\"303\":1}}],[\"通常在memcached里\",{\"1\":{\"378\":1}}],[\"通常也会称之为消息总线message\",{\"1\":{\"321\":1}}],[\"通常通过索引查询数据比全表扫描要快\",{\"1\":{\"162\":1}}],[\"通常来说\",{\"1\":{\"157\":1,\"455\":1}}],[\"通常情况下\",{\"1\":{\"151\":1,\"339\":1}}],[\"通常用来存储一些不敏感信息\",{\"1\":{\"42\":1}}],[\"通常\",{\"1\":{\"27\":1,\"39\":1,\"265\":1}}],[\"通过多线程\",{\"1\":{\"675\":1}}],[\"通过置换worker中runnable对象\",{\"1\":{\"674\":1}}],[\"通过实现rejectedexecutionhandler接口\",{\"1\":{\"670\":1}}],[\"通过重复利用已创建的线程降低线程创建和销毁造成的消耗\",{\"1\":{\"668\":1}}],[\"通过让线程执行循环等待锁的释放\",{\"1\":{\"661\":1}}],[\"通过扩大锁的范围\",{\"1\":{\"660\":1}}],[\"通过锁消除\",{\"1\":{\"654\":1}}],[\"通过自旋循环一定次数来获取锁\",{\"1\":{\"652\":1}}],[\"通过该\",{\"1\":{\"651\":1}}],[\"通过lock\",{\"1\":{\"648\":1,\"707\":1}}],[\"通过list\",{\"1\":{\"382\":1}}],[\"通过atomicreference来保证原子性\",{\"1\":{\"645\":1}}],[\"通过控制变量值的版本来保证cas的正确性\",{\"1\":{\"645\":1}}],[\"通过它实现了原子操作\",{\"1\":{\"644\":1}}],[\"通过它执行sql语句\",{\"1\":{\"201\":1}}],[\"通过原子方式用新值\",{\"1\":{\"644\":1}}],[\"通过指定锁的获取顺序\",{\"1\":{\"627\":1,\"694\":1}}],[\"通过调用线程的sleep\",{\"1\":{\"623\":1,\"690\":1}}],[\"通过调用discard\",{\"1\":{\"409\":1}}],[\"通过future对象可以了解任务执行情况\",{\"1\":{\"621\":1,\"688\":1}}],[\"通过上面的描述\",{\"1\":{\"615\":1}}],[\"通过上述setnx\",{\"1\":{\"435\":1}}],[\"通过reentrantlock的解锁方法unlock进行解锁\",{\"1\":{\"615\":1}}],[\"通过reentrantlock的加锁方法lock进行加锁操作\",{\"1\":{\"615\":1}}],[\"通过redis的set能够很方便得出\",{\"1\":{\"381\":1}}],[\"通过tryacquire完成加锁过程\",{\"1\":{\"614\":1}}],[\"通过当前的线程和锁模式新建一个节点\",{\"1\":{\"607\":1}}],[\"通过内置的fifo队列来完成资源获取的排队工作\",{\"1\":{\"602\":1}}],[\"通过ensurecapacityinternal\",{\"1\":{\"573\":1}}],[\"通过expire或pexpire命令\",{\"1\":{\"387\":1}}],[\"通过explain\",{\"1\":{\"157\":1}}],[\"通过hashcode\",{\"1\":{\"555\":1}}],[\"通过取模计算下标\",{\"1\":{\"555\":1,\"579\":1}}],[\"通过所封装的流的功能调用实现数据读写\",{\"1\":{\"539\":1}}],[\"通过传入的类路径参数没有找到该类\",{\"1\":{\"533\":1}}],[\"通过下面的代码进行序列化及反序列化\",{\"1\":{\"521\":1,\"522\":1}}],[\"通过反序列化重建对象\",{\"1\":{\"518\":1}}],[\"通过反射加载\",{\"1\":{\"506\":1}}],[\"通过反射机制\",{\"1\":{\"471\":1}}],[\"通过反射来接收被代理的类\",{\"1\":{\"284\":1}}],[\"通过反射实例化返回类\",{\"1\":{\"203\":1}}],[\"通过反射将resultset中结果设置到目标resulttype对象中\",{\"1\":{\"198\":1}}],[\"通过cas讲tail重新指向新的尾部节点\",{\"1\":{\"607\":1}}],[\"通过cas完成对state值的修改\",{\"1\":{\"602\":1}}],[\"通过compareandsettail方法\",{\"1\":{\"607\":1}}],[\"通过connection\",{\"1\":{\"506\":1}}],[\"通过class的名称获取class对象\",{\"1\":{\"506\":1}}],[\"通过class\",{\"1\":{\"506\":1}}],[\"通过class对象我们可以任意调用类的方法\",{\"1\":{\"505\":1}}],[\"通过字节码生成的方式加快反射速度\",{\"1\":{\"502\":1}}],[\"通过序列化机制\",{\"1\":{\"471\":1}}],[\"通过继承创建的新类称为\",{\"1\":{\"464\":1}}],[\"通过增加slave做standby数据副本\",{\"1\":{\"417\":1}}],[\"通过增加从服务器来提高数据库的性能\",{\"1\":{\"130\":1}}],[\"通过另外的标记变量来标识事务是否执行完成\",{\"1\":{\"412\":1}}],[\"通过这个\",{\"1\":{\"697\":1}}],[\"通过这个future对象可以判断任务是否执行成功\",{\"1\":{\"669\":1}}],[\"通过这个队列\",{\"1\":{\"403\":1}}],[\"通过这两个字段双方都可以知道在自己发出的数据中\",{\"1\":{\"12\":1}}],[\"通过将这些命令的执行进行异步化\",{\"1\":{\"400\":1}}],[\"通过互斥锁或者队列来控制读数据写缓存的线程数量\",{\"1\":{\"394\":1,\"396\":1}}],[\"通过vm功能可以实现冷热数据分离\",{\"1\":{\"377\":1}}],[\"通过version的方式来进行锁定\",{\"1\":{\"116\":1}}],[\"通过交换器来路由消息\",{\"1\":{\"352\":1}}],[\"通过一个阻塞队列来实现的\",{\"1\":{\"713\":1}}],[\"通过一个后台的异步线程进行缓存的构建\",{\"1\":{\"394\":1,\"396\":1}}],[\"通过一个\",{\"1\":{\"346\":1}}],[\"通过接口调用发送\",{\"1\":{\"346\":1}}],[\"通过multi和exec指令包起来\",{\"1\":{\"376\":1}}],[\"通过mq的方式异步去处理\",{\"1\":{\"345\":1}}],[\"通过mapperinterface拿到sqlid\",{\"1\":{\"200\":1}}],[\"通过制定\",{\"1\":{\"336\":1}}],[\"通过网络将消息发送到\",{\"1\":{\"322\":1}}],[\"通过创建application\",{\"1\":{\"305\":1}}],[\"通过参数解析器是将\",{\"1\":{\"299\":1}}],[\"通过依赖注入机制\",{\"1\":{\"270\":1}}],[\"通过加载读取配置文件\",{\"1\":{\"270\":1}}],[\"通过加固\",{\"1\":{\"14\":1}}],[\"通过面向接口编程的方式来是实现对业务组件的动态依赖\",{\"1\":{\"270\":1}}],[\"通过给channel设计别名\",{\"1\":{\"237\":1}}],[\"通过setaccessible\",{\"1\":{\"502\":1}}],[\"通过scan命令扫库\",{\"1\":{\"421\":1}}],[\"通过statementhandler和connection获取preparedstatement\",{\"1\":{\"198\":1}}],[\"通过sqlsession执行数据库操作\",{\"1\":{\"177\":1}}],[\"通过sqlsessionfactory创建sqlsession\",{\"1\":{\"177\":1}}],[\"通过build重载\",{\"1\":{\"194\":1}}],[\"通过在resultmap里面的collection节点配置一对多的类就可以完成\",{\"1\":{\"187\":1}}],[\"通过在resultmap里面配置association节点配置一对一的类就可以完成\",{\"1\":{\"186\":1}}],[\"通过在网络上占领多台\",{\"1\":{\"43\":1}}],[\"通过xml\",{\"1\":{\"172\":1}}],[\"通过使用索引\",{\"1\":{\"147\":1}}],[\"通过对内容建立索引形成目录\",{\"1\":{\"146\":1}}],[\"通过分库分表的方式进行优化\",{\"1\":{\"142\":1}}],[\"通过建立中间表\",{\"1\":{\"140\":1}}],[\"通过配置文件\",{\"1\":{\"129\":1}}],[\"通过表级锁定来减少死锁产生的概率\",{\"1\":{\"118\":1}}],[\"通过\",{\"1\":{\"112\":1,\"157\":1,\"280\":1,\"281\":1,\"299\":1,\"404\":1,\"506\":2,\"585\":1,\"605\":1,\"647\":1,\"729\":1}}],[\"通过保存修改的旧版本信息来支持并发一致性读和回滚等特性\",{\"1\":{\"102\":1}}],[\"通过强制事务排序\",{\"1\":{\"102\":1}}],[\"通过主键索引效率很高\",{\"1\":{\"92\":1}}],[\"通过ip地址哈希化来确定要选择的服务器编号\",{\"1\":{\"46\":1}}],[\"通过检验和的方式\",{\"1\":{\"22\":1}}],[\"通过定时器\",{\"1\":{\"19\":1}}],[\"通过防火墙\",{\"1\":{\"14\":1}}],[\"通过发送大量的半连接请求\",{\"1\":{\"14\":1}}],[\"话不多说\",{\"1\":{\"26\":1}}],[\"巨人的肩膀\",{\"0\":{\"25\":1,\"48\":1,\"551\":1,\"567\":1,\"599\":1}}],[\"乘法减小\",{\"1\":{\"24\":1}}],[\"当条件满足跳出循环执行具体处理逻辑\",{\"1\":{\"732\":1}}],[\"当我们不希望处理某些信号的时候\",{\"1\":{\"729\":1}}],[\"当信号发生时\",{\"1\":{\"729\":1}}],[\"当worker无法获取到任务\",{\"1\":{\"714\":1}}],[\"当队列满时\",{\"1\":{\"713\":1}}],[\"当以上都不适用时\",{\"1\":{\"675\":1}}],[\"当任务提交后\",{\"1\":{\"711\":1}}],[\"当任务大于核心线程数corepoolsize\",{\"1\":{\"671\":1}}],[\"当任务小于核心线程数corepoolsize\",{\"1\":{\"671\":1}}],[\"当任务到达时\",{\"1\":{\"668\":1}}],[\"当任何一个\",{\"1\":{\"323\":1}}],[\"当锁降级时\",{\"1\":{\"662\":1}}],[\"当同一时间有多个线程竞争锁时\",{\"1\":{\"658\":1}}],[\"当存在第二个线程申请同一个锁对象时\",{\"1\":{\"657\":1}}],[\"当该线程再次请求锁时\",{\"1\":{\"656\":1}}],[\"当持有锁的线程释放锁时\",{\"1\":{\"653\":1}}],[\"当计数器为0则可以成功获取\",{\"1\":{\"651\":1}}],[\"当计数归\",{\"1\":{\"435\":1}}],[\"当且仅当\",{\"1\":{\"644\":1}}],[\"当且仅当x\",{\"1\":{\"476\":1}}],[\"当volatile变量被修改\",{\"1\":{\"637\":1,\"708\":1}}],[\"当分配到时间片后就可以开始运行了\",{\"1\":{\"635\":1,\"703\":1}}],[\"当notify或者notifyall被调用后\",{\"1\":{\"633\":1,\"701\":1}}],[\"当睡眠时间到了\",{\"1\":{\"633\":1,\"701\":1}}],[\"当sleep\",{\"1\":{\"623\":1,\"690\":1}}],[\"当session\",{\"1\":{\"188\":1}}],[\"当cpu开始调度处于就绪状态的线程时\",{\"1\":{\"623\":1,\"690\":1}}],[\"当cwndssthresh时\",{\"1\":{\"24\":1}}],[\"当只有一个线程的时候会导致\",{\"1\":{\"622\":1,\"689\":1}}],[\"当其\",{\"1\":{\"612\":1}}],[\"当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人\",{\"1\":{\"720\":1}}],[\"当线程池决定哪些线程需要回收时\",{\"1\":{\"714\":1}}],[\"当线程执行完任务后则会继续获取新的任务去执行\",{\"1\":{\"711\":1}}],[\"当线程执行完逻辑后\",{\"1\":{\"611\":1}}],[\"当线程要获取锁时\",{\"1\":{\"680\":1}}],[\"当线程数量大于maximumpoolsize\",{\"1\":{\"671\":1}}],[\"当线程尝试获取锁失败\",{\"1\":{\"653\":1}}],[\"当线程因为某种原因放弃\",{\"1\":{\"639\":1}}],[\"当线程对象对创建后\",{\"1\":{\"623\":1,\"690\":1}}],[\"当线程获取同步状态失败后\",{\"1\":{\"611\":1}}],[\"当线程获取同步状态后\",{\"1\":{\"611\":1}}],[\"当线程在持有锁的情况下再次请求加锁\",{\"1\":{\"435\":1}}],[\"当头结点在释放同步状态时\",{\"1\":{\"608\":1}}],[\"当出现锁竞争以及释放锁的时候\",{\"1\":{\"607\":1}}],[\"当出现redis查不到数据\",{\"1\":{\"395\":1}}],[\"当溢出发生时\",{\"1\":{\"576\":1}}],[\"当r1=h1\",{\"1\":{\"576\":1}}],[\"当redis中的key被scan的时候\",{\"1\":{\"421\":1}}],[\"当redis的内存超过最大允许的内存之后\",{\"1\":{\"388\":1}}],[\"当满足一定条件\",{\"1\":{\"557\":1}}],[\"当元素大于\",{\"1\":{\"553\":1,\"577\":1}}],[\"当元素小于\",{\"1\":{\"553\":1,\"577\":1}}],[\"当链表超过\",{\"1\":{\"553\":1,\"575\":1}}],[\"当链表过长\",{\"1\":{\"553\":1,\"575\":1}}],[\"当在链表长度达到8的时候\",{\"1\":{\"585\":1}}],[\"当在链表长度达到\",{\"1\":{\"547\":1}}],[\"当在服务器上看到大量的半连接状态时\",{\"1\":{\"14\":1}}],[\"当试图将一个string转换为指定的数字类型\",{\"1\":{\"534\":1}}],[\"当试图通过newinstance\",{\"1\":{\"534\":1}}],[\"当访问某个类的不存在的方法时抛出该异常\",{\"1\":{\"534\":1}}],[\"当访问某个类的不存在的属性时抛出该异常\",{\"1\":{\"534\":1}}],[\"当访问某个序列的索引值小于0或大于等于序列大小时\",{\"1\":{\"534\":1}}],[\"当对数组的索引值为负数或大于等于数组大小时抛出\",{\"1\":{\"534\":1}}],[\"当对表中的数据进行增加\",{\"1\":{\"86\":1,\"147\":1}}],[\"当应用试图在要求使用对象的地方使用了null时\",{\"1\":{\"534\":1}}],[\"当应用试图根据字符串形式的类名构造类\",{\"1\":{\"534\":1}}],[\"当应用增多相对复杂的系统中\",{\"1\":{\"381\":1}}],[\"当可用内存不足以让java虚拟机分配给一个对象时抛出该错误\",{\"1\":{\"534\":1}}],[\"当再次需要这个对象的时候\",{\"1\":{\"518\":1}}],[\"当值超出此范围\",{\"1\":{\"499\":1}}],[\"当值在\",{\"1\":{\"499\":1}}],[\"当需要使用字符串时\",{\"1\":{\"487\":1}}],[\"当需要该key时\",{\"1\":{\"386\":1}}],[\"当初始化一个string变量时\",{\"1\":{\"482\":1}}],[\"当调用\",{\"1\":{\"631\":2,\"699\":2}}],[\"当调用线程对象的start\",{\"1\":{\"623\":1,\"690\":1}}],[\"当调用max\",{\"1\":{\"467\":1}}],[\"当调用接口方法时\",{\"1\":{\"182\":1}}],[\"当类被java虚拟机载入的时候\",{\"1\":{\"457\":1}}],[\"当使用索引值访问某个字符串中的字符\",{\"1\":{\"534\":1}}],[\"当使用\",{\"1\":{\"533\":1}}],[\"当使用externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeexternal\",{\"1\":{\"522\":1}}],[\"当使用redis存储大量数据时\",{\"1\":{\"438\":1}}],[\"当使用append\",{\"1\":{\"407\":1}}],[\"当获取锁失败时\",{\"1\":{\"435\":1}}],[\"当并发量比较大时\",{\"1\":{\"435\":1}}],[\"当未获取到锁时\",{\"1\":{\"435\":1}}],[\"当得到的锁的线程执行完任务\",{\"1\":{\"434\":1}}],[\"当一个node被初始化的时候的默认值\",{\"1\":{\"603\":1}}],[\"当一个线程执行\",{\"1\":{\"622\":1,\"689\":1}}],[\"当一个线程执行setnx返回0\",{\"1\":{\"434\":1}}],[\"当一个线程执行setnx返回1\",{\"1\":{\"434\":1}}],[\"当一个线程占用锁访问其中一个段数据时\",{\"1\":{\"584\":1}}],[\"当一个线程占用锁访问其中一段数据时\",{\"1\":{\"546\":1}}],[\"当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误\",{\"1\":{\"534\":1}}],[\"当一个应用试图通过java的new操作符构造一个抽象类或者接口时抛出该异常\",{\"1\":{\"534\":1}}],[\"当一个应用试图访问\",{\"1\":{\"534\":1}}],[\"当一个网页打开完成后\",{\"1\":{\"31\":1}}],[\"当master被\",{\"1\":{\"425\":1}}],[\"当mysql单表记录数过大时\",{\"1\":{\"142\":1}}],[\"当有足够数量的\",{\"1\":{\"425\":1}}],[\"当有新消息的时候返回请求\",{\"1\":{\"367\":1}}],[\"当启动一个slave\",{\"1\":{\"420\":1}}],[\"当多个key分布于不同的节点上时无法使用事务功能\",{\"1\":{\"417\":1}}],[\"当多个用户同时请求一个服务时\",{\"1\":{\"282\":1}}],[\"当多个用户并发地存取数据时\",{\"1\":{\"113\":1}}],[\"当遇到单机内存\",{\"1\":{\"417\":1}}],[\"当主节点出现故障时\",{\"1\":{\"419\":1}}],[\"当主服务器宕机后\",{\"1\":{\"416\":1}}],[\"当主库节点出现故障时\",{\"1\":{\"415\":1}}],[\"当操作被打断时\",{\"1\":{\"409\":1}}],[\"当exec命令被调用时\",{\"1\":{\"409\":1}}],[\"当事件处理器处理完一个事件后\",{\"1\":{\"403\":1}}],[\"当这些方法被调用后\",{\"1\":{\"511\":1}}],[\"当这些\",{\"1\":{\"403\":1}}],[\"当流量达到一定的阈值\",{\"1\":{\"396\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"388\":2}}],[\"当aof文件的大小超过所设定的阈值时\",{\"1\":{\"383\":1}}],[\"当路由不到时\",{\"1\":{\"355\":1}}],[\"当broker正常关闭时\",{\"1\":{\"340\":1}}],[\"当bean不再用到\",{\"1\":{\"275\":1}}],[\"当你知道该类的全路径名时\",{\"1\":{\"503\":1}}],[\"当你把对象加入\",{\"1\":{\"478\":1}}],[\"当你手动运行kafka\",{\"1\":{\"340\":2}}],[\"当你希望将特定功能应用于某些请求时\",{\"1\":{\"298\":1}}],[\"当前变量在寄存器\",{\"1\":{\"646\":1}}],[\"当前线程获取同步状态失败\",{\"1\":{\"679\":1}}],[\"当前线程将睡眠n毫秒\",{\"1\":{\"633\":1,\"701\":1}}],[\"当前线程就可以尝试获取锁\",{\"1\":{\"617\":1}}],[\"当前线程会根据公平性原则来进行阻塞等待\",{\"1\":{\"610\":1}}],[\"当前线程处在shared情况下\",{\"1\":{\"603\":1}}],[\"当前节点在队列中的状态\",{\"1\":{\"603\":1}}],[\"当前节点无需使用cf解析完成的域名\",{\"1\":{\"69\":2}}],[\"当前访问的是从库\",{\"1\":{\"421\":1}}],[\"当前访问的master则返回null\",{\"1\":{\"421\":1}}],[\"当前最新的版本0\",{\"1\":{\"338\":1}}],[\"当isr中所有replica都向leader发送ack时\",{\"1\":{\"330\":1}}],[\"当某个broker下线了\",{\"1\":{\"374\":1}}],[\"当某个实例挂掉的时候\",{\"1\":{\"326\":1}}],[\"当某一个作用域\",{\"1\":{\"188\":1}}],[\"当创建一个\",{\"1\":{\"323\":1}}],[\"当进行查询时\",{\"1\":{\"153\":1}}],[\"当然接收数据时\",{\"1\":{\"731\":1}}],[\"当然这也可以通过线程池机制改善\",{\"1\":{\"542\":1}}],[\"当然这些默认配置是可以按需修改的\",{\"1\":{\"304\":1}}],[\"当然可以\",{\"1\":{\"473\":1}}],[\"当然可以通过sdk的合理设计来提高slave资源的利用率\",{\"1\":{\"417\":1}}],[\"当然为了满足业务的高可用性\",{\"1\":{\"414\":1}}],[\"当然也可以编写自\",{\"1\":{\"352\":1}}],[\"当然也可以根据需要重写它们以满足开发人员的需求\",{\"1\":{\"304\":1}}],[\"当然你也可以配置jetty或undertow\",{\"1\":{\"304\":1}}],[\"当然还有许多性能上与代码质量上的工作需要完成\",{\"1\":{\"260\":1}}],[\"当然它是及其不完善的\",{\"1\":{\"218\":1}}],[\"当然\",{\"1\":{\"151\":1,\"292\":1,\"294\":1,\"297\":1,\"337\":1,\"353\":1}}],[\"当\",{\"1\":{\"141\":1,\"169\":1,\"278\":1,\"403\":2,\"516\":1,\"537\":1,\"555\":2,\"560\":1,\"582\":1,\"639\":1}}],[\"当时我们可以修改为select\",{\"1\":{\"136\":1}}],[\"当当开源的\",{\"1\":{\"126\":1}}],[\"当执行acquire\",{\"1\":{\"606\":1}}],[\"当执行副本重分配后\",{\"1\":{\"340\":1}}],[\"当执行\",{\"1\":{\"112\":1,\"651\":1}}],[\"当系统管理员\",{\"1\":{\"103\":1}}],[\"当表结构发生变化的时候\",{\"1\":{\"89\":1}}],[\"当表中的数据量越来越大时\",{\"1\":{\"78\":1}}],[\"当无法使用statement的时候使用row\",{\"1\":{\"89\":1}}],[\"当判断缓存是否命中时\",{\"1\":{\"88\":1,\"99\":1}}],[\"当用户提交了一个任务\",{\"1\":{\"713\":1}}],[\"当用户要进行数据的写入时\",{\"1\":{\"115\":1}}],[\"当用户要进行数据的读取时\",{\"1\":{\"115\":1}}],[\"当用户第二次访问服务器的时候\",{\"1\":{\"40\":1}}],[\"当用户在应用程序的\",{\"1\":{\"39\":1}}],[\"当客户端关闭会话\",{\"1\":{\"39\":1}}],[\"当浏览器每遇到这样一个web资源\",{\"1\":{\"31\":1}}],[\"当发送方连续收到三个重复确认时\",{\"1\":{\"24\":1}}],[\"窗口会导致主从节点之间的数据不一致\",{\"1\":{\"342\":1}}],[\"窗口内等待发送的分组也会不断被发送\",{\"1\":{\"23\":1}}],[\"窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值\",{\"1\":{\"23\":1}}],[\"才可以做后续的分配工作\",{\"1\":{\"713\":1}}],[\"才可以发送下一个数据包\",{\"1\":{\"23\":1}}],[\"才诞生了读写锁readwritelock\",{\"1\":{\"667\":1}}],[\"才\",{\"1\":{\"623\":1,\"690\":1}}],[\"才认为完全释放锁\",{\"1\":{\"617\":1}}],[\"才认为本次写成功了\",{\"1\":{\"333\":1}}],[\"才算真正的获取锁成功\",{\"1\":{\"437\":1}}],[\"才对键进行设置操作\",{\"1\":{\"435\":2}}],[\"才叫做单线程的模型\",{\"1\":{\"403\":1}}],[\"才会转红黑树\",{\"1\":{\"553\":1,\"575\":1}}],[\"才会去执行下一个操作\",{\"1\":{\"392\":1}}],[\"才会进入死信队列\",{\"1\":{\"373\":1}}],[\"才是所谓的rabbitmq的高可用模式\",{\"1\":{\"361\":1}}],[\"才能对某资源进行操作\",{\"1\":{\"627\":1,\"694\":1}}],[\"才能认为是写成功了\",{\"1\":{\"334\":1}}],[\"才能将\",{\"1\":{\"277\":1}}],[\"才有机会再次获得\",{\"1\":{\"639\":1}}],[\"才有了\",{\"1\":{\"310\":1}}],[\"才有利于后面使用netty的方式实现客户端\",{\"1\":{\"237\":1}}],[\"才进入\",{\"1\":{\"16\":1}}],[\"提升吞吐量\",{\"1\":{\"720\":1}}],[\"提升了读写的性能\",{\"1\":{\"667\":1}}],[\"提升用户体验\",{\"1\":{\"345\":1}}],[\"提前将相关的缓存数据加载到缓存系统\",{\"1\":{\"397\":1}}],[\"提交事务\",{\"1\":{\"177\":1}}],[\"提示\",{\"1\":{\"69\":1,\"493\":1}}],[\"提高程序运行性能\",{\"1\":{\"674\":1}}],[\"提高线程的可管理性\",{\"1\":{\"668\":1}}],[\"提高响应速度\",{\"1\":{\"668\":1,\"720\":1}}],[\"提高灵活性\",{\"1\":{\"502\":1}}],[\"提高了系统的安全性\",{\"1\":{\"490\":1}}],[\"提高了开发难度\",{\"1\":{\"417\":1}}],[\"提高机器内存读写的速度\",{\"1\":{\"401\":1}}],[\"提高序列化反序列化效率\",{\"1\":{\"236\":1}}],[\"提高系统的扩展性和可用性\",{\"1\":{\"417\":1}}],[\"提高系统的性能\",{\"1\":{\"147\":1}}],[\"提高系统安全性\",{\"1\":{\"181\":1}}],[\"提高效率\",{\"1\":{\"178\":1}}],[\"提高数据安全\",{\"1\":{\"130\":1}}],[\"提高通信速率\",{\"1\":{\"98\":1}}],[\"提高网络吞吐量\",{\"1\":{\"24\":1}}],[\"提高性能\",{\"1\":{\"22\":1}}],[\"提供多个不同的hash函数\",{\"1\":{\"576\":1}}],[\"提供帧的处理\",{\"1\":{\"354\":1}}],[\"提供可靠性同步机制和错误处理\",{\"1\":{\"354\":1}}],[\"提供可设置应用整体样式风格的支持\",{\"1\":{\"291\":1}}],[\"提供默认配置\",{\"1\":{\"304\":1}}],[\"提供的\",{\"1\":{\"292\":1}}],[\"提供的zookeeper客户端\",{\"1\":{\"251\":1}}],[\"提供国际化支持\",{\"1\":{\"291\":1}}],[\"提供了四大场景\",{\"1\":{\"677\":1}}],[\"提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值\",{\"1\":{\"676\":1}}],[\"提供了更多的方法和特性\",{\"1\":{\"574\":1}}],[\"提供了许多插件\",{\"1\":{\"352\":1}}],[\"提供了一个易用的用户界面\",{\"1\":{\"352\":1}}],[\"提供了\",{\"1\":{\"323\":1}}],[\"提供了完全的\",{\"1\":{\"285\":1}}],[\"提供了与\",{\"1\":{\"283\":1}}],[\"提供了哪些配置方式\",{\"0\":{\"268\":1}}],[\"提供了日志\",{\"1\":{\"175\":1}}],[\"提供方便的api把具体技术相关的异常\",{\"1\":{\"263\":1}}],[\"提供一个持续的事务管理接口\",{\"1\":{\"263\":1}}],[\"提供一个便宜域名注册网站\",{\"1\":{\"66\":1}}],[\"提供对象关系映射\",{\"1\":{\"179\":1}}],[\"提供对象关系映射标签\",{\"1\":{\"173\":1}}],[\"提供\",{\"1\":{\"179\":1,\"294\":1}}],[\"提供映射标签\",{\"1\":{\"173\":1,\"179\":1}}],[\"提供xml标签\",{\"1\":{\"173\":1}}],[\"提供参数化查询接口\",{\"1\":{\"45\":1}}],[\"提供无连接的\",{\"1\":{\"8\":1}}],[\"提供面向连接的\",{\"1\":{\"8\":1}}],[\"造成了内存泄漏问题\",{\"1\":{\"665\":1}}],[\"造成了一定的空间浪费\",{\"1\":{\"386\":1}}],[\"造成很深的问题\",{\"1\":{\"553\":1}}],[\"造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题\",{\"1\":{\"480\":1}}],[\"造成大量数据库的访问\",{\"1\":{\"396\":1}}],[\"造成缓存雪崩的关键在于同一时间的大规模的key失效\",{\"1\":{\"396\":1}}],[\"造成数据库压力过大\",{\"1\":{\"395\":1}}],[\"造成的\",{\"1\":{\"141\":1}}],[\"造成网络拥堵\",{\"1\":{\"22\":1}}],[\"造成资源浪费\",{\"1\":{\"12\":1}}],[\"告知应用开发负责人\",{\"1\":{\"720\":1}}],[\"告知对方自己的初始序号值\",{\"1\":{\"12\":1}}],[\"告诉发送方\",{\"1\":{\"22\":1}}],[\"每来一个人不会去管队列如何\",{\"1\":{\"616\":1}}],[\"每当提交一个任务就创建一个工作线程\",{\"1\":{\"672\":1}}],[\"每当迭代器使用hashnext\",{\"1\":{\"598\":1}}],[\"每当有分区上线时\",{\"1\":{\"340\":1}}],[\"每当有记录在表中增减或索引列被修改时\",{\"1\":{\"162\":1}}],[\"每当有修改事务时\",{\"1\":{\"104\":1}}],[\"每种流包括输入和输出两种所以一共四个\",{\"1\":{\"539\":1}}],[\"每修改同步\",{\"1\":{\"383\":1}}],[\"每秒几万没问题\",{\"1\":{\"439\":1}}],[\"每秒记录\",{\"1\":{\"383\":1}}],[\"每秒同步策略效率较好\",{\"1\":{\"383\":1}}],[\"每秒同步\",{\"1\":{\"383\":1}}],[\"每秒可以处理超过\",{\"1\":{\"376\":1}}],[\"每秒钟就\",{\"1\":{\"348\":1}}],[\"每秒钟就拉取\",{\"1\":{\"348\":1}}],[\"每秒钟\",{\"1\":{\"348\":1}}],[\"每秒钟最多处理\",{\"1\":{\"348\":1}}],[\"每秒钟对\",{\"1\":{\"348\":1}}],[\"每秒\",{\"1\":{\"348\":1}}],[\"每秒并发请求数量突然会暴增到\",{\"1\":{\"348\":1}}],[\"每秒并发请求数量就\",{\"1\":{\"348\":1}}],[\"每天\",{\"1\":{\"348\":1}}],[\"每一级缓存的失效时间都不同\",{\"1\":{\"396\":1}}],[\"每一种场景对应于一种选举策略\",{\"1\":{\"340\":1}}],[\"每一次创建都会调用根对象的copy方法复制一份\",{\"1\":{\"507\":1}}],[\"每一次\",{\"1\":{\"272\":2}}],[\"每一次http请求都会产生一个新的bean\",{\"1\":{\"269\":1}}],[\"每一次代理对象调用方法\",{\"1\":{\"223\":1}}],[\"每一个类必须有自己的构造函数\",{\"1\":{\"468\":1}}],[\"每一个客户端都必须知道对应服务的ip与端口号\",{\"1\":{\"247\":1}}],[\"每一个版本都有着要解决的问题与此版本的最大痛点\",{\"1\":{\"206\":1}}],[\"每一个索引还要占一定的物理空间\",{\"1\":{\"86\":1}}],[\"每一版本前有一个背景知识\",{\"1\":{\"206\":1}}],[\"每一版本都有着对应独立的代码与文档\",{\"1\":{\"206\":1}}],[\"每一行数据都有一个隐藏的回滚指针\",{\"1\":{\"112\":1}}],[\"每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化\",{\"1\":{\"104\":1}}],[\"每次都只有一个线程运行\",{\"1\":{\"601\":1}}],[\"每次在add\",{\"1\":{\"573\":1}}],[\"每次调用前都进行安全检查\",{\"1\":{\"511\":1}}],[\"每次使用时都需要强制转换成想要的类型\",{\"1\":{\"510\":1}}],[\"每次getmethod获取到的method对象都持有对根对象的引用\",{\"1\":{\"507\":1}}],[\"每次对string\",{\"1\":{\"481\":1}}],[\"每次增加或减少master节点都是对16384取模\",{\"1\":{\"429\":1}}],[\"每次切换的version号都必须是唯一的\",{\"1\":{\"427\":1}}],[\"每次一个事件的方式向文件时间分派器中传送\",{\"1\":{\"403\":1}}],[\"每次发生数据变更会被立即记录到磁盘\",{\"1\":{\"383\":1}}],[\"每次浏览都得给+1\",{\"1\":{\"381\":1}}],[\"每次请求都会产生一个新的实例\",{\"1\":{\"272\":1}}],[\"每次请求都会创建一个新的\",{\"1\":{\"269\":1}}],[\"每次执行do\",{\"1\":{\"198\":1}}],[\"每次插入都是插入到最后\",{\"1\":{\"158\":1}}],[\"每次loop循环再对内表进行查询\",{\"1\":{\"96\":1}}],[\"每次客户端访问的服务器都是同一个服务器\",{\"1\":{\"46\":1}}],[\"每次接收方收到数据后\",{\"1\":{\"22\":1}}],[\"每台服务器都具有等价的地位\",{\"1\":{\"46\":1}}],[\"每个进程都可以直接访问\",{\"1\":{\"731\":1}}],[\"每个进程都是共享一个内核空间\",{\"1\":{\"731\":1}}],[\"每个进程都有独立的代码和数据空间\",{\"1\":{\"620\":1,\"687\":1}}],[\"每个worker会while死循环从阻塞队列中取数据\",{\"1\":{\"674\":1}}],[\"每个worker都是一个线程\",{\"1\":{\"674\":1}}],[\"每个entry代表一个完整的对象\",{\"1\":{\"664\":2}}],[\"每个独立的进程有程序运行的入口\",{\"1\":{\"620\":1,\"687\":1}}],[\"每个线程调用await方法告诉\",{\"1\":{\"681\":1}}],[\"每个线程池还维护一些基本统计信息\",{\"1\":{\"668\":1}}],[\"每个线程在往threadlocal里设置值的时候\",{\"1\":{\"664\":1}}],[\"每个线程都有自己独立的运行栈和程序计数器\",{\"1\":{\"620\":1,\"687\":1}}],[\"每个线程分别消费一个内存\",{\"1\":{\"337\":1}}],[\"每个小数组有\",{\"1\":{\"546\":1,\"584\":1}}],[\"每个重载的方法\",{\"1\":{\"466\":1}}],[\"每个主节点存一部分数据\",{\"1\":{\"439\":1}}],[\"每个主题分区下的每条消息都被赋予了一个唯一的id数值\",{\"1\":{\"328\":1}}],[\"每个sentinel以每秒钟一次的频率向它所知的master\",{\"1\":{\"425\":1}}],[\"每个节点负责维护一部分槽以及槽所印映射的键值数据\",{\"1\":{\"417\":1}}],[\"每个节点数据会一致\",{\"1\":{\"374\":1}}],[\"每个处理器对应不同的\",{\"1\":{\"403\":1}}],[\"每个工作线程串行地拿到对应的操作\",{\"1\":{\"392\":1}}],[\"每个实例都需要各自保存一份缓存\",{\"1\":{\"380\":1}}],[\"每个5s执行一次检查pullrequesttable有没有消息\",{\"1\":{\"367\":1}}],[\"每个group都会有一个consumer消费到数据\",{\"1\":{\"364\":1}}],[\"每个角色作用和特点是什么\",{\"0\":{\"363\":1}}],[\"每个机器启动一个\",{\"1\":{\"361\":1}}],[\"每个机器就放一部分数据\",{\"1\":{\"323\":1}}],[\"每个服务叫做一个\",{\"1\":{\"322\":1}}],[\"每个\",{\"1\":{\"269\":1,\"272\":1,\"323\":4,\"382\":1,\"425\":1}}],[\"每个子标签\",{\"1\":{\"204\":1}}],[\"每个查询对应的表名\",{\"1\":{\"157\":1}}],[\"每个叶子节点都指向相邻的叶子节点的地址\",{\"1\":{\"149\":1}}],[\"每个库表都包含部分字段\",{\"1\":{\"128\":1}}],[\"每个库表的结构都不一样\",{\"1\":{\"128\":1}}],[\"每个事务对同一张表\",{\"1\":{\"111\":1}}],[\"每个请求按访问\",{\"1\":{\"42\":1}}],[\"每个连接的request可以随机的混杂在一起\",{\"1\":{\"34\":1}}],[\"每隔一段时间\",{\"1\":{\"386\":1}}],[\"每隔1ms检查commitlog中是否有新消息\",{\"1\":{\"367\":1}}],[\"每隔\",{\"1\":{\"19\":1}}],[\"假定继承者\",{\"1\":{\"653\":1}}],[\"假定有以下这样一个服务\",{\"1\":{\"215\":1}}],[\"假定会发生并发冲突\",{\"1\":{\"116\":1}}],[\"假如我们要计算一个复杂的任务\",{\"1\":{\"622\":1,\"689\":1}}],[\"假如我们现在已经有了两个客户端\",{\"1\":{\"237\":1}}],[\"假如master是10g那slave也只能存10g数据\",{\"1\":{\"439\":1}}],[\"假如传进来的这个不存在的key值每次都是随机的\",{\"1\":{\"395\":1}}],[\"假如有黑客传进大量的不存在的key\",{\"1\":{\"395\":1}}],[\"假如有差错就会直接丢弃tcp段\",{\"1\":{\"22\":1}}],[\"假如耗时\",{\"1\":{\"347\":1}}],[\"假如小明要给小红转账1000元\",{\"1\":{\"100\":1}}],[\"假如申请了char\",{\"1\":{\"95\":1}}],[\"假如创建一个\",{\"1\":{\"84\":1}}],[\"假设初始条件是a\",{\"1\":{\"645\":1}}],[\"假设concurrenthashmap\",{\"1\":{\"588\":1}}],[\"假设线程1和线程2同时执行put\",{\"1\":{\"565\":1}}],[\"假设hashmap初始化大小为2\",{\"1\":{\"564\":1}}],[\"假设此时\",{\"1\":{\"548\":1,\"588\":1}}],[\"假设\",{\"1\":{\"548\":1,\"564\":1}}],[\"假设使用可重入锁来获得同步支持\",{\"1\":{\"546\":1}}],[\"假设有类a和b\",{\"1\":{\"534\":1}}],[\"假设有5个完全独立的redis主服务器\",{\"1\":{\"437\":1}}],[\"假设一个master存32g\",{\"1\":{\"439\":1}}],[\"假设一个场景中\",{\"1\":{\"435\":1}}],[\"假设现在有两个线程同时进行\",{\"1\":{\"564\":1}}],[\"假设现在\",{\"1\":{\"345\":1}}],[\"假设现在建立了\",{\"1\":{\"153\":1}}],[\"假设原来的ar是\",{\"1\":{\"340\":1}}],[\"假设我们有一个\",{\"1\":{\"277\":1}}],[\"假设我们在员工表的年龄上建立了索引\",{\"1\":{\"152\":1}}],[\"假设不会发生并发冲突\",{\"1\":{\"116\":1}}],[\"假设为\",{\"1\":{\"112\":1}}],[\"假设用户\",{\"1\":{\"74\":1}}],[\"假设客户端发送\",{\"1\":{\"12\":1}}],[\"接近\",{\"1\":{\"347\":1}}],[\"接着工作\",{\"1\":{\"564\":1}}],[\"接着其他\",{\"1\":{\"323\":1}}],[\"接着会返回一个\",{\"1\":{\"133\":1}}],[\"接抛出beancurrentlylncreationexception异常\",{\"1\":{\"281\":1}}],[\"接受的是response对象\",{\"1\":{\"223\":1}}],[\"接口对象能执行我们的线程任务\",{\"1\":{\"676\":1}}],[\"接口不会返回结果或抛出检查异常\",{\"1\":{\"629\":1,\"696\":1}}],[\"接口可以返回结果或抛出检查异常\",{\"1\":{\"629\":1,\"696\":1}}],[\"接口以启用其序列化功能\",{\"1\":{\"521\":1}}],[\"接口接收连接\",{\"1\":{\"506\":1}}],[\"接口或则对象的信息\",{\"1\":{\"504\":1}}],[\"接口中不能含有静态代码块以及静态方法\",{\"1\":{\"469\":1}}],[\"接口是通过\",{\"1\":{\"301\":1}}],[\"接口和方法的创建中\",{\"1\":{\"509\":1}}],[\"接口和\",{\"1\":{\"284\":1}}],[\"接口注入\",{\"1\":{\"265\":1}}],[\"接口\",{\"0\":{\"521\":1,\"522\":1},\"1\":{\"196\":1,\"197\":1,\"198\":1,\"201\":1,\"202\":1,\"203\":1,\"291\":2,\"292\":1,\"451\":2,\"543\":2,\"571\":1,\"638\":2}}],[\"接口名\",{\"1\":{\"193\":1,\"199\":2}}],[\"接口全限名+方法名的拼接字符串作为key值\",{\"1\":{\"182\":1}}],[\"接口方法内的参数\",{\"1\":{\"182\":1}}],[\"接口的一个实例\",{\"1\":{\"638\":1}}],[\"接口的方法名\",{\"1\":{\"182\":1}}],[\"接口的全限名就是映射文件中的namespace的值\",{\"1\":{\"182\":1}}],[\"接下来这个任务将如何执行都是由这个阶段决定的\",{\"1\":{\"713\":1}}],[\"接下来调用beanpostprocess的postprocessbeforeinitialization方法\",{\"1\":{\"276\":1}}],[\"接下来就是一些修修补补已经扩展功能的模块了\",{\"1\":{\"255\":1}}],[\"接下来就可以用对称加密愉快地进行通信了\",{\"1\":{\"37\":1}}],[\"接下来我会以一个从数据库里取数据的例子来进行一次模拟rpc过程的一个完整流程\",{\"1\":{\"215\":1}}],[\"接下来的其它操作或故障不应该对其执行结果有任何影响\",{\"1\":{\"101\":1}}],[\"接下来可能会继续发送数据\",{\"1\":{\"17\":1}}],[\"接收消息\",{\"1\":{\"358\":1}}],[\"接收到消息后\",{\"1\":{\"333\":1}}],[\"接收到response\",{\"1\":{\"237\":1}}],[\"接收到了哪些数据\",{\"1\":{\"22\":1}}],[\"接收object\",{\"1\":{\"202\":1}}],[\"接收sql语句作为参数\",{\"1\":{\"198\":1}}],[\"接收configuration\",{\"1\":{\"194\":1}}],[\"接收方可以根据request的\",{\"1\":{\"34\":1}}],[\"接收端可以检测出来数据是否有差错和异常\",{\"1\":{\"22\":1}}],[\"检查现在线程池的运行状态\",{\"1\":{\"713\":1}}],[\"检查是否溢出\",{\"1\":{\"573\":1}}],[\"检查用户主题时\",{\"1\":{\"298\":1}}],[\"检查方法\",{\"1\":{\"200\":1}}],[\"检查数据表和数据列是否存在\",{\"1\":{\"88\":1,\"99\":1}}],[\"检查约束\",{\"1\":{\"87\":1}}],[\"检查tls是否为\",{\"1\":{\"71\":1}}],[\"检查csv头部是否包含必需字段\",{\"1\":{\"71\":1}}],[\"检查响应状态是否为\",{\"1\":{\"71\":1}}],[\"检验和\",{\"1\":{\"22\":1}}],[\"检测一个对象是否等于另一个对象\",{\"1\":{\"476\":1}}],[\"检测是否以xml后缀结尾\",{\"1\":{\"196\":1}}],[\"检测\",{\"1\":{\"14\":1}}],[\"滑动窗口里面也分为两块\",{\"1\":{\"23\":1}}],[\"滑动窗口右边是还没有轮到的分组\",{\"1\":{\"23\":1}}],[\"滑动窗口既提高了报文传输的效率\",{\"1\":{\"22\":1}}],[\"滑动窗口\",{\"1\":{\"22\":2}}],[\"由内部来维护\",{\"1\":{\"712\":1}}],[\"由executor框架完成线程的调配和任务的执行部分\",{\"1\":{\"711\":1}}],[\"由结构图是可以看出\",{\"1\":{\"664\":1}}],[\"由应用程序提供多个线程执行控制\",{\"1\":{\"620\":1,\"687\":1}}],[\"由公式\",{\"1\":{\"564\":1}}],[\"由reflectionfactory创建\",{\"1\":{\"507\":1}}],[\"由sentinel自动完成故障发现和转移\",{\"1\":{\"419\":1}}],[\"由该命令回复处理器将准备好的响应数据写入\",{\"1\":{\"403\":1}}],[\"由事件\",{\"1\":{\"366\":1}}],[\"由交换器将消息路由到一个或者多个队列中\",{\"1\":{\"355\":1}}],[\"由多个\",{\"1\":{\"323\":1}}],[\"由它去执行处理器\",{\"1\":{\"291\":1}}],[\"由谁实现\",{\"1\":{\"270\":1}}],[\"由\",{\"1\":{\"265\":1,\"553\":2,\"575\":2}}],[\"由此便产生了数据不一致的问题\",{\"1\":{\"342\":1}}],[\"由此\",{\"1\":{\"237\":1}}],[\"由此我们将传输对象抽象成为object\",{\"1\":{\"223\":1}}],[\"由简陋到逐渐完备\",{\"1\":{\"206\":1}}],[\"由其选择是否还要继续通信\",{\"1\":{\"37\":1}}],[\"由小到大逐渐增加拥塞窗口的大小\",{\"1\":{\"24\":1}}],[\"由浏览器来主动断开连接\",{\"1\":{\"21\":1}}],[\"由于每个进程的用户空间都是独立的\",{\"1\":{\"731\":1}}],[\"由于线程池的任务队列永远不会放满\",{\"1\":{\"673\":1}}],[\"由于线程被无限期地阻塞\",{\"1\":{\"625\":1,\"692\":1}}],[\"由于大量线程同时运行\",{\"1\":{\"672\":1}}],[\"由于是重入锁所以需要将\",{\"1\":{\"617\":1}}],[\"由于reentrantlock是通过公平锁和非公平锁内部类实现的tryacquire方法\",{\"1\":{\"615\":1}}],[\"由于本篇文章不讲述condition\",{\"1\":{\"603\":1}}],[\"由于迭代时是对原集合的拷贝进行遍历\",{\"1\":{\"598\":1}}],[\"由于hashmap的k值本身就不允许重复\",{\"1\":{\"595\":1}}],[\"由于\",{\"1\":{\"547\":1,\"644\":1,\"673\":1}}],[\"由于只能通过1个return返回\",{\"1\":{\"536\":1}}],[\"由于类型擦除\",{\"1\":{\"511\":1}}],[\"由于泛型的实现方式\",{\"1\":{\"510\":1}}],[\"由于integer变量实际上是对一个integer对象的引用\",{\"1\":{\"496\":1}}],[\"由于会大量的使用string常量\",{\"1\":{\"482\":1}}],[\"由于面向对象有封装\",{\"1\":{\"463\":1}}],[\"由于字节码并不专对一种特定的机器\",{\"1\":{\"446\":1}}],[\"由于sync\",{\"1\":{\"615\":1}}],[\"由于string是不可变的\",{\"1\":{\"482\":1}}],[\"由于setnx指令本身是不支持传入超时时间的\",{\"1\":{\"435\":1}}],[\"由于sql的执行是有上下文的\",{\"1\":{\"89\":1}}],[\"由于主从延迟导致读取到过期数据怎么处理\",{\"0\":{\"421\":1}}],[\"由于该锁已经被持有\",{\"1\":{\"435\":1}}],[\"由于该\",{\"1\":{\"403\":1}}],[\"由于开始之初\",{\"1\":{\"403\":1}}],[\"由于这个文件事件处理器是单线程的\",{\"1\":{\"403\":1}}],[\"由于这种不确定性\",{\"1\":{\"341\":1}}],[\"由于绝大部分都是rdb格式\",{\"1\":{\"384\":1}}],[\"由于网络等原因导致消息丢失\",{\"1\":{\"333\":1}}],[\"由于网络原因造成\",{\"1\":{\"12\":1}}],[\"由于现代的操作系统提供了预读和写技术\",{\"1\":{\"329\":1}}],[\"由于b拿到了a的对象引用\",{\"1\":{\"281\":1}}],[\"由于b+树的数据都存储在叶子结点中\",{\"1\":{\"150\":1}}],[\"由于a通过objectfactory将自己提前曝光了\",{\"1\":{\"281\":1}}],[\"由于json序列化的方式是通过把对象转化成字符串\",{\"1\":{\"244\":1}}],[\"由于mybatis专注于sql本身\",{\"1\":{\"172\":1}}],[\"由于加密处理\",{\"1\":{\"35\":1}}],[\"由于源地址是不存在的\",{\"1\":{\"14\":1}}],[\"都不需要拷贝来拷贝去\",{\"1\":{\"727\":1}}],[\"都要进行的\",{\"1\":{\"535\":1}}],[\"都要与它保持对齐\",{\"1\":{\"327\":1}}],[\"都觉得可能有潜在的问题\",{\"1\":{\"535\":1}}],[\"都能变成一样的东西\",{\"1\":{\"519\":1}}],[\"都能够调用它的任意一个方法和属性\",{\"1\":{\"501\":1}}],[\"都能够知道这个类的所有属性和方法\",{\"1\":{\"501\":1}}],[\"都必须有一个独一无二的参数类型列表\",{\"1\":{\"466\":1}}],[\"都可以编译生成固定格式的字节码\",{\"1\":{\"445\":1}}],[\"都可以用\",{\"1\":{\"310\":1}}],[\"都可能拿到锁\",{\"1\":{\"436\":1}}],[\"都去问这个\",{\"1\":{\"431\":1}}],[\"都采用了\",{\"1\":{\"406\":1}}],[\"都消费一次\",{\"1\":{\"364\":1}}],[\"都直接从mq中获取消息并处理即可\",{\"1\":{\"345\":1}}],[\"都同步到了消息之后\",{\"1\":{\"333\":1}}],[\"都同步成功返回\",{\"1\":{\"323\":1}}],[\"都有可能会出现消息丢失\",{\"1\":{\"331\":1}}],[\"都有不同的会话\",{\"1\":{\"269\":1}}],[\"都有哪些动态sql\",{\"0\":{\"190\":1}}],[\"都add到了configuration中\",{\"1\":{\"194\":1}}],[\"都支持封装\",{\"1\":{\"443\":1}}],[\"都支持\",{\"1\":{\"179\":1}}],[\"都用于dao层的开发\",{\"1\":{\"175\":1}}],[\"都是工作于同一台主机\",{\"1\":{\"731\":1}}],[\"都是一次只允许一个线程访问某个资源\",{\"1\":{\"681\":1}}],[\"都是一系列得到支持的管理传递性依赖\",{\"1\":{\"307\":1}}],[\"都是往自己的threadlocalmap里存\",{\"1\":{\"664\":1}}],[\"都是基于abstractqueuedsynchronizer\",{\"1\":{\"601\":1}}],[\"都是近似\",{\"1\":{\"571\":1}}],[\"都是不同步的\",{\"1\":{\"571\":1}}],[\"都是\",{\"1\":{\"516\":1}}],[\"都是父类\",{\"1\":{\"511\":1}}],[\"都是面向对象的语言\",{\"1\":{\"443\":1}}],[\"都是pull\",{\"1\":{\"365\":1}}],[\"都是持久层的框架\",{\"1\":{\"175\":1}}],[\"都是对jdbc的封装\",{\"1\":{\"175\":1}}],[\"都是访问最新的数据\",{\"1\":{\"128\":1}}],[\"都是客户端所处的状态\",{\"1\":{\"21\":1}}],[\"都会有发生用户态与内核态之间的消息拷贝过程\",{\"1\":{\"727\":1}}],[\"都会回收该对象占用的内存\",{\"1\":{\"665\":1}}],[\"都会检测modcount变量是否为expectedmodcount值\",{\"1\":{\"598\":1}}],[\"都会生成一个新的string对象\",{\"1\":{\"481\":1}}],[\"都会访问到数据库中\",{\"1\":{\"397\":1}}],[\"都会自动把消息到多个实例的queue里进行消息同步\",{\"1\":{\"361\":1}}],[\"都会写一个dao接口与之对应\",{\"0\":{\"182\":1}}],[\"都会保存数据\",{\"1\":{\"80\":1}}],[\"都会对传输方进行确认应答\",{\"1\":{\"22\":1}}],[\"都会重新复位这个计时器\",{\"1\":{\"19\":1}}],[\"一书中给出的原因是\",{\"1\":{\"717\":1}}],[\"一书中建议使用\",{\"1\":{\"515\":1}}],[\"一句话总结它的作用\",{\"1\":{\"656\":1}}],[\"一致\",{\"1\":{\"652\":1}}],[\"一致性问题\",{\"1\":{\"349\":2}}],[\"一致性\",{\"1\":{\"74\":1,\"101\":1,\"476\":1}}],[\"一样吗\",{\"0\":{\"488\":1},\"1\":{\"484\":1}}],[\"一是因为jvm针对各种操作系统\",{\"1\":{\"445\":1}}],[\"一半以上\",{\"1\":{\"436\":1}}],[\"一小部分服务器宕机不影响正常使用\",{\"1\":{\"431\":1}}],[\"一主一从的模式\",{\"1\":{\"428\":1}}],[\"一方面\",{\"1\":{\"415\":1}}],[\"一旦有信号发生\",{\"1\":{\"731\":1}}],[\"一旦有信号产生\",{\"1\":{\"729\":1}}],[\"一旦这类错误发生\",{\"1\":{\"530\":1}}],[\"一旦类被修改了\",{\"1\":{\"525\":1}}],[\"一旦插入失败就会直接报错\",{\"1\":{\"432\":1}}],[\"一旦解锁操作失败\",{\"1\":{\"432\":1}}],[\"一旦数据库挂掉\",{\"1\":{\"432\":1}}],[\"一旦发现延迟超过了该值就不会往master中写入数据\",{\"1\":{\"424\":1}}],[\"一旦发现类似问题\",{\"1\":{\"407\":1}}],[\"一旦其中有一个键被修改\",{\"1\":{\"409\":1}}],[\"一旦重启\",{\"1\":{\"396\":1}}],[\"一旦开启了混合持久化\",{\"1\":{\"384\":1}}],[\"一旦消息被写入到分区日志\",{\"1\":{\"328\":1}}],[\"一条消息只会被同group中的一个consumer消费\",{\"1\":{\"364\":1}}],[\"一条记录\",{\"1\":{\"104\":1}}],[\"一条记录就\",{\"1\":{\"104\":1}}],[\"一级缓存session\",{\"1\":{\"188\":1}}],[\"一级缓存\",{\"1\":{\"188\":1}}],[\"一但需\",{\"1\":{\"178\":1}}],[\"一些非法的参数\",{\"1\":{\"395\":1}}],[\"一些关键日志还要通过邮件的方式发送给指定的人\",{\"1\":{\"345\":1}}],[\"一些\",{\"1\":{\"301\":1}}],[\"一些常见的优化措施如下\",{\"1\":{\"142\":1}}],[\"一些特殊行业可能还需要手动备份\",{\"1\":{\"130\":1}}],[\"一定是true\",{\"1\":{\"476\":2}}],[\"一定会被分发到同一个\",{\"1\":{\"336\":1}}],[\"一定要注意控制任务的数量\",{\"1\":{\"672\":1}}],[\"一定要实际上手敲代码\",{\"1\":{\"206\":1}}],[\"一定要扩容了\",{\"1\":{\"121\":1}}],[\"一定程度上弥补了http1\",{\"1\":{\"33\":1}}],[\"一种动态地往一个类中添加新的行为的设计模式\",{\"1\":{\"543\":1}}],[\"一种叫快照rdb\",{\"1\":{\"383\":1}}],[\"一种是<\",{\"1\":{\"512\":1}}],[\"一种是可以将数据分割到多个redisserver上\",{\"1\":{\"377\":1}}],[\"一种是按照\",{\"1\":{\"128\":1}}],[\"一种是真正的入住一晚\",{\"1\":{\"115\":1}}],[\"一种是来看房\",{\"1\":{\"115\":1}}],[\"一种折中的方案\",{\"1\":{\"89\":1}}],[\"一次性申请所有的资源\",{\"1\":{\"627\":1,\"694\":1}}],[\"一次性读入内存的需要查找的关键字也就越多\",{\"1\":{\"150\":1}}],[\"一次编译\",{\"1\":{\"445\":1}}],[\"一次编写\",{\"1\":{\"442\":1}}],[\"一次锁定相邻的一组记录\",{\"1\":{\"114\":1}}],[\"一次查询需要的i\",{\"1\":{\"80\":1}}],[\"一直不释放cpu\",{\"1\":{\"661\":1}}],[\"一直不成功\",{\"1\":{\"645\":1}}],[\"一直延迟到运行时才能确定\",{\"1\":{\"465\":1}}],[\"一直大家都认为exists比in语句的效率要高\",{\"1\":{\"96\":1}}],[\"一直向主机b发送数据\",{\"1\":{\"22\":1}}],[\"一张表一定包含一个聚集索引构成的\",{\"1\":{\"83\":1}}],[\"一个初始化的任务firsttask\",{\"1\":{\"714\":1}}],[\"一个操作一旦开始\",{\"1\":{\"682\":1}}],[\"一个unlock操作先行发生\",{\"1\":{\"650\":1}}],[\"一个线程在执行一个带锁的方法\",{\"1\":{\"648\":1,\"707\":1}}],[\"一个线程去消费一个queue里的消息\",{\"1\":{\"368\":1}}],[\"一个带有标记的原子引用类\",{\"1\":{\"645\":1}}],[\"一个进程因请求资源而阻塞时\",{\"1\":{\"626\":1,\"693\":1}}],[\"一个进程崩溃后\",{\"1\":{\"620\":1,\"687\":1}}],[\"一个元素时\",{\"1\":{\"573\":1}}],[\"一个方法用\",{\"1\":{\"532\":1}}],[\"一个在堆中的stringobject对象\",{\"1\":{\"488\":4}}],[\"一个类只能继承一个抽象类\",{\"1\":{\"469\":1}}],[\"一个private或者是static的方法\",{\"0\":{\"456\":1}}],[\"一个对象的\",{\"1\":{\"454\":1}}],[\"一个人访问某个网站多次\",{\"1\":{\"382\":1}}],[\"一个数据变更的操作\",{\"1\":{\"392\":1}}],[\"一个数据多个副本\",{\"1\":{\"350\":1}}],[\"一个数据列只能有一个主键\",{\"1\":{\"93\":1}}],[\"一个一个来\",{\"1\":{\"345\":1}}],[\"一个bean定义对应一个实例\",{\"1\":{\"269\":1}}],[\"一个完整功能的rpc已经出现\",{\"1\":{\"260\":1}}],[\"一个实现类可能实现多个服务接口\",{\"1\":{\"251\":1}}],[\"一个实现类可能实现多个接口\",{\"1\":{\"230\":1}}],[\"一个\",{\"1\":{\"251\":1,\"445\":1,\"635\":1,\"703\":1}}],[\"一个使用用例为\",{\"1\":{\"237\":1}}],[\"一个rpc最最最简单的过程是客户端调用服务端的的一个方法\",{\"1\":{\"215\":1}}],[\"一个request对应一个id\",{\"1\":{\"34\":1}}],[\"一个最简单的rpc调用\",{\"0\":{\"213\":1}}],[\"一个特殊的值或者一个空串代替空值\",{\"1\":{\"160\":1}}],[\"一个索引包含\",{\"1\":{\"152\":1}}],[\"一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果\",{\"1\":{\"140\":1}}],[\"一个是本地进程间通信方式\",{\"1\":{\"731\":1}}],[\"一个是基于\",{\"1\":{\"731\":2}}],[\"一个是\",{\"1\":{\"728\":1}}],[\"一个是可重入\",{\"1\":{\"666\":1}}],[\"一个是支持公平锁和非公平锁\",{\"1\":{\"666\":1}}],[\"一个是在堆中的\",{\"1\":{\"488\":2}}],[\"一个是在常量池中的\",{\"1\":{\"488\":2}}],[\"一个是最小关键码的叶节点\",{\"1\":{\"149\":1}}],[\"一个是树的根节点\",{\"1\":{\"149\":1}}],[\"一个是并行复制\",{\"1\":{\"133\":1}}],[\"一个是半同步复制\",{\"1\":{\"133\":1}}],[\"一个是大表\",{\"1\":{\"96\":1}}],[\"一个服务器充当主服务器\",{\"1\":{\"129\":1}}],[\"一个事务只能看见已经提交事务所做的改变\",{\"1\":{\"102\":1}}],[\"一个事务的执行不能其它事务干扰\",{\"1\":{\"101\":1}}],[\"一个事务范围内多次查询却返回了不同的数据值\",{\"1\":{\"75\":1}}],[\"一个存储过程替代大量\",{\"1\":{\"98\":1}}],[\"一个表允许有多个\",{\"1\":{\"94\":1}}],[\"一个表可以有多个单列索引\",{\"1\":{\"79\":1,\"148\":1}}],[\"一个属性可以为作为一个超键\",{\"1\":{\"93\":1}}],[\"一\",{\"1\":{\"69\":2}}],[\"一键生成免费订阅链接\",{\"0\":{\"54\":1,\"56\":1}}],[\"一般就是指做得快的线程\",{\"1\":{\"643\":1}}],[\"一般就是你本地启动了玩玩儿的\",{\"1\":{\"361\":1}}],[\"一般来讲\",{\"1\":{\"639\":1}}],[\"一般来说\",{\"1\":{\"121\":1,\"128\":1,\"141\":1,\"282\":1,\"431\":1}}],[\"一般用integer\",{\"1\":{\"560\":1,\"582\":1}}],[\"一般用什么作为hashmap的key\",{\"0\":{\"582\":1},\"1\":{\"560\":1}}],[\"一般不要修改\",{\"1\":{\"554\":1,\"578\":1}}],[\"一般选择字节流\",{\"1\":{\"541\":1}}],[\"一般异常\",{\"0\":{\"531\":1},\"1\":{\"484\":1}}],[\"一般有两种方式解决该问题\",{\"1\":{\"435\":1}}],[\"一般都是通过cas和循环来完成的\",{\"1\":{\"613\":1}}],[\"一般都会搭建以redis等内存数据库为中心的session服务\",{\"1\":{\"381\":1}}],[\"一般都需要考虑线程同步\",{\"1\":{\"282\":1}}],[\"一般请下一个broker可以看做一个rabbitmq服务器\",{\"1\":{\"355\":1}}],[\"一般\",{\"1\":{\"350\":1,\"380\":1,\"398\":1,\"476\":1}}],[\"一般配合大数据类的系统来进行实时数据计算\",{\"1\":{\"350\":1}}],[\"一般要求是每个请求都必须在\",{\"1\":{\"347\":1}}],[\"一般互联网类的企业\",{\"1\":{\"347\":1}}],[\"一般设置为单例\",{\"1\":{\"299\":1}}],[\"一般查询返回结果集小于表中记录数的30\",{\"1\":{\"162\":1}}],[\"一般需要join的字段我们都要求是0\",{\"1\":{\"161\":1}}],[\"一般我们都会做数据备份\",{\"1\":{\"130\":1}}],[\"一般会经常产生冲突\",{\"1\":{\"116\":1}}],[\"一般会有以下几种解决方案\",{\"1\":{\"42\":1}}],[\"一般失效时间较短\",{\"1\":{\"41\":1}}],[\"一般情况下我们使用反射获取一个对象的步骤\",{\"1\":{\"505\":1}}],[\"一般情况下我们可以在\",{\"1\":{\"41\":1}}],[\"一般情况下\",{\"1\":{\"21\":1,\"153\":1}}],[\"一共使用了四种算法来实现拥塞控制\",{\"1\":{\"24\":1}}],[\"一块是已经发送但是未被确认的分组\",{\"1\":{\"23\":1}}],[\"一对多\",{\"1\":{\"9\":1}}],[\"此过程就构成了\",{\"1\":{\"652\":1}}],[\"此线程立即就会执行\",{\"1\":{\"623\":1,\"690\":1}}],[\"此问题在jdk\",{\"1\":{\"565\":1,\"566\":1,\"583\":2}}],[\"此种方式具有以下特性\",{\"1\":{\"436\":1}}],[\"此举主要针对的是那些非常耗时的命令\",{\"1\":{\"400\":1}}],[\"此处有可能因为网络问题导致ack失败\",{\"1\":{\"360\":1}}],[\"此处有可能因为网络问题导致ack消息无法发送到client\",{\"1\":{\"359\":1}}],[\"此接口定义了三种方法\",{\"1\":{\"298\":1}}],[\"此服务已存在\",{\"1\":{\"251\":1}}],[\"此版本中我们加入了注册中心\",{\"1\":{\"253\":1}}],[\"此版本最大痛点\",{\"0\":{\"247\":1,\"254\":1,\"261\":1}}],[\"此版本我们完成了客户端的重构\",{\"1\":{\"239\":1}}],[\"此rpc最大痛点\",{\"0\":{\"240\":1}}],[\"此rpc最大的痛点\",{\"0\":{\"233\":1}}],[\"此rpc的最大痛点\",{\"0\":{\"219\":1}}],[\"此判断中即使参数只有一个也为true\",{\"1\":{\"202\":1}}],[\"此类的\",{\"1\":{\"388\":1}}],[\"此类返回了查询的返回结果\",{\"1\":{\"200\":1}}],[\"此类根据该对象利用反射获取成员变量列表并赋值\",{\"1\":{\"198\":1}}],[\"此字段是\",{\"1\":{\"157\":1}}],[\"此外还支持优先级排序\",{\"1\":{\"382\":1}}],[\"此外还提供了交集\",{\"1\":{\"382\":1}}],[\"此外还提供\",{\"1\":{\"175\":1}}],[\"此外可以根据特例的查询或者表结构进行单独的调整\",{\"1\":{\"153\":1}}],[\"此外\",{\"1\":{\"89\":1}}],[\"此\",{\"1\":{\"70\":1}}],[\"此套接字选项告诉内核\",{\"1\":{\"20\":1}}],[\"此时其申请锁带来的开销也就变大\",{\"1\":{\"658\":1}}],[\"此时mark\",{\"1\":{\"656\":1}}],[\"此时a已经非彼a\",{\"1\":{\"645\":1}}],[\"此时进入阻塞状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"此时进行初始化的第二步\",{\"1\":{\"281\":1}}],[\"此时需清除aos中的线程记录\",{\"1\":{\"617\":1}}],[\"此时需要红黑树来加快查询速度\",{\"1\":{\"553\":1,\"577\":1}}],[\"此时需要紧急人工降级\",{\"1\":{\"398\":1}}],[\"此时再失败则进入队列等待\",{\"1\":{\"616\":1}}],[\"此时table会变成如下状态\",{\"1\":{\"565\":1}}],[\"此时假设线程1\",{\"1\":{\"565\":1}}],[\"此时的b\",{\"1\":{\"564\":1}}],[\"此时的解决办法就是如果是对\",{\"1\":{\"391\":1}}],[\"此时做查询操作\",{\"1\":{\"553\":1,\"577\":1}}],[\"此时常量池中存储的是对象\",{\"1\":{\"487\":1}}],[\"此时每个boolean数据1字节占8bit\",{\"1\":{\"449\":1}}],[\"此时boolean数据4字节32位\",{\"1\":{\"449\":1}}],[\"此时线程才得以真正执行\",{\"1\":{\"623\":1,\"690\":1}}],[\"此时线程\",{\"1\":{\"435\":2}}],[\"此时setnx刚执行成功\",{\"1\":{\"435\":1}}],[\"此时首先要选举一个slave来\",{\"1\":{\"426\":1}}],[\"此时虽然某个slave被切换成了master\",{\"1\":{\"423\":1}}],[\"此时哨兵可能就会认为master宕机了\",{\"1\":{\"423\":1}}],[\"此时这把锁就没有设置过期时间\",{\"1\":{\"435\":1}}],[\"此时这些部分数据就丢失了\",{\"1\":{\"423\":1}}],[\"此时这条消息肯定会被重复消费一次\",{\"1\":{\"332\":1}}],[\"此时如果同步不成功\",{\"1\":{\"415\":1}}],[\"此时如果客户端已经断开了连接\",{\"1\":{\"18\":1}}],[\"此时事件分派器从队列中取得该事件\",{\"1\":{\"403\":1}}],[\"此时可以根据情况自动降级或者人工降级\",{\"1\":{\"398\":1}}],[\"此时可以使用age字段用做索引查找\",{\"1\":{\"153\":1}}],[\"此时系统的吞吐量会下降\",{\"1\":{\"394\":1,\"396\":1}}],[\"此时将redis\",{\"1\":{\"393\":1}}],[\"此时解决方案就是利用消息队列进行删除的补偿\",{\"1\":{\"393\":1}}],[\"此时会向当前idle的worker线程发起中断请求以实现回收\",{\"1\":{\"721\":1}}],[\"此时会重新获取一个新的configuration\",{\"1\":{\"427\":1}}],[\"此时会从数据库中读取最新的值\",{\"1\":{\"392\":1}}],[\"此时会在队列中积压\",{\"1\":{\"392\":1}}],[\"此时会发生reassign\",{\"1\":{\"340\":1}}],[\"此时同步数据还未完成\",{\"1\":{\"391\":1}}],[\"此时来了两个请求\",{\"1\":{\"390\":1,\"391\":1}}],[\"此时来了一个request\",{\"1\":{\"229\":1}}],[\"此时就会把锁从轻量级升级为重量级锁\",{\"1\":{\"652\":1}}],[\"此时就没有majority来允许执行故障转移\",{\"1\":{\"428\":1}}],[\"此时就要注意了\",{\"1\":{\"282\":1}}],[\"此时就尝试去get\",{\"1\":{\"281\":1}}],[\"此时返回a中\",{\"1\":{\"281\":1}}],[\"此时索引仅仅按照name严格有序\",{\"1\":{\"153\":1}}],[\"此时引入拥塞控制机制\",{\"1\":{\"22\":1}}],[\"此时部分客户端就会显示连接不上\",{\"1\":{\"20\":1}}],[\"此时\",{\"1\":{\"15\":1,\"16\":1,\"276\":1,\"334\":1,\"341\":1,\"403\":1,\"407\":1,\"487\":1,\"717\":1}}],[\"此时服务器处于\",{\"1\":{\"14\":1}}],[\"此时服务器进入syn\",{\"1\":{\"11\":1}}],[\"此时双方均建立连接\",{\"1\":{\"13\":1}}],[\"此时姗姗来迟的\",{\"1\":{\"12\":1}}],[\"套接字选项来避免\",{\"1\":{\"20\":1}}],[\"若无可回收\",{\"1\":{\"672\":1}}],[\"若该\",{\"1\":{\"639\":1}}],[\"若干进程之间形成一种头尾相接的循环等待资源关系\",{\"1\":{\"626\":1,\"693\":1}}],[\"若预设值大于默认的最大值\",{\"1\":{\"573\":1}}],[\"若arraylist已有的存储能力满足最低存储要求\",{\"1\":{\"573\":1}}],[\"若不能\",{\"1\":{\"573\":1}}],[\"若能\",{\"1\":{\"573\":1}}],[\"若有\",{\"1\":{\"488\":1}}],[\"若有多个线程同时执行写操作\",{\"1\":{\"282\":1}}],[\"若它们的内容相等\",{\"1\":{\"476\":1}}],[\"若每个线程中对全局变量\",{\"1\":{\"282\":1}}],[\"若配置了destry\",{\"1\":{\"275\":1}}],[\"若实现了disposablebean接口\",{\"1\":{\"275\":1}}],[\"若dao层函数有多个参数\",{\"1\":{\"183\":1}}],[\"若对并发操作不加控制就可能会读取和存储不正确的数据\",{\"1\":{\"113\":1}}],[\"若你的省份为红色\",{\"1\":{\"62\":1}}],[\"若颜色是绿色和黄色\",{\"1\":{\"62\":1}}],[\"若都没有\",{\"1\":{\"38\":1}}],[\"若没有足够数量的\",{\"1\":{\"425\":1}}],[\"若没有\",{\"1\":{\"38\":2,\"488\":1}}],[\"若主机b的接收缓冲区情况仍未好转\",{\"1\":{\"22\":1}}],[\"若一连发送\",{\"1\":{\"19\":1}}],[\"若\",{\"1\":{\"19\":1,\"425\":1,\"556\":1,\"580\":1}}],[\"直顶网络上限\",{\"1\":{\"329\":1}}],[\"直\",{\"1\":{\"281\":1}}],[\"直到最后一个线程到达屏障时\",{\"1\":{\"681\":1}}],[\"直到最后会自动断开连接\",{\"1\":{\"19\":1}}],[\"直到锁被另外一个线程释放为止\",{\"1\":{\"651\":1}}],[\"直到其进入到就绪状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"直到获取锁为止\",{\"1\":{\"610\":1}}],[\"直到没有冲突为止\",{\"1\":{\"576\":1}}],[\"直到找到一个不冲突的哈希地址pi\",{\"1\":{\"576\":1}}],[\"直到成功获取锁或等待超时\",{\"1\":{\"435\":1}}],[\"直到事务完成\",{\"1\":{\"119\":1}}],[\"直到提交事务\",{\"1\":{\"116\":1}}],[\"直连订阅\",{\"1\":{\"53\":1}}],[\"直接申请线程执行该任务\",{\"1\":{\"711\":1}}],[\"直接调用线程的\",{\"1\":{\"640\":1}}],[\"直接执行\",{\"1\":{\"635\":1,\"703\":1}}],[\"直接执行一次cas操作竞争锁\",{\"1\":{\"616\":1}}],[\"直接使用this即可获得当前线程\",{\"1\":{\"621\":1,\"688\":1}}],[\"直接使用sql语句操作数据库\",{\"1\":{\"175\":1}}],[\"直接尝试获取锁\",{\"1\":{\"616\":1}}],[\"直接覆盖value\",{\"1\":{\"556\":1}}],[\"直接等待前面的更新操作请求完成即可\",{\"1\":{\"392\":1}}],[\"直接根据id去到对应的内容页即可\",{\"1\":{\"381\":1}}],[\"直接操作缓存能够承受的请求是远远大于直接访问数据库的\",{\"1\":{\"379\":1}}],[\"直接从\",{\"1\":{\"346\":1}}],[\"直接将页缓存中的数据发送到网卡的buffer中\",{\"1\":{\"341\":1}}],[\"直接将信息存储在cookie中\",{\"1\":{\"42\":1}}],[\"直接请求到\",{\"1\":{\"290\":1}}],[\"直接手写的\",{\"1\":{\"230\":1}}],[\"直接编写原生态\",{\"1\":{\"178\":1}}],[\"直接\",{\"1\":{\"175\":1}}],[\"直接选择使用\",{\"1\":{\"92\":1}}],[\"直接返回默认数据或访问服务的内存数据\",{\"1\":{\"398\":1}}],[\"直接返回null\",{\"1\":{\"395\":1}}],[\"直接返回即可\",{\"1\":{\"136\":1}}],[\"直接返回\",{\"1\":{\"71\":1,\"396\":1,\"452\":1}}],[\"直接出现vless节点码\",{\"1\":{\"71\":1}}],[\"直接进入closed状态\",{\"1\":{\"20\":1}}],[\"直播等\",{\"1\":{\"9\":1}}],[\"也要与发送方发送的消息体的数据类型保持一致\",{\"1\":{\"731\":1}}],[\"也即终止进程后\",{\"1\":{\"729\":1}}],[\"也称为散列码\",{\"1\":{\"477\":1}}],[\"也称永久性\",{\"1\":{\"101\":1}}],[\"也将发送到同一个jvm内部的内存队列中\",{\"1\":{\"392\":1}}],[\"也能保证考虑到高低bit都参与到hash的计算中\",{\"1\":{\"555\":1}}],[\"也能有效释放过期键占用的内存\",{\"1\":{\"386\":1}}],[\"也能防止非法数据插入外键列\",{\"1\":{\"94\":1}}],[\"也提供了灵活的键淘汰策略\",{\"1\":{\"381\":1}}],[\"也不会造成后续的指令不做\",{\"1\":{\"407\":1}}],[\"也不返回数据\",{\"1\":{\"367\":1}}],[\"也不需要考虑人家是否调用成功\",{\"1\":{\"346\":1}}],[\"也不利于维护\",{\"1\":{\"155\":1}}],[\"也可能有问题\",{\"1\":{\"645\":1}}],[\"也可能是之前的下线分区重新上线\",{\"1\":{\"340\":1}}],[\"也可用于相同类型的对象之间的比较\",{\"1\":{\"476\":1}}],[\"也可以设置\",{\"1\":{\"721\":1}}],[\"也可以叫同步点\",{\"1\":{\"681\":1}}],[\"也可以将类序列化为流数据进行传输\",{\"1\":{\"519\":1}}],[\"也可以将数据写入kafka消息队列\",{\"1\":{\"424\":1}}],[\"也可以是list<b>\",{\"1\":{\"512\":1}}],[\"也可以是\",{\"1\":{\"450\":1}}],[\"也可以是数据库\",{\"1\":{\"431\":1}}],[\"也可以看出字节码对于java生态的重要性\",{\"1\":{\"445\":1}}],[\"也可以节省大量内存\",{\"1\":{\"438\":1}}],[\"也可以考虑用memcached替代\",{\"1\":{\"414\":1}}],[\"也可以牺牲一个备用节点\",{\"1\":{\"414\":1}}],[\"也可以根据实际业务情况动态地扩展\",{\"1\":{\"352\":1}}],[\"也可以通过插件机制来实现自己的交换器\",{\"1\":{\"352\":1}}],[\"也可以关闭某个自动配置的选项\",{\"1\":{\"306\":1}}],[\"也可以作用于方法上面\",{\"1\":{\"293\":1}}],[\"也可以用\",{\"1\":{\"291\":1}}],[\"也可以轻松扩展为其它序列化方式\",{\"1\":{\"246\":1}}],[\"也可以自己实现其他的\",{\"1\":{\"245\":1}}],[\"也可以不处理它\",{\"1\":{\"18\":1}}],[\"也一定是有顺序的\",{\"1\":{\"336\":1}}],[\"也没有\",{\"1\":{\"281\":1}}],[\"也包含整个类的定义\",{\"1\":{\"240\":1}}],[\"也许会使新手更容易理解这样做的缘故是啥\",{\"1\":{\"206\":1}}],[\"也无返回值\",{\"1\":{\"202\":1}}],[\"也需要定期维护\",{\"1\":{\"162\":1}}],[\"也只会分裂很少一部分\",{\"1\":{\"158\":1}}],[\"也被称之为非聚簇索引\",{\"1\":{\"151\":1}}],[\"也被称之为聚簇索引\",{\"1\":{\"151\":1}}],[\"也被称之为脏读\",{\"1\":{\"102\":1}}],[\"也有可能是每个\",{\"1\":{\"141\":1}}],[\"也有一些公司开始在用了\",{\"1\":{\"127\":1}}],[\"也为\",{\"1\":{\"112\":1}}],[\"也支持所谓\",{\"1\":{\"102\":1}}],[\"也是为什么java中任意对象可以作为锁的原因\",{\"1\":{\"651\":1}}],[\"也是直接尝试获取锁\",{\"1\":{\"616\":1}}],[\"也是线程安全的\",{\"1\":{\"570\":1}}],[\"也是一个静态内部类\",{\"1\":{\"546\":1}}],[\"也是一个重要的字段\",{\"1\":{\"157\":1}}],[\"也是true\",{\"1\":{\"476\":1}}],[\"也是通过collection\",{\"1\":{\"187\":1}}],[\"也是通过association配置\",{\"1\":{\"186\":1}}],[\"也是数据库并发控制的基本单位\",{\"1\":{\"100\":1}}],[\"也是用于控件字段内容不能重复\",{\"1\":{\"94\":1}}],[\"也是\",{\"1\":{\"92\":1}}],[\"也叫做递归锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"也叫\",{\"1\":{\"39\":1,\"133\":1}}],[\"也会导致成本的升高\",{\"1\":{\"36\":1}}],[\"也避免了发送方发送过多的数据而导致接收方无法正常处理的异常\",{\"1\":{\"22\":1}}],[\"也就对应核心线程创建时的情况\",{\"1\":{\"714\":1}}],[\"也就可以理解为常量\",{\"1\":{\"481\":1}}],[\"也就分几个\",{\"1\":{\"380\":1}}],[\"也就是每个进程都有自己独立的虚拟内存空间\",{\"1\":{\"727\":1}}],[\"也就是消息体\",{\"1\":{\"726\":1}}],[\"也就是从内核中读取这段数据\",{\"1\":{\"725\":1}}],[\"也就是获取的任务为空时\",{\"1\":{\"714\":1}}],[\"也就是获取锁\",{\"1\":{\"617\":1}}],[\"也就是空闲的状态\",{\"1\":{\"714\":1}}],[\"也就是非核心线程的创建\",{\"1\":{\"714\":1}}],[\"也就是无法并发执行\",{\"1\":{\"646\":1}}],[\"也就是头节点才是锁的持有者\",{\"1\":{\"602\":1}}],[\"也就是不保证线程安全\",{\"1\":{\"571\":1}}],[\"也就是放在数组的第一个位置\",{\"1\":{\"560\":1}}],[\"也就是使用了单链表的头插入方式\",{\"1\":{\"558\":1,\"581\":1}}],[\"也就是产生了碰撞\",{\"1\":{\"555\":1}}],[\"也就是\",{\"1\":{\"555\":1,\"648\":1,\"707\":1}}],[\"也就是比如你设置的值是17\",{\"1\":{\"548\":1,\"589\":1}}],[\"也就是并发度为\",{\"1\":{\"546\":1}}],[\"也就是你构建\",{\"1\":{\"511\":1}}],[\"也就是stringobject对象的引用地址\",{\"1\":{\"488\":1}}],[\"也就是在字符串常量区建立该常量\",{\"1\":{\"488\":1}}],[\"也就是判断两个对象是否指向了同一块内存区域\",{\"1\":{\"476\":1}}],[\"也就是同一个内存空间\",{\"1\":{\"474\":1}}],[\"也就是变量所对应的内存空间的地址\",{\"1\":{\"474\":1}}],[\"也就是编译时不确定究竟调用哪个具体方法\",{\"1\":{\"465\":1}}],[\"也就是把客观事物封装成抽象的类\",{\"1\":{\"464\":1}}],[\"也就是锁的持有者才可以释放锁\",{\"1\":{\"431\":1}}],[\"也就是大多数哨兵都是运行的\",{\"1\":{\"428\":1}}],[\"也就是所谓的脑裂\",{\"1\":{\"423\":1}}],[\"也就是客户端和服务端之间的网络传输延迟\",{\"1\":{\"399\":1}}],[\"也就是最频繁被访问的数据将来最有可能被访问到\",{\"1\":{\"388\":1}}],[\"也就是需要高可用\",{\"1\":{\"374\":1}}],[\"也就是让用户态和内核态共享内核态的数据缓冲区\",{\"1\":{\"341\":1}}],[\"也就是我们平常说的\",{\"1\":{\"290\":1}}],[\"也就是构造器循环依赖和field循环依赖\",{\"1\":{\"281\":1}}],[\"也就是分布式系统\",{\"1\":{\"135\":1}}],[\"也就是必须等待事务执行完毕以后才释放共享锁\",{\"1\":{\"119\":1}}],[\"也就是说你先进入链表\",{\"1\":{\"653\":1}}],[\"也就是说正在等待的线程可以选择放弃等待\",{\"1\":{\"648\":1,\"707\":1}}],[\"也就是说由于线程获取同步状态失败加入到clh同步队列中\",{\"1\":{\"610\":1}}],[\"也就是说只需要锁住这个链表头结点\",{\"1\":{\"584\":1}}],[\"也就是说只需要锁住这个链表头节点\",{\"1\":{\"546\":1}}],[\"也就是说传递前和传递后都指向同一个引用\",{\"1\":{\"474\":1}}],[\"也就是说传递后就互不相关了\",{\"1\":{\"474\":1}}],[\"也就是说每一个对象都有这么个方法\",{\"1\":{\"454\":1}}],[\"也就是说每台\",{\"1\":{\"417\":1}}],[\"也就是说当内存不足以容纳新写入数据时\",{\"1\":{\"388\":1}}],[\"也就是说当前滑动窗口的大小决定了当前\",{\"1\":{\"23\":1}}],[\"也就是说未被消费的消息不会存在超时删除这情况\",{\"1\":{\"372\":1}}],[\"也就是说申请的只是最大长度\",{\"1\":{\"95\":1}}],[\"也就是说一个事务执行之前和执行之后都必须处于一致性状态\",{\"1\":{\"74\":1}}],[\"也就是说\",{\"1\":{\"31\":1,\"278\":1,\"506\":1,\"511\":1,\"518\":1,\"535\":1,\"542\":3,\"554\":1,\"555\":1,\"578\":1,\"623\":1,\"690\":1}}],[\"也就是发送ack报文\",{\"1\":{\"22\":1}}],[\"也就无需再第四次握手了\",{\"1\":{\"13\":1}}],[\"也请继续并重用它\",{\"1\":{\"20\":1}}],[\"再来匿名管道是只能用于存在父子关系的进程间通信\",{\"1\":{\"731\":1}}],[\"再来看jdk1\",{\"1\":{\"547\":2,\"585\":1}}],[\"再来看下jdk1\",{\"1\":{\"546\":1,\"584\":1}}],[\"再开始执行\",{\"1\":{\"681\":1}}],[\"再看一下tryacquire方法\",{\"1\":{\"605\":1}}],[\"再计算r2=h2\",{\"1\":{\"576\":1}}],[\"再计算不同前缀长度的选择性\",{\"1\":{\"155\":1}}],[\"再哈希法\",{\"1\":{\"576\":2}}],[\"再进行操作则会得到原来的数值1000\",{\"1\":{\"555\":1}}],[\"再进行持久化或网络传输\",{\"1\":{\"525\":1}}],[\"再多的就更少了\",{\"1\":{\"553\":1}}],[\"再转红黑树\",{\"0\":{\"577\":1},\"1\":{\"553\":1}}],[\"再通知服务器应用去启动线程进行处理\",{\"1\":{\"542\":1}}],[\"再通过ssqlid拿到statement具体sql信息\",{\"1\":{\"200\":1}}],[\"再从二进制流中反序列化出对象\",{\"1\":{\"518\":1}}],[\"再把引用指向该对象\",{\"1\":{\"490\":1}}],[\"再将其地址赋给a\",{\"1\":{\"488\":1}}],[\"再将服务端应答返回客户端\",{\"1\":{\"354\":1}}],[\"再就是我们想在没有创建对象的情况下也想调用方法\",{\"1\":{\"455\":1}}],[\"再读库\",{\"1\":{\"392\":1}}],[\"再次进入的时候会先判断\",{\"1\":{\"652\":1}}],[\"再次强调\",{\"1\":{\"644\":1}}],[\"再次hash\",{\"1\":{\"576\":1}}],[\"再次回到以前的路径\",{\"1\":{\"536\":1}}],[\"再次加锁会失败\",{\"1\":{\"435\":1}}],[\"再次删除\",{\"1\":{\"391\":1}}],[\"再次淘汰缓存\",{\"1\":{\"391\":1}}],[\"再写数据库\",{\"1\":{\"391\":1}}],[\"再检查当前键值是否过期\",{\"1\":{\"386\":1}}],[\"再加上redis自身的事件处理模型将epoll中的连接\",{\"1\":{\"377\":1}}],[\"再加上udp本身的处理既简单又高效\",{\"1\":{\"10\":1}}],[\"再说第二个\",{\"1\":{\"341\":1}}],[\"再回过来讨论\",{\"1\":{\"230\":1}}],[\"再去另外一个表里面查询数据\",{\"1\":{\"186\":1,\"187\":1}}],[\"再做出相应的调整\",{\"1\":{\"141\":1}}],[\"再重新跑这些\",{\"1\":{\"141\":1}}],[\"再比如a\",{\"1\":{\"84\":1}}],[\"再例如\",{\"1\":{\"83\":1}}],[\"再根据配置信息对资源进行初始化\",{\"1\":{\"308\":1}}],[\"再根据message转化成相应的对象\",{\"1\":{\"244\":1}}],[\"再根据长度读取data\",{\"1\":{\"244\":1}}],[\"再根据\",{\"1\":{\"40\":1,\"547\":1}}],[\"再经过时间\",{\"1\":{\"18\":1}}],[\"计数器\",{\"1\":{\"381\":1}}],[\"计算时\",{\"1\":{\"622\":2,\"689\":2}}],[\"计算新的resize上限\",{\"1\":{\"559\":1}}],[\"计算index\",{\"1\":{\"556\":1}}],[\"计算\",{\"1\":{\"555\":1}}],[\"计算得到存储的位置\",{\"1\":{\"555\":1,\"579\":1}}],[\"计算出hash值\",{\"1\":{\"555\":1,\"579\":1}}],[\"计算出\",{\"1\":{\"547\":3,\"585\":1}}],[\"计算null对象的长度\",{\"1\":{\"534\":1}}],[\"计算较少的场景\",{\"1\":{\"414\":1}}],[\"计算基数所需的空间总是固定\",{\"1\":{\"382\":1}}],[\"计算当前待发送消息的长度\",{\"1\":{\"237\":1}}],[\"计算机网络面试题第二期来了\",{\"1\":{\"26\":1}}],[\"计算机网络下\",{\"0\":{\"26\":1},\"1\":{\"26\":1}}],[\"计算机网络体系可以大致分为一下三种\",{\"1\":{\"8\":1}}],[\"计算机网络的各层协议及作用\",{\"0\":{\"8\":1}}],[\"计算机网络知识点也非常多\",{\"1\":{\"7\":1}}],[\"计算机网络可以说是必考题目\",{\"1\":{\"7\":1}}],[\"计算机网络上\",{\"0\":{\"7\":1},\"1\":{\"7\":1}}],[\"计时器\",{\"1\":{\"18\":1}}],[\"就对其改进无从下手\",{\"1\":{\"720\":1}}],[\"就拿美团来说\",{\"1\":{\"718\":1}}],[\"就向阻塞队列添加任务\",{\"1\":{\"671\":1}}],[\"就顺利进入临界区\",{\"1\":{\"661\":1}}],[\"就绪状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"就获取到了同步状态\",{\"1\":{\"608\":1}}],[\"就等资源释放了\",{\"1\":{\"603\":1}}],[\"就等于显示地承诺编译器\",{\"1\":{\"535\":1}}],[\"就发生了死循环\",{\"1\":{\"564\":1}}],[\"就要扩容\",{\"1\":{\"564\":1}}],[\"就要想办法在其他表中更新\",{\"1\":{\"140\":1}}],[\"就被缓存了\",{\"1\":{\"560\":1,\"582\":1}}],[\"就被称为位移\",{\"1\":{\"328\":1}}],[\"就扩充为原来的2倍\",{\"1\":{\"559\":1}}],[\"就扩容\",{\"1\":{\"556\":1}}],[\"就只好随你碰撞去吧\",{\"1\":{\"559\":1}}],[\"就覆盖掉\",{\"1\":{\"556\":2,\"580\":2}}],[\"就在于第二步\",{\"1\":{\"555\":1,\"579\":1}}],[\"就在这个时候插入了一条具体分数的记录\",{\"1\":{\"103\":1}}],[\"就到这里了\",{\"1\":{\"550\":1}}],[\"就回答因为作者doug不喜欢\",{\"1\":{\"548\":1,\"588\":1}}],[\"就有了二义性\",{\"1\":{\"548\":1}}],[\"就从红黑树里面查询\",{\"1\":{\"547\":1}}],[\"就直接返回\",{\"1\":{\"547\":1}}],[\"就功能而言\",{\"1\":{\"543\":1}}],[\"就又重新形成了一条返回路径\",{\"1\":{\"536\":1}}],[\"就进行扩容\",{\"1\":{\"556\":2,\"580\":1}}],[\"就进行反序列化还原\",{\"1\":{\"519\":1}}],[\"就进入睡眠状态并等待master产生新的事件\",{\"1\":{\"132\":1}}],[\"就像访问进程自己的空间一样快捷方便\",{\"1\":{\"731\":1}}],[\"就像在本地机上运行对象时一样\",{\"1\":{\"519\":1}}],[\"就像我们平时用的u盘一样\",{\"1\":{\"518\":1}}],[\"就返回原对象的一个拷贝\",{\"1\":{\"473\":1}}],[\"就放弃获取这个锁\",{\"1\":{\"437\":1}}],[\"就将这个节点挂在树上\",{\"1\":{\"556\":1,\"580\":1}}],[\"就将它的hash\",{\"1\":{\"429\":1}}],[\"就将其他master的hash\",{\"1\":{\"429\":1}}],[\"就支持主从复制的断点续传\",{\"1\":{\"420\":1,\"422\":1}}],[\"就简单太多了\",{\"1\":{\"380\":1}}],[\"就取消对\",{\"1\":{\"346\":1}}],[\"就无限重试\",{\"1\":{\"334\":1}}],[\"就无法提供读写服务\",{\"1\":{\"323\":1}}],[\"就无法正常断开连接\",{\"1\":{\"18\":1}}],[\"就认为消费者已经处理完这条消息\",{\"1\":{\"332\":1}}],[\"就自动提交了\",{\"1\":{\"332\":1}}],[\"就算是发送成功了\",{\"1\":{\"330\":1}}],[\"就已经准备好了一切资源\",{\"1\":{\"308\":1}}],[\"就把当前事务挂起\",{\"1\":{\"289\":1}}],[\"就抛出异常\",{\"1\":{\"289\":1}}],[\"就以非事务方式执行\",{\"1\":{\"289\":1}}],[\"就以我的经验来看\",{\"1\":{\"121\":1}}],[\"就新建一个事务\",{\"1\":{\"289\":1}}],[\"就需要信号量来保护共享资源\",{\"1\":{\"731\":1}}],[\"就需要\",{\"1\":{\"730\":1}}],[\"就需要用\",{\"1\":{\"729\":1}}],[\"就需要工作盗窃算法啦~\",{\"1\":{\"643\":1}}],[\"就需要加入到等待队列中\",{\"1\":{\"605\":1}}],[\"就需要一定的阻塞等待唤醒机制来保证锁分配\",{\"1\":{\"602\":1}}],[\"就需要对哈希表有一个基本的认识\",{\"1\":{\"479\":1}}],[\"就需要执行leader选举\",{\"1\":{\"340\":1}}],[\"就需要自行保证线程安全\",{\"1\":{\"282\":1}}],[\"就需要拆分为多个数据包进行发送\",{\"1\":{\"23\":1}}],[\"就很好的解决了这一问题\",{\"1\":{\"727\":1}}],[\"就很麻烦\",{\"1\":{\"247\":1}}],[\"就很容易明白为什么不建议使用过长的字段作为主键\",{\"1\":{\"83\":1}}],[\"就不用往后执行了\",{\"1\":{\"605\":1}}],[\"就不会被其他线程干扰\",{\"1\":{\"682\":1}}],[\"就不会影响其他的哈希桶元素的读写\",{\"1\":{\"584\":1}}],[\"就不会影响其他的哈希桶数组元素的读写\",{\"1\":{\"546\":1}}],[\"就不会出现链表成环的问题了\",{\"1\":{\"557\":1}}],[\"就不会去创建一个新的字符串变量\",{\"1\":{\"482\":1}}],[\"就不会让其加入操作成功\",{\"1\":{\"478\":1}}],[\"就不需要再查询数据库了\",{\"1\":{\"395\":1}}],[\"就不贴代码了\",{\"1\":{\"237\":1}}],[\"就不能使用到索引\",{\"1\":{\"161\":1}}],[\"就不能像b+tree索引一样利用索引完成排序\",{\"1\":{\"150\":1}}],[\"就new一个线程去处理\",{\"1\":{\"230\":1}}],[\"就剩下id\",{\"1\":{\"185\":1,\"191\":1}}],[\"就\",{\"1\":{\"181\":1,\"348\":1,\"623\":1,\"690\":1}}],[\"就停止匹配\",{\"1\":{\"154\":1,\"161\":1}}],[\"就搞一个主库\",{\"1\":{\"131\":1}}],[\"就好像发生了幻觉一样\",{\"1\":{\"103\":1}}],[\"就说数据库处于一致性状态\",{\"1\":{\"101\":1}}],[\"就可以忽略该信号\",{\"1\":{\"729\":1}}],[\"就可以满足绝大多数的业务需求\",{\"1\":{\"720\":1}}],[\"就可以进行通用的格式传输或保存\",{\"1\":{\"519\":1}}],[\"就可以进行这样的声明\",{\"1\":{\"494\":1}}],[\"就可以解决问题\",{\"1\":{\"447\":1}}],[\"就可以正常提供服务\",{\"1\":{\"436\":1}}],[\"就可以允许执行故障转移\",{\"1\":{\"428\":1}}],[\"就可以计算接近\",{\"1\":{\"382\":1}}],[\"就可以使用\",{\"1\":{\"382\":1}}],[\"就可以保证消息不会丢失\",{\"1\":{\"332\":1}}],[\"就可以保证本连接持续的时间内产生的所有报文段都从网络中消失\",{\"1\":{\"18\":1}}],[\"就可以获取到我们想要的根据指定配置进行初始化的实例对象\",{\"1\":{\"270\":1}}],[\"就可以在缓存里缓存更多的行\",{\"1\":{\"128\":1}}],[\"就可以\",{\"1\":{\"84\":1}}],[\"就是终止进程的意思\",{\"1\":{\"729\":1}}],[\"就是拿出一块虚拟地址空间来\",{\"1\":{\"727\":1}}],[\"就是内核里面的一串缓存\",{\"1\":{\"725\":1}}],[\"就是为了避开这个耗时问题~\",{\"1\":{\"645\":1}}],[\"就是为了创建容器类\",{\"1\":{\"510\":1}}],[\"就是分而治之思想的体现啦\",{\"1\":{\"643\":1}}],[\"就是分布式项目开发中用到的锁\",{\"1\":{\"431\":1}}],[\"就是舍弃队列的fifo特性\",{\"1\":{\"614\":1}}],[\"就是设置head节点不需要用cas\",{\"1\":{\"608\":1}}],[\"就是编译时多态的一个例子\",{\"1\":{\"465\":1}}],[\"就是mq本身\",{\"1\":{\"363\":1}}],[\"就是demo级别的\",{\"1\":{\"361\":1}}],[\"就是当broker没有消息时\",{\"1\":{\"324\":1}}],[\"就是\",{\"1\":{\"323\":1,\"401\":1,\"601\":2}}],[\"就是说一个\",{\"1\":{\"323\":1}}],[\"就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的url地址\",{\"1\":{\"28\":1}}],[\"就是单例模式\",{\"1\":{\"282\":1}}],[\"就是没有实例变量的对象\",{\"1\":{\"282\":1}}],[\"就是有实例变量的对象\",{\"1\":{\"282\":1}}],[\"就是传递给sql的参数\",{\"1\":{\"182\":1}}],[\"就是映射文件中mapper的statement的id值\",{\"1\":{\"182\":1}}],[\"就是把\",{\"1\":{\"181\":1}}],[\"就是把时\",{\"1\":{\"181\":1}}],[\"就是把一个有很多字段的表给拆分成多个表\",{\"1\":{\"128\":1}}],[\"就是把一个表的数据给弄到多个库的多个表里去\",{\"1\":{\"128\":1}}],[\"就是非聚簇索引\",{\"1\":{\"148\":1}}],[\"就是显示数据库引擎对于sql语句的执行的详细情况\",{\"1\":{\"134\":1}}],[\"就是基于主从复制架构\",{\"1\":{\"131\":1}}],[\"就是每个库一段连续的数据\",{\"1\":{\"128\":1}}],[\"就是将数据均匀放更多的库里\",{\"1\":{\"128\":1}}],[\"就是查询\",{\"1\":{\"112\":1}}],[\"就是串行化读数据\",{\"1\":{\"76\":1}}],[\"就能从磁盘上自动加载数据恢复内存中的数据\",{\"1\":{\"396\":1}}],[\"就能看到vless节点url和clash\",{\"1\":{\"61\":1}}],[\"就能够收到服务端重传的\",{\"1\":{\"18\":1}}],[\"就开始处理请求\",{\"1\":{\"38\":1}}],[\"就建立一次连接\",{\"1\":{\"31\":1}}],[\"就执行\",{\"1\":{\"24\":1}}],[\"就会不断地进行轮询\",{\"1\":{\"714\":1}}],[\"就会执行饱和策略\",{\"1\":{\"671\":1}}],[\"就会调用addwaiter加入到等待队列中去\",{\"1\":{\"606\":1}}],[\"就会改变modcount的值\",{\"1\":{\"598\":1}}],[\"就会get出null\",{\"1\":{\"566\":1}}],[\"就会出现这种情况\",{\"1\":{\"665\":1}}],[\"就会出现死循环了\",{\"1\":{\"564\":2}}],[\"就会出现登录失效问题\",{\"1\":{\"42\":1}}],[\"就会扩容\",{\"1\":{\"558\":1,\"581\":1}}],[\"就会按照哈希表结构遍历每个元素\",{\"1\":{\"548\":1,\"590\":1}}],[\"就会将该异常转交给默认的异常处理器\",{\"1\":{\"537\":1}}],[\"就会将强制此时立即将数据同步到从库\",{\"1\":{\"133\":1}}],[\"就会返回修改后的值\",{\"1\":{\"536\":1}}],[\"就会返回写成功的消息给生产者\",{\"1\":{\"323\":1}}],[\"就会抛出该异常\",{\"1\":{\"533\":1}}],[\"就会抛出\",{\"1\":{\"493\":1}}],[\"就会重新散列到其他位置\",{\"1\":{\"478\":1}}],[\"就会导致锁记录一直在数据库中\",{\"1\":{\"432\":1}}],[\"就会导致端口资源被占用\",{\"1\":{\"20\":1}}],[\"就会立即退出并给出相应的错误提示\",{\"1\":{\"407\":1}}],[\"就会删除该\",{\"1\":{\"403\":1}}],[\"就会产生一个\",{\"1\":{\"403\":2}}],[\"就会产生超级加倍的效果\",{\"1\":{\"155\":1}}],[\"就会造成大量请求读缓存没读到数据\",{\"1\":{\"394\":1}}],[\"就会造成服务器上出现大量的time\",{\"1\":{\"20\":1}}],[\"就会丢失最后一次快照后的所有修改\",{\"1\":{\"383\":1}}],[\"就会丢失一部分数据\",{\"1\":{\"334\":1}}],[\"就会发送\",{\"1\":{\"323\":1}}],[\"就会写新的库了\",{\"1\":{\"128\":1}}],[\"就会停止匹配\",{\"1\":{\"84\":1}}],[\"就会向访问者显示一个警告\",{\"1\":{\"37\":1}}],[\"就会建立一个http会话\",{\"1\":{\"31\":1}}],[\"就会在等待确认应答包环节浪费时间\",{\"1\":{\"23\":1}}],[\"就立即进入\",{\"1\":{\"16\":1}}],[\"从管道的一段写入的数据\",{\"1\":{\"725\":1}}],[\"从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率\",{\"1\":{\"719\":1}}],[\"从最近几个jdk版本中可以看出\",{\"1\":{\"654\":1}}],[\"从当代互联网发展趋势来说\",{\"1\":{\"622\":1,\"689\":1}}],[\"从计算机底层来说\",{\"1\":{\"622\":2,\"689\":2}}],[\"从原来的遍历链表o\",{\"1\":{\"591\":1}}],[\"从速度\",{\"1\":{\"555\":1}}],[\"从jdk1\",{\"1\":{\"542\":2}}],[\"从文件中读取出二进制流\",{\"1\":{\"518\":1}}],[\"从class目录下获取指定的xml文件\",{\"1\":{\"506\":1}}],[\"从configuration中通过class\",{\"1\":{\"197\":1}}],[\"从configuration中拿出mapper\",{\"1\":{\"194\":1}}],[\"从这个简单的例子可以看出\",{\"1\":{\"505\":1}}],[\"从这里取\",{\"1\":{\"201\":1}}],[\"从代码中可以看到我们使用反射调用了\",{\"1\":{\"505\":1}}],[\"从节点只能复制主节点\",{\"1\":{\"417\":1}}],[\"从节点作为备用节点\",{\"1\":{\"417\":1}}],[\"从节点可以扩展主库节点的读能力\",{\"1\":{\"415\":1}}],[\"从实用性的角度来说\",{\"1\":{\"411\":1}}],[\"从实现机制可以看出\",{\"1\":{\"405\":1}}],[\"从实质上讲\",{\"1\":{\"8\":1}}],[\"从两个方面解决\",{\"1\":{\"394\":1}}],[\"从两个方面来回答\",{\"1\":{\"150\":1}}],[\"从数据集\",{\"1\":{\"388\":1}}],[\"从已设置过期时间的数据集\",{\"1\":{\"388\":3}}],[\"从不同步\",{\"1\":{\"383\":1}}],[\"从高性能上来说\",{\"1\":{\"379\":1}}],[\"从高并发上来说\",{\"1\":{\"379\":1}}],[\"从内存交换到磁盘中\",{\"1\":{\"377\":1}}],[\"从几十到几百个时候\",{\"1\":{\"350\":1}}],[\"从redis\",{\"1\":{\"316\":1,\"420\":1,\"422\":1}}],[\"从request中得到方法名\",{\"1\":{\"230\":1}}],[\"从request得到interfacename\",{\"1\":{\"230\":1}}],[\"从注册中心获取host\",{\"1\":{\"251\":1}}],[\"从注册中心获得\",{\"1\":{\"251\":1}}],[\"从字节数组反序列化成消息\",{\"1\":{\"244\":1}}],[\"从此可能调用不同的方法\",{\"1\":{\"225\":1}}],[\"从服务端得到的blog为\",{\"1\":{\"231\":1}}],[\"从服务端得到的user为\",{\"1\":{\"223\":1}}],[\"从服务端代码分离出来\",{\"1\":{\"230\":1}}],[\"从服务器的中继日志\",{\"1\":{\"132\":1}}],[\"从服务器可以终止复制进程\",{\"1\":{\"130\":1}}],[\"从服务器甚至可以通过拨号断断续续地连接主服务器\",{\"1\":{\"129\":1}}],[\"从服务器来讲\",{\"1\":{\"20\":1}}],[\"从io中读取数据错误\",{\"1\":{\"216\":1,\"223\":1,\"230\":1}}],[\"从0开始的rpc的迭代过程\",{\"1\":{\"212\":1}}],[\"从零开始\",{\"1\":{\"206\":1}}],[\"从main入口往下\",{\"1\":{\"192\":1}}],[\"从执行sql到返回result的过程\",{\"1\":{\"172\":1}}],[\"从存储引擎中查询对应的数据\",{\"1\":{\"156\":1}}],[\"从存储结构上来划分\",{\"1\":{\"79\":1,\"148\":1}}],[\"从库提升为主库提供服务\",{\"1\":{\"415\":1}}],[\"从库负责读\",{\"1\":{\"142\":1}}],[\"从库将日志写入自己本地的\",{\"1\":{\"133\":1}}],[\"从\",{\"1\":{\"132\":2,\"342\":1,\"450\":2,\"493\":1,\"506\":1,\"549\":1}}],[\"从上面程序可以看出\",{\"1\":{\"612\":1}}],[\"从上面可以分析出\",{\"1\":{\"488\":4}}],[\"从上面讲述的单例bean初始化步骤我们可以知道\",{\"1\":{\"281\":1}}],[\"从上面对两种锁的介绍\",{\"1\":{\"116\":1}}],[\"从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组\",{\"1\":{\"23\":1}}],[\"从锁的类别上来讲\",{\"1\":{\"115\":1}}],[\"从锁的类别上分mysql都有哪些锁呢\",{\"0\":{\"115\":1}}],[\"从应用层次来分\",{\"1\":{\"79\":1,\"148\":1}}],[\"从第二行开始遍历csv行\",{\"1\":{\"71\":1}}],[\"从hel2copy的优选线路\",{\"1\":{\"71\":2}}],[\"从客户端来讲\",{\"1\":{\"20\":1}}],[\"从而良好的缓冲任务\",{\"1\":{\"711\":1}}],[\"从而实现了线程隔离\",{\"1\":{\"664\":1}}],[\"从而起到线程隔离的作用\",{\"1\":{\"663\":1}}],[\"从而减低了锁带来的性能消耗\",{\"1\":{\"652\":1}}],[\"从而减少锁冲突\",{\"1\":{\"120\":1}}],[\"从而执行相应的同步调用\",{\"1\":{\"651\":1}}],[\"从而执行不同的行为\",{\"1\":{\"465\":1}}],[\"从而可以有选择性的进行线程通知\",{\"1\":{\"648\":1,\"707\":1}}],[\"从而可以将cpu\",{\"1\":{\"621\":1,\"688\":1}}],[\"从而\",{\"1\":{\"646\":1}}],[\"从而引起程序性能下降\",{\"1\":{\"548\":1}}],[\"从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作\",{\"1\":{\"543\":1}}],[\"从而使服务端正常关闭连接\",{\"1\":{\"18\":1}}],[\"从而避免\",{\"1\":{\"684\":1}}],[\"从而避免存入或取出错误的数据\",{\"1\":{\"516\":1}}],[\"从而避免了对底层存储系统的查询压力\",{\"1\":{\"395\":1}}],[\"从而尝试获取下个锁\",{\"1\":{\"437\":1}}],[\"从而梳理出哪些必须誓死保护\",{\"1\":{\"398\":1}}],[\"从而造成内存泄漏\",{\"1\":{\"386\":1}}],[\"从而腾出宝贵的内存空间用于其它需要访问的数据\",{\"1\":{\"377\":1}}],[\"从而在编译阶段就可生成\",{\"1\":{\"284\":1}}],[\"从而与主数据库中的数据保持一致\",{\"1\":{\"132\":1}}],[\"从而提高主服务器的性能\",{\"1\":{\"130\":1}}],[\"从而调整整个数据库的性能\",{\"1\":{\"130\":1}}],[\"从而导致元素的丢失\",{\"1\":{\"565\":1,\"583\":1}}],[\"从而导致高并发访问数据库\",{\"1\":{\"394\":1}}],[\"从而导致恶性循环的现象\",{\"1\":{\"118\":1}}],[\"从而导致多了一次\",{\"1\":{\"17\":1}}],[\"从而达到事务的未入磁盘数据进行持久化这一特性\",{\"1\":{\"106\":1}}],[\"从而解决幻读问题\",{\"1\":{\"102\":1}}],[\"从而会导致大量的数据丢包\",{\"1\":{\"22\":1}}],[\"返回前驱节点\",{\"1\":{\"603\":1}}],[\"返回为\",{\"1\":{\"548\":2,\"588\":2}}],[\"返回其地址\",{\"1\":{\"488\":1}}],[\"返回stringobject对象的地址\",{\"1\":{\"488\":1}}],[\"返回对象\",{\"1\":{\"488\":4}}],[\"返回对象2的地址\",{\"1\":{\"488\":1}}],[\"返回对应的对象\",{\"1\":{\"216\":1}}],[\"返回false\",{\"1\":{\"476\":1}}],[\"返回ok\",{\"1\":{\"435\":1}}],[\"返回空值\",{\"1\":{\"409\":1}}],[\"返回事务块内所有命令的返回值\",{\"1\":{\"409\":1}}],[\"返回旧值不是又导致缓存和数据库不一致了么\",{\"1\":{\"392\":1}}],[\"返回什么样的数据格式\",{\"1\":{\"294\":1}}],[\"返回例如\",{\"1\":{\"294\":1}}],[\"返回使用的序列器\",{\"1\":{\"244\":1}}],[\"返回给请求者\",{\"1\":{\"290\":1}}],[\"返回给客户端\",{\"1\":{\"230\":1}}],[\"返回给浏览器\",{\"1\":{\"40\":1}}],[\"返回值为int\",{\"1\":{\"612\":1}}],[\"返回值为泛型类型的方法都会擦除成\",{\"1\":{\"511\":1}}],[\"返回值只支持user对象\",{\"1\":{\"219\":1}}],[\"返回值越大说明字段的唯一值越多字段的离散程度高\",{\"1\":{\"160\":1}}],[\"返回类型可以相同也可以不同\",{\"1\":{\"466\":1}}],[\"返回类型\",{\"1\":{\"203\":1}}],[\"返回结果类的list对象\",{\"1\":{\"203\":1}}],[\"返回preparedstatememnt对象\",{\"1\":{\"198\":1}}],[\"返回的同样是sqlsession的default实现类\",{\"1\":{\"196\":1}}],[\"返回defaultsqlsessionfactory\",{\"1\":{\"195\":1}}],[\"返回了\",{\"1\":{\"194\":1}}],[\"返回到mysql服务端\",{\"1\":{\"156\":1}}],[\"返回n行\",{\"1\":{\"136\":1}}],[\"返回处理后的结果\",{\"1\":{\"71\":1}}],[\"返回\",{\"0\":{\"297\":1},\"1\":{\"17\":1,\"488\":1,\"605\":1}}],[\"即在这个时间范围内\",{\"1\":{\"718\":1}}],[\"即在rpcserver中加一个hashmap\",{\"1\":{\"230\":1}}],[\"即大量的阻塞\",{\"1\":{\"675\":1}}],[\"即该任务需要大量的io\",{\"1\":{\"675\":1}}],[\"即只创建唯一的工作者线程来执行任务\",{\"1\":{\"672\":1}}],[\"即线程池中没有可运行任务时\",{\"1\":{\"672\":1}}],[\"即线程本地变量\",{\"1\":{\"663\":1}}],[\"即如果工作线程空闲了指定的时间\",{\"1\":{\"672\":1}}],[\"即获取锁的过程只需要检查\",{\"1\":{\"656\":1}}],[\"即比较并交换\",{\"1\":{\"644\":1}}],[\"即快线程和慢线程各在一端\",{\"1\":{\"643\":1}}],[\"即让出了\",{\"1\":{\"639\":1}}],[\"即时java编译器\",{\"1\":{\"637\":1,\"708\":1}}],[\"即进入到运行状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"即进入了新建状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"即请求访问共享资源的顺序\",{\"1\":{\"614\":1}}],[\"即请求成功完成\",{\"1\":{\"71\":1}}],[\"即concurrenthashmap\",{\"1\":{\"584\":1}}],[\"即8\",{\"1\":{\"555\":1}}],[\"即16\",{\"1\":{\"555\":1}}],[\"即segment\",{\"1\":{\"548\":1}}],[\"即编译时该类存在\",{\"1\":{\"533\":1}}],[\"即复制对象本身及引用的对象本身\",{\"1\":{\"519\":1}}],[\"即远程调用remote\",{\"1\":{\"519\":1}}],[\"即字符串池\",{\"1\":{\"487\":1}}],[\"即对类抽象\",{\"1\":{\"469\":1}}],[\"即外壳不变\",{\"1\":{\"466\":1}}],[\"即重载的方法不能根据返回类型进行区分\",{\"1\":{\"466\":1}}],[\"即默认\",{\"1\":{\"451\":1}}],[\"即以字节为单位进行读取\",{\"1\":{\"445\":1}}],[\"即永远只有一个\",{\"1\":{\"436\":1}}],[\"即基于关系型数据库\",{\"1\":{\"432\":1}}],[\"即两个redis实例\",{\"1\":{\"428\":1}}],[\"即db\",{\"1\":{\"417\":1}}],[\"即redis节点需要动态变化的情况\",{\"1\":{\"385\":1}}],[\"即持久化\",{\"1\":{\"383\":1}}],[\"即unique\",{\"1\":{\"382\":1}}],[\"即key\",{\"1\":{\"382\":1}}],[\"即原子性\",{\"1\":{\"376\":1}}],[\"即不断开连接\",{\"1\":{\"367\":1}}],[\"即不能为空值\",{\"1\":{\"93\":1}}],[\"即拉取方式\",{\"1\":{\"365\":1}}],[\"即即使这些\",{\"1\":{\"364\":1}}],[\"即从ar中挑选首个在isr中的副本\",{\"1\":{\"340\":1}}],[\"即消费者组是kafka提供的可扩展且具有容错性的消费者机制\",{\"1\":{\"326\":1}}],[\"即作为企业级的消息引擎被广泛使用\",{\"1\":{\"321\":1}}],[\"即由容器动态的将某个依赖关系注入到组件之中\",{\"1\":{\"270\":1}}],[\"即可调用公共的接口sendrequest发送请求\",{\"1\":{\"237\":1}}],[\"即为返回类的路径\",{\"1\":{\"203\":1}}],[\"即检查返回类型是否为集合\",{\"1\":{\"200\":1}}],[\"即平均1条扫描10条记录\",{\"1\":{\"161\":1}}],[\"即使进程\",{\"1\":{\"727\":1}}],[\"即使当计算\",{\"1\":{\"717\":1}}],[\"即使是在多个线程一起执行的时候\",{\"1\":{\"682\":1}}],[\"即使是一主多从也是不能解决该问题\",{\"1\":{\"439\":1}}],[\"即使在单核cpu上这种加速主要就是利用了被浪费掉的阻塞时间\",{\"1\":{\"675\":1}}],[\"即使锁定资源的服务崩溃或者分区\",{\"1\":{\"436\":1}}],[\"即使有备用的节点解决高可用性\",{\"1\":{\"414\":1}}],[\"即使它是私有的或者受保护的\",{\"1\":{\"203\":1}}],[\"即使要进行页分裂\",{\"1\":{\"158\":1}}],[\"即使此端口正忙\",{\"1\":{\"20\":1}}],[\"即随机io次数越多\",{\"1\":{\"151\":1}}],[\"即将数据存储与索引放到了一块\",{\"1\":{\"151\":1}}],[\"即冲突真的很少发生的时候\",{\"1\":{\"116\":1}}],[\"即多版本并发控制\",{\"1\":{\"111\":1}}],[\"即一个线程处理所有网络请求\",{\"1\":{\"377\":1}}],[\"即一个消费者组中可以包含多个消费者进程\",{\"1\":{\"326\":1}}],[\"即一个事务内部的\",{\"1\":{\"101\":1}}],[\"即一个索引只包含单个列\",{\"1\":{\"79\":1,\"148\":1}}],[\"即没有冗余元素的超键\",{\"1\":{\"93\":1}}],[\"即数据库表的每一列都是不可分割的原子数据项\",{\"1\":{\"91\":1}}],[\"即便是在数据库系统遇到故障的性况下也不会丢失提交事务的操作\",{\"1\":{\"74\":1}}],[\"即本地\",{\"1\":{\"38\":1}}],[\"即每个线程都有一个属于自己的threadlocalmap\",{\"1\":{\"664\":1}}],[\"即每一个sql造成的影响会记录\",{\"1\":{\"89\":1}}],[\"即每一个request都是用作连接共享机制的\",{\"1\":{\"34\":1}}],[\"即每经过一个往返时间rtt就把发送方的拥塞窗口cwnd加1而不是加倍\",{\"1\":{\"24\":1}}],[\"即连接共享\",{\"1\":{\"34\":1}}],[\"即返回码是206\",{\"1\":{\"33\":1}}],[\"即修改net\",{\"1\":{\"20\":1}}],[\"即\",{\"1\":{\"18\":1,\"265\":1,\"270\":1,\"283\":1,\"476\":1,\"546\":1,\"555\":2,\"598\":1,\"646\":1,\"650\":1,\"729\":1,\"731\":1}}],[\"即客户端到服务端的连接已经释放了\",{\"1\":{\"16\":1}}],[\"即客户端上次发送的报文的最后一个字节的序号\",{\"1\":{\"16\":1}}],[\"即服务端上次发送的报文的最后一个字节的序号\",{\"1\":{\"16\":2}}],[\"k++\",{\"1\":{\"499\":1,\"506\":1}}],[\"k1\",{\"1\":{\"403\":1}}],[\"kb\",{\"1\":{\"382\":1}}],[\"kit\",{\"1\":{\"444\":1}}],[\"kip\",{\"1\":{\"327\":1}}],[\"kill\",{\"1\":{\"141\":1,\"731\":1}}],[\"kancloud\",{\"1\":{\"685\":1}}],[\"kafka等流行的消息队列中间件\",{\"1\":{\"381\":1}}],[\"kafka便无法利用zero\",{\"1\":{\"341\":1}}],[\"kafka就可以利用zero\",{\"1\":{\"341\":1}}],[\"kafka的哪些场景中使用了零拷贝\",{\"0\":{\"341\":1}}],[\"kafka副本当前分为领导者副本和追随者副本\",{\"1\":{\"339\":1}}],[\"kafka中的isr\",{\"0\":{\"338\":1}}],[\"kafka如何保证消息不丢失\",{\"0\":{\"331\":1}}],[\"kafka将完全不再依赖于zookeeper\",{\"1\":{\"327\":1}}],[\"kafka使用zookeeper存放集群元数据\",{\"1\":{\"327\":1}}],[\"kafka允许你将同一份消息广播到多个消费者组里\",{\"1\":{\"326\":1}}],[\"kafka有个参数可以让消费者阻塞知道是否有新消息到达\",{\"1\":{\"324\":1}}],[\"kafka是一款分布式流处理平台\",{\"1\":{\"321\":1}}],[\"kafka是什么\",{\"0\":{\"321\":1}}],[\"kafka\",{\"0\":{\"320\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"329\":1,\"330\":1,\"334\":1,\"335\":1,\"336\":1,\"339\":1,\"350\":1,\"375\":1},\"1\":{\"322\":4,\"323\":5,\"325\":3,\"332\":3,\"333\":1,\"334\":4,\"335\":1,\"336\":2,\"342\":3,\"343\":1,\"350\":4}}],[\"kaiche\",{\"1\":{\"58\":1}}],[\"kryo\",{\"1\":{\"242\":1,\"244\":1}}],[\"knowledge\",{\"1\":{\"70\":1}}],[\"kuaidi100\",{\"1\":{\"70\":2}}],[\"kong\",{\"1\":{\"52\":1,\"70\":1}}],[\"keeya\",{\"1\":{\"551\":1}}],[\"keep\",{\"1\":{\"31\":2,\"32\":1,\"33\":1}}],[\"keepalivetime\",{\"1\":{\"230\":2,\"670\":1,\"712\":1}}],[\"keepalive\",{\"1\":{\"21\":1}}],[\"key是threadlocal本身\",{\"1\":{\"664\":2}}],[\"key是锁的唯一标识\",{\"1\":{\"434\":1}}],[\"key2\",{\"1\":{\"559\":1}}],[\"key1\",{\"1\":{\"559\":3,\"576\":2}}],[\"key已经存在直接覆盖value\",{\"1\":{\"556\":1}}],[\"key长度\",{\"1\":{\"438\":1}}],[\"key作为数据分区的最小粒度\",{\"1\":{\"417\":1}}],[\"key事务操作支持有限\",{\"1\":{\"417\":1}}],[\"key批量操作限制\",{\"1\":{\"417\":1}}],[\"key的过期时间和永久有效分别怎么设置\",{\"0\":{\"387\":1}}],[\"key索引\",{\"1\":{\"159\":1}}],[\"keys操作\",{\"1\":{\"417\":1}}],[\"keys\",{\"1\":{\"157\":1,\"316\":1}}],[\"keywords\",{\"1\":{\"70\":1}}],[\"key\",{\"0\":{\"491\":1,\"579\":1,\"588\":1},\"1\":{\"37\":5,\"87\":2,\"94\":2,\"110\":1,\"135\":2,\"157\":4,\"159\":4,\"195\":1,\"237\":4,\"316\":5,\"336\":3,\"337\":1,\"376\":1,\"382\":1,\"391\":3,\"393\":1,\"395\":3,\"396\":1,\"399\":1,\"405\":1,\"417\":2,\"432\":1,\"434\":3,\"435\":1,\"438\":1,\"477\":1,\"484\":1,\"491\":1,\"547\":3,\"548\":10,\"555\":5,\"556\":19,\"559\":2,\"560\":4,\"565\":4,\"576\":1,\"579\":4,\"580\":3,\"582\":1,\"583\":2,\"585\":4,\"586\":1,\"588\":6,\"665\":1}}],[\"k\",{\"1\":{\"16\":2,\"499\":4,\"506\":4,\"553\":3,\"555\":4,\"556\":8,\"579\":3,\"586\":1}}],[\"主动回收自己\",{\"1\":{\"714\":1}}],[\"主动关闭连接\",{\"1\":{\"16\":2}}],[\"主线程通过单线程的方式执行请求命令\",{\"1\":{\"404\":1}}],[\"主线程阻塞等待\",{\"1\":{\"404\":2}}],[\"主线程处理完读事件之后\",{\"1\":{\"404\":1}}],[\"主线程负责接收建立连接请求\",{\"1\":{\"404\":1}}],[\"主机宕机\",{\"1\":{\"376\":1}}],[\"主机会自动将数据同步到从机\",{\"1\":{\"376\":1}}],[\"主机b通过告诉主机a自己接收缓冲区的大小\",{\"1\":{\"22\":1}}],[\"主写从读的功能并不太适用\",{\"1\":{\"342\":1}}],[\"主题解析器\",{\"1\":{\"291\":1}}],[\"主题等\",{\"1\":{\"39\":1}}],[\"主库节点生成备份文件导致服务器磁盘io和cpu\",{\"1\":{\"415\":1}}],[\"主库执行全量备份的同时可能会造成毫秒或秒级的卡顿\",{\"1\":{\"415\":1}}],[\"主库的存储能力受到单机的限制\",{\"1\":{\"415\":1}}],[\"主库的写能力受到单机的限制\",{\"1\":{\"415\":1}}],[\"主库与从库进行同步数据的操作\",{\"1\":{\"391\":1}}],[\"主库负责写\",{\"1\":{\"142\":1,\"439\":1}}],[\"主库接收到至少一个从库的\",{\"1\":{\"133\":1}}],[\"主从架构的核心原理\",{\"1\":{\"420\":1}}],[\"主从实例部署在不同的物理服务器上\",{\"1\":{\"415\":1}}],[\"主从\",{\"0\":{\"415\":1},\"1\":{\"413\":1}}],[\"主从+\",{\"1\":{\"396\":1}}],[\"主从模式下\",{\"1\":{\"416\":1}}],[\"主从模式\",{\"1\":{\"369\":1,\"413\":1}}],[\"主从同步会比\",{\"1\":{\"342\":1}}],[\"主从同步使得数据可以从一个数据库服务器复制到其他服务器上\",{\"1\":{\"129\":1}}],[\"主从复制的过程中如果因为网络原因停止复制了会怎么样\",{\"0\":{\"422\":1}}],[\"主从复制的断点续传\",{\"1\":{\"420\":1}}],[\"主从复制\",{\"1\":{\"135\":1,\"439\":1}}],[\"主数据库的二进制日志\",{\"1\":{\"132\":1}}],[\"主\",{\"1\":{\"132\":1}}],[\"主键索引或者唯一二级索引进行等值匹配的情况下\",{\"1\":{\"157\":1}}],[\"主键索引\",{\"1\":{\"151\":1}}],[\"主键索引和辅助索引是独立的\",{\"1\":{\"92\":1}}],[\"主键\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"主键约束\",{\"1\":{\"87\":1}}],[\"主要应用场景和\",{\"1\":{\"681\":1}}],[\"主要应用例如\",{\"1\":{\"519\":1}}],[\"主要进行了以下操作\",{\"1\":{\"662\":1}}],[\"主要来说主要有三点\",{\"1\":{\"648\":1,\"707\":1}}],[\"主要的流程如下\",{\"1\":{\"607\":1}}],[\"主要的组成如下\",{\"1\":{\"546\":2}}],[\"主要原理图如下\",{\"1\":{\"602\":1}}],[\"主要做了三件事\",{\"1\":{\"507\":1}}],[\"主要交换故障信息\",{\"1\":{\"430\":1}}],[\"主要体现在配置中心\",{\"1\":{\"418\":1}}],[\"主要解决redis分布式方面的需求\",{\"1\":{\"417\":1}}],[\"主要传输二进制数据流\",{\"1\":{\"354\":1}}],[\"主要定义了一些客户端调用的命令\",{\"1\":{\"354\":1}}],[\"主要支持简单的\",{\"1\":{\"350\":1}}],[\"主要需要考虑如下两点\",{\"1\":{\"335\":1}}],[\"主要组合包含了以下\",{\"1\":{\"306\":1}}],[\"主要分为两大类\",{\"1\":{\"284\":1}}],[\"主要是分为三类\",{\"1\":{\"609\":1}}],[\"主要是methodaccessor\",{\"1\":{\"507\":1}}],[\"主要是先获取\",{\"1\":{\"507\":1}}],[\"主要是针对海量数据+高并发+高可用的场景\",{\"1\":{\"413\":1}}],[\"主要是承载高并发高性能的场景\",{\"1\":{\"413\":1}}],[\"主要是beanfactoryaware接口\",{\"1\":{\"276\":1}}],[\"主要是配合快重传\",{\"1\":{\"24\":1}}],[\"主要把握创建过程和销毁过程这两个大的方面\",{\"1\":{\"276\":1}}],[\"主要作用是在spring完成实例化之后\",{\"1\":{\"274\":1}}],[\"主要在创建和销毁两个时期\",{\"1\":{\"273\":1}}],[\"主要用户接受用户请求并调用\",{\"1\":{\"271\":1}}],[\"主要用于实现进程间的互斥与同步\",{\"1\":{\"728\":1}}],[\"主要用于将私有线程和该线程存放的副本对象做一个映射\",{\"1\":{\"704\":1}}],[\"主要用于存储地理位置信息\",{\"1\":{\"382\":1}}],[\"主要用于业务解耦\",{\"1\":{\"381\":1}}],[\"主要用于数据库相关操作\",{\"1\":{\"271\":1}}],[\"主要用于以下三个方面\",{\"1\":{\"39\":1}}],[\"主要涉及一些复杂的逻辑\",{\"1\":{\"271\":1}}],[\"主要负责客户端命令发送给服务器\",{\"1\":{\"354\":1}}],[\"主要负责序列化的编码解码\",{\"1\":{\"237\":1}}],[\"主要负责数据格式的转换\",{\"1\":{\"8\":1}}],[\"主要工作是binlog\",{\"1\":{\"132\":1}}],[\"主要实现数据库的一致性\",{\"1\":{\"104\":1}}],[\"主要有两个特性\",{\"1\":{\"666\":1}}],[\"主要有两个原因\",{\"1\":{\"18\":1}}],[\"主要有两种可能\",{\"1\":{\"396\":1}}],[\"主要有三个\",{\"1\":{\"345\":1}}],[\"主要有三个原因\",{\"1\":{\"12\":1}}],[\"主要有垂直分表和水平分表\",{\"1\":{\"142\":1}}],[\"主要包括ip协议\",{\"1\":{\"8\":1}}],[\"的设备文件\",{\"1\":{\"731\":1}}],[\"的设计是什么样的\",{\"0\":{\"322\":1}}],[\"的意思是\",{\"1\":{\"729\":1}}],[\"的意思是这个集合是一个可以持有任意类型的集合\",{\"1\":{\"512\":1}}],[\"的虚拟地址是一样的\",{\"1\":{\"727\":1}}],[\"的虚拟机机制\",{\"1\":{\"442\":1}}],[\"的屏障\",{\"1\":{\"681\":1}}],[\"的字面意思是可循环使用\",{\"1\":{\"681\":1}}],[\"的获取与释放方式即可\",{\"1\":{\"680\":1}}],[\"的特点是内部元素并不是按照放入的时间排序\",{\"1\":{\"673\":1}}],[\"的情况是阻塞队列的容量是无限的\",{\"1\":{\"673\":1}}],[\"的情况恰恰相反\",{\"1\":{\"673\":1}}],[\"的情况下一般会用到\",{\"1\":{\"102\":1}}],[\"的最大值\",{\"1\":{\"673\":1}}],[\"的最大线程数是\",{\"1\":{\"673\":1}}],[\"的弱引用\",{\"1\":{\"665\":1}}],[\"的threadid即可\",{\"1\":{\"656\":1}}],[\"的非公平其实在源码中应该有不少地方\",{\"1\":{\"653\":1}}],[\"的持有权\",{\"1\":{\"651\":1}}],[\"的高开销\",{\"1\":{\"684\":1}}],[\"的高级功能\",{\"1\":{\"648\":1,\"707\":1}}],[\"的高16位异或低16位实现\",{\"1\":{\"555\":1}}],[\"的实例对象\",{\"1\":{\"638\":1}}],[\"的实现方式\",{\"1\":{\"652\":1}}],[\"的实现方式是不同的\",{\"1\":{\"546\":1,\"584\":1}}],[\"的实现那样重新计算hash\",{\"1\":{\"559\":1}}],[\"的实现原理是什么\",{\"0\":{\"584\":1},\"1\":{\"546\":1}}],[\"的实现原理\",{\"0\":{\"112\":1},\"1\":{\"112\":1}}],[\"的实现\",{\"1\":{\"111\":1,\"353\":1}}],[\"的汇编代码\",{\"1\":{\"637\":1,\"708\":1}}],[\"的利用率\",{\"1\":{\"622\":1,\"689\":1}}],[\"的队列中中是否有其他线程\",{\"1\":{\"617\":1}}],[\"的key存在\",{\"1\":{\"588\":1}}],[\"的value\",{\"1\":{\"588\":1}}],[\"的锁标记位为偏向锁以及当前线程id等于\",{\"1\":{\"656\":1}}],[\"的锁\",{\"1\":{\"585\":1}}],[\"的锁粒度更低\",{\"1\":{\"549\":1,\"592\":1}}],[\"的大小是动态变化的\",{\"1\":{\"574\":1}}],[\"的大小扩大为原来数组的两倍\",{\"1\":{\"558\":1,\"581\":1}}],[\"的扩容机制\",{\"0\":{\"573\":1}}],[\"的扩容方式\",{\"0\":{\"581\":1},\"1\":{\"558\":1}}],[\"的第一个\",{\"1\":{\"564\":1}}],[\"的线程也能确保\",{\"1\":{\"717\":1}}],[\"的线程池时\",{\"1\":{\"673\":1}}],[\"的线程有可能在进入到暂停状态后马上又被执行\",{\"1\":{\"636\":1,\"705\":1}}],[\"的线程不安全问题\",{\"1\":{\"561\":1}}],[\"的线程安全问题\",{\"0\":{\"282\":1}}],[\"的引用赋给了\",{\"1\":{\"558\":1,\"581\":1}}],[\"的引用地址\",{\"1\":{\"488\":2}}],[\"的代码\",{\"1\":{\"558\":1,\"581\":1}}],[\"的代码几乎相同\",{\"1\":{\"447\":1}}],[\"的put方法区别是什么\",{\"1\":{\"557\":1}}],[\"的put方法流程\",{\"0\":{\"580\":1},\"1\":{\"556\":1}}],[\"的次幂\",{\"1\":{\"555\":1}}],[\"的次数\",{\"1\":{\"478\":1}}],[\"的结果一样\",{\"1\":{\"555\":1}}],[\"的形式\",{\"1\":{\"555\":1}}],[\"的幂次方\",{\"1\":{\"555\":1}}],[\"的n次方时\",{\"1\":{\"555\":1}}],[\"的存储索引是怎么计算的\",{\"0\":{\"579\":1},\"1\":{\"555\":1}}],[\"的存储位置\",{\"1\":{\"491\":1}}],[\"的性能\",{\"1\":{\"553\":1,\"575\":1}}],[\"的面试专题文章\",{\"1\":{\"552\":1}}],[\"的知识点非常多\",{\"1\":{\"552\":1}}],[\"的效率要高于hashtable\",{\"1\":{\"592\":1}}],[\"的效率要高于\",{\"1\":{\"549\":1}}],[\"的效率哪个更高\",{\"1\":{\"549\":1}}],[\"的效率好坏\",{\"1\":{\"157\":1}}],[\"的分段锁机制实现线程安全\",{\"1\":{\"549\":1}}],[\"的分布式存储\",{\"1\":{\"417\":1}}],[\"的迭代器创建后\",{\"1\":{\"548\":1,\"590\":1}}],[\"的数组长度\",{\"1\":{\"548\":1}}],[\"的数据结构\",{\"1\":{\"673\":1}}],[\"的数据库的连接\",{\"1\":{\"506\":1}}],[\"的数据即可\",{\"1\":{\"337\":1}}],[\"的数据都放到同一个内存\",{\"1\":{\"337\":1}}],[\"的数据\",{\"1\":{\"323\":1,\"336\":1,\"546\":1}}],[\"的并发度是多少\",{\"0\":{\"589\":1}}],[\"的并发度是什么\",{\"1\":{\"548\":1}}],[\"的并发性\",{\"1\":{\"112\":1}}],[\"的操作\",{\"1\":{\"548\":1,\"588\":1}}],[\"的操作中\",{\"1\":{\"506\":1}}],[\"的真实情况是没有找到对应的key\",{\"1\":{\"588\":1}}],[\"的真实情况是没有找到对应的\",{\"1\":{\"548\":1}}],[\"的原子类都存放在\",{\"1\":{\"682\":1}}],[\"的原子指令\",{\"1\":{\"644\":1}}],[\"的原因\",{\"0\":{\"588\":1},\"1\":{\"548\":1}}],[\"的原理\",{\"0\":{\"37\":1}}],[\"的元素\",{\"1\":{\"547\":1,\"586\":1}}],[\"的架构\",{\"1\":{\"542\":2}}],[\"的serialversionuid进行比较\",{\"1\":{\"524\":1}}],[\"的子类并重写\",{\"1\":{\"638\":1}}],[\"的子类\",{\"1\":{\"511\":2}}],[\"的过程称为抛出异常\",{\"1\":{\"537\":1}}],[\"的过程\",{\"1\":{\"506\":1,\"564\":1}}],[\"的过期时间设置多少不明确\",{\"1\":{\"432\":1}}],[\"的过期时间同时\",{\"1\":{\"386\":1}}],[\"的值等于\",{\"1\":{\"644\":1}}],[\"的值表示获取成功\",{\"1\":{\"612\":1}}],[\"的值计算\",{\"1\":{\"556\":1,\"580\":1}}],[\"的值\",{\"1\":{\"505\":1}}],[\"的值修改为\",{\"1\":{\"342\":1}}],[\"的异常\",{\"1\":{\"493\":1}}],[\"的异同\",{\"0\":{\"299\":1}}],[\"的属性必须要用包装类型呢\",{\"1\":{\"493\":1}}],[\"的属性时\",{\"1\":{\"277\":1}}],[\"的包装类就是\",{\"1\":{\"493\":1}}],[\"的地址\",{\"1\":{\"488\":2}}],[\"的地址是固定的\",{\"1\":{\"250\":1}}],[\"的相关规定\",{\"1\":{\"479\":1}}],[\"的缩写\",{\"1\":{\"444\":1}}],[\"的突出特征\",{\"1\":{\"443\":1}}],[\"的语言\",{\"1\":{\"442\":1}}],[\"的长度\",{\"1\":{\"438\":1,\"559\":1}}],[\"的发布订阅功能\",{\"1\":{\"435\":1}}],[\"的方法是run\",{\"1\":{\"621\":1,\"688\":1}}],[\"的方法是call\",{\"1\":{\"621\":1,\"688\":1}}],[\"的方法并用super进行调用\",{\"1\":{\"543\":1}}],[\"的方法\",{\"1\":{\"480\":1}}],[\"的方案\",{\"1\":{\"432\":1}}],[\"的方式来通知进程\",{\"1\":{\"729\":1}}],[\"的方式来实时推送\",{\"1\":{\"366\":1}}],[\"的方式获取同步状态\",{\"1\":{\"605\":1}}],[\"的方式尝试添加\",{\"1\":{\"547\":1}}],[\"的方式\",{\"1\":{\"339\":1}}],[\"的方式首先可以保证在\",{\"1\":{\"336\":1}}],[\"的主体\",{\"1\":{\"553\":1,\"575\":1}}],[\"的主观下线状态就会被移除\",{\"1\":{\"425\":1}}],[\"的主要目的是复制和恢复\",{\"1\":{\"108\":1}}],[\"的客观下线状态就会变成主观下线\",{\"1\":{\"425\":1}}],[\"的哨兵模式基本已经可以实现高可用\",{\"1\":{\"417\":1}}],[\"的奇数个\",{\"1\":{\"416\":1}}],[\"的事务是总是带有隔离性的\",{\"1\":{\"410\":1}}],[\"的多线程部分只是用来处理网络数据的读写和协议解析\",{\"1\":{\"405\":1}}],[\"的读写分离的架构的话\",{\"1\":{\"391\":1}}],[\"的影响\",{\"1\":{\"386\":1}}],[\"的统计规则是基于概率完成的\",{\"1\":{\"382\":1}}],[\"的映射表\",{\"1\":{\"382\":1}}],[\"的底层是\",{\"1\":{\"382\":1}}],[\"的缓存可以持久化\",{\"1\":{\"380\":1}}],[\"的模型架构是一样的\",{\"1\":{\"353\":1}}],[\"的模型架构\",{\"1\":{\"353\":1}}],[\"的开源消息代理软件\",{\"1\":{\"351\":1}}],[\"的开发风格做到一键启动和部署\",{\"1\":{\"310\":1}}],[\"的开发便利性巧妙地简化了分布式系统基础设施的开发\",{\"1\":{\"310\":1}}],[\"的时钟周期不会被浪费\",{\"1\":{\"717\":1}}],[\"的时间\",{\"1\":{\"437\":1}}],[\"的时间后\",{\"1\":{\"16\":1}}],[\"的时候\",{\"0\":{\"491\":1},\"1\":{\"323\":1,\"484\":1,\"547\":1,\"559\":1,\"560\":1,\"677\":1}}],[\"的所有\",{\"1\":{\"323\":1,\"425\":1}}],[\"的所有内容序列化\",{\"1\":{\"42\":1}}],[\"的基本架构组成是\",{\"1\":{\"323\":1}}],[\"的基于\",{\"1\":{\"277\":1}}],[\"的关系\",{\"0\":{\"310\":1}}],[\"的配置信息\",{\"1\":{\"308\":1}}],[\"的配置元数据在\",{\"1\":{\"277\":1}}],[\"的工作原理是什么\",{\"0\":{\"308\":1}}],[\"的核心面试题了\",{\"1\":{\"561\":1}}],[\"的核心注解\",{\"1\":{\"306\":1}}],[\"的核心注解是哪个\",{\"0\":{\"306\":1}}],[\"的核心组件\",{\"0\":{\"291\":1},\"1\":{\"291\":1}}],[\"的入门是一个\",{\"1\":{\"299\":1}}],[\"的入口函数也就是前端控制器\",{\"1\":{\"290\":1}}],[\"的请求的解析器\",{\"1\":{\"291\":1}}],[\"的作用是获取哈希码\",{\"1\":{\"477\":1}}],[\"的作用是接收请求\",{\"1\":{\"290\":1}}],[\"的作用\",{\"0\":{\"328\":1},\"1\":{\"684\":1}}],[\"的作用域有哪些\",{\"0\":{\"269\":1}}],[\"的一部分\",{\"1\":{\"537\":1}}],[\"的一大特点\",{\"1\":{\"350\":1}}],[\"的一大优势\",{\"1\":{\"350\":1}}],[\"的一个普通方法调用\",{\"1\":{\"635\":1,\"703\":1}}],[\"的一个内部类\",{\"1\":{\"546\":1}}],[\"的一个新特性\",{\"1\":{\"509\":1}}],[\"的一个实现\",{\"1\":{\"447\":1}}],[\"的一个\",{\"1\":{\"337\":1}}],[\"的一致编程模型\",{\"1\":{\"288\":1}}],[\"的一道桥梁\",{\"1\":{\"40\":1}}],[\"的增强或通知\",{\"1\":{\"286\":1}}],[\"的技术\",{\"1\":{\"284\":1}}],[\"的名称注入对象依赖项\",{\"1\":{\"278\":1}}],[\"的协作者\",{\"1\":{\"278\":1}}],[\"的内容让\",{\"1\":{\"278\":1}}],[\"的内部可以保持简单且快速\",{\"1\":{\"411\":1}}],[\"的内部\",{\"0\":{\"277\":1}}],[\"的生命周期范围内\",{\"1\":{\"272\":1}}],[\"的概念\",{\"1\":{\"272\":1}}],[\"的类型不同\",{\"1\":{\"731\":1}}],[\"的类型定义为\",{\"1\":{\"511\":1}}],[\"的类型是\",{\"1\":{\"291\":1}}],[\"的类\",{\"1\":{\"271\":1}}],[\"的注解有哪些\",{\"0\":{\"271\":1}}],[\"的2倍和20倍\",{\"1\":{\"251\":1}}],[\"的用户\",{\"1\":{\"216\":1}}],[\"的返回类型\",{\"1\":{\"200\":1}}],[\"的哈希表\",{\"1\":{\"200\":1}}],[\"的变量替换是在\",{\"1\":{\"181\":1}}],[\"的变量替换是在dbms\",{\"1\":{\"181\":1}}],[\"的优化又可以分为两个方向\",{\"1\":{\"401\":1}}],[\"的优势就是查找和操作的时间复杂度都是o\",{\"1\":{\"377\":1}}],[\"的优点是\",{\"1\":{\"382\":1}}],[\"的优点\",{\"0\":{\"179\":1}}],[\"的优缺点\",{\"0\":{\"36\":1}}],[\"的列放到联合索引的前面\",{\"1\":{\"160\":1}}],[\"的索引\",{\"1\":{\"156\":1,\"161\":1}}],[\"的索引则都可以用到\",{\"1\":{\"154\":1,\"161\":1}}],[\"的索引要使用\",{\"0\":{\"80\":1}}],[\"的话他怎么处理\",{\"0\":{\"141\":1}}],[\"的行所加的排他锁\",{\"1\":{\"112\":1}}],[\"的行加排他锁\",{\"1\":{\"112\":1}}],[\"的二进制日志是事务安全型的\",{\"1\":{\"108\":1}}],[\"的二进制日志\",{\"1\":{\"108\":1}}],[\"的反向语句进行逻辑操作\",{\"1\":{\"104\":1}}],[\"的默认事务隔离级别\",{\"1\":{\"102\":1}}],[\"的默认存储引擎\",{\"1\":{\"92\":1}}],[\"的四种隔离级别\",{\"0\":{\"102\":1}}],[\"的四次挥手过程\",{\"0\":{\"16\":1}}],[\"的空间\",{\"1\":{\"95\":1}}],[\"的联合索引\",{\"1\":{\"84\":1,\"153\":1}}],[\"的记录\",{\"1\":{\"75\":1}}],[\"的记录时\",{\"1\":{\"75\":1}}],[\"的后一个字段\",{\"1\":{\"71\":1}}],[\"的脚本\",{\"1\":{\"69\":1,\"70\":1,\"71\":1}}],[\"的国家简写\",{\"1\":{\"65\":1}}],[\"的现象\",{\"1\":{\"42\":1}}],[\"的唯一标识信息\",{\"1\":{\"40\":1}}],[\"的连接\",{\"1\":{\"38\":1}}],[\"的三次握手\",{\"1\":{\"38\":1}}],[\"的三次握手机制\",{\"0\":{\"11\":1}}],[\"的80端口\",{\"1\":{\"37\":1}}],[\"的\",{\"0\":{\"585\":1,\"586\":1},\"1\":{\"37\":1,\"42\":1,\"83\":1,\"102\":1,\"268\":1,\"272\":2,\"295\":1,\"302\":1,\"323\":2,\"334\":3,\"348\":2,\"382\":1,\"393\":1,\"403\":4,\"425\":1,\"443\":1,\"491\":1,\"547\":3,\"548\":2,\"555\":6,\"556\":1,\"557\":1,\"559\":3,\"560\":1,\"585\":1,\"644\":1,\"673\":1,\"697\":1}}],[\"的安全是有范围的\",{\"1\":{\"36\":1}}],[\"的区别及作用\",{\"0\":{\"452\":1}}],[\"的区别是什么\",{\"0\":{\"447\":1,\"466\":1,\"481\":1,\"532\":1,\"646\":1},\"1\":{\"484\":1}}],[\"的区别有哪些\",{\"1\":{\"92\":1}}],[\"的区别\",{\"0\":{\"35\":1,\"175\":1,\"181\":1,\"339\":1,\"549\":1,\"591\":1,\"707\":1}}],[\"的状态变量\",{\"1\":{\"24\":1}}],[\"的问题\",{\"1\":{\"19\":1,\"548\":1,\"588\":1}}],[\"的确认\",{\"1\":{\"16\":1}}],[\"9之间\",{\"1\":{\"675\":1}}],[\"9606\",{\"1\":{\"567\":1}}],[\"9632958\",{\"1\":{\"551\":1}}],[\"9f\",{\"1\":{\"544\":1}}],[\"9是属于基本数据类型的\",{\"1\":{\"494\":1}}],[\"95\",{\"1\":{\"720\":1}}],[\"9522814\",{\"1\":{\"599\":1}}],[\"953ms\",{\"1\":{\"347\":1}}],[\"95054\",{\"1\":{\"156\":3}}],[\"9408037\",{\"1\":{\"311\":1}}],[\"90的查询时\",{\"1\":{\"152\":1}}],[\"90\",{\"1\":{\"71\":1,\"544\":1}}],[\"99线等\",{\"1\":{\"720\":1}}],[\"99\",{\"1\":{\"71\":2}}],[\"91\",{\"1\":{\"70\":2}}],[\"9db4ff\",{\"1\":{\"70\":1}}],[\"9a\",{\"1\":{\"69\":5,\"70\":5}}],[\"9afa0f97\",{\"1\":{\"53\":2,\"69\":2,\"70\":3}}],[\"9\",{\"0\":{\"16\":1,\"35\":1,\"81\":1,\"99\":1,\"110\":1,\"142\":1,\"154\":1,\"180\":1,\"271\":1,\"329\":1,\"359\":1,\"384\":1,\"577\":1,\"636\":1,\"676\":1,\"704\":1},\"1\":{\"69\":1,\"70\":2,\"353\":1,\"494\":3,\"555\":1}}],[\"响应consumer\",{\"1\":{\"367\":1}}],[\"响应clients端的请求\",{\"1\":{\"339\":1}}],[\"响应结果\",{\"1\":{\"290\":1}}],[\"响应主体\",{\"1\":{\"32\":1}}],[\"响应首部\",{\"1\":{\"32\":1}}],[\"响应报文\",{\"1\":{\"32\":1}}],[\"响应\",{\"1\":{\"15\":1}}],[\"8~0\",{\"1\":{\"675\":1}}],[\"82215563\",{\"1\":{\"618\":1}}],[\"8系列之重新认识hashmap\",{\"1\":{\"562\":1}}],[\"8做了两处优化\",{\"1\":{\"559\":1}}],[\"8的优化\",{\"0\":{\"559\":1}}],[\"8的不同之处\",{\"1\":{\"555\":1,\"579\":1}}],[\"8使用尾插法插入元素\",{\"1\":{\"557\":1,\"564\":1,\"583\":1}}],[\"8hashmap\",{\"1\":{\"556\":1}}],[\"8为例说明\",{\"1\":{\"573\":1}}],[\"8为例\",{\"1\":{\"555\":1,\"579\":1}}],[\"8没有这个方法\",{\"1\":{\"555\":1,\"579\":1}}],[\"8中有什么不一样\",{\"1\":{\"559\":1}}],[\"8中\",{\"1\":{\"548\":1}}],[\"8688859\",{\"1\":{\"544\":1}}],[\"86\",{\"1\":{\"544\":1}}],[\"8e\",{\"1\":{\"544\":1}}],[\"84\",{\"1\":{\"544\":1}}],[\"8443\",{\"1\":{\"69\":3,\"70\":1}}],[\"8d\",{\"1\":{\"544\":1}}],[\"8f\",{\"1\":{\"544\":1}}],[\"8开始\",{\"1\":{\"420\":1,\"422\":1}}],[\"81\",{\"1\":{\"382\":1,\"483\":1}}],[\"8156\",{\"1\":{\"53\":4,\"69\":2,\"70\":3}}],[\"8ms\",{\"1\":{\"347\":2}}],[\"8编码\",{\"1\":{\"204\":1}}],[\"8899\",{\"1\":{\"216\":2,\"223\":2,\"230\":2,\"237\":1,\"251\":1}}],[\"881903\",{\"1\":{\"70\":2}}],[\"8880\",{\"1\":{\"69\":3,\"70\":1,\"71\":1}}],[\"8a\",{\"1\":{\"70\":1}}],[\"8a2e\",{\"1\":{\"69\":1,\"70\":1}}],[\"89ab\",{\"1\":{\"69\":1,\"70\":1}}],[\"85a3\",{\"1\":{\"69\":1,\"70\":1}}],[\"8080\",{\"1\":{\"69\":2,\"70\":1,\"71\":1}}],[\"80m\",{\"1\":{\"69\":1,\"70\":1}}],[\"80或者2052端口\",{\"1\":{\"61\":1}}],[\"8075\",{\"1\":{\"52\":1}}],[\"80\",{\"1\":{\"35\":1,\"38\":1,\"52\":3,\"61\":1,\"65\":2,\"69\":3,\"70\":2,\"71\":3}}],[\"8\",{\"0\":{\"15\":1,\"34\":1,\"63\":1,\"80\":1,\"98\":1,\"120\":1,\"141\":1,\"153\":1,\"179\":1,\"270\":1,\"328\":1,\"358\":1,\"374\":1,\"383\":1,\"549\":1,\"576\":1,\"578\":1,\"591\":1,\"635\":1,\"675\":1,\"703\":1},\"1\":{\"69\":6,\"70\":7,\"71\":12,\"204\":1,\"205\":1,\"271\":1,\"323\":2,\"381\":1,\"449\":4,\"489\":1,\"546\":4,\"547\":3,\"549\":5,\"553\":10,\"554\":1,\"555\":5,\"556\":3,\"557\":3,\"559\":2,\"563\":1,\"565\":2,\"566\":2,\"575\":4,\"577\":2,\"579\":1,\"580\":3,\"583\":2,\"584\":3,\"585\":1,\"591\":1,\"592\":1}}],[\"洪泛攻击的一种手段\",{\"1\":{\"14\":1}}],[\"协议最高层\",{\"1\":{\"354\":1}}],[\"协议中相\",{\"1\":{\"353\":1}}],[\"协议从客户端发送数据到服务端\",{\"1\":{\"300\":1}}],[\"协议编码\",{\"1\":{\"210\":1}}],[\"协议的通信方式\",{\"1\":{\"731\":2}}],[\"协议的\",{\"1\":{\"353\":1}}],[\"协议的配置\",{\"1\":{\"70\":1}}],[\"协议的服务器必须要有一套数字\",{\"1\":{\"37\":1}}],[\"协议记录稳定的状态信息成为了可能\",{\"1\":{\"39\":1}}],[\"协议\",{\"1\":{\"35\":1}}],[\"协议需要对数据进行确认后\",{\"1\":{\"23\":1}}],[\"协议里指定\",{\"1\":{\"21\":1}}],[\"协议栈防范\",{\"1\":{\"14\":1}}],[\"协议缺陷\",{\"1\":{\"14\":1}}],[\"防止任务无限制堆积\",{\"1\":{\"720\":1}}],[\"防止这部分线程被jvm回收\",{\"1\":{\"714\":1}}],[\"防止客户端宕机或者网络不可达时产生死锁\",{\"1\":{\"431\":1}}],[\"防止锁超时\",{\"1\":{\"431\":1}}],[\"防止过多的请求打在数据库上将数据库击垮\",{\"1\":{\"396\":1}}],[\"防止redis宕机导致缓存雪崩的问题\",{\"1\":{\"396\":1}}],[\"防止粘包\",{\"1\":{\"244\":1}}],[\"防止sql注入\",{\"1\":{\"201\":1}}],[\"防止在发生故障的时间点\",{\"1\":{\"106\":1}}],[\"防止小白过多的操作失误\",{\"1\":{\"69\":1}}],[\"防止已失效的连接请求报文段出现在之后的连接中\",{\"1\":{\"18\":1}}],[\"防止已过期的连接请求报文突然又传送到服务器\",{\"1\":{\"12\":1}}],[\"防范\",{\"1\":{\"14\":1}}],[\"攻击带过来的大量key是随机\",{\"1\":{\"395\":1}}],[\"攻击者就可以执行计划外的命令或访问未被授权的数据\",{\"1\":{\"45\":1}}],[\"攻击\",{\"1\":{\"14\":1}}],[\"攻击的攻击者在短时间内伪造大量不存在的\",{\"1\":{\"14\":1}}],[\"攻击的一种\",{\"1\":{\"14\":1}}],[\"地址修为优选\",{\"1\":{\"61\":1}}],[\"地址栏改为优选ip\",{\"1\":{\"61\":1}}],[\"地址是随机的\",{\"1\":{\"14\":1}}],[\"地址\",{\"1\":{\"14\":1,\"38\":1,\"251\":2}}],[\"则表明当前没有阻塞中的进程\",{\"1\":{\"728\":1}}],[\"则表明当前有阻塞中的进程\",{\"1\":{\"728\":1}}],[\"则表明还有资源可使用\",{\"1\":{\"728\":1}}],[\"则表明资源已被占用\",{\"1\":{\"728\":1}}],[\"则对空闲线程发起中断请求\",{\"1\":{\"721\":1}}],[\"则线程池会创建新的worker线程来执行队列任务\",{\"1\":{\"721\":1}}],[\"则线程池重新创建一个工作线程\",{\"1\":{\"672\":1}}],[\"则不应该中断线程\",{\"1\":{\"714\":1}}],[\"则创建并启动一个线程来执行新提交的任务\",{\"1\":{\"713\":2}}],[\"则该工作线程将自动终止\",{\"1\":{\"672\":1}}],[\"则该线程可以直接执行调用的方法\",{\"1\":{\"648\":1,\"707\":1}}],[\"则新建线程\",{\"1\":{\"672\":1}}],[\"则升级偏向锁为轻量级锁\",{\"1\":{\"652\":1}}],[\"则是锁定当前变量\",{\"1\":{\"646\":1}}],[\"则是在不管有没捕获异常\",{\"1\":{\"535\":1}}],[\"则无需使用thread\",{\"1\":{\"621\":1,\"688\":1}}],[\"则无法使用\",{\"1\":{\"62\":1}}],[\"则执行过程不是一条线的\",{\"1\":{\"620\":1,\"687\":1}}],[\"则当前竞争锁的线程必须进入队列等待\",{\"1\":{\"616\":1}}],[\"则准备进入fifo队列\",{\"1\":{\"616\":1}}],[\"则说明当前线程获取锁成功\",{\"1\":{\"605\":1}}],[\"则异常不会抛出\",{\"1\":{\"598\":1}}],[\"则改为阻塞获取锁\",{\"1\":{\"585\":1}}],[\"则改为阻塞锁获取\",{\"1\":{\"547\":1}}],[\"则以p1为基础\",{\"1\":{\"576\":1}}],[\"则以p为基础\",{\"1\":{\"576\":1}}],[\"则返回add直接添加元素\",{\"1\":{\"573\":1}}],[\"则返回true\",{\"1\":{\"476\":1}}],[\"则直接拒绝\",{\"1\":{\"713\":1}}],[\"则直接添加在末尾\",{\"1\":{\"573\":1}}],[\"则直接reject掉\",{\"1\":{\"156\":1}}],[\"则链表元素会倒置\",{\"1\":{\"559\":1}}],[\"则将任务添加到该阻塞队列中\",{\"1\":{\"713\":1}}],[\"则将提交的任务存入到池队列中\",{\"1\":{\"672\":1}}],[\"则将会清空工作内存中此变量的值\",{\"1\":{\"650\":1}}],[\"则将这个结构转换为红黑树\",{\"1\":{\"556\":1,\"580\":1}}],[\"则将该字符串常量加入到字符串常量区\",{\"1\":{\"488\":1}}],[\"则通过cas的方式尝试添加\",{\"1\":{\"585\":1}}],[\"则通过\",{\"1\":{\"547\":1}}],[\"则通过equals\",{\"1\":{\"476\":1}}],[\"则利用\",{\"1\":{\"547\":1}}],[\"则抛出该异常\",{\"1\":{\"534\":1}}],[\"则抛出异常\",{\"1\":{\"289\":1}}],[\"则需要用\",{\"1\":{\"617\":1}}],[\"则需要判断获取锁的线程是否为当前线程\",{\"1\":{\"617\":1}}],[\"则需要经过下面的步骤\",{\"1\":{\"505\":1}}],[\"则需要自定义多套\",{\"1\":{\"178\":1}}],[\"则比较结果为false\",{\"1\":{\"499\":1}}],[\"则比较结果为true\",{\"1\":{\"499\":1}}],[\"则结果为true\",{\"1\":{\"497\":1}}],[\"则处理是把堆区该对象的引用加入到字符串常量池中\",{\"1\":{\"488\":1}}],[\"则hashcode一定也是相同的\",{\"1\":{\"479\":1}}],[\"则有hashcode\",{\"1\":{\"479\":1}}],[\"则真正锁有效时间为3s\",{\"1\":{\"437\":1}}],[\"则锁的真正有效时间是\",{\"1\":{\"437\":1}}],[\"则redis的配置quorum=1\",{\"1\":{\"428\":1}}],[\"则master会被标记为客观下线\",{\"1\":{\"425\":1}}],[\"则mysql首先会返回符合zipcode=\",{\"1\":{\"156\":1}}],[\"则mysql会通过zipcode=\",{\"1\":{\"156\":1}}],[\"则正在监视这个master的所有\",{\"1\":{\"425\":1}}],[\"则这个实例会被当前\",{\"1\":{\"425\":1}}],[\"则必须使用thread\",{\"1\":{\"621\":1,\"688\":1}}],[\"则必须用catch显示声明以便进一步处理\",{\"1\":{\"535\":1}}],[\"则必须按照以上的几步完成\",{\"1\":{\"506\":1}}],[\"则必须考虑线程同步问题\",{\"1\":{\"282\":1}}],[\"则必然会引入某些同步机制\",{\"1\":{\"399\":1}}],[\"则可以马上获取到锁\",{\"1\":{\"653\":1}}],[\"则可以\",{\"1\":{\"646\":1}}],[\"则可以使用在\",{\"1\":{\"646\":1}}],[\"则可以直接使用\",{\"1\":{\"487\":1}}],[\"则可优先采用第一种方式进行缓存\",{\"1\":{\"395\":1}}],[\"则可能导致主机b的接受缓冲区满了而无法再接受数据\",{\"1\":{\"22\":1}}],[\"则肯定会造成数据不一致\",{\"1\":{\"389\":1}}],[\"则多个\",{\"1\":{\"362\":1}}],[\"则一个\",{\"1\":{\"362\":1}}],[\"则进行扩容\",{\"1\":{\"573\":1}}],[\"则进行与propagation\",{\"1\":{\"289\":1}}],[\"则进行迭代查询\",{\"1\":{\"38\":1}}],[\"则在application\",{\"1\":{\"305\":2}}],[\"则在嵌套事务内执行\",{\"1\":{\"289\":1}}],[\"则在前面添加一个斜杠\",{\"1\":{\"71\":1}}],[\"则尝试通过\",{\"1\":{\"278\":1}}],[\"则匹配并装配属性\",{\"1\":{\"278\":1}}],[\"则调用该方法将当前线程加入到clh同步队列尾部\",{\"1\":{\"610\":1}}],[\"则调用locksupport\",{\"1\":{\"602\":1}}],[\"则调用\",{\"1\":{\"556\":1,\"580\":1}}],[\"则调用异常处理代码\",{\"1\":{\"537\":1}}],[\"则调用之\",{\"1\":{\"276\":1}}],[\"则调用它\",{\"1\":{\"276\":1}}],[\"则按照school进行排序\",{\"1\":{\"153\":1}}],[\"则按照age排序\",{\"1\":{\"153\":1}}],[\"则根据拒绝策略来处理该任务\",{\"1\":{\"713\":1}}],[\"则根据该索引来定位对应的数据\",{\"1\":{\"156\":1}}],[\"则根据\",{\"1\":{\"104\":1}}],[\"则子查询表大的用exists\",{\"1\":{\"96\":1}}],[\"则应该使用\",{\"1\":{\"95\":1}}],[\"则取出其\",{\"1\":{\"82\":1}}],[\"则找\",{\"1\":{\"38\":1}}],[\"则搜索操作系统的hosts文件\",{\"1\":{\"38\":1}}],[\"则搜索操作系统的dns缓存\",{\"1\":{\"38\":1}}],[\"则post的数据则可以非常大\",{\"1\":{\"30\":1}}],[\"则会加入到这个clh同步队列的对尾并一直保持着自旋\",{\"1\":{\"611\":1}}],[\"则会抛出concurrent\",{\"1\":{\"598\":1}}],[\"则会严重影响\",{\"1\":{\"553\":1,\"575\":1}}],[\"则会进行全量同步\",{\"1\":{\"415\":1}}],[\"则会丢失数据\",{\"1\":{\"330\":1}}],[\"则会调用其配置的销毁方法\",{\"1\":{\"275\":1}}],[\"则会调用destroy方法\",{\"1\":{\"275\":1}}],[\"则会注入bean对容器基础设施层面的依赖\",{\"1\":{\"274\":1}}],[\"则会将大量的时间浪费在重传数据上\",{\"1\":{\"22\":1}}],[\"则会不断重发请求直至成功\",{\"1\":{\"14\":1}}],[\"则\",{\"1\":{\"14\":1,\"555\":1,\"639\":1}}],[\"则向客户端发送同步确认报文\",{\"1\":{\"11\":1}}],[\"之类的文件定位操作\",{\"1\":{\"731\":1}}],[\"之类的提示\",{\"1\":{\"396\":1}}],[\"之所以线程池\",{\"1\":{\"673\":1}}],[\"之所以被称之为字节码\",{\"1\":{\"445\":1}}],[\"之外\",{\"1\":{\"499\":1}}],[\"之间\",{\"1\":{\"398\":1}}],[\"之间如何转账\",{\"1\":{\"74\":1}}],[\"之前确保一致性的主要手段是高水位机制\",{\"1\":{\"339\":1}}],[\"之前这里使用map简单实现的\",{\"1\":{\"230\":1}}],[\"之前的命令不会回滚\",{\"1\":{\"407\":1}}],[\"之前的数据需要重新计算\",{\"1\":{\"128\":1}}],[\"之前的\",{\"1\":{\"14\":1}}],[\"之后优化\",{\"1\":{\"652\":1}}],[\"之后推出了泛型的概念\",{\"1\":{\"510\":1}}],[\"之后使用反射调用了\",{\"1\":{\"505\":1}}],[\"之后的事务就不会执行\",{\"1\":{\"409\":1}}],[\"之后增加了一些的非阻塞命令如\",{\"1\":{\"400\":1}}],[\"之后将主节点中\",{\"1\":{\"342\":1}}],[\"之后对于匹配到的列而言\",{\"1\":{\"153\":1}}],[\"之后修改语句或者修改索引\",{\"1\":{\"137\":1}}],[\"之后才会认为写操作完成了\",{\"1\":{\"133\":1}}],[\"之后会使用私钥b将其解密\",{\"1\":{\"37\":1}}],[\"之后\",{\"1\":{\"14\":1,\"132\":1,\"133\":1,\"141\":1,\"323\":1,\"327\":1,\"334\":2,\"392\":1,\"559\":2,\"564\":1}}],[\"之后正常断开连接\",{\"1\":{\"12\":1}}],[\"包中的原子类是哪4类\",{\"0\":{\"683\":1}}],[\"包中的\",{\"1\":{\"530\":1}}],[\"包中的类\",{\"1\":{\"504\":3}}],[\"包中\",{\"1\":{\"506\":1}}],[\"包中寻找\",{\"1\":{\"308\":1}}],[\"包装的\",{\"1\":{\"547\":1,\"586\":1}}],[\"包装类型需要占用更多的内存空间\",{\"1\":{\"493\":1}}],[\"包装类型可用于泛型\",{\"1\":{\"493\":1}}],[\"包装类型可以为\",{\"1\":{\"493\":1}}],[\"包装类型是什么\",{\"0\":{\"493\":1},\"1\":{\"484\":1}}],[\"包装类型\",{\"0\":{\"492\":1},\"1\":{\"484\":1,\"493\":1}}],[\"包装器设计模式\",{\"1\":{\"286\":1}}],[\"包括修改线程池核心大小\",{\"1\":{\"720\":1}}],[\"包括执行一个任务\",{\"1\":{\"668\":1}}],[\"包括get和put\",{\"1\":{\"554\":1,\"578\":1}}],[\"包括构造函数\",{\"1\":{\"506\":1}}],[\"包括属性\",{\"1\":{\"469\":1}}],[\"包括数组\",{\"1\":{\"449\":1}}],[\"包括\",{\"1\":{\"444\":1,\"531\":1}}],[\"包括延迟时间replica\",{\"1\":{\"338\":1}}],[\"包括这些java类的一组初始化值\",{\"1\":{\"270\":1}}],[\"包去扫描项目所依赖的\",{\"1\":{\"308\":1}}],[\"包含了\",{\"1\":{\"644\":1}}],[\"包含关系\",{\"1\":{\"620\":1,\"687\":1}}],[\"包含处理器\",{\"1\":{\"291\":1}}],[\"包含并管理应用中对象的生命周期和配置\",{\"1\":{\"263\":1}}],[\"包含所有被引用的类\",{\"1\":{\"240\":1}}],[\"包越过time\",{\"1\":{\"20\":1}}],[\"包将长时间占用未连接队列\",{\"1\":{\"14\":1}}],[\"包\",{\"1\":{\"14\":4,\"308\":1}}],[\"包总量较少的通信\",{\"1\":{\"10\":1}}],[\"原子更新长整型字段的更新器\",{\"1\":{\"683\":1}}],[\"原子更新整型字段的更新器\",{\"1\":{\"683\":1}}],[\"原子更新带有标记位的引用类型\",{\"1\":{\"683\":2}}],[\"原子更新带有版本号的引用类型\",{\"1\":{\"683\":1}}],[\"原子操作特征的类\",{\"1\":{\"682\":1}}],[\"原子类\",{\"0\":{\"682\":1}}],[\"原子性\",{\"1\":{\"74\":1,\"101\":1,\"650\":1}}],[\"原语属于操作系统用于范畴\",{\"1\":{\"644\":1}}],[\"原来是对需要进行数据操作的segment加锁\",{\"1\":{\"591\":1}}],[\"原来哈希表的长度\",{\"1\":{\"559\":1}}],[\"原索引放到bucket里\",{\"1\":{\"559\":1}}],[\"原索引+oldcap放到bucket里\",{\"1\":{\"559\":1}}],[\"原索引+oldcap\",{\"1\":{\"559\":1}}],[\"原索引\",{\"1\":{\"559\":2}}],[\"原本位于同一个segment内的访问会扩散到不同的segment中\",{\"1\":{\"548\":1}}],[\"原始类型\",{\"1\":{\"493\":1}}],[\"原生地支持它\",{\"1\":{\"648\":1,\"707\":1}}],[\"原生复制的弊端在早期的版本中也会比较突出\",{\"1\":{\"415\":1}}],[\"原生序列化\",{\"1\":{\"244\":1}}],[\"原生\",{\"1\":{\"244\":1}}],[\"原\",{\"1\":{\"181\":1}}],[\"原因是设置head节点是由获得锁的线程来完成的\",{\"1\":{\"608\":1}}],[\"原因是namespace+id是作为map<string\",{\"1\":{\"185\":1}}],[\"原因就是它扫描进来的bean定义是最先被注册的~\",{\"1\":{\"280\":1}}],[\"原因就是namespace+id是作为map<string\",{\"1\":{\"191\":1}}],[\"原因很简单\",{\"1\":{\"161\":1,\"731\":1}}],[\"原因之一就是\",{\"1\":{\"12\":1}}],[\"原则上它是不能直接赋值给一个对象integer的\",{\"1\":{\"494\":1}}],[\"原则上\",{\"1\":{\"157\":1}}],[\"原理理解更繁琐\",{\"1\":{\"416\":1}}],[\"原理如下图所示\",{\"1\":{\"290\":1}}],[\"原理\",{\"0\":{\"602\":1},\"1\":{\"14\":1,\"598\":2}}],[\"耗费\",{\"1\":{\"14\":1}}],[\"它俩名字虽然相似\",{\"1\":{\"731\":1}}],[\"它直接分配一个共享空间\",{\"1\":{\"731\":1}}],[\"它没有名字标识\",{\"1\":{\"731\":1}}],[\"它同时包含两部分的信息\",{\"1\":{\"712\":1}}],[\"它要做的事情是\",{\"1\":{\"681\":1}}],[\"它也可以实现线程间的技术等待\",{\"1\":{\"681\":1}}],[\"它也是\",{\"1\":{\"306\":1}}],[\"它也是无状态的\",{\"1\":{\"302\":1}}],[\"它定义了锁的实现机制\",{\"1\":{\"677\":1}}],[\"它对应的线程池分别是\",{\"1\":{\"673\":1}}],[\"它对数据库中的数据的改变就应该是永久性的\",{\"1\":{\"101\":1}}],[\"它具有线程池提高程序效率和节省创建线程时所耗的开销的优点\",{\"1\":{\"672\":1}}],[\"它这时候如果不被回收\",{\"1\":{\"665\":1}}],[\"它\",{\"1\":{\"645\":1}}],[\"它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件\",{\"1\":{\"642\":1}}],[\"它相当于只有一个线程的任务\",{\"1\":{\"620\":1,\"687\":1}}],[\"它发现后面还有finally\",{\"1\":{\"536\":1}}],[\"它限定\",{\"1\":{\"511\":1}}],[\"它只会用唯一的工作线程来执行任务\",{\"1\":{\"672\":1}}],[\"它只是用于限定类型的\",{\"1\":{\"511\":1}}],[\"它只能在\",{\"1\":{\"454\":1}}],[\"它实际上是返回一个int整数\",{\"1\":{\"477\":1}}],[\"它实现简单\",{\"1\":{\"114\":1}}],[\"它在所有的实例中的值是一样的\",{\"1\":{\"457\":1}}],[\"它依赖于\",{\"1\":{\"449\":1}}],[\"它能够创建和编译程序\",{\"1\":{\"444\":1}}],[\"它拥有\",{\"1\":{\"444\":1}}],[\"它为我们提供多种数据结构\",{\"1\":{\"438\":1}}],[\"它为编程事务管理提供了比jta等许多复杂事务api更简单的api\",{\"1\":{\"288\":1}}],[\"它会阻止其他线程获取当前对象的监控锁\",{\"1\":{\"646\":1}}],[\"它会进入同步阻塞状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"它会发送一个psync命令给master\",{\"1\":{\"420\":1}}],[\"它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上\",{\"1\":{\"39\":1}}],[\"它总是返回ok\",{\"1\":{\"409\":1}}],[\"它和缓存击穿的根本区别在于传进来的key在redis中是不存在的\",{\"1\":{\"395\":1}}],[\"它恢复时是将快照文件直接读到内存里\",{\"1\":{\"383\":1}}],[\"它里面有几个区别于标准消息中件间的概念\",{\"1\":{\"362\":1}}],[\"它还会为某些返回值为限定的泛型类型的方法进行强制类型转换\",{\"1\":{\"511\":1}}],[\"它还是将消息放到mq中即可\",{\"1\":{\"345\":1}}],[\"它还支持属性级别的\",{\"1\":{\"285\":1}}],[\"它需要经历网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘这几个阶段\",{\"1\":{\"342\":1}}],[\"它的自旋的次数不再固定\",{\"1\":{\"661\":1}}],[\"它的实现就是直接调用native方法实现反射\",{\"1\":{\"507\":1}}],[\"它的\",{\"1\":{\"491\":1}}],[\"它的特点是\",{\"1\":{\"477\":1}}],[\"它的作用也是判断两个对象是否相等\",{\"1\":{\"476\":1}}],[\"它的优点是简单\",{\"1\":{\"386\":1}}],[\"它的好处是提高系统灵活性\",{\"1\":{\"345\":1}}],[\"它的某个实现类使用了filechannel的transferto方法\",{\"1\":{\"341\":1}}],[\"它的位移值将不能被修改\",{\"1\":{\"328\":1}}],[\"它以集群的方式运行\",{\"1\":{\"325\":1}}],[\"它包含了一系列可以集成到应用里面的依赖包\",{\"1\":{\"307\":1}}],[\"它主要由哪几个注解组成的\",{\"0\":{\"306\":1}}],[\"它可以让某一个线程等待直到倒计时结束\",{\"1\":{\"681\":1}}],[\"它可以是list<a>\",{\"1\":{\"512\":1}}],[\"它可以用来获取类中的方法信息或者执行方法\",{\"1\":{\"504\":1}}],[\"它可以使用现有类的所有功能\",{\"1\":{\"464\":1}}],[\"它可以随时发送数据\",{\"1\":{\"10\":1}}],[\"它可能意味着消息的安全性\",{\"1\":{\"303\":1}}],[\"它不会释放工作线程\",{\"1\":{\"672\":1}}],[\"它不能用于创建新程序\",{\"1\":{\"444\":1}}],[\"它不能在服务端修改资源\",{\"1\":{\"301\":1}}],[\"它不应该依赖于以前或下一个请求或服务器端维护的一些数据\",{\"1\":{\"302\":1}}],[\"它不完全是一个\",{\"1\":{\"178\":1}}],[\"它很好地集成了spring的各种数据访问抽象\",{\"1\":{\"288\":1}}],[\"它支持声明式事务管理\",{\"1\":{\"288\":1}}],[\"它提供了检查计算是否完成的方法\",{\"1\":{\"621\":1,\"688\":1}}],[\"它提供了引入语句\",{\"1\":{\"443\":1}}],[\"它提供了跨不同事务api\",{\"1\":{\"288\":1}}],[\"它提供了判断查询是否高效的重要依据依据\",{\"1\":{\"157\":1}}],[\"它与\",{\"1\":{\"283\":1}}],[\"它与全自动的区别在哪里\",{\"0\":{\"174\":1}}],[\"它有四个主要功能\",{\"1\":{\"419\":1}}],[\"它有一个核心的功能广为人知\",{\"1\":{\"321\":1}}],[\"它有一个保持时间\",{\"1\":{\"31\":1}}],[\"它有大量的参数\",{\"1\":{\"278\":1}}],[\"它通过调用类的构造函数来注入依赖项\",{\"1\":{\"278\":1}}],[\"它匹配并装配其属性与\",{\"1\":{\"278\":1}}],[\"它根据类型注入对象依赖项\",{\"1\":{\"278\":1}}],[\"它根据\",{\"1\":{\"278\":1}}],[\"它被称为装配或\",{\"1\":{\"278\":1}}],[\"它被所有构成某个\",{\"1\":{\"272\":1}}],[\"它使得包装类型可以应用于\",{\"1\":{\"493\":1}}],[\"它使得应用程序的测试很简单\",{\"1\":{\"270\":1}}],[\"它使用语法显式提供资源对象\",{\"1\":{\"266\":1}}],[\"它使用即时加载\",{\"1\":{\"266\":1}}],[\"它使用懒加载\",{\"1\":{\"266\":1}}],[\"它们用于在任何时候中断或结束某一进程\",{\"1\":{\"729\":1}}],[\"它们以字节为单位\",{\"1\":{\"726\":1}}],[\"它们最大程度地决定了线程池的任务分配和线程分配策略\",{\"1\":{\"720\":1}}],[\"它们被统一维护在线程池内\",{\"1\":{\"711\":1}}],[\"它们使用的阻塞队列是容量为\",{\"1\":{\"673\":1}}],[\"它们中的一个或者全部都在等待某个资源被释放\",{\"1\":{\"625\":1,\"692\":1}}],[\"它们的\",{\"1\":{\"516\":1}}],[\"它们也不一定是相等的\",{\"1\":{\"479\":1}}],[\"它们有什么区别\",{\"0\":{\"443\":1}}],[\"它们能快速持续的运行\",{\"1\":{\"307\":1}}],[\"它们就使用到了模板模式\",{\"1\":{\"286\":1}}],[\"它们总是作为原型\",{\"1\":{\"277\":1}}],[\"它们基于portlet容器\",{\"1\":{\"269\":1}}],[\"它们通常以\",{\"1\":{\"268\":1}}],[\"它们包含着对数据表里所有记录的引用指针\",{\"1\":{\"146\":1}}],[\"它自己创建和管理资源对象\",{\"1\":{\"266\":1}}],[\"它内部封装了jdbc\",{\"1\":{\"172\":1}}],[\"它是专门为了那些可以递归划分成许多子模块设计的\",{\"1\":{\"706\":1}}],[\"它是一条\",{\"1\":{\"644\":1}}],[\"它是一个静态方法而且只保证当前线程放弃cpu占用而不能保证使其它线程一定能占用cpu\",{\"1\":{\"636\":1,\"705\":1}}],[\"它是一种辐射式设计\",{\"1\":{\"469\":1}}],[\"它是一种模板式设计\",{\"1\":{\"469\":1}}],[\"它是指在父类中定义的属性和方法被子类继承之后\",{\"1\":{\"464\":1}}],[\"它是运行已编译\",{\"1\":{\"444\":1}}],[\"它是功能齐全的\",{\"1\":{\"444\":1}}],[\"它是由controller独立完成的\",{\"1\":{\"340\":1}}],[\"它是由一些\",{\"1\":{\"98\":1}}],[\"它是根据\",{\"1\":{\"300\":1}}],[\"它是通过特定的aware接口来完成的\",{\"1\":{\"274\":1}}],[\"它是速度最慢的\",{\"1\":{\"157\":1}}],[\"它是要占据物理空间的\",{\"1\":{\"146\":1}}],[\"它是在每个读的数据行上加上共享锁\",{\"1\":{\"102\":1}}],[\"它确保同一事务的多个实例在并发读取数据时\",{\"1\":{\"102\":1}}],[\"它满足了隔离的简单定义\",{\"1\":{\"102\":1}}],[\"它之后的字段会停止匹配\",{\"1\":{\"84\":1}}],[\"它用于告知服务端两个请求是否来自同一浏览器\",{\"1\":{\"39\":1}}],[\"它允许只请求资源的某个部分\",{\"1\":{\"33\":1}}],[\"它利用\",{\"1\":{\"14\":1,\"310\":1}}],[\"什么时候可以有机会获取锁呢\",{\"1\":{\"614\":1}}],[\"什么时候该应\",{\"0\":{\"574\":1}}],[\"什么也不写\",{\"1\":{\"451\":1}}],[\"什么情况下不走索引\",{\"0\":{\"163\":1}}],[\"什么是线程死锁\",{\"0\":{\"624\":1,\"691\":1}}],[\"什么是serialversionuid\",{\"0\":{\"524\":1},\"1\":{\"484\":1}}],[\"什么是springmvc拦截器以及如何使用它\",{\"0\":{\"298\":1}}],[\"什么是泛型中的限定通配符和非限定通配符\",{\"0\":{\"512\":1},\"1\":{\"484\":1}}],[\"什么是类型擦除\",{\"0\":{\"511\":1},\"1\":{\"484\":1}}],[\"什么是反射\",{\"0\":{\"501\":1},\"1\":{\"484\":1}}],[\"什么是字符串常量池\",{\"0\":{\"487\":1},\"1\":{\"484\":1}}],[\"什么是不可变对象\",{\"0\":{\"472\":1}}],[\"什么是分布式锁\",{\"0\":{\"431\":1}}],[\"什么是缓存降级\",{\"0\":{\"398\":1}}],[\"什么是缓存预热\",{\"0\":{\"397\":1}}],[\"什么是缓存雪崩\",{\"0\":{\"396\":1}}],[\"什么是缓存穿透\",{\"0\":{\"395\":1}}],[\"什么是缓存击穿\",{\"0\":{\"394\":1}}],[\"什么是计数器\",{\"1\":{\"381\":1}}],[\"什么是消费者组\",{\"0\":{\"326\":1}}],[\"什么是安全的\",{\"0\":{\"301\":1}}],[\"什么是依赖注入\",{\"0\":{\"265\":1}}],[\"什么是rpc\",{\"1\":{\"215\":1}}],[\"什么是mysql主从同步\",{\"0\":{\"129\":1}}],[\"什么是mysql的\",{\"0\":{\"108\":1}}],[\"什么是死锁\",{\"0\":{\"118\":1}}],[\"什么是脏读\",{\"0\":{\"103\":1}}],[\"什么是数据库事务\",{\"0\":{\"100\":1}}],[\"什么是存储过程\",{\"0\":{\"98\":1}}],[\"什么是最左匹配原则\",{\"0\":{\"84\":1}}],[\"什么是xss攻击\",{\"0\":{\"44\":1}}],[\"什么是ddos攻击\",{\"0\":{\"43\":1}}],[\"什么是\",{\"0\":{\"14\":1,\"39\":1,\"111\":1,\"264\":1,\"277\":1,\"278\":1,\"283\":1},\"1\":{\"39\":2}}],[\"什么都无法确认\",{\"1\":{\"12\":1}}],[\"79060070\",{\"1\":{\"723\":1}}],[\"7e9a2689d223acaab1636f93d\",{\"1\":{\"618\":1}}],[\"7316153563782823691l\",{\"1\":{\"616\":1}}],[\"7334\",{\"1\":{\"69\":1,\"70\":1}}],[\"77431970\",{\"1\":{\"599\":1}}],[\"71751\",{\"1\":{\"599\":1}}],[\"7采用segment的分段锁机制实现线程安全\",{\"1\":{\"591\":1}}],[\"7与jdk1\",{\"0\":{\"591\":1}}],[\"7和\",{\"1\":{\"565\":1,\"566\":1,\"583\":2}}],[\"7和1\",{\"1\":{\"555\":1,\"579\":1}}],[\"74a14482\",{\"1\":{\"560\":1}}],[\"7就会在一个位置形成链表\",{\"1\":{\"555\":1}}],[\"7的源码\",{\"1\":{\"555\":1,\"579\":1}}],[\"7的遍历链表o\",{\"1\":{\"549\":1}}],[\"7开始支持\",{\"1\":{\"542\":1}}],[\"7中采用分段锁实现线程安全\",{\"1\":{\"592\":1}}],[\"7中的concurrenthashmap\",{\"1\":{\"584\":1}}],[\"7中的\",{\"1\":{\"564\":1,\"583\":1}}],[\"7中\",{\"1\":{\"488\":1,\"548\":1,\"589\":1}}],[\"7以后有不同的处理\",{\"1\":{\"488\":1}}],[\"769\",{\"1\":{\"483\":1}}],[\"72\",{\"1\":{\"71\":1}}],[\"7个http端口可任意选择\",{\"1\":{\"69\":2}}],[\"75是对空间和时间效率的一个平衡选择\",{\"1\":{\"554\":1,\"578\":1}}],[\"75\",{\"0\":{\"578\":1},\"1\":{\"19\":1,\"553\":1,\"554\":5,\"562\":1,\"564\":1,\"578\":4}}],[\"7\",{\"0\":{\"14\":1,\"33\":1,\"79\":1,\"97\":1,\"108\":1,\"119\":1,\"140\":1,\"152\":1,\"170\":1,\"178\":1,\"269\":1,\"327\":1,\"357\":1,\"369\":1,\"370\":1,\"382\":1,\"549\":1,\"575\":1,\"632\":1,\"674\":1,\"700\":1},\"1\":{\"69\":1,\"70\":2,\"198\":1,\"274\":1,\"381\":1,\"450\":1,\"488\":1,\"546\":3,\"547\":2,\"549\":3,\"553\":3,\"554\":1,\"555\":5,\"557\":3,\"558\":1,\"559\":2,\"564\":1,\"575\":2,\"578\":1,\"579\":2,\"581\":1,\"584\":2,\"585\":1}}],[\"66\",{\"1\":{\"729\":2}}],[\"666\",{\"1\":{\"112\":1}}],[\"61019\",{\"1\":{\"637\":1,\"708\":1}}],[\"6中\",{\"1\":{\"488\":1}}],[\"6以前\",{\"1\":{\"488\":1}}],[\"6种数据淘汰策略\",{\"1\":{\"388\":1}}],[\"60653066\",{\"1\":{\"553\":1}}],[\"60\",{\"0\":{\"439\":1},\"1\":{\"230\":1}}],[\"6引入了索引下推优化\",{\"1\":{\"156\":1}}],[\"6272a4\",{\"1\":{\"70\":1}}],[\"6856664924203663367\",{\"1\":{\"544\":1}}],[\"6810\",{\"1\":{\"70\":1}}],[\"6844904068771479559\",{\"1\":{\"374\":1}}],[\"6844904005315854343\",{\"1\":{\"11\":1,\"25\":1}}],[\"6844903966103306247\",{\"1\":{\"599\":1}}],[\"6844903986475040781\",{\"1\":{\"461\":1}}],[\"6844903796225605640\",{\"1\":{\"567\":1}}],[\"6844903741032759310\",{\"1\":{\"544\":1}}],[\"6844903746682486791\",{\"1\":{\"526\":1,\"544\":1}}],[\"6844903554264596487\",{\"1\":{\"567\":1}}],[\"6844903520856965128\",{\"1\":{\"544\":1}}],[\"6844903575684907016\",{\"1\":{\"48\":1}}],[\"6844903848167866375\",{\"1\":{\"544\":1}}],[\"6844903860658503693\",{\"1\":{\"311\":1}}],[\"6844903890840715271\",{\"1\":{\"48\":1}}],[\"6844903489596833800\",{\"1\":{\"48\":1}}],[\"64\",{\"1\":{\"70\":1,\"449\":2,\"549\":1,\"553\":2,\"556\":3,\"575\":2,\"580\":2,\"585\":1}}],[\"643e\",{\"1\":{\"53\":4,\"69\":2,\"70\":3}}],[\"6个https端口可任意选择\",{\"1\":{\"69\":2}}],[\"6bb1b9873c71c353\",{\"1\":{\"65\":1}}],[\"65535\",{\"1\":{\"38\":1}}],[\"6oct2003\",{\"1\":{\"32\":1}}],[\"6秒\",{\"1\":{\"15\":1}}],[\"6\",{\"0\":{\"13\":1,\"32\":1,\"78\":1,\"96\":1,\"105\":1,\"118\":1,\"139\":1,\"151\":1,\"169\":1,\"177\":1,\"255\":1,\"268\":1,\"326\":1,\"356\":1,\"368\":1,\"381\":1,\"401\":1,\"402\":1,\"404\":1,\"405\":1,\"406\":1,\"574\":1,\"578\":1,\"628\":1,\"673\":1,\"695\":1},\"1\":{\"69\":1,\"70\":1,\"71\":1,\"112\":1,\"198\":1,\"274\":1,\"340\":1,\"377\":1,\"381\":1,\"399\":1,\"400\":2,\"402\":1,\"403\":3,\"435\":1,\"488\":1,\"546\":1,\"553\":1,\"554\":1,\"555\":2,\"648\":1,\"652\":1,\"707\":1}}],[\"只会一个\",{\"1\":{\"622\":1,\"689\":1}}],[\"只会等待master过期key\",{\"1\":{\"420\":1}}],[\"只演示了\",{\"1\":{\"565\":1}}],[\"只使用链表\",{\"1\":{\"557\":1}}],[\"只需切换到\",{\"1\":{\"447\":1}}],[\"只需要将其引用消除即可\",{\"1\":{\"714\":1}}],[\"只需要把head节点设置为原首节点的后继节点\",{\"1\":{\"608\":1}}],[\"只需要看看原来的\",{\"1\":{\"559\":1}}],[\"只需要实现该接口即可\",{\"1\":{\"523\":1}}],[\"只需要增加redis从实例就行了\",{\"1\":{\"439\":1}}],[\"只需要添加一个监听器就可以了\",{\"1\":{\"432\":1}}],[\"只需要扫一遍叶子结点即可\",{\"1\":{\"150\":1}}],[\"只在键已经存在时\",{\"1\":{\"435\":1}}],[\"只在键不存在时\",{\"1\":{\"435\":1}}],[\"只在提交操作时检查是否违反数据完整性\",{\"1\":{\"116\":1}}],[\"只作为故障转移使用\",{\"1\":{\"417\":1}}],[\"只保留可以恢复数据的最小指令集\",{\"1\":{\"383\":1}}],[\"只许追加文件但不可以改写文件\",{\"1\":{\"383\":1}}],[\"只是说明此线程已经做好了准备\",{\"1\":{\"623\":1,\"690\":1}}],[\"只是可以获取访问权的线程数多了些\",{\"1\":{\"614\":1}}],[\"只是读写文件\",{\"1\":{\"541\":1}}],[\"只是更能确保类型安全而已\",{\"1\":{\"510\":1}}],[\"只是cache数组对象存储的是指向了堆中的integer对象\",{\"1\":{\"499\":1}}],[\"只是用来处理网络数据的读写和协议的解析\",{\"1\":{\"400\":1}}],[\"只是一个普通的对象\",{\"1\":{\"380\":1}}],[\"只是挪过去\",{\"1\":{\"371\":1}}],[\"只是最佳实践而已\",{\"1\":{\"191\":1}}],[\"只要垃圾回收机制一运行\",{\"1\":{\"665\":1}}],[\"只要破坏产生死锁的四个条件中的其中一个就可以了\",{\"1\":{\"627\":1,\"694\":1}}],[\"只要fifo队列中有线程在等待\",{\"1\":{\"616\":1}}],[\"只要持有共享资源的线程释放了锁\",{\"1\":{\"614\":1}}],[\"只要有一个线程访问或操作该对象\",{\"1\":{\"549\":1,\"593\":1}}],[\"只要不变就行\",{\"1\":{\"525\":1}}],[\"只要两个变量的值是向等的\",{\"1\":{\"497\":1}}],[\"只要大部分\",{\"1\":{\"436\":1}}],[\"只要高峰期一过\",{\"1\":{\"348\":1}}],[\"只要加入\",{\"1\":{\"307\":1}}],[\"只存放一部分数据\",{\"1\":{\"323\":1}}],[\"只删地址\",{\"1\":{\"251\":1}}],[\"只为preparedstatement设置参数\",{\"1\":{\"202\":1}}],[\"只查询一次\",{\"1\":{\"187\":1}}],[\"只有应用开发负责人才能够修改应用的线程池参数\",{\"1\":{\"720\":1}}],[\"只有一个线程能执行\",{\"1\":{\"680\":1}}],[\"只有一台应用可以获取到分布式锁\",{\"1\":{\"431\":1}}],[\"只有用到condition才需要去实现它\",{\"1\":{\"678\":1}}],[\"只有当前线程可以访问该变量\",{\"1\":{\"646\":1}}],[\"只有重新占用互斥锁之后才会进入可运行状态\",{\"1\":{\"633\":1,\"701\":1}}],[\"只有获得a锁的线程才有资格获取b锁\",{\"1\":{\"627\":1,\"694\":1}}],[\"只有自己使用完毕后才释放资源\",{\"1\":{\"626\":1,\"693\":1}}],[\"只有链表的头节点\",{\"1\":{\"546\":1}}],[\"只有这样该引用才既能可以调用父类的方法\",{\"1\":{\"465\":1}}],[\"只有满足这\",{\"1\":{\"465\":1}}],[\"只有在每次访问的时候才会检查键值是否过期\",{\"1\":{\"386\":1}}],[\"只有索引应用了mmap\",{\"1\":{\"341\":1}}],[\"只有leader副本才能对外提供读写服务\",{\"1\":{\"339\":1}}],[\"只有将\",{\"1\":{\"277\":1}}],[\"只有memory存储引擎显式支持哈希索引\",{\"1\":{\"150\":1}}],[\"只有精确匹配索引所有列的查询才有效\",{\"1\":{\"149\":1}}],[\"只有发起方的初始序号可以得到确认\",{\"1\":{\"12\":1}}],[\"只取\",{\"1\":{\"136\":1}}],[\"只不过我们hashset是实现了set接口并且把数据作为k值\",{\"1\":{\"595\":1}}],[\"只不过\",{\"1\":{\"474\":1}}],[\"只不过每个库表放的数据是不同的\",{\"1\":{\"128\":1}}],[\"只不过联合索引的健值数量不是一个\",{\"1\":{\"84\":1}}],[\"只支持多key在同一节点上的事务操作\",{\"1\":{\"417\":1}}],[\"只支持\",{\"1\":{\"76\":1}}],[\"只能给代码块加锁\",{\"1\":{\"647\":1}}],[\"只能保证一个变量的原子操作\",{\"1\":{\"645\":1}}],[\"只能保存\",{\"1\":{\"41\":1}}],[\"只能遍历list实现的对象\",{\"1\":{\"597\":1}}],[\"只能包含对象类型\",{\"1\":{\"574\":1}}],[\"只能根据元素本身来访问\",{\"1\":{\"569\":1}}],[\"只能根据实际情况调整\",{\"1\":{\"432\":1}}],[\"只能用于抛出一种异常\",{\"1\":{\"532\":1}}],[\"只能修饰变量\",{\"1\":{\"527\":1}}],[\"只能是\",{\"1\":{\"450\":1}}],[\"只能是一对一通信\",{\"1\":{\"9\":1}}],[\"只能存在创建它的程序里\",{\"1\":{\"380\":1}}],[\"只能靠客户端自己来拉\",{\"1\":{\"374\":1}}],[\"只能被同组内部的一个\",{\"1\":{\"337\":1}}],[\"只能设计为多例\",{\"1\":{\"299\":1}}],[\"只能调用服务端service唯一确定的方法\",{\"1\":{\"219\":1}}],[\"只能加载inputstream流\",{\"1\":{\"195\":1}}],[\"只能增加树的高度\",{\"1\":{\"80\":1}}],[\"只认0和1的组合\",{\"1\":{\"34\":1}}],[\"可根据创建\",{\"1\":{\"731\":1}}],[\"可根据元素的key来访问value\",{\"1\":{\"569\":1}}],[\"可避免在做相关决策时\",{\"1\":{\"712\":1}}],[\"可避免脏读的发生\",{\"1\":{\"76\":1}}],[\"可避免脏读\",{\"1\":{\"76\":2}}],[\"可灵活回收空闲线程\",{\"1\":{\"672\":1}}],[\"可见性\",{\"1\":{\"650\":1}}],[\"可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常\",{\"1\":{\"12\":1}}],[\"可取消任务的执行\",{\"1\":{\"621\":1,\"688\":1}}],[\"可直接根据元素的索引来访问\",{\"1\":{\"569\":1}}],[\"可谓是重中之重\",{\"1\":{\"552\":1}}],[\"可序列化类的所有子类型本身都是可序列化的\",{\"1\":{\"521\":1}}],[\"可与动态编译结合class\",{\"1\":{\"502\":1}}],[\"可变与不可变\",{\"1\":{\"481\":1}}],[\"可生成一个\",{\"1\":{\"435\":1}}],[\"可缩性好\",{\"1\":{\"418\":1}}],[\"可线性扩展到1000多个节点\",{\"1\":{\"417\":1}}],[\"可扩展性\",{\"1\":{\"417\":1}}],[\"可扩展的平台\",{\"1\":{\"270\":1}}],[\"可动态调整数据分布\",{\"1\":{\"417\":1}}],[\"可极大满足redis大容量或高性能的业务需求\",{\"1\":{\"416\":1}}],[\"可用于解决原子的更新数据和数据的版本号\",{\"1\":{\"683\":1}}],[\"可用实现多节点redis的分布式锁\",{\"1\":{\"436\":1}}],[\"可用性高\",{\"1\":{\"413\":1}}],[\"可用性不高\",{\"1\":{\"413\":1}}],[\"可用性\",{\"1\":{\"350\":1}}],[\"可用来保存对象的状态\",{\"1\":{\"188\":1}}],[\"可进行\",{\"1\":{\"295\":1}}],[\"可注解在类和方法上\",{\"1\":{\"295\":1}}],[\"可标注任意类为\",{\"1\":{\"271\":1}}],[\"可通过对锁进行重入计数\",{\"1\":{\"435\":1}}],[\"可通过回调函数\",{\"1\":{\"237\":1}}],[\"可通过此方法\",{\"0\":{\"56\":1}}],[\"可在它的映射文件中配置\",{\"1\":{\"188\":1}}],[\"可唯一定位一个mapperstatement\",{\"1\":{\"182\":1}}],[\"可预测性的提前查到内容\",{\"1\":{\"136\":1}}],[\"可串行化\",{\"1\":{\"102\":2}}],[\"可重入锁指的是在一个线程中可以多次获取同一把锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"可重入锁\",{\"1\":{\"546\":1,\"648\":1,\"707\":1}}],[\"可重读\",{\"1\":{\"102\":2}}],[\"可重复读\",{\"1\":{\"76\":2,\"120\":1}}],[\"可自行搭建https\",{\"1\":{\"71\":1}}],[\"可参考文章\",{\"1\":{\"438\":1}}],[\"可参考内容格式\",{\"1\":{\"71\":2}}],[\"可参考这个视频>>的11\",{\"1\":{\"67\":1}}],[\"可绑定自定义域\",{\"1\":{\"71\":1}}],[\"可不使用自定义域\",{\"1\":{\"53\":1}}],[\"可存储数据远高于\",{\"1\":{\"41\":1}}],[\"可设置为长时间保持\",{\"1\":{\"41\":1}}],[\"可防止数据在传输过程中不被窃取\",{\"1\":{\"36\":1}}],[\"可供选择的缓存头来控制缓存策略\",{\"1\":{\"33\":1}}],[\"可能本身是为了防止线程a在写数据\",{\"1\":{\"667\":1}}],[\"可能获取锁时只有一个线程\",{\"1\":{\"661\":1}}],[\"可能发生改变\",{\"1\":{\"560\":1}}],[\"可能有一系列的方法调用\",{\"1\":{\"537\":1}}],[\"可能有几十万甚至几百万的请求积压在\",{\"1\":{\"348\":1}}],[\"可能在看这个问题之前很多人和我一样并没有接触和使用过\",{\"1\":{\"447\":1}}],[\"可能瞬间就会导致数据库宕机\",{\"1\":{\"396\":1}}],[\"可能会造成线程的阻塞\",{\"1\":{\"646\":1}}],[\"可能会遇到了许多应用程序崩溃的问题\",{\"1\":{\"447\":1}}],[\"可能会导致在操作数据过程中带来很多加锁解锁的开销\",{\"1\":{\"399\":1}}],[\"可能会设置响应的回调函数\",{\"1\":{\"358\":1}}],[\"可能会产生一些逻辑错误\",{\"1\":{\"335\":1}}],[\"可能触发此类选举\",{\"1\":{\"340\":1}}],[\"可能直接影响可用性\",{\"1\":{\"339\":1}}],[\"可能多也可能少\",{\"1\":{\"176\":1}}],[\"可能是编译后被删除了等原因导致\",{\"1\":{\"533\":1}}],[\"可能是创建了新分区\",{\"1\":{\"340\":1}}],[\"可能是太多行或列\",{\"1\":{\"138\":1}}],[\"可能是加载了许多结果中并不需要的列\",{\"1\":{\"137\":1}}],[\"可能是查询了多余的行并且抛弃掉了\",{\"1\":{\"137\":1}}],[\"可能是写定时任务\",{\"1\":{\"130\":1}}],[\"可能就跑的很慢了\",{\"1\":{\"121\":1}}],[\"可能导致get为null\",{\"0\":{\"566\":1},\"1\":{\"583\":1}}],[\"可能导致集群的一些操作会有一些滞后\",{\"1\":{\"430\":1}}],[\"可能导致从库延迟变大\",{\"1\":{\"108\":1}}],[\"可能导致大量的超时现象和锁竞争\",{\"1\":{\"102\":1}}],[\"可能返回不同结果\",{\"1\":{\"102\":1}}],[\"可能由于网络状态的问题\",{\"1\":{\"22\":1}}],[\"可能还有一些数据要传输\",{\"1\":{\"17\":1}}],[\"可以查看线程池参数的修改记录\",{\"1\":{\"720\":1}}],[\"可以由其他线程来使用cpu\",{\"1\":{\"718\":1}}],[\"可以由一个或多个服务组成\",{\"1\":{\"322\":1}}],[\"可以完成更多任务的工作线程可以从其它线程中窃取任务来执行\",{\"1\":{\"706\":1}}],[\"可以解决使用\",{\"1\":{\"683\":1}}],[\"可以创建自定义线程池\",{\"1\":{\"676\":1}}],[\"可以认为是无界队列\",{\"1\":{\"673\":1}}],[\"可以的\",{\"1\":{\"662\":1}}],[\"可以是一前一后地交替执行同步块\",{\"1\":{\"657\":1}}],[\"可以是redis\",{\"1\":{\"431\":1}}],[\"可以知道有没有成功获取锁\",{\"1\":{\"647\":1}}],[\"可以知道自己在容器中的名字\",{\"1\":{\"274\":1}}],[\"可以给类\",{\"1\":{\"647\":1}}],[\"可以主动释放它占有的资源\",{\"1\":{\"627\":1,\"694\":1}}],[\"可以遍历所有集合\",{\"1\":{\"597\":1}}],[\"可以包含基本类型和对象类型\",{\"1\":{\"574\":1}}],[\"可以增加负载因子loadfactor的值\",{\"1\":{\"554\":1,\"578\":1}}],[\"可以降低负载因子load\",{\"1\":{\"554\":1,\"578\":1}}],[\"可以降低网络通信量\",{\"1\":{\"98\":1}}],[\"可以传递请求\",{\"1\":{\"543\":1}}],[\"可以从或向一个特定的地方读写数据\",{\"1\":{\"539\":1}}],[\"可以从两个方面入手\",{\"1\":{\"236\":1}}],[\"可以省略\",{\"1\":{\"535\":1}}],[\"可以抛出多个异常\",{\"1\":{\"532\":1}}],[\"可以阻止该变量被序列化到文件中\",{\"1\":{\"527\":1}}],[\"可以阻断\",{\"1\":{\"454\":1}}],[\"可以进行反序列化\",{\"1\":{\"524\":1}}],[\"可以进行读写分离\",{\"1\":{\"376\":1}}],[\"可以让你在即使jvm停机的情况下也能把对象保存下来的方案\",{\"1\":{\"518\":1}}],[\"可以提供编译期的类型安全保证\",{\"1\":{\"515\":1}}],[\"可以获取集合中元素的索引\",{\"1\":{\"597\":1}}],[\"可以获取类的属性\",{\"1\":{\"504\":1}}],[\"可以获取key对应的hash\",{\"1\":{\"429\":1}}],[\"可以调用包装类的type属性来获得该包装类的class对象\",{\"1\":{\"503\":1}}],[\"可以保证内存可见性\",{\"1\":{\"547\":1}}],[\"可以保证数据的一致性\",{\"1\":{\"490\":1}}],[\"可以保存在文件中或在网络连接上传递\",{\"1\":{\"519\":1}}],[\"可以保存数据\",{\"1\":{\"282\":1}}],[\"可以参加表达式运算\",{\"1\":{\"486\":1}}],[\"可以参考这篇文章\",{\"1\":{\"461\":1,\"469\":1,\"474\":1}}],[\"可以把list\",{\"0\":{\"514\":1}}],[\"可以把list<string>传递给一个接受list<object>参数的方法吗\",{\"1\":{\"484\":1}}],[\"可以把用不到的删掉\",{\"1\":{\"157\":1}}],[\"可以快速找到所需要的对象\",{\"1\":{\"477\":1}}],[\"可以具有不同的数据类型或表现出不同的行为\",{\"1\":{\"464\":1}}],[\"可以设计出低耦合的系统\",{\"1\":{\"463\":1}}],[\"可以设置如下\",{\"1\":{\"334\":1}}],[\"可以\",{\"1\":{\"459\":1,\"460\":1,\"553\":1,\"560\":1}}],[\"可以支撑高并发的获取\",{\"1\":{\"432\":1}}],[\"可以支撑大量的\",{\"1\":{\"350\":1}}],[\"可以接着上次复制的地方\",{\"1\":{\"422\":1}}],[\"可以考虑pika\",{\"1\":{\"415\":1}}],[\"可以考虑分片\",{\"1\":{\"415\":1}}],[\"可以考虑表中的数据量是否太大\",{\"1\":{\"137\":1}}],[\"可以实现无状态的调用\",{\"1\":{\"704\":1}}],[\"可以实现\",{\"1\":{\"629\":1,\"696\":1}}],[\"可以实现一套sentinel监控一组redis数据节点或多组数据节点\",{\"1\":{\"416\":1}}],[\"可以实现故障发现\",{\"1\":{\"416\":1}}],[\"可以实现同时对外提供服务和读写分离策略\",{\"1\":{\"415\":1}}],[\"可以实现分布式的缓存\",{\"1\":{\"380\":1}}],[\"可以监控一个或多个键\",{\"1\":{\"409\":1}}],[\"可以为null\",{\"1\":{\"714\":1}}],[\"可以为\",{\"1\":{\"409\":1,\"560\":1}}],[\"可以充分利用服务器\",{\"1\":{\"401\":1}}],[\"可以自动降级或人工降级\",{\"1\":{\"398\":1}}],[\"可以自动降级\",{\"1\":{\"398\":1}}],[\"可以理解为线程数是可以无限扩展的\",{\"1\":{\"673\":1}}],[\"可以理解为\",{\"1\":{\"387\":1}}],[\"可以利用redis的setnx功能来编写分布式的锁\",{\"1\":{\"381\":1}}],[\"可以处理每秒百万级的并发\",{\"1\":{\"380\":1}}],[\"可以用任意类型来替代\",{\"1\":{\"512\":1}}],[\"可以用来执行任务\",{\"1\":{\"714\":1}}],[\"可以用来获取和设置类之中的属性值\",{\"1\":{\"504\":1}}],[\"可以用来控制分布式系统之间同步访问共享资源\",{\"1\":{\"431\":1}}],[\"可以用几十\",{\"1\":{\"380\":1}}],[\"可以用这个方式来获取其它bean\",{\"1\":{\"274\":1}}],[\"可以做到\",{\"1\":{\"350\":1}}],[\"可以达到几百\",{\"1\":{\"350\":1}}],[\"可以指定多个线程同时访问某个资源\",{\"1\":{\"681\":1}}],[\"可以指定一个\",{\"1\":{\"336\":1}}],[\"可以指定复制所有的数据库\",{\"1\":{\"129\":1}}],[\"可以灵活伸缩\",{\"1\":{\"325\":1}}],[\"可以存在于不同的\",{\"1\":{\"323\":1}}],[\"可以存任意数据类型\",{\"1\":{\"41\":1}}],[\"可以选择选择需要的功能\",{\"1\":{\"304\":1}}],[\"可以像servlet一样处理http请求\",{\"1\":{\"269\":1}}],[\"可以发现系统中的配置问题\",{\"1\":{\"266\":1}}],[\"可以扩展到上至本地事务下至全局事务\",{\"1\":{\"263\":1}}],[\"可以有效的防止sql注入\",{\"1\":{\"181\":1}}],[\"可以严格控制\",{\"1\":{\"178\":1}}],[\"可以严格控制sql执行性能\",{\"1\":{\"172\":1}}],[\"可以根据对象关系模型直接获取\",{\"1\":{\"174\":1}}],[\"可以根据条件来完成行锁锁定\",{\"1\":{\"117\":1}}],[\"可以通过这两个方式解决这个问题\",{\"1\":{\"645\":1}}],[\"可以通过atomicstampedreference解决aba问题\",{\"1\":{\"645\":1}}],[\"可以通过\",{\"1\":{\"530\":1,\"532\":1,\"648\":1,\"697\":1,\"707\":1}}],[\"可以通过反射机制来实现\",{\"1\":{\"506\":1}}],[\"可以通过客户端轮询的方式解决该问题\",{\"1\":{\"435\":1}}],[\"可以通过限制删除操作执行的时长和频率来减少删除操作对\",{\"1\":{\"386\":1}}],[\"可以通过上线更多consumer临时解决消息堆积问题\",{\"1\":{\"370\":1}}],[\"可以通过检查\",{\"1\":{\"278\":1}}],[\"可以通过多少种方式完成依赖注入\",{\"0\":{\"265\":1}}],[\"可以通过count\",{\"1\":{\"160\":1}}],[\"可以通过如下技巧去优化\",{\"1\":{\"138\":1}}],[\"可以大大加快数据的检索速度\",{\"1\":{\"147\":1}}],[\"可以大大降低死锁机会\",{\"1\":{\"118\":1}}],[\"可以建立中间表以提高查询效率\",{\"1\":{\"140\":1}}],[\"可以将线程池的参数从代码中迁移到分布式配置中心上\",{\"1\":{\"719\":1}}],[\"可以将修改线程池参数的成本降下来\",{\"1\":{\"719\":1}}],[\"可以将整个对象层次写入字节流中\",{\"1\":{\"519\":1}}],[\"可以将1秒内所造成的缓存脏数据\",{\"1\":{\"391\":1}}],[\"可以将内存中的数据保持在磁盘中\",{\"1\":{\"378\":1}}],[\"可以将多个\",{\"1\":{\"352\":1}}],[\"可以将一些非核心流程\",{\"1\":{\"345\":1}}],[\"可以将其关闭\",{\"1\":{\"156\":1}}],[\"可以将这些字段分离出来形成新表\",{\"1\":{\"140\":1}}],[\"可以将put\",{\"1\":{\"29\":1}}],[\"可以缓存数据\",{\"1\":{\"138\":1}}],[\"可以在多线程下并发使用\",{\"1\":{\"598\":1}}],[\"可以在运行时动态的生成某个类的子类\",{\"1\":{\"284\":1}}],[\"可以在减少回表次数\",{\"1\":{\"156\":1}}],[\"可以在查询的过程中\",{\"1\":{\"147\":1}}],[\"可以在从服务器上备份而不破坏主服务器相应数据\",{\"1\":{\"130\":1}}],[\"可以在不同的服务器软件\",{\"1\":{\"31\":1}}],[\"可以动态地调整从服务器的数量\",{\"1\":{\"130\":1}}],[\"可以平均分配每个库的数据量和请求压力\",{\"1\":{\"128\":1}}],[\"可以尝试使用升级锁定颗粒度\",{\"1\":{\"118\":1}}],[\"可以按照锁的粒度把数据库锁分为行级锁\",{\"1\":{\"114\":1}}],[\"可以一定程度上确保数据安全\",{\"1\":{\"98\":1}}],[\"可以一定程度上减少服务器的这个问题\",{\"1\":{\"21\":1}}],[\"可以使用访问控制符来保护对类\",{\"1\":{\"451\":1}}],[\"可以使用java\",{\"1\":{\"304\":1}}],[\"可以使用表锁来提高处理速度活着减少死锁的可能\",{\"1\":{\"120\":1}}],[\"可以使用\",{\"1\":{\"95\":1,\"172\":1,\"271\":1,\"297\":1,\"396\":1}}],[\"可以使用这个bean了\",{\"1\":{\"276\":1}}],[\"可以使用这个\",{\"1\":{\"61\":1}}],[\"可以空\",{\"1\":{\"87\":1}}],[\"可以去其他网站注册便宜的域名\",{\"1\":{\"66\":1}}],[\"可以直接使用下方域名\",{\"1\":{\"62\":1}}],[\"可以防止证书被篡改\",{\"1\":{\"37\":1}}],[\"可以公开的\",{\"1\":{\"37\":1}}],[\"可以看成是组合式\",{\"1\":{\"680\":1}}],[\"可以看出管道传输数据是单向的\",{\"1\":{\"725\":1}}],[\"可以看出\",{\"1\":{\"605\":1}}],[\"可以看出负载均衡策略已经成功\",{\"1\":{\"259\":1}}],[\"可以看这篇文章这道面试题我真不知道面试官想要的回答是什么\",{\"1\":{\"548\":1,\"588\":1}}],[\"可以看这篇文章\",{\"1\":{\"526\":1,\"548\":1,\"590\":1}}],[\"可以看看\",{\"1\":{\"300\":1}}],[\"可以看作增\",{\"1\":{\"29\":1}}],[\"可以看到线程池的任务执行情况\",{\"1\":{\"720\":1}}],[\"可以看到是使用\",{\"1\":{\"617\":1}}],[\"可以看到这些都用了volatile修饰\",{\"1\":{\"586\":1}}],[\"可以看到链表中元素个数为\",{\"1\":{\"553\":1}}],[\"可以看到从\",{\"1\":{\"126\":1}}],[\"可以看到滑动窗口起到了一个限流的作用\",{\"1\":{\"23\":1}}],[\"可以看到\",{\"1\":{\"16\":1}}],[\"可以正常通信\",{\"1\":{\"13\":1}}],[\"可靠性\",{\"1\":{\"352\":1,\"442\":1}}],[\"可靠性最高\",{\"1\":{\"330\":1}}],[\"可靠传输\",{\"1\":{\"9\":1}}],[\"可靠的数据传输服务\",{\"1\":{\"8\":1}}],[\"状态的线程在获取对象的同步锁时\",{\"1\":{\"639\":1}}],[\"状态的线程执行\",{\"1\":{\"639\":2}}],[\"状态的客户端无法再接受确认报文段\",{\"1\":{\"12\":1}}],[\"状态超时\",{\"1\":{\"623\":1,\"639\":1,\"690\":1}}],[\"状态为0\",{\"1\":{\"617\":1}}],[\"状态就不能再改变\",{\"1\":{\"472\":1}}],[\"状态信息\",{\"1\":{\"223\":1}}],[\"状态行\",{\"1\":{\"32\":1}}],[\"状态码301和302的区别是什么\",{\"0\":{\"28\":1}}],[\"状态码开头代表类型\",{\"1\":{\"27\":1}}],[\"状态过多会产生什么后果\",{\"0\":{\"20\":1}}],[\"状态必须等待\",{\"0\":{\"18\":1}}],[\"状态\",{\"1\":{\"12\":4,\"14\":1,\"16\":3,\"639\":1}}],[\"这部分完成的工作是\",{\"1\":{\"713\":1}}],[\"这部分功能要分离出来\",{\"1\":{\"223\":1}}],[\"这和我们以往通过实现接口的方式有很大区别\",{\"1\":{\"678\":1}}],[\"这才起到多线程的效果~\",{\"1\":{\"641\":1}}],[\"这通常被认为是解决死锁很好的一种方法\",{\"1\":{\"627\":1,\"694\":1}}],[\"这减少了线程上下文切换的开销\",{\"1\":{\"622\":1,\"689\":1}}],[\"这几个方法都是final修饰的\",{\"1\":{\"604\":1}}],[\"这几乎是不可接受的\",{\"1\":{\"347\":1}}],[\"这句代码\",{\"1\":{\"565\":1}}],[\"这八处没有存放数据\",{\"1\":{\"555\":1}}],[\"这保证了多个线程并发执行的连续性和扩展性\",{\"1\":{\"548\":1,\"590\":1}}],[\"这无疑带来了巨大内存浪费\",{\"1\":{\"546\":1}}],[\"这无疑又使得\",{\"1\":{\"399\":1}}],[\"这份cache也可以被称作根对象\",{\"1\":{\"507\":1}}],[\"这份class对象里维护着该类的所有method\",{\"1\":{\"507\":1}}],[\"这段代码在jdk6中输出是false\",{\"1\":{\"488\":1}}],[\"这其中就利用到了散列码\",{\"1\":{\"477\":1}}],[\"这使得代码更加可读\",{\"1\":{\"510\":1}}],[\"这使得同一个属性或方法在父类及其各个子类中具有不同的含义\",{\"1\":{\"464\":1}}],[\"这使程序更简洁易读\",{\"1\":{\"443\":1}}],[\"这块资源将会永远被锁住\",{\"1\":{\"434\":1}}],[\"这把锁也要在一段时间后自动释放\",{\"1\":{\"434\":1}}],[\"这把锁是非重入的\",{\"1\":{\"432\":1}}],[\"这把锁只能是非阻塞的\",{\"1\":{\"432\":1}}],[\"这把锁没有失效时间\",{\"1\":{\"432\":1}}],[\"这把锁强依赖数据库的可用性\",{\"1\":{\"432\":1}}],[\"这么做可以在数组\",{\"1\":{\"555\":1}}],[\"这么做\",{\"1\":{\"391\":1}}],[\"这大大增加了网络io的次数和数据体积\",{\"1\":{\"378\":1}}],[\"这不是18个时间吗\",{\"1\":{\"373\":1}}],[\"这4类选举策略的大致思想是类似的\",{\"1\":{\"340\":1}}],[\"这三个角色\",{\"1\":{\"331\":1}}],[\"这有助于你的消费能力的动态调整\",{\"1\":{\"326\":1}}],[\"这意味着你可以通过编程的方式管理事务\",{\"1\":{\"287\":1}}],[\"这意味着每条记录的i\",{\"1\":{\"162\":1}}],[\"这将覆盖自动装配\",{\"1\":{\"279\":1}}],[\"这将导致服务器长时间单方面等待\",{\"1\":{\"12\":1}}],[\"这四个方法的调用有点类似aop\",{\"1\":{\"276\":1}}],[\"这一系列方法调用的有序列表叫做调用栈\",{\"1\":{\"537\":1}}],[\"这一个过程就叫做\",{\"1\":{\"511\":1}}],[\"这一种情况也会出现问题\",{\"1\":{\"393\":1}}],[\"这一步主要是多bean的依赖属性进行填充\",{\"1\":{\"281\":1}}],[\"这一步最麻烦\",{\"1\":{\"135\":1}}],[\"这一版本中\",{\"1\":{\"260\":1}}],[\"这显然是不合理的\",{\"1\":{\"223\":1}}],[\"这里需要注意\",{\"1\":{\"673\":1}}],[\"这里需要操作一下\",{\"1\":{\"237\":1}}],[\"这里稍微总结下\",{\"1\":{\"611\":1}}],[\"这里有一个小的变化\",{\"1\":{\"608\":1}}],[\"这里会涉及到两个变化\",{\"1\":{\"607\":1}}],[\"这里会解析xml配置并执行configuration中的addmapper\",{\"1\":{\"196\":1}}],[\"这里只是aqs的简单实现\",{\"1\":{\"605\":1}}],[\"这里以非公平锁为例进行分析\",{\"1\":{\"605\":1}}],[\"这里异常的抛出条件是检测到\",{\"1\":{\"598\":1}}],[\"这里了\",{\"1\":{\"564\":1,\"565\":1}}],[\"这里就不做解释了\",{\"1\":{\"612\":1}}],[\"这里就是使用一个容量更大的数组来代替已有的容量小的数组\",{\"1\":{\"558\":1,\"581\":1}}],[\"这里就引出消费幂等的问题\",{\"1\":{\"360\":1}}],[\"这里不是return\",{\"1\":{\"536\":1}}],[\"这里我想的是\",{\"1\":{\"392\":1}}],[\"这里我们将只创建一个\",{\"1\":{\"277\":1}}],[\"这里默认用的第一个\",{\"1\":{\"251\":1}}],[\"这里是json\",{\"1\":{\"245\":1}}],[\"这里是为了取里面的mapperstatement\",{\"1\":{\"203\":1}}],[\"这里使用的还是java\",{\"1\":{\"237\":1}}],[\"这里建议先学习下netty的启动代码\",{\"1\":{\"237\":1}}],[\"这里其实可以利用class对象自动得到\",{\"1\":{\"230\":1}}],[\"这里其实是在mapperregistry中生产一个mapper对应的代理工厂\",{\"1\":{\"204\":1}}],[\"这里回到了更新1\",{\"1\":{\"230\":1}}],[\"这里负责zookeeper客户端的初始化\",{\"1\":{\"251\":1}}],[\"这里负责解析得到的request请求\",{\"1\":{\"230\":1}}],[\"这里负责底层与服务端的通信\",{\"1\":{\"223\":1}}],[\"这里先不去讨论实现其中的细节\",{\"1\":{\"230\":1}}],[\"这里的\",{\"1\":{\"555\":1,\"579\":1}}],[\"这里的a就不是a变量了\",{\"1\":{\"536\":1}}],[\"这里的request是封装好的\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"这里的sqlsessionfactory和sqlsession都是接口\",{\"1\":{\"193\":1}}],[\"这里getproperties将值取出用以连接jdbc\",{\"1\":{\"198\":1}}],[\"这里get的statementid为接口+方法名\",{\"1\":{\"197\":1}}],[\"这里selectone方法是特殊的selectlist方法\",{\"1\":{\"197\":1}}],[\"这里所描述的是索引存储时保存的形式\",{\"1\":{\"79\":1,\"148\":1}}],[\"这既占内存空间\",{\"1\":{\"155\":1}}],[\"这涉及到查询语句所要求的字段是否全部命中了索引\",{\"1\":{\"152\":1}}],[\"这条语句需要\",{\"1\":{\"136\":1}}],[\"这也就是map喜欢将string作为key的原因\",{\"1\":{\"482\":1}}],[\"这也就是说\",{\"1\":{\"411\":1}}],[\"这也是它比其他并发集合比如\",{\"1\":{\"547\":1,\"586\":1}}],[\"这也是为什么jdk1\",{\"1\":{\"637\":1,\"708\":1}}],[\"这也是为什么\",{\"1\":{\"515\":1}}],[\"这也是为什么有时候多态方法又被称为延迟方法的原因\",{\"1\":{\"465\":1}}],[\"这也是和zookeeper的重要区别之一\",{\"1\":{\"363\":1}}],[\"这也是spring的核心思想\",{\"1\":{\"270\":1}}],[\"这也是创建索引的最主要的原因\",{\"1\":{\"147\":1}}],[\"这也是我们主要集中关注的\",{\"1\":{\"136\":1}}],[\"这也会消耗很多系统资源\",{\"1\":{\"21\":1}}],[\"这会导致数据库处于不一致的状态\",{\"1\":{\"109\":1}}],[\"这会导致另一个棘手的问题\",{\"1\":{\"102\":1}}],[\"这类操作\",{\"1\":{\"108\":1}}],[\"这就会\",{\"1\":{\"665\":1}}],[\"这就会导致上层应用会不断的进行retry\",{\"1\":{\"116\":1}}],[\"这就解决了自旋锁带来的缺点\",{\"1\":{\"661\":1}}],[\"这就表示arraylist的存储能力不足\",{\"1\":{\"573\":1}}],[\"这就跟原来使用链表结构一样了\",{\"1\":{\"553\":1}}],[\"这就有了二义性\",{\"1\":{\"548\":1,\"588\":2}}],[\"这就有达到了所谓的高可用性\",{\"1\":{\"323\":1}}],[\"这就与我们的假设的真实情况不符合了\",{\"1\":{\"548\":1,\"588\":1}}],[\"这就无法判断\",{\"1\":{\"548\":1}}],[\"这就意味着java中的任何类都包含有hashcode\",{\"1\":{\"477\":1}}],[\"这就意味着ioc是spring针对解决程序耦合而存在的\",{\"1\":{\"270\":1}}],[\"这就增加了程序员的负担\",{\"1\":{\"443\":1}}],[\"这就需要人工干预\",{\"1\":{\"416\":1}}],[\"这就需要消费者根据实际情况保证幂等性\",{\"1\":{\"332\":1}}],[\"这就数据不一致了\",{\"1\":{\"349\":1}}],[\"这就转变为上面提到的如何保证消息的可靠传输的问题了\",{\"1\":{\"337\":1}}],[\"这就导致\",{\"1\":{\"291\":1}}],[\"这就是自旋锁的优化方式\",{\"1\":{\"661\":1}}],[\"这就是为什么公平锁的吞吐比非公平锁低的原因\",{\"1\":{\"616\":1}}],[\"这就是\",{\"1\":{\"560\":1,\"582\":1,\"677\":1}}],[\"这就是弱一致性\",{\"1\":{\"548\":1,\"590\":1}}],[\"这就是一个version号\",{\"1\":{\"427\":1}}],[\"这就是缓存雪崩\",{\"1\":{\"396\":1}}],[\"这就是解耦\",{\"1\":{\"345\":1}}],[\"这就是天然的分布式消息队列\",{\"1\":{\"323\":1}}],[\"这就是所谓的分库分表\",{\"1\":{\"121\":1}}],[\"这就是事务的一致性\",{\"1\":{\"74\":1}}],[\"这就叫幻读\",{\"1\":{\"103\":1}}],[\"这些重写方法很简单\",{\"1\":{\"678\":1}}],[\"这些底层的同步函数操作会涉及到\",{\"1\":{\"661\":1}}],[\"这些锁本质的区别就是在于获取共享资源访问权的方式不同\",{\"1\":{\"614\":1}}],[\"这些集合类\",{\"1\":{\"598\":1}}],[\"这些类已经很规范的重写了\",{\"1\":{\"560\":1,\"582\":1}}],[\"这些问题不能在入队时发现\",{\"1\":{\"411\":1}}],[\"这些命令不会立即被执行\",{\"1\":{\"409\":1}}],[\"这些键便永远不会被删除\",{\"1\":{\"386\":1}}],[\"这些复杂的操作通常和一般的get\",{\"1\":{\"378\":1}}],[\"这些日志可以被重复读取和无限期保留\",{\"1\":{\"325\":1}}],[\"这些拦截器非常有用\",{\"1\":{\"298\":1}}],[\"这些都交给spring的bean工厂帮我们创建管理\",{\"1\":{\"270\":1}}],[\"这些配置文件通常包含许多\",{\"1\":{\"268\":1}}],[\"这些未完成事务对数据库所做的修改有一部分已写入物理数据库\",{\"1\":{\"101\":1}}],[\"这些操作要么全部发生\",{\"1\":{\"101\":1}}],[\"这些\",{\"1\":{\"98\":1}}],[\"这些伪造的\",{\"1\":{\"14\":1}}],[\"这种类型的线程池特点是\",{\"1\":{\"672\":1}}],[\"这种相当于是对上面自旋锁优化方式的进一步优化\",{\"1\":{\"661\":1}}],[\"这种优化更彻底\",{\"1\":{\"659\":1}}],[\"这种不可变类当\",{\"1\":{\"560\":1,\"582\":1}}],[\"这种参数类型可以用在类\",{\"1\":{\"509\":1}}],[\"这种方法只适合在编译前就知道操作的\",{\"1\":{\"503\":1}}],[\"这种方式就是互斥访问\",{\"1\":{\"731\":1}}],[\"这种方式对于服务器资源要求比较高\",{\"1\":{\"542\":1}}],[\"这种方式比较消耗服务器资源\",{\"1\":{\"435\":1}}],[\"这种方式有什么优点\",{\"0\":{\"429\":1}}],[\"这种方式并不推荐\",{\"1\":{\"416\":1}}],[\"这种方式会阻塞其他的线程\",{\"1\":{\"394\":1,\"396\":1}}],[\"这种方式意味着你可以将事务管理和业务代码分离\",{\"1\":{\"287\":1}}],[\"这种方式带来了很大的灵活性\",{\"1\":{\"287\":1}}],[\"这种动态获取的信息以及动态调用对象的方法的功能称为\",{\"1\":{\"501\":1}}],[\"这种机制的好处在于\",{\"1\":{\"430\":1}}],[\"这种failover是没有必要的\",{\"1\":{\"417\":1}}],[\"这种现象就叫做缓存击穿\",{\"1\":{\"394\":1}}],[\"这种模式下\",{\"1\":{\"416\":1}}],[\"这种模式\",{\"1\":{\"361\":1}}],[\"这种模式让我们可以根据客户的需求能够动态切换不同的数据源\",{\"1\":{\"286\":1}}],[\"这种组件\",{\"1\":{\"342\":1}}],[\"这种循环依赖的情况\",{\"1\":{\"281\":1}}],[\"这种依赖spring是处理不了的\",{\"1\":{\"281\":1}}],[\"这种情况时间复杂度就是o\",{\"1\":{\"571\":1}}],[\"这种情况的泛型类型\",{\"1\":{\"511\":1}}],[\"这种情况下\",{\"1\":{\"473\":1,\"720\":2}}],[\"这种情况下需要特别谨慎\",{\"1\":{\"473\":1}}],[\"这种情况下数据传输效率最高\",{\"1\":{\"330\":1}}],[\"这种情况就需要将提供分布式锁的服务以集群的方式部署\",{\"1\":{\"431\":1}}],[\"这种情况就需要跟应用一起来分析为何连接数会激增\",{\"1\":{\"141\":1}}],[\"这种情况很难修复\",{\"1\":{\"109\":1}}],[\"这种查询其实也是有可以优化的余地的\",{\"1\":{\"136\":1}}],[\"这种隔离级别\",{\"1\":{\"102\":1}}],[\"这种说法其实是不准确的\",{\"1\":{\"96\":1}}],[\"这种时间随着数据量的增加而增加\",{\"1\":{\"86\":1}}],[\"这种索引叫作联合索引\",{\"1\":{\"84\":1}}],[\"这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的\",{\"1\":{\"44\":1}}],[\"这被称为\",{\"1\":{\"82\":1}}],[\"这两个附加的操作是\",{\"1\":{\"713\":1}}],[\"这两个list的声明都是限定通配符的例子\",{\"1\":{\"513\":1}}],[\"这两个字段的值会在初始序号值得基础递增\",{\"1\":{\"12\":1}}],[\"这两种线程池的最大特点就是可以延迟执行任务\",{\"1\":{\"673\":1}}],[\"这两种对象都是可变的\",{\"1\":{\"481\":1}}],[\"这两种级别\",{\"1\":{\"76\":1}}],[\"这两步和原来一样\",{\"1\":{\"391\":1}}],[\"这是为了方便我们能在任何时候结束或停止某个进程\",{\"1\":{\"731\":1}}],[\"这是为了不要过长时间等待已经关闭的redis服务\",{\"1\":{\"437\":1}}],[\"这是模板方法模式很经典的一个运用\",{\"1\":{\"678\":1}}],[\"这是一种完全依赖于硬件的功能\",{\"1\":{\"644\":1}}],[\"这是一个类型限定的语法\",{\"1\":{\"511\":1}}],[\"这是真正的多线程工作\",{\"1\":{\"635\":1,\"703\":1}}],[\"这是公平锁特有的情况\",{\"1\":{\"617\":1}}],[\"这是因为我们在存入的时候\",{\"1\":{\"510\":1}}],[\"这是因为优化器把子查询变成了连接查询\",{\"1\":{\"157\":1}}],[\"这是反射的核心\",{\"1\":{\"505\":1}}],[\"这是业务不能忍受的错误\",{\"1\":{\"386\":1}}],[\"这是最常见的分区leader选举场景\",{\"1\":{\"340\":1}}],[\"这是最常见的选择\",{\"1\":{\"289\":1}}],[\"这是通过认证和授权提供的加密或访问限制提供的\",{\"1\":{\"303\":1}}],[\"这是默认设置\",{\"1\":{\"278\":1}}],[\"这是客户端与服务端都已知的\",{\"1\":{\"216\":1}}],[\"这是不走索引的\",{\"1\":{\"166\":1}}],[\"这是库级别的并行\",{\"1\":{\"133\":1}}],[\"这是\",{\"1\":{\"102\":1,\"350\":2}}],[\"这是大多数数据库系统的默认隔离级别\",{\"1\":{\"102\":1}}],[\"这是由于在查询间隔\",{\"1\":{\"75\":1}}],[\"这是生成\",{\"1\":{\"70\":1}}],[\"这是对七层模型和四层模型的一个折中\",{\"1\":{\"8\":1}}],[\"这个操作会把信号量加上\",{\"1\":{\"728\":1}}],[\"这个操作会把信号量减去\",{\"1\":{\"728\":1}}],[\"这个操作相当于一个内存屏障\",{\"1\":{\"637\":1,\"708\":1}}],[\"这个地方就很简单了\",{\"1\":{\"721\":1}}],[\"这个地方还有个需要注意的小点就是\",{\"1\":{\"717\":1}}],[\"这个地址可以从响应的location首部中获取\",{\"1\":{\"28\":1}}],[\"这个分配线程的策略是在上个步骤完成的\",{\"1\":{\"714\":1}}],[\"这个任务可以有也可以为null\",{\"1\":{\"714\":1}}],[\"这个工具通常用来控制线程等待\",{\"1\":{\"681\":1}}],[\"这个过程是原子的\",{\"1\":{\"644\":1}}],[\"这个过程也是涉及到两个变化\",{\"1\":{\"608\":1}}],[\"这个也是由其子类实现\",{\"1\":{\"617\":1}}],[\"这个指针不多介绍\",{\"1\":{\"603\":1}}],[\"这个机制主要用的是clh队列的变体实现的\",{\"1\":{\"602\":1}}],[\"这个异常只建议用于检测并发修改的bug\",{\"1\":{\"598\":1}}],[\"这个条件我们没有办法破坏\",{\"1\":{\"627\":1,\"694\":1}}],[\"这个条件\",{\"1\":{\"598\":1}}],[\"这个外部比较器要实现comparator接口的\",{\"1\":{\"596\":1}}],[\"这个设计非常的巧妙\",{\"1\":{\"559\":1}}],[\"这个返回路径就形成了\",{\"1\":{\"536\":1}}],[\"这个哈希码的作用是确定该对象在哈希表中的索引位置\",{\"1\":{\"477\":1}}],[\"这个方法主要是对tailoffset和expect进行比较\",{\"1\":{\"607\":1}}],[\"这个方法是需要同步组件自己实现的\",{\"1\":{\"605\":1}}],[\"这个方法会创建一个异常对象\",{\"1\":{\"537\":1}}],[\"这个方法在\",{\"1\":{\"454\":1}}],[\"这个方法能大大降低了脏数据读取的概率\",{\"1\":{\"421\":1}}],[\"这个问题\",{\"1\":{\"445\":1}}],[\"这个问题前\",{\"1\":{\"400\":1}}],[\"这个version号就很重要了\",{\"1\":{\"427\":1}}],[\"这个时候重要的就是如何判断线程是否在运行\",{\"1\":{\"714\":1}}],[\"这个时候就可以从自旋过程中退出\",{\"1\":{\"612\":1}}],[\"这个时候都需要序列化和反序列化\",{\"1\":{\"519\":1}}],[\"这个时候我们就需要用到分布式锁\",{\"1\":{\"431\":1}}],[\"这个时候\",{\"1\":{\"423\":1}}],[\"这个时间差要小于ttl时间并且至少有3个redis实例成功获取锁\",{\"1\":{\"437\":1}}],[\"这个时间\",{\"1\":{\"342\":1}}],[\"这个处理器叫做文件事件处理器\",{\"1\":{\"403\":1}}],[\"这个应该没人使用吧\",{\"1\":{\"388\":1}}],[\"这个不能和专业的消息中间件相比\",{\"1\":{\"381\":1}}],[\"这个短暂的高峰期积压是\",{\"1\":{\"348\":1}}],[\"这个参数的含义是一旦写入失败\",{\"1\":{\"334\":1}}],[\"这个参数的含义是一个\",{\"1\":{\"334\":1}}],[\"这个参数是要求\",{\"1\":{\"333\":1}}],[\"这个id数值\",{\"1\":{\"328\":1}}],[\"这个消息才会被消费者读到\",{\"1\":{\"323\":1}}],[\"这个新的\",{\"1\":{\"323\":1}}],[\"这个\",{\"1\":{\"323\":3,\"511\":1,\"717\":1}}],[\"这个注解可以作用于类上面\",{\"1\":{\"293\":1}}],[\"这个全局变量是线程安全的\",{\"1\":{\"282\":1}}],[\"这个jar包应该依赖log4j\",{\"1\":{\"251\":1}}],[\"这个在hanlder中设置\",{\"1\":{\"237\":1}}],[\"这个在官网有登记使用的公司\",{\"1\":{\"126\":1}}],[\"这个hashmap的地方需要改成serviprovider\",{\"1\":{\"230\":1}}],[\"这个实现类代表着java原始的bio监听模式\",{\"1\":{\"230\":1}}],[\"这个类负责的功能太复杂\",{\"1\":{\"223\":1}}],[\"这个例子以不到百行的代码\",{\"1\":{\"218\":1}}],[\"这个判断只有1个参数也为true\",{\"1\":{\"202\":1}}],[\"这个值可以大于1\",{\"1\":{\"554\":1,\"578\":1}}],[\"这个值可以在构造函数中设置\",{\"1\":{\"548\":1,\"589\":1}}],[\"这个值必须大于\",{\"1\":{\"334\":2}}],[\"这个值也很难确定\",{\"1\":{\"161\":1}}],[\"这个值非常直观显示\",{\"1\":{\"157\":1}}],[\"这个比例有什么经验值吗\",{\"1\":{\"161\":1}}],[\"这个再根据聚集索引查找数据的过程\",{\"1\":{\"151\":1}}],[\"这个较为常用\",{\"1\":{\"128\":1}}],[\"这个一般是按比如时间范围来的\",{\"1\":{\"128\":1}}],[\"这个一般在表层面做的较多一些\",{\"1\":{\"128\":1}}],[\"这个其实就是看看你了解哪些分库分表的中间件\",{\"1\":{\"122\":1}}],[\"这个历史版本存放在\",{\"1\":{\"112\":1}}],[\"这个记录就是来自\",{\"1\":{\"112\":1}}],[\"这个转账会涉及到两个关键操作就是\",{\"1\":{\"100\":1}}],[\"这个签名用来验证证书的完整性和真实性\",{\"1\":{\"37\":1}}],[\"这个是最常用的\",{\"1\":{\"388\":1}}],[\"这个是要求每条数据\",{\"1\":{\"334\":1}}],[\"这个是要区分环境的\",{\"1\":{\"96\":1}}],[\"这个是它们本质区别\",{\"1\":{\"30\":1}}],[\"这个是因为它们使用的操作系统和浏览器设置的不同引起的区别\",{\"1\":{\"30\":1}}],[\"这个是因为http协议用法的约定\",{\"1\":{\"30\":1}}],[\"这个说法没毛病\",{\"1\":{\"30\":1}}],[\"这个重定向只是临时地从旧地址a跳转到地址b\",{\"1\":{\"28\":1}}],[\"这个资源不可访问了\",{\"1\":{\"28\":1}}],[\"这个ack报文当中带有对应的确认序列号\",{\"1\":{\"22\":1}}],[\"这表示服务器提供了请求的网页\",{\"1\":{\"27\":1}}],[\"这表示客户端已经没有数据发送了\",{\"1\":{\"16\":1}}],[\"这样这个进程写入的东西\",{\"1\":{\"727\":1}}],[\"这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间\",{\"1\":{\"719\":1}}],[\"这样去做一个简单的线程隔离\",{\"1\":{\"718\":1}}],[\"这样可灵活的往线程池中添加线程\",{\"1\":{\"672\":1}}],[\"这样可以通过添加引用\",{\"1\":{\"714\":1}}],[\"这样可以给某个对象而不是整个类添加一些功能\",{\"1\":{\"543\":1}}],[\"这样可以共享实例提高性能\",{\"1\":{\"282\":1}}],[\"这样可以控制每个表的数据量在可控的范围内\",{\"1\":{\"121\":1}}],[\"这样可以避免间隙锁对并发插入的影响\",{\"1\":{\"120\":1}}],[\"这样可以省去了锁的开销\",{\"1\":{\"116\":1}}],[\"这样其他线程必须重新从主内存中读取变量值\",{\"1\":{\"637\":1,\"708\":1}}],[\"这样代码看起来会更加简洁\",{\"1\":{\"629\":1,\"696\":1}}],[\"这样两个的利用率就可以在理想情况下达到\",{\"1\":{\"622\":1,\"689\":1}}],[\"这样的队列是什么数据结构呢\",{\"1\":{\"614\":1}}],[\"这样的话\",{\"1\":{\"392\":1}}],[\"这样arraylist就有利于节约内存空间\",{\"1\":{\"572\":1}}],[\"这样先放在一个索引上的元素终会被放到\",{\"1\":{\"558\":1,\"581\":1}}],[\"这样以后就不会扩容了\",{\"1\":{\"558\":1,\"581\":1}}],[\"这样表示他们在\",{\"1\":{\"555\":1}}],[\"这样做的好处是避免多线程频繁线程切换\",{\"1\":{\"674\":1}}],[\"这样做的好处是缩短主流程的响应时间\",{\"1\":{\"345\":1}}],[\"这样做虽然不易产生堆集\",{\"1\":{\"576\":1}}],[\"这样做效果上等同于取模\",{\"1\":{\"555\":1}}],[\"这样迭代器线程可以使用原来老的数据\",{\"1\":{\"548\":1,\"590\":1}}],[\"这样在反序列化时新旧版本的serialversionuid就一致了\",{\"1\":{\"525\":1}}],[\"这样对象还是对象\",{\"1\":{\"519\":1}}],[\"这样我们就大大减少了\",{\"1\":{\"478\":1}}],[\"这样彼此就会产生矛盾\",{\"1\":{\"470\":1}}],[\"这样不同的系统拿到的就可以认为是同一把锁\",{\"1\":{\"431\":1}}],[\"这样原本在老的master上的数据不会因master的新增或减少而找不到\",{\"1\":{\"429\":1}}],[\"这样列表永远为n个id\",{\"1\":{\"381\":1}}],[\"这样用户的一部分请求会直接到缓存这里而不用经过数据库\",{\"1\":{\"379\":1}}],[\"这样会导致节点间数据信息会发生短暂的不一致\",{\"1\":{\"374\":1}}],[\"这样会导致死锁\",{\"1\":{\"120\":1}}],[\"这样下来\",{\"1\":{\"346\":1,\"348\":1}}],[\"这样才能保证读取的数据是正确的\",{\"1\":{\"731\":1}}],[\"这样才能确保\",{\"1\":{\"334\":1}}],[\"这样才能将请求和方法进行映射\",{\"1\":{\"293\":1}}],[\"这样才可以提高容错性\",{\"1\":{\"323\":1}}],[\"这样服务端就能根据这些信息根据反射调用相应的方法\",{\"1\":{\"223\":1}}],[\"这样服务端迟迟收不到\",{\"1\":{\"18\":1}}],[\"这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了\",{\"1\":{\"146\":1}}],[\"这样mysql才有可能使用索引\",{\"1\":{\"139\":1}}],[\"这样存储引擎不需要回表获取对应行就可以返回结果\",{\"1\":{\"138\":1}}],[\"这样虽然也\",{\"1\":{\"136\":1}}],[\"这样大大的减少死锁的机会\",{\"1\":{\"120\":1}}],[\"这样反倒是降低了性能\",{\"1\":{\"116\":1}}],[\"这样导致在非叶子节点中能保存的指针数量变少\",{\"1\":{\"80\":1}}],[\"这样来自同一\",{\"1\":{\"42\":1}}],[\"这样\",{\"1\":{\"39\":1,\"308\":1,\"518\":1}}],[\"这样一个没有容量限制的阻塞队列来存放任务\",{\"1\":{\"673\":1}}],[\"这样一个连接上可以有多个request\",{\"1\":{\"34\":1}}],[\"这样一来就让当前对象中被\",{\"1\":{\"646\":1}}],[\"这样一来\",{\"1\":{\"23\":1,\"565\":1}}],[\"这样就省去了大量有关锁申请的操作\",{\"1\":{\"656\":1}}],[\"这样就提高了\",{\"1\":{\"622\":1,\"689\":1}}],[\"这样就保证了数据的不可重复性\",{\"1\":{\"595\":1}}],[\"这样就会导致查询速度降低\",{\"1\":{\"555\":1}}],[\"这样就会造成数据库中的数据与缓存中数据不一致的问题\",{\"1\":{\"389\":1}}],[\"这样就能保证顺序性\",{\"1\":{\"337\":1}}],[\"这样就不会跟被修改的数据上的排他锁冲突\",{\"1\":{\"119\":1}}],[\"这样就不对了\",{\"1\":{\"100\":1}}],[\"这样就降低了数据的维护速度\",{\"1\":{\"86\":1}}],[\"这样就方便了开发者自由的选择以便于充分利用带宽和连接\",{\"1\":{\"33\":1}}],[\"这样就可以避免在发生故障时大量的数据丢失\",{\"1\":{\"424\":1}}],[\"这样就可以避免因为内存不足而造成访问速度下降的问题\",{\"1\":{\"377\":1}}],[\"这样就可以使下一个连接中不会出现这种旧的连接请求报文段\",{\"1\":{\"18\":1}}],[\"这样就可以愉快地进行通信了\",{\"1\":{\"12\":1}}],[\"这样拥塞窗口按线性规律缓慢增长\",{\"1\":{\"24\":1}}],[\"这时可以对该线程进行中断\",{\"1\":{\"714\":1}}],[\"这时需要看我们的业务是io密集型还是cpu密集型\",{\"1\":{\"675\":1}}],[\"这时需要重新重新选举该\",{\"1\":{\"334\":1}}],[\"这时就需要借助内核空间来实现进程间通信\",{\"1\":{\"731\":1}}],[\"这时就需要\",{\"1\":{\"673\":1}}],[\"这时线程1的\",{\"1\":{\"564\":1}}],[\"这时有a\",{\"1\":{\"548\":1,\"588\":1}}],[\"这时会调用\",{\"1\":{\"478\":1}}],[\"这时连接应答处理器会与客户端建立连接\",{\"1\":{\"403\":1}}],[\"这时队列中的消息会被平摊\",{\"1\":{\"355\":1}}],[\"这时自己宕机了\",{\"1\":{\"332\":1}}],[\"这时如果消费者宕机\",{\"1\":{\"332\":1}}],[\"这时候条件队列就会管理该线程\",{\"1\":{\"677\":1}}],[\"这时候有可能任务没有执行完\",{\"1\":{\"669\":1,\"697\":1}}],[\"这时候为了充分提高效率\",{\"1\":{\"643\":1}}],[\"这时候就有可能因为没有重写hashcode方法\",{\"1\":{\"480\":1}}],[\"这时候如果只重写了equals\",{\"1\":{\"480\":1}}],[\"这时候如果运维马上又重启数据库\",{\"1\":{\"396\":1}}],[\"这时候仅仅是读库后返回而不放缓存\",{\"1\":{\"392\":1}}],[\"这时候producer才能认为一个请求中的消息都commit了\",{\"1\":{\"330\":1}}],[\"这时候需要在bean中设置对容器的感知\",{\"1\":{\"274\":1}}],[\"这时多个线程会并发执行该请求对应的业务逻辑\",{\"1\":{\"282\":1}}],[\"这时数据库就处于一种不正确的状态\",{\"1\":{\"101\":1}}],[\"这时\",{\"1\":{\"16\":1,\"75\":1,\"332\":1,\"403\":1}}],[\"这次\",{\"1\":{\"12\":1}}],[\"服务消费者\",{\"1\":{\"253\":1}}],[\"服务提供者\",{\"1\":{\"253\":1}}],[\"服务提供者下线时\",{\"1\":{\"251\":1}}],[\"服务注册接口\",{\"1\":{\"251\":1}}],[\"服务注册中心\",{\"1\":{\"209\":1}}],[\"服务线程组boss负责建立连接\",{\"1\":{\"237\":1}}],[\"服务启动时要暴露其相关的实现类0\",{\"1\":{\"230\":1}}],[\"服务暴露类\",{\"1\":{\"230\":1}}],[\"服务的方法2\",{\"1\":{\"223\":1}}],[\"服务的方法1\",{\"1\":{\"223\":1}}],[\"服务的时候\",{\"1\":{\"106\":1}}],[\"服务类名\",{\"1\":{\"223\":1}}],[\"服务端设置\",{\"1\":{\"334\":1}}],[\"服务端反而需要把自己的ip\",{\"1\":{\"251\":1}}],[\"服务端的一本书可以以\",{\"1\":{\"300\":1}}],[\"服务端的改造\",{\"1\":{\"251\":1}}],[\"服务端的实现\",{\"1\":{\"237\":1}}],[\"服务端的实现类userserviceimpl要实现增加的功能\",{\"1\":{\"223\":1}}],[\"服务端暴露服务时\",{\"1\":{\"251\":1}}],[\"服务端上线时\",{\"1\":{\"250\":1}}],[\"服务端与客户端通信的host与port预先就必须知道的\",{\"1\":{\"247\":1}}],[\"服务端代码第一次重构完毕\",{\"1\":{\"230\":1}}],[\"服务端代码重构\",{\"1\":{\"230\":1}}],[\"服务端新的服务接口实现类\",{\"1\":{\"230\":1}}],[\"服务端功能太复杂\",{\"1\":{\"226\":1}}],[\"服务端以bio的方式性能是否太低\",{\"1\":{\"226\":1}}],[\"服务端以bio的方式监听socket\",{\"1\":{\"216\":1}}],[\"服务端我们直接绑定的是userservice服务\",{\"1\":{\"226\":1}}],[\"服务端接受解析reuqest与封装发送response对象\",{\"1\":{\"223\":1}}],[\"服务端接受request请求\",{\"1\":{\"223\":1}}],[\"服务端启动了\",{\"1\":{\"216\":1,\"223\":1,\"230\":2}}],[\"服务端返回的user\",{\"1\":{\"216\":1}}],[\"服务端返回执行方法的返回值给客服端\",{\"1\":{\"215\":1}}],[\"服务端需要实现service接口的功能\",{\"1\":{\"216\":1}}],[\"服务端需要提供的服务接口\",{\"1\":{\"216\":1}}],[\"服务端需要操作这个对象\",{\"1\":{\"216\":1}}],[\"服务端查询到user对象返回给客户端\",{\"1\":{\"215\":1}}],[\"服务端程序抽象化\",{\"1\":{\"212\":1}}],[\"服务端向客户端发送确认数据包\",{\"1\":{\"43\":1}}],[\"服务端向客户端发送连接释放报文\",{\"1\":{\"16\":1}}],[\"服务端无状态话\",{\"1\":{\"42\":1}}],[\"服务端使用\",{\"1\":{\"42\":1}}],[\"服务端会从\",{\"1\":{\"40\":1}}],[\"服务端会超时重传\",{\"1\":{\"18\":1}}],[\"服务端推送\",{\"1\":{\"34\":1}}],[\"服务端重发\",{\"1\":{\"19\":1}}],[\"服务端则会继续超时重试直到断开连接\",{\"1\":{\"18\":1}}],[\"服务端结束\",{\"1\":{\"16\":1}}],[\"服务端将以rst包\",{\"1\":{\"15\":1}}],[\"服务端自动关闭这个连接\",{\"1\":{\"15\":1}}],[\"服务端\",{\"1\":{\"15\":1,\"18\":1,\"210\":1,\"215\":1}}],[\"服务端收到连接释放报文后\",{\"1\":{\"16\":1}}],[\"服务端收到连接请求报文后\",{\"1\":{\"11\":1}}],[\"服务端收\",{\"1\":{\"13\":1}}],[\"服务端确认\",{\"1\":{\"13\":2}}],[\"服务器就需要启动一个线程进行处理\",{\"1\":{\"542\":1}}],[\"服务器就开始重试\",{\"1\":{\"19\":1}}],[\"服务器都存储相同的数据\",{\"1\":{\"417\":1}}],[\"服务器下线就删除节点\",{\"1\":{\"251\":1}}],[\"服务器发生错误\",{\"1\":{\"223\":1}}],[\"服务器发送\",{\"1\":{\"14\":1}}],[\"服务器启动失败\",{\"1\":{\"216\":1,\"223\":1,\"230\":1}}],[\"服务器查询数据\",{\"1\":{\"216\":1}}],[\"服务器注册与发现的实现\",{\"1\":{\"212\":1}}],[\"服务器一直等待来自客户端的确认\",{\"1\":{\"43\":1}}],[\"服务器登录了\",{\"1\":{\"42\":1}}],[\"服务器根据用户提交的相关信息\",{\"1\":{\"40\":1}}],[\"服务器响应\",{\"1\":{\"38\":1}}],[\"服务器响应客户端请求\",{\"1\":{\"37\":1}}],[\"服务器\",{\"1\":{\"38\":3,\"258\":1}}],[\"服务器使用密钥\",{\"1\":{\"37\":1}}],[\"服务器在收到随机码\",{\"1\":{\"37\":1}}],[\"服务器在收到客户端的\",{\"1\":{\"17\":1}}],[\"服务器劫持等情况下几乎起不到作用\",{\"1\":{\"36\":1}}],[\"服务器还可以额外的向客户端推送资源\",{\"1\":{\"34\":1}}],[\"服务器除了对最初请求的响应外\",{\"1\":{\"34\":1}}],[\"服务器会在一段时间之后自动释放锁\",{\"1\":{\"431\":1}}],[\"服务器会等待30秒\",{\"1\":{\"43\":1}}],[\"服务器会将通信路径返回给客户端\",{\"1\":{\"29\":1}}],[\"服务器会向客户单发送\",{\"1\":{\"17\":1}}],[\"服务器遇到错误\",{\"1\":{\"27\":1}}],[\"服务器内部错误\",{\"1\":{\"27\":1}}],[\"服务器找不到请求的网页\",{\"1\":{\"27\":1}}],[\"服务器收到请求\",{\"1\":{\"27\":1}}],[\"服务器目前从不同位置的网页响应请求\",{\"1\":{\"27\":1}}],[\"服务器返回此响应\",{\"1\":{\"27\":1}}],[\"服务器已成功处理了请求\",{\"1\":{\"27\":1}}],[\"服务器端\",{\"1\":{\"245\":1}}],[\"服务器端一般设置不主动关闭连接\",{\"1\":{\"21\":1}}],[\"服务器端的三次握手做一些修改\",{\"1\":{\"14\":1}}],[\"服务器可以设置\",{\"1\":{\"20\":1}}],[\"服务器可以确认自己发送能力和接收能力正常\",{\"1\":{\"12\":1}}],[\"服务器每收到一次客户端的数据\",{\"1\":{\"19\":1}}],[\"服务器的ack和fin一般都会分开发送\",{\"1\":{\"17\":1}}],[\"服务器需要不断的重发直至超时\",{\"1\":{\"14\":1}}],[\"服务器回复\",{\"1\":{\"14\":1}}],[\"服务器随即返回确认报文并进入\",{\"1\":{\"12\":2}}],[\"服务器接收不到请求报文段就不会返回确认报文段\",{\"1\":{\"12\":1}}],[\"而造成的数据错乱\",{\"1\":{\"728\":1}}],[\"而前面提到的匿名管道的生命周期\",{\"1\":{\"726\":1}}],[\"而cpu还有许多运算要处理\",{\"1\":{\"717\":1}}],[\"而concurrenthashmap\",{\"1\":{\"549\":1,\"592\":1}}],[\"而消费者也只从容器里拿元素\",{\"1\":{\"713\":1}}],[\"而做到这一点最关键的思想就是将任务和线程两者解耦\",{\"1\":{\"713\":1}}],[\"而占用锁资源\",{\"1\":{\"712\":1}}],[\"而没有阻塞\",{\"1\":{\"675\":1}}],[\"而延迟队列正好可以把任务按时间进行排序\",{\"1\":{\"673\":1}}],[\"而言\",{\"1\":{\"673\":1}}],[\"而使用\",{\"1\":{\"669\":1,\"697\":1}}],[\"而使用自增字段作为主键则是一个很好的选择\",{\"1\":{\"83\":1}}],[\"而线程2从阻塞队列中移除元素\",{\"1\":{\"713\":1}}],[\"而线程b需要调用这个实例对象所属类的静态\",{\"1\":{\"649\":1}}],[\"而线程是处理器任务调度和执行的基本单位\",{\"1\":{\"620\":1,\"687\":1}}],[\"而synchronized关键字可能会发生阻塞\",{\"1\":{\"709\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"而synchronized\",{\"1\":{\"646\":1}}],[\"而static方法是编译时静态绑定的\",{\"1\":{\"456\":1}}],[\"而创建多个线程就可以让多个\",{\"1\":{\"622\":1,\"689\":1}}],[\"而多线程并发编程正是开发高并发系统的基础\",{\"1\":{\"622\":1,\"689\":1}}],[\"而runnable的任务是不能返回值的\",{\"1\":{\"621\":1,\"688\":1}}],[\"而rpcclientproxy类中需要加入一个rpcclient类变量即可\",{\"1\":{\"237\":1}}],[\"而进程之间的地址空间和资源是相互独立的\",{\"1\":{\"620\":1,\"687\":1}}],[\"而把传统的进程称为重型进程\",{\"1\":{\"620\":1,\"687\":1}}],[\"而共享锁也是一样\",{\"1\":{\"614\":1}}],[\"而独占且公平的锁很明显获取访问权的方式是通过fifo队列的顺序\",{\"1\":{\"614\":1}}],[\"而同步锁只能由一个线程获得\",{\"1\":{\"608\":1}}],[\"而被阻塞后的唤醒只能依靠前驱节点出队或者阻塞线程被中断来实现\",{\"1\":{\"605\":1}}],[\"而v值一直使用一个相同的虚值来保存\",{\"1\":{\"595\":1}}],[\"而linkedlist的空间花费则体现在它的每一个元素都需要消耗比arraylist更多的空间\",{\"1\":{\"571\":1}}],[\"而list<string>却只能用来存储string\",{\"1\":{\"514\":1}}],[\"而list<\",{\"1\":{\"513\":1}}],[\"而arraylist\",{\"1\":{\"571\":1}}],[\"而a>1and\",{\"1\":{\"84\":1}}],[\"而数组为近似\",{\"1\":{\"571\":1}}],[\"而下一次循环的next\",{\"1\":{\"564\":1}}],[\"而链表是\",{\"1\":{\"553\":1,\"577\":1}}],[\"而链表是糟糕的\",{\"1\":{\"553\":1,\"575\":1}}],[\"而单链表不需要\",{\"1\":{\"553\":1,\"577\":1}}],[\"而选择先用链表\",{\"0\":{\"577\":1},\"1\":{\"553\":1}}],[\"而写线程也可以并发的完成改变\",{\"1\":{\"548\":1,\"590\":1}}],[\"而如果变化发生在未遍历过的部分\",{\"1\":{\"548\":1,\"590\":1}}],[\"而如果要调用某一个方法\",{\"1\":{\"505\":1}}],[\"而用于单线程状态的hashmap却可以用containskey\",{\"1\":{\"588\":1}}],[\"而用于单线程状态的\",{\"1\":{\"548\":1}}],[\"而运行时异常在编译时没有如此规定\",{\"1\":{\"535\":1}}],[\"而该索引值小于0或大于等于序列大小时\",{\"1\":{\"534\":1}}],[\"而该字符串确不满足数字类型要求的格式时\",{\"1\":{\"534\":1}}],[\"而该类是一个抽象类或接口时\",{\"1\":{\"534\":1}}],[\"而静态变量优先于对象存在\",{\"1\":{\"528\":1}}],[\"而序列化提供了一种方案\",{\"1\":{\"518\":1}}],[\"而java反序列化是指把字节序列恢复为java对象的过程\",{\"1\":{\"518\":1}}],[\"而jvm以两个十六进制值为一组\",{\"1\":{\"445\":1}}],[\"而有一种情况则不是\",{\"1\":{\"511\":1}}],[\"而最引人注意的一个原因\",{\"1\":{\"510\":1}}],[\"而new\",{\"1\":{\"498\":1}}],[\"而not\",{\"1\":{\"96\":1}}],[\"而包装类型则存储的是堆中的引用\",{\"1\":{\"493\":1}}],[\"而原始类型只能是\",{\"1\":{\"493\":1}}],[\"而基本类型则不行\",{\"1\":{\"493\":1}}],[\"而基本类型不可以\",{\"1\":{\"493\":2}}],[\"而equals\",{\"1\":{\"480\":1}}],[\"而exists语句是对外表作loop循环\",{\"1\":{\"96\":1}}],[\"而接口是一种行为规范\",{\"1\":{\"469\":1}}],[\"而接口是对行为的抽象\",{\"1\":{\"469\":1}}],[\"而接口中的成员变量只能是public\",{\"1\":{\"469\":1}}],[\"而接口中只能存在public\",{\"1\":{\"469\":1}}],[\"而一个类却可以实现多个接口\",{\"1\":{\"469\":1}}],[\"而一些状态\",{\"1\":{\"161\":1}}],[\"而抽象类可以有静态代码块和静态方法\",{\"1\":{\"469\":1}}],[\"而参数不同\",{\"1\":{\"466\":1}}],[\"而后者实现的是运行时的多态性\",{\"1\":{\"466\":1}}],[\"而保证这一点的正是\",{\"1\":{\"442\":1}}],[\"而另外一部分数据却已经丢失\",{\"1\":{\"407\":1}}],[\"而另一方的初始序号则得不到确认\",{\"1\":{\"12\":1}}],[\"而执行命令依旧是单线程\",{\"1\":{\"400\":1}}],[\"而执行计划\",{\"1\":{\"134\":1}}],[\"而我们知道\",{\"1\":{\"399\":1}}],[\"而对于空数据的key有限的\",{\"1\":{\"395\":1}}],[\"而缓存击穿是某个热点的key失效\",{\"1\":{\"394\":1}}],[\"而内存时无法感知到数据在数据库的修改\",{\"1\":{\"389\":1}}],[\"而当前只有redis集群可以做到这样\",{\"1\":{\"385\":1}}],[\"而pull的方式可以根据当前自身情况来pull\",{\"1\":{\"366\":1}}],[\"而post将数据放在body中\",{\"1\":{\"30\":1}}],[\"而群集和故障转移是构建在开放电信平台框架上的\",{\"1\":{\"351\":1}}],[\"而实现的是一种主写主读的生产消费模型\",{\"1\":{\"342\":1}}],[\"而这里\",{\"1\":{\"673\":1}}],[\"而这个时间线程不会占用cpu来处理\",{\"1\":{\"718\":1}}],[\"而这个时候又需要缓存海量数据\",{\"1\":{\"439\":1}}],[\"而这个方法是一个抽象方法\",{\"1\":{\"617\":1}}],[\"而这个节点正好是某个\",{\"1\":{\"334\":1}}],[\"而这些模板方法会调用使用者重写的方法\",{\"1\":{\"678\":1}}],[\"而这些操作都是比较耗时的\",{\"1\":{\"661\":1}}],[\"而这些错误应该在开发的过程中被发现\",{\"1\":{\"411\":1}}],[\"而这些配置通常都是重复添加的\",{\"1\":{\"304\":1}}],[\"而开发\",{\"1\":{\"310\":1}}],[\"而无写操作\",{\"1\":{\"282\":1}}],[\"而无需重新获得锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"而无需任何代码就可指定目标需要的资源\",{\"1\":{\"270\":1}}],[\"而无需客户端明确的请求\",{\"1\":{\"34\":1}}],[\"而其他管理类任务包括但不限于主题删除\",{\"1\":{\"327\":1}}],[\"而其它提供者调用不到\",{\"1\":{\"254\":1}}],[\"而其出度m非常大\",{\"1\":{\"80\":1}}],[\"而客户端调用服务时\",{\"1\":{\"250\":1}}],[\"而建立连接与发送请求的方式是不同点\",{\"1\":{\"237\":1}}],[\"而mybatis在查询关联对象或关联集合对象时\",{\"1\":{\"174\":1}}],[\"而myisam支持\",{\"1\":{\"73\":1}}],[\"而myisam支持表级锁\",{\"1\":{\"73\":1}}],[\"而myisam不支持\",{\"1\":{\"73\":2}}],[\"而myisam不支持事物\",{\"1\":{\"73\":1}}],[\"而innodb的主键索引是聚簇索引\",{\"1\":{\"151\":1}}],[\"而非主键索引\",{\"1\":{\"151\":1}}],[\"而索引b+\",{\"1\":{\"151\":1}}],[\"而\",{\"1\":{\"92\":2,\"95\":1,\"157\":1,\"283\":1,\"296\":1,\"348\":1,\"401\":1,\"406\":1,\"442\":1,\"443\":4,\"447\":3,\"515\":1,\"564\":1,\"597\":3,\"633\":1,\"635\":1,\"647\":3,\"648\":2,\"701\":1,\"703\":1,\"707\":2,\"709\":1}}],[\"而boolean数组将会被编码成java虚拟机的byte数组\",{\"1\":{\"449\":1}}],[\"而boolean类型数据在经过编译后在jvm中会通过int类型来表示\",{\"1\":{\"449\":1}}],[\"而b\",{\"1\":{\"149\":1}}],[\"而b的值是没有顺序的1\",{\"1\":{\"84\":1}}],[\"而b+tree只需要o\",{\"1\":{\"80\":1}}],[\"而是应该立即执行\",{\"1\":{\"720\":1}}],[\"而是使用aqs\",{\"1\":{\"714\":1}}],[\"而是伴随着线程池的运行\",{\"1\":{\"712\":1}}],[\"而是会按照延迟的时间长短对任务进行排序\",{\"1\":{\"673\":1}}],[\"而是会返回已经存在了的字符串的引用\",{\"1\":{\"482\":1}}],[\"而是多条线\",{\"1\":{\"620\":1,\"687\":1}}],[\"而是多个\",{\"1\":{\"84\":1}}],[\"而是先复制原有集合内容\",{\"1\":{\"598\":1}}],[\"而是常量30\",{\"1\":{\"536\":1}}],[\"而是记录下返回值待\",{\"1\":{\"536\":1}}],[\"而是交给了jvm去加载\",{\"1\":{\"507\":1}}],[\"而是cache\",{\"1\":{\"499\":1}}],[\"而是要转化为基本数据类型后才能进行加减乘除\",{\"1\":{\"494\":1}}],[\"而是被放到一个队列中\",{\"1\":{\"409\":1}}],[\"而是\",{\"1\":{\"399\":1,\"536\":1}}],[\"而是由session服务及内存数据库管理\",{\"1\":{\"381\":1}}],[\"而是自己实现\",{\"1\":{\"377\":1}}],[\"而是为了提升组件重用的频率\",{\"1\":{\"270\":1}}],[\"而是描述配置文件中哪些组件需要哪些服务\",{\"1\":{\"265\":1}}],[\"而是存储该列对应的主键\",{\"1\":{\"151\":1}}],[\"而是一种数据存储方式\",{\"1\":{\"148\":1}}],[\"而是取offset+n行\",{\"1\":{\"136\":1}}],[\"而是在访问数据的时候\",{\"1\":{\"386\":1}}],[\"而是在事务的执行过程中\",{\"1\":{\"106\":1}}],[\"而是在整个用户会话中一直存在下去\",{\"1\":{\"39\":1}}],[\"而是直接使用\",{\"1\":{\"99\":1}}],[\"而是直接使用sql语句和客户端发送过来的其他原始信息\",{\"1\":{\"88\":1}}],[\"而辅助索引只用于加速数据的查找\",{\"1\":{\"83\":1}}],[\"而在单核cpu上\",{\"1\":{\"675\":1}}],[\"而在很多情况下\",{\"1\":{\"661\":1}}],[\"而在遍历classpah之后找不到对应名称的class文件时\",{\"1\":{\"534\":1}}],[\"而在于内存容量\",{\"1\":{\"439\":1}}],[\"而在redis2\",{\"1\":{\"435\":1}}],[\"而在发送request时\",{\"1\":{\"251\":1}}],[\"而在从服务器上分析这些数据\",{\"1\":{\"130\":1}}],[\"而在\",{\"1\":{\"76\":1,\"342\":1}}],[\"而在重传的过程中\",{\"1\":{\"22\":1}}],[\"而不能真正删除节点\",{\"1\":{\"576\":1}}],[\"而不再是\",{\"1\":{\"511\":1}}],[\"而不存在于运行阶段\",{\"1\":{\"511\":1}}],[\"而不重写hashcode的方法\",{\"1\":{\"480\":2}}],[\"而不应该出现在生产环境中\",{\"1\":{\"411\":1}}],[\"而不同的数据结构对同步访问的加锁粒度又不尽相同\",{\"1\":{\"399\":1}}],[\"而不用\",{\"0\":{\"380\":1}}],[\"而不需要另外保存它们\",{\"1\":{\"673\":1}}],[\"而不需要到处找示例代码和依赖包\",{\"1\":{\"307\":1}}],[\"而不需要关心具体的资源来自何处\",{\"1\":{\"270\":1}}],[\"而不必继续等待设置的重传计时器时间到期\",{\"1\":{\"24\":1}}],[\"而不要等到自己发送数据时捎带确认\",{\"1\":{\"24\":1}}],[\"而不是用于缓存进程间通信的数据\",{\"1\":{\"728\":1}}],[\"而不是等到\",{\"1\":{\"638\":1}}],[\"而不是\",{\"0\":{\"574\":1}}],[\"而不是转换为红黑树\",{\"1\":{\"553\":1,\"575\":1}}],[\"而不是生成新的对象并改变对象引用\",{\"1\":{\"481\":1}}],[\"而不是根据master数量\",{\"1\":{\"429\":1}}],[\"而不是从头开始复制一份\",{\"1\":{\"420\":1,\"422\":1}}],[\"而不是cp\",{\"1\":{\"374\":1}}],[\"而不是使用\",{\"1\":{\"268\":1}}],[\"而不是创建或查找依赖的对象们\",{\"1\":{\"263\":1}}],[\"而不是想要的相应的response\",{\"1\":{\"237\":1}}],[\"而不是b\",{\"0\":{\"150\":1}}],[\"而不是扫描全部的表\",{\"1\":{\"135\":1}}],[\"而不是先申请共享锁\",{\"1\":{\"120\":1}}],[\"而不是四次\",{\"0\":{\"13\":1}}],[\"而不是两次\",{\"0\":{\"12\":1}}],[\"而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值\",{\"1\":{\"23\":1}}],[\"而服务器却将整个对象送过来了\",{\"1\":{\"33\":1}}],[\"而服务器可以确认自己的接收能力和对方的发送能力正常\",{\"1\":{\"12\":1}}],[\"而服务端只要收到客户端发出的确认\",{\"1\":{\"16\":1}}],[\"而且支持定时的以及周期性的任务执行\",{\"1\":{\"672\":1}}],[\"而且一个项目里面一般来说不止一个自定义线程池吧\",{\"1\":{\"718\":1}}],[\"而且一个健康的单库并发值你最好保持在每秒\",{\"1\":{\"121\":1}}],[\"而且一旦线程启动后\",{\"1\":{\"638\":1}}],[\"而且因为存在再次hash\",{\"1\":{\"576\":1}}],[\"而且空间不浪费\",{\"1\":{\"555\":1}}],[\"而且并发局限于应用中\",{\"1\":{\"542\":1}}],[\"而且递归保存对象引用的每个对象的数据\",{\"1\":{\"519\":1}}],[\"而且majority哨兵都允许了主备切换\",{\"1\":{\"426\":1}}],[\"而且\",{\"1\":{\"390\":1,\"446\":1,\"560\":1,\"582\":1,\"646\":1}}],[\"而且传统的关系数据库类型不适合存储这种类型的数据\",{\"1\":{\"381\":1}}],[\"而且这个\",{\"1\":{\"336\":1}}],[\"而且需要做很多框架使用及环境参数的重复配置\",{\"1\":{\"304\":1}}],[\"而且不会通知客户端\",{\"1\":{\"374\":1}}],[\"而且不同的客户在每次访问中根据需要会去访问不同的数据库\",{\"1\":{\"286\":1}}],[\"而且不支持读写分离\",{\"1\":{\"123\":1}}],[\"而且更加幸运的是\",{\"1\":{\"281\":1}}],[\"而且通过bean工厂创建的bean生命周期会简单一些\",{\"1\":{\"266\":1}}],[\"而且有可能会出现空指针异常的错误\",{\"1\":{\"266\":1}}],[\"而且在netty服务端\",{\"1\":{\"244\":1}}],[\"而且索引是一个文件\",{\"1\":{\"146\":1}}],[\"而且还可以多地备份\",{\"1\":{\"130\":1}}],[\"而且目前应该是非常火的而且不断流行的数据库中间件\",{\"1\":{\"127\":1}}],[\"而且目前推出到了\",{\"1\":{\"126\":1}}],[\"而且确实之前使用的公司会比较多一些\",{\"1\":{\"126\":1}}],[\"而且是多台服务器共同作用\",{\"1\":{\"43\":1}}],[\"而且是先有了理论模型\",{\"1\":{\"8\":1}}],[\"而且每次都要重复发送\",{\"1\":{\"34\":1}}],[\"而且也可以完成对双方初始序号值得确认\",{\"1\":{\"13\":1}}],[\"为的就是实现不可重入的特性去反应线程现在的执行状态\",{\"1\":{\"714\":1}}],[\"为空\",{\"1\":{\"652\":1}}],[\"为1\",{\"1\":{\"603\":1}}],[\"为2的幂次方\",{\"1\":{\"555\":1}}],[\"为第二步\",{\"1\":{\"555\":1,\"579\":1}}],[\"为第一步\",{\"1\":{\"555\":2,\"579\":2}}],[\"为帮助大家高效复习\",{\"1\":{\"545\":1}}],[\"为例\",{\"1\":{\"507\":1,\"555\":1}}],[\"为例子来说明为什么要有\",{\"1\":{\"478\":1}}],[\"为每个原始类型提供了包装类型\",{\"1\":{\"493\":1}}],[\"为每一个基本数据类型都引入了对应的包装类型\",{\"1\":{\"493\":1}}],[\"为每张表选择合适的存储引擎非常重要\",{\"1\":{\"109\":1}}],[\"为对应的引用\",{\"1\":{\"474\":1}}],[\"为将要过期但未释放的锁增加有效时间\",{\"1\":{\"435\":1}}],[\"为获取锁的线程增加守护线程\",{\"1\":{\"435\":1}}],[\"为避免出现此种情况\",{\"1\":{\"383\":1}}],[\"为此引入zk增加维护成本还强依赖另一个中间件了\",{\"1\":{\"374\":1}}],[\"为单位进行归纳\",{\"1\":{\"322\":1}}],[\"为这个方法生成一个对应的处理器对象\",{\"1\":{\"292\":1}}],[\"为false则正常进行权限检测\",{\"1\":{\"203\":1}}],[\"为true则表示对象应该允许访问\",{\"1\":{\"203\":1}}],[\"为executor的default实现类\",{\"1\":{\"197\":1}}],[\"为\",{\"0\":{\"588\":1},\"1\":{\"112\":1,\"201\":2,\"291\":1,\"511\":1,\"548\":1,\"559\":1,\"560\":1,\"603\":3,\"648\":1,\"665\":1,\"707\":1}}],[\"为了防止多进程竞争共享资源\",{\"1\":{\"728\":1}}],[\"为了解决参数不好配\",{\"1\":{\"720\":1}}],[\"为了高效的并发运行\",{\"1\":{\"675\":1}}],[\"为了高可用一般是集群\",{\"1\":{\"250\":1}}],[\"为了能够重用redis数据\",{\"1\":{\"383\":1}}],[\"为了保证数据实时效\",{\"1\":{\"381\":1}}],[\"为了避免这点\",{\"1\":{\"324\":1}}],[\"为了避免这种情况\",{\"1\":{\"23\":1}}],[\"为了定义\",{\"1\":{\"277\":1}}],[\"为了加强性能\",{\"1\":{\"230\":1}}],[\"为了方便查找书中的内容\",{\"1\":{\"146\":1}}],[\"为了方便记忆\",{\"1\":{\"29\":1}}],[\"为了有好的查询效率\",{\"1\":{\"135\":1}}],[\"为了预防网络发生拥塞\",{\"1\":{\"24\":1}}],[\"为什么重量级锁开销大\",{\"1\":{\"661\":1}}],[\"为什么重写\",{\"0\":{\"480\":1}}],[\"为什么我们不能直接调用run\",{\"0\":{\"641\":1}}],[\"为什么我们不能直接调用\",{\"0\":{\"635\":1,\"703\":1}}],[\"为什么我们调用start\",{\"0\":{\"641\":1}}],[\"为什么我们调用\",{\"0\":{\"635\":1,\"703\":1}}],[\"为什么concurrenthashmap\",{\"1\":{\"590\":1}}],[\"为什么线程不安全\",{\"1\":{\"563\":1,\"583\":1}}],[\"为什么是\",{\"0\":{\"578\":1},\"1\":{\"554\":1}}],[\"为什么链表改为红黑树的阈值是\",{\"1\":{\"553\":1}}],[\"为什么在解决\",{\"0\":{\"577\":1},\"1\":{\"553\":1}}],[\"为什么也不能为\",{\"1\":{\"548\":1}}],[\"为什么不能为\",{\"1\":{\"548\":1,\"588\":1}}],[\"为什么不对表中的每一个列创建一个索引呢\",{\"0\":{\"86\":1}}],[\"为什么serialversionuid会被序列化\",{\"1\":{\"528\":1}}],[\"为什么类型\",{\"1\":{\"511\":1}}],[\"为什么还要显示指定serialversionuid的值\",{\"0\":{\"525\":1},\"1\":{\"484\":1}}],[\"为什么引入反射概念\",{\"0\":{\"506\":1},\"1\":{\"484\":1}}],[\"为什么说java中只有值传递\",{\"0\":{\"474\":1}}],[\"为什么说mybatis是半自动orm映射工具\",{\"0\":{\"174\":1}}],[\"为什么用分布式锁\",{\"0\":{\"431\":1}}],[\"为什么redis哨兵集群只有2个节点无法正常工作\",{\"0\":{\"428\":1}}],[\"为什么使用mq\",{\"0\":{\"345\":1}}],[\"为什么kafka不支持读写分离\",{\"0\":{\"342\":1}}],[\"为什么那么快\",{\"0\":{\"329\":1}}],[\"为什么官方建议使用自增长主键作为索引\",{\"0\":{\"158\":1}}],[\"为什么需要序列化与反序列化\",{\"0\":{\"519\":1},\"1\":{\"484\":1}}],[\"为什么需要注意联合索引中的顺序\",{\"0\":{\"153\":1}}],[\"为什么需要三次握手\",{\"0\":{\"12\":1}}],[\"为什么索引结构默认使用b+tree\",{\"0\":{\"150\":1}}],[\"为什么要引入偏向锁和轻量级锁\",{\"1\":{\"661\":1}}],[\"为什么要使用多线程呢\",{\"0\":{\"622\":1,\"689\":1}}],[\"为什么要\",{\"1\":{\"555\":1}}],[\"为什么要用线程池\",{\"0\":{\"668\":1}}],[\"为什么要用static关键字\",{\"0\":{\"455\":1}}],[\"为什么要用springboot\",{\"0\":{\"304\":1}}],[\"为什么要用\",{\"0\":{\"379\":1,\"380\":1}}],[\"为什么要主动拉取消息而不使用事件监听方式\",{\"0\":{\"366\":1}}],[\"为什么要做主从同步\",{\"0\":{\"130\":1}}],[\"为什么要分库分表\",{\"0\":{\"121\":1}}],[\"为什么要加锁\",{\"0\":{\"113\":1}}],[\"为什么要三次握手\",{\"0\":{\"13\":1}}],[\"为什么\",{\"0\":{\"80\":1,\"423\":1,\"586\":1,\"592\":1},\"1\":{\"547\":1,\"549\":1,\"555\":1}}],[\"为什么客户端的\",{\"0\":{\"18\":1}}],[\"为什么连接的时候是三次握手\",{\"0\":{\"17\":1}}],[\"为应用程序提供交互服务\",{\"1\":{\"8\":1}}],[\"5以后可以使用双锁检测实现单例模式\",{\"1\":{\"637\":1,\"708\":1}}],[\"5以后volatile完全避免了指令重排优化\",{\"1\":{\"637\":1,\"708\":1}}],[\"5倍\",{\"1\":{\"572\":1,\"573\":2}}],[\"57\",{\"0\":{\"436\":1}}],[\"55\",{\"0\":{\"432\":1}}],[\"54\",{\"0\":{\"431\":1}}],[\"52701171\",{\"1\":{\"483\":1}}],[\"52\",{\"0\":{\"429\":1}}],[\"5的majority=3\",{\"1\":{\"428\":1}}],[\"5k\",{\"1\":{\"348\":3}}],[\"5k+\",{\"1\":{\"348\":1}}],[\"5ms\",{\"1\":{\"347\":1}}],[\"51gjie\",{\"1\":{\"483\":1}}],[\"51\",{\"0\":{\"428\":1},\"1\":{\"237\":1}}],[\"51cto\",{\"1\":{\"70\":2}}],[\"59\",{\"0\":{\"438\":1},\"1\":{\"157\":1}}],[\"58\",{\"0\":{\"437\":1},\"1\":{\"70\":2}}],[\"50\",{\"0\":{\"427\":1},\"1\":{\"179\":1,\"348\":2,\"622\":1,\"689\":1}}],[\"50px\",{\"1\":{\"70\":1}}],[\"500提案完成后\",{\"1\":{\"327\":1}}],[\"5000\",{\"1\":{\"74\":2}}],[\"500\",{\"1\":{\"27\":1,\"71\":2,\"141\":1,\"223\":1,\"327\":1}}],[\"53888018\",{\"1\":{\"544\":1}}],[\"53\",{\"0\":{\"430\":1},\"1\":{\"69\":3,\"70\":3}}],[\"56\",{\"0\":{\"433\":1}}],[\"56处查看\",{\"1\":{\"67\":1}}],[\"568071\",{\"1\":{\"25\":1}}],[\"5ddd1f30e51d4532c42c5abe\",{\"1\":{\"16\":1}}],[\"5\",{\"0\":{\"12\":1,\"31\":1,\"77\":1,\"95\":1,\"104\":1,\"117\":1,\"133\":1,\"138\":1,\"150\":1,\"168\":1,\"176\":1,\"248\":1,\"267\":1,\"325\":1,\"355\":1,\"367\":1,\"380\":1,\"560\":1,\"573\":1,\"624\":1,\"672\":1,\"681\":1,\"691\":1,\"736\":1},\"1\":{\"32\":1,\"68\":5,\"69\":1,\"70\":2,\"71\":1,\"125\":1,\"156\":1,\"161\":1,\"162\":1,\"177\":1,\"179\":1,\"198\":1,\"272\":1,\"274\":1,\"340\":1,\"347\":1,\"381\":1,\"382\":1,\"435\":1,\"450\":1,\"489\":1,\"493\":1,\"494\":1,\"505\":2,\"509\":1,\"510\":1,\"553\":4,\"555\":2,\"564\":2,\"565\":1,\"623\":1,\"629\":1,\"690\":1,\"696\":1,\"714\":1}}],[\"在任意时刻只能被一个进程访问\",{\"1\":{\"728\":1}}],[\"在任何时刻\",{\"1\":{\"431\":1}}],[\"在发送数据时\",{\"1\":{\"726\":1}}],[\"在不颠覆原有线程池使用方式的基础之上\",{\"1\":{\"719\":1}}],[\"在不同的操作系统下\",{\"1\":{\"341\":1}}],[\"在不同方法调用间不保留任何状态\",{\"1\":{\"282\":1}}],[\"在worker类中的run方法调用了runworker方法来执行任务\",{\"1\":{\"714\":1}}],[\"在队列为空时\",{\"1\":{\"713\":1}}],[\"在每个thread里面维护了一个以开地址法实现的threadlocal\",{\"1\":{\"704\":1}}],[\"在高并发场景下\",{\"1\":{\"704\":1}}],[\"在高请求高并发下\",{\"1\":{\"432\":1}}],[\"在单线程上运行io密集型的任务会导致大量的cpu运算能力浪费在等待\",{\"1\":{\"675\":1}}],[\"在单核时代多线程主要是为了提高\",{\"1\":{\"622\":1,\"689\":1}}],[\"在自己的map里找对应的key\",{\"1\":{\"664\":1}}],[\"在全局安全点\",{\"1\":{\"662\":1}}],[\"在1和2之间\",{\"1\":{\"653\":1}}],[\"在第一次访问的时候\",{\"1\":{\"652\":1}}],[\"在锁对象的对象头里面有一个\",{\"1\":{\"652\":1}}],[\"在锁的实现上\",{\"1\":{\"546\":1,\"584\":1}}],[\"在调度线程上更加灵活\",{\"1\":{\"648\":1,\"707\":1}}],[\"在调用这些方法时就会调用子类的方法\",{\"1\":{\"465\":1}}],[\"在新建类时实现\",{\"1\":{\"638\":1}}],[\"在保护模式下不会对其他进程产生影响\",{\"1\":{\"620\":1,\"687\":1}}],[\"在保证足够的性能表现之下\",{\"1\":{\"399\":1}}],[\"在保证tcp可靠性的同时\",{\"1\":{\"22\":1}}],[\"在引入了线程的操作系统中\",{\"1\":{\"620\":1,\"687\":1}}],[\"在引入虚拟机之后\",{\"1\":{\"442\":1}}],[\"在进入队列之前\",{\"1\":{\"616\":1}}],[\"在进行反序列化时\",{\"1\":{\"524\":1}}],[\"在进行降级之前要对系统进行梳理\",{\"1\":{\"398\":1}}],[\"在进行数据传输时\",{\"1\":{\"23\":1}}],[\"在clh同步队列中的线程在自旋时会判断其前驱节点是否为首节点\",{\"1\":{\"611\":1}}],[\"在非公平锁中\",{\"1\":{\"605\":1}}],[\"在fifo队列中\",{\"1\":{\"602\":1}}],[\"在aqs中维护着一个fifo的同步队列\",{\"1\":{\"611\":1}}],[\"在aqs中维护了一个\",{\"1\":{\"602\":1}}],[\"在aqs中的锁类型有两种\",{\"1\":{\"601\":1}}],[\"在abstractstringbuilder中也是使用字符数组保存字符串\",{\"1\":{\"481\":1}}],[\"在遍历期间原集合发生的修改迭代器是不知道的\",{\"1\":{\"598\":1}}],[\"在遍历时不是直接在集合内容上访问的\",{\"1\":{\"598\":1}}],[\"在拷贝的集合上进行遍历\",{\"1\":{\"598\":1}}],[\"在用迭代器遍历一个集合对象时\",{\"1\":{\"598\":1}}],[\"在用到这个功能的时候调用他就行了\",{\"1\":{\"98\":1}}],[\"在代码\",{\"1\":{\"566\":1}}],[\"在容量超过负载因子所定义的容量之后\",{\"1\":{\"558\":1,\"581\":1}}],[\"在扩容时会保持链表元素原本的顺序\",{\"1\":{\"557\":1,\"564\":1,\"583\":1}}],[\"在与h的二进制与操作效率会非常的快\",{\"1\":{\"555\":1}}],[\"在速度\",{\"1\":{\"555\":1}}],[\"在时间和空间成本上提供了很好的折衷\",{\"1\":{\"554\":1,\"578\":1}}],[\"在数组定义好长度之后\",{\"1\":{\"554\":1,\"578\":1}}],[\"在数据结构上\",{\"1\":{\"546\":1,\"584\":1}}],[\"在数据库中就会产生多个事务同时存取同一数据的情况\",{\"1\":{\"113\":1}}],[\"在数据传输过程中\",{\"1\":{\"22\":1}}],[\"在数据发送完后\",{\"1\":{\"17\":1}}],[\"在竞争激烈的多线程环境下性能依然也非常差\",{\"1\":{\"549\":1,\"594\":1}}],[\"在竞争激烈的多线程场景中性能就会非常差\",{\"1\":{\"549\":1,\"593\":1}}],[\"在读写文件需要对内容按行处理\",{\"1\":{\"541\":1}}],[\"在程序执行到这一步的时候\",{\"1\":{\"536\":1}}],[\"在被反序列化后\",{\"1\":{\"527\":1}}],[\"在被mapperproxyfactory代理时调用\",{\"1\":{\"200\":1}}],[\"在变量声明前加上该关键字\",{\"1\":{\"527\":1}}],[\"在实际开发中\",{\"1\":{\"525\":1}}],[\"在实际应用中\",{\"1\":{\"270\":1}}],[\"在反序列化时\",{\"1\":{\"525\":1}}],[\"在编译后的\",{\"1\":{\"511\":1}}],[\"在编译时编译器并不知道类型转换是否正常\",{\"1\":{\"510\":1}}],[\"在vm初始化期间\",{\"1\":{\"499\":1}}],[\"在v2rayn导入url\",{\"1\":{\"61\":1}}],[\"在常量池中创建\",{\"1\":{\"488\":1}}],[\"在常量池中寻找与s3变量内容相同的对象\",{\"1\":{\"488\":2}}],[\"在常量池中寻找与s变量内容相同的对象\",{\"1\":{\"488\":2}}],[\"在常量池寻找是否有相同内容的对象\",{\"1\":{\"488\":4}}],[\"在网络连接和数据库连接中字符串常常作为参数\",{\"1\":{\"482\":1}}],[\"在网络模型中实现多线程\",{\"1\":{\"400\":1}}],[\"在并发场景下\",{\"1\":{\"482\":1}}],[\"在堆中开辟一块存储空间string\",{\"1\":{\"482\":1}}],[\"在多线程条件下\",{\"1\":{\"627\":1,\"694\":1}}],[\"在多线程环境下线程a修改结点的val或者新增节点的时候是对线程b可见的\",{\"1\":{\"586\":1}}],[\"在多线程环境下线程a修改节点的\",{\"1\":{\"547\":1}}],[\"在多线程的环境下\",{\"1\":{\"564\":1,\"583\":1}}],[\"在多线程的环境下有可能导致环形链表的出现\",{\"1\":{\"557\":1}}],[\"在多态中需要将子类的引用赋给父类对象\",{\"1\":{\"465\":1}}],[\"在多态中必须存在有继承关系的子类和父类\",{\"1\":{\"465\":1}}],[\"在多实例的情况下\",{\"1\":{\"380\":1}}],[\"在目前所有的版本中都是不可以的\",{\"1\":{\"450\":1}}],[\"在java线程池留有高扩展性的基础上\",{\"1\":{\"720\":1}}],[\"在java中占两个字节\",{\"1\":{\"486\":1}}],[\"在java中\",{\"1\":{\"482\":1}}],[\"在java中的一些容器中\",{\"1\":{\"480\":1}}],[\"在java中序列化可以通过实现externalizable或者serializable来实现\",{\"1\":{\"471\":1}}],[\"在java中一般是用javac命令编译源代码为字节码文件\",{\"1\":{\"445\":1}}],[\"在jit编译时\",{\"1\":{\"659\":1}}],[\"在jdbc\",{\"1\":{\"506\":1}}],[\"在jdk1\",{\"1\":{\"488\":3,\"548\":2,\"553\":3,\"575\":3,\"589\":1,\"592\":2}}],[\"在jdk8中\",{\"1\":{\"487\":1}}],[\"在jdk7中\",{\"1\":{\"487\":1}}],[\"在jdk6中\",{\"1\":{\"487\":1}}],[\"在jvm中并没有提供boolean专用的字节码指令\",{\"1\":{\"449\":1}}],[\"在响应性和\",{\"1\":{\"447\":1}}],[\"在完整描述业务情况下\",{\"1\":{\"438\":1}}],[\"在完成请求后调用\",{\"1\":{\"298\":1}}],[\"在获取锁的过程中的获取时间比锁过期时间短很多\",{\"1\":{\"437\":1}}],[\"在获取某个键时\",{\"1\":{\"386\":1}}],[\"在删除之前验证key对应的value是不是自己线程的id\",{\"1\":{\"435\":1}}],[\"在del释放锁之前加一个判断\",{\"1\":{\"435\":1}}],[\"在dao层的参数中前加\",{\"1\":{\"183\":1}}],[\"在分布式场景下\",{\"1\":{\"431\":1}}],[\"在整个系统提供一个全局\",{\"1\":{\"431\":1}}],[\"在从节点中选取一个主节点\",{\"1\":{\"425\":1}}],[\"在从服务器上向外提供读功能\",{\"1\":{\"130\":1}}],[\"在指定的时间范围内确认master的确进入了主观下线状态\",{\"1\":{\"425\":1}}],[\"在指定的时间间隔内将内存中的数据集快照写入磁盘\",{\"1\":{\"383\":1}}],[\"在缓存使用\",{\"1\":{\"414\":1}}],[\"在缓存失效后\",{\"1\":{\"394\":1,\"396\":1}}],[\"在键空间中\",{\"1\":{\"388\":2}}],[\"在过期键比较多的时候\",{\"1\":{\"386\":1}}],[\"在设置某个key\",{\"1\":{\"386\":1}}],[\"在设计\",{\"1\":{\"302\":1}}],[\"在4\",{\"1\":{\"384\":1}}],[\"在输入元素的数量或者体积非常非常大\",{\"1\":{\"382\":1}}],[\"在很多互联网公司中都使用了分布式技术\",{\"1\":{\"381\":1}}],[\"在应用不多的情况下一般使用容器自带的session复制功能就能满足\",{\"1\":{\"381\":1}}],[\"在消息进入队列之前\",{\"1\":{\"352\":1}}],[\"在消费者组中\",{\"1\":{\"326\":1}}],[\"在同一类内可见\",{\"1\":{\"451\":1}}],[\"在同一包内可见\",{\"1\":{\"451\":1}}],[\"在同一个事务中\",{\"1\":{\"118\":1}}],[\"在同等机器下\",{\"1\":{\"350\":2}}],[\"在主节点和从节点中\",{\"1\":{\"342\":1}}],[\"在主服务器上生成实时数据\",{\"1\":{\"130\":1}}],[\"在主服务器上执行写入和更新\",{\"1\":{\"130\":1}}],[\"在哪些场景下\",{\"1\":{\"340\":1}}],[\"在处理大量\",{\"1\":{\"337\":1}}],[\"在某些业务场景下\",{\"1\":{\"335\":1}}],[\"在选举某个\",{\"1\":{\"334\":1}}],[\"在宕机时刚好还有些数据没有同步到\",{\"1\":{\"334\":1}}],[\"在kafka中\",{\"0\":{\"327\":1},\"1\":{\"328\":1,\"341\":2}}],[\"在内部通过复制数据提升容错能力和高可用性\",{\"1\":{\"325\":1}}],[\"在其他机器上还存在副本\",{\"1\":{\"323\":1}}],[\"在生产中使用https\",{\"1\":{\"309\":1}}],[\"在启动的时候\",{\"1\":{\"308\":1}}],[\"在启动的时候会干这几件事情\",{\"1\":{\"308\":1}}],[\"在启动时会去依赖的\",{\"1\":{\"308\":1}}],[\"在开发web应用程序时\",{\"1\":{\"304\":1}}],[\"在于是否修改服务端的资源\",{\"1\":{\"301\":1}}],[\"在执行引擎使用此变量前\",{\"1\":{\"650\":1}}],[\"在执行过程中不允许被中断\",{\"1\":{\"644\":1}}],[\"在执行到entry<k\",{\"1\":{\"564\":1}}],[\"在执行完实际程序之后调用\",{\"1\":{\"298\":1}}],[\"在执行实际处理程序之前调用\",{\"1\":{\"298\":1}}],[\"在执行create\",{\"1\":{\"159\":1}}],[\"在类上面一般是配置这个控制器的\",{\"1\":{\"293\":1}}],[\"在上面已经讲过了\",{\"1\":{\"293\":1}}],[\"在上面的\",{\"1\":{\"292\":1}}],[\"在上个例子中\",{\"1\":{\"223\":1}}],[\"在spring中无状态的bean适合用不变模式\",{\"1\":{\"282\":1}}],[\"在sqlmapconfig\",{\"1\":{\"176\":1}}],[\"在系统启动的时候\",{\"1\":{\"266\":1}}],[\"在依赖注入中\",{\"1\":{\"265\":1}}],[\"在服务器中实现的模式为一个有效请求一个线程\",{\"1\":{\"542\":1}}],[\"在服务器中实现的模式为一个请求一个线程\",{\"1\":{\"542\":1}}],[\"在服务器中实现的模式为一个连接一个线程\",{\"1\":{\"542\":1}}],[\"在服务发现方法中使用负载均衡\",{\"1\":{\"258\":1}}],[\"在服务暴露类加入注册的功能\",{\"1\":{\"251\":1}}],[\"在服务端中用接口名指向实现类\",{\"1\":{\"223\":1}}],[\"在注册中心注册服务\",{\"1\":{\"251\":1}}],[\"在注册中心注册自己的服务与对应的地址\",{\"1\":{\"250\":1}}],[\"在注册类的哈希表中维护着值\",{\"1\":{\"200\":1}}],[\"在netty初始化类\",{\"1\":{\"245\":1}}],[\"在前面的rpc版本中\",{\"1\":{\"244\":1}}],[\"在前面实验的第\",{\"1\":{\"112\":1}}],[\"在properties文件中配置信息\",{\"1\":{\"204\":1}}],[\"在对\",{\"1\":{\"393\":1}}],[\"在对应xml文件中创建namespace\",{\"1\":{\"193\":1}}],[\"在对一条sql语句进行执行的过程中都会做很多相关的优化\",{\"1\":{\"134\":1}}],[\"在mod\",{\"1\":{\"564\":1,\"565\":1}}],[\"在mapperproxy中执行selectone\",{\"1\":{\"194\":1}}],[\"在mapperproxy中有两个调用\",{\"1\":{\"194\":1}}],[\"在mapper中如何传递多个参数\",{\"0\":{\"183\":1}}],[\"在mysql中\",{\"1\":{\"160\":1}}],[\"在插入过程中尽量减少页分裂\",{\"1\":{\"158\":1}}],[\"在插入数据的时候会重新维护各个索引树\",{\"1\":{\"85\":1}}],[\"在当前查询时所真正使用到的索引\",{\"1\":{\"157\":1}}],[\"在⼀个⼤的查询语句中每个select关键字都对应⼀个唯⼀的id\",{\"1\":{\"157\":1}}],[\"在innodb中只针对二级索引有效\",{\"1\":{\"156\":1}}],[\"在创建多列索引时\",{\"1\":{\"154\":1}}],[\"在联合索引中\",{\"1\":{\"153\":1}}],[\"在索引的叶子节点上\",{\"1\":{\"152\":1}}],[\"在索引检索的时候\",{\"1\":{\"82\":1}}],[\"在运行期线程池使用方调用此方法设置corepoolsize之后\",{\"1\":{\"721\":1}}],[\"在运行期间可能出现的异常\",{\"1\":{\"531\":1}}],[\"在运行时在内存中\",{\"1\":{\"284\":1}}],[\"在运行\",{\"1\":{\"141\":1}}],[\"在业务系统中\",{\"1\":{\"137\":1}}],[\"在阿里巴巴\",{\"1\":{\"136\":1}}],[\"在使用cachedthreadpool时\",{\"1\":{\"672\":1}}],[\"在使用notify\",{\"1\":{\"648\":1,\"707\":1}}],[\"在使用\",{\"0\":{\"491\":1},\"1\":{\"484\":1}}],[\"在使用spring框架进行开发的过程中\",{\"1\":{\"304\":1}}],[\"在使用start\",{\"1\":{\"132\":1}}],[\"在使用长连接的情况下\",{\"1\":{\"31\":1}}],[\"在复制数据时\",{\"1\":{\"129\":1}}],[\"在redis的配置文件里设置参数\",{\"1\":{\"424\":1}}],[\"在redis\",{\"1\":{\"399\":1}}],[\"在redis中\",{\"1\":{\"378\":1}}],[\"在repeatable\",{\"1\":{\"119\":1}}],[\"在read\",{\"1\":{\"119\":2}}],[\"在修改数据的时候把事务锁起来\",{\"1\":{\"116\":1}}],[\"在查询redis前先去布隆过滤器查询\",{\"1\":{\"395\":1}}],[\"在查询完数据的时候就把事务锁起来\",{\"1\":{\"116\":1}}],[\"在查找内容之前可以先在目录中查找索引位置\",{\"1\":{\"77\":1}}],[\"在关系型数据库中\",{\"1\":{\"114\":1}}],[\"在关系中能唯一标识元组的属性集称为关系模式的超键\",{\"1\":{\"93\":1}}],[\"在可重复读级别解决了幻读问题\",{\"1\":{\"110\":1}}],[\"在正常提交的情况下不会有什么问题\",{\"1\":{\"109\":1}}],[\"在重启\",{\"1\":{\"106\":1}}],[\"在操作任何数据之前\",{\"1\":{\"105\":1}}],[\"在事务开启之前\",{\"1\":{\"407\":1}}],[\"在事务\",{\"1\":{\"103\":1}}],[\"在该隔离级别\",{\"1\":{\"102\":1}}],[\"在这里\",{\"1\":{\"713\":1}}],[\"在这里我们要自定义我们的传输格式和编解码\",{\"1\":{\"244\":1}}],[\"在这种方式下\",{\"1\":{\"621\":1,\"688\":1}}],[\"在这种情况下\",{\"1\":{\"330\":1,\"606\":1,\"661\":1}}],[\"在这两种情况下\",{\"1\":{\"455\":1}}],[\"在这两大核心的功能上不断的发展\",{\"1\":{\"310\":1}}],[\"在这三个角色数据处理和传输过程中\",{\"1\":{\"331\":1}}],[\"在这一版本下\",{\"1\":{\"260\":1}}],[\"在这版本中\",{\"1\":{\"246\":1}}],[\"在这期间\",{\"1\":{\"115\":1}}],[\"在这个方法中\",{\"1\":{\"714\":1}}],[\"在这个场景中\",{\"1\":{\"346\":1}}],[\"在这个级别\",{\"1\":{\"102\":1}}],[\"在这个范围中b是无序的\",{\"1\":{\"84\":1}}],[\"在这样的情况下\",{\"1\":{\"98\":1}}],[\"在检索效率上来讲\",{\"1\":{\"95\":1}}],[\"在大多数情况下\",{\"1\":{\"656\":1}}],[\"在大多数的情况下\",{\"1\":{\"92\":1}}],[\"在大数据领域的实时计算以及日志采集被大规模使用\",{\"1\":{\"350\":1}}],[\"在大量短连接的情况下\",{\"1\":{\"21\":1}}],[\"在线程回收过程中就使用到了这种特性\",{\"1\":{\"714\":1}}],[\"在线程池执行任务的生命周期添加监控能力\",{\"1\":{\"720\":1}}],[\"在线程池空闲时\",{\"1\":{\"672\":1}}],[\"在线程池创建新的线程\",{\"1\":{\"671\":1}}],[\"在线代理域名池url\",{\"1\":{\"71\":1}}],[\"在线订阅转换后端\",{\"1\":{\"71\":1}}],[\"在本地网络打不开\",{\"1\":{\"69\":1}}],[\"在二级域名后加\",{\"1\":{\"61\":1}}],[\"在握手的第三步\",{\"1\":{\"43\":1}}],[\"在互联网项目中\",{\"1\":{\"98\":2}}],[\"在互联网公司为了可以支撑更大的流量\",{\"1\":{\"42\":1}}],[\"在互联网中的应用层协议很多\",{\"1\":{\"8\":1}}],[\"在浏览器中输入www\",{\"0\":{\"38\":1}}],[\"在现有的证书机制下\",{\"1\":{\"36\":1}}],[\"在黑客攻击\",{\"1\":{\"36\":1}}],[\"在相同网络环境中\",{\"1\":{\"36\":1}}],[\"在一定程度上解决了传统解释型语言执行效率低的问题\",{\"1\":{\"446\":1}}],[\"在一定间隔时间做一次备份\",{\"1\":{\"383\":1}}],[\"在一般情况下\",{\"1\":{\"425\":1}}],[\"在一段时间后重新写入master来保证数据不丢失\",{\"1\":{\"424\":1}}],[\"在一版本中\",{\"1\":{\"232\":1}}],[\"在一些大表中清除大量数据时在\",{\"1\":{\"108\":1}}],[\"在一个方法中如果发生异常\",{\"1\":{\"537\":1}}],[\"在一个http\",{\"1\":{\"269\":1}}],[\"在一个表中存在的另一个表的主键称此表的外键\",{\"1\":{\"93\":1}}],[\"在一个tcp连接上可以传送多个http请求和响应\",{\"1\":{\"33\":1}}],[\"在一台物理服务器上可以存在多个虚拟主机\",{\"1\":{\"33\":1}}],[\"在http1\",{\"1\":{\"33\":4}}],[\"在http\",{\"1\":{\"31\":1}}],[\"在\",{\"1\":{\"21\":1,\"76\":1,\"107\":1,\"151\":1,\"156\":1,\"265\":1,\"272\":1,\"278\":1,\"283\":1,\"294\":1,\"323\":2,\"334\":3,\"342\":1,\"400\":1,\"402\":1,\"443\":2,\"499\":2,\"515\":1,\"536\":3,\"546\":2,\"549\":2,\"555\":1,\"584\":1,\"642\":1,\"652\":1,\"661\":1,\"726\":1,\"733\":1}}],[\"在三次握手过程中\",{\"1\":{\"14\":1}}],[\"在双方两次握手即可建立连接的情况下\",{\"1\":{\"12\":1}}],[\"在通信双方中的任何一方主动关闭连接之前\",{\"1\":{\"11\":1}}],[\"yuan\",{\"1\":{\"682\":1}}],[\"yield方法可以暂停当前正在执行的线程对象\",{\"1\":{\"636\":1,\"705\":1}}],[\"yinyong\",{\"1\":{\"474\":1}}],[\"y和z\",{\"1\":{\"476\":1}}],[\"ynet\",{\"1\":{\"70\":2}}],[\"year\",{\"1\":{\"70\":2}}],[\"yonggekkk\",{\"1\":{\"69\":3}}],[\"youendless\",{\"1\":{\"618\":1}}],[\"youzu\",{\"1\":{\"70\":2}}],[\"youth\",{\"1\":{\"70\":3}}],[\"youtu\",{\"1\":{\"69\":1}}],[\"youku\",{\"1\":{\"70\":2}}],[\"youxuan\",{\"1\":{\"61\":1}}],[\"your\",{\"1\":{\"2\":2,\"4\":1,\"60\":1,\"69\":1,\"70\":1,\"71\":3,\"399\":2}}],[\"you\",{\"1\":{\"2\":1,\"3\":1,\"4\":3,\"5\":1,\"69\":1,\"70\":3,\"71\":2}}],[\"yaml配置文件\",{\"1\":{\"68\":1}}],[\"ymyuuu\",{\"1\":{\"58\":1}}],[\"yrx420909\",{\"1\":{\"25\":1}}],[\"y\",{\"1\":{\"11\":2,\"342\":2,\"476\":4}}],[\"+oldcap\",{\"1\":{\"559\":1}}],[\"++j\",{\"1\":{\"559\":1}}],[\"++size\",{\"1\":{\"556\":1}}],[\"++modcount\",{\"1\":{\"556\":1}}],[\"++bincount\",{\"1\":{\"556\":1}}],[\"++i\",{\"1\":{\"69\":1,\"70\":1}}],[\"+consumergroup\",{\"1\":{\"373\":2}}],[\"+integer\",{\"1\":{\"223\":1}}],[\"+id+\",{\"1\":{\"216\":1,\"230\":1}}],[\"+user\",{\"1\":{\"216\":1,\"223\":1}}],[\"+namespace\",{\"1\":{\"204\":1}}],[\"+stream\",{\"1\":{\"195\":1}}],[\"+=\",{\"1\":{\"69\":1,\"70\":1,\"71\":5}}],[\"+\",{\"1\":{\"11\":3,\"16\":7,\"18\":1,\"19\":1,\"69\":62,\"70\":114,\"71\":18,\"167\":1,\"196\":5,\"199\":16,\"200\":2,\"202\":2,\"204\":3,\"223\":1,\"231\":1,\"251\":8,\"258\":3,\"317\":1,\"347\":4,\"396\":1,\"426\":1,\"488\":3,\"499\":2,\"505\":2,\"521\":3,\"522\":3,\"546\":1,\"555\":1,\"559\":2,\"573\":2,\"584\":1,\"616\":1,\"617\":2,\"677\":1,\"717\":1}}],[\"确定索引位置的示例\",{\"1\":{\"559\":2}}],[\"确定要执行的流程\",{\"1\":{\"200\":1}}],[\"确定on或者using子句中是否有索引\",{\"1\":{\"139\":1}}],[\"确定应用程序是否在检索大量超过需要的数据\",{\"1\":{\"138\":1}}],[\"确实之前用的还比较多一些\",{\"1\":{\"126\":1}}],[\"确保线程互斥的访问同步代码\",{\"1\":{\"650\":1}}],[\"确保代码逻辑在锁释放之前能够执行完成\",{\"1\":{\"435\":1}}],[\"确保读请求结束\",{\"1\":{\"391\":1}}],[\"确保group\",{\"1\":{\"139\":1}}],[\"确保数据的完整性\",{\"1\":{\"36\":1}}],[\"确保数据发送到正确的客户机和服务器\",{\"1\":{\"36\":1}}],[\"确保数据及时传送\",{\"1\":{\"8\":1}}],[\"确保\",{\"1\":{\"18\":1}}],[\"确认是select\",{\"1\":{\"204\":1}}],[\"确认mysql服务器是否在分析大量不必要的数据行\",{\"1\":{\"138\":1}}],[\"确认应答\",{\"1\":{\"22\":2}}],[\"确认号\",{\"1\":{\"16\":3}}],[\"确认号为\",{\"1\":{\"11\":2,\"16\":1}}],[\"确认报文后也进入\",{\"1\":{\"12\":1}}],[\"第31行treeifybin方法部分代码\",{\"1\":{\"556\":1}}],[\"第一个就是我们上面说的\",{\"1\":{\"718\":1}}],[\"第一个select的id是1\",{\"1\":{\"157\":1}}],[\"第一级缓存失效的基础上\",{\"1\":{\"396\":1}}],[\"第一种\",{\"1\":{\"506\":1,\"596\":1}}],[\"第一种是redis宕机\",{\"1\":{\"396\":1}}],[\"第一种和第二种方案\",{\"1\":{\"389\":1}}],[\"第一是否可以考虑热点key不设置过期时间\",{\"1\":{\"394\":1}}],[\"第一步是尝试获取锁\",{\"1\":{\"617\":1}}],[\"第一步\",{\"1\":{\"132\":1}}],[\"第一范式\",{\"1\":{\"91\":1}}],[\"第一次索引一般是顺序io\",{\"1\":{\"151\":1}}],[\"第一次挥手\",{\"1\":{\"16\":1}}],[\"第一次握手\",{\"1\":{\"11\":1,\"12\":1,\"13\":1}}],[\"第四次挥手时\",{\"1\":{\"18\":1}}],[\"第四次挥手\",{\"1\":{\"16\":1}}],[\"第三个不说了\",{\"1\":{\"718\":1}}],[\"第三个包\",{\"1\":{\"14\":1}}],[\"第三种阻塞队列是delayedworkqueue\",{\"1\":{\"673\":1}}],[\"第三步\",{\"1\":{\"132\":1,\"555\":1,\"579\":1}}],[\"第三范式\",{\"1\":{\"91\":1}}],[\"第三次挥手\",{\"1\":{\"16\":1}}],[\"第三次的ack在网络中丢失\",{\"1\":{\"15\":1}}],[\"第三次握手\",{\"1\":{\"11\":1,\"12\":1,\"13\":1}}],[\"第二种阻塞队列是\",{\"1\":{\"673\":1}}],[\"第二种\",{\"1\":{\"506\":1,\"596\":1}}],[\"第二种可能就是采用了相同的过期时间\",{\"1\":{\"396\":1}}],[\"第二种方案存在的问题是\",{\"1\":{\"389\":1}}],[\"第二是否可以考虑降低打在数据库上的请求数量\",{\"1\":{\"394\":1}}],[\"第二部\",{\"1\":{\"281\":1}}],[\"第二个设置为\",{\"1\":{\"718\":1}}],[\"第二个是一个\",{\"1\":{\"510\":1}}],[\"第二个select的id是2\",{\"1\":{\"157\":1}}],[\"第二个包\",{\"1\":{\"14\":1}}],[\"第二加缓存\",{\"1\":{\"135\":1}}],[\"第二步\",{\"1\":{\"132\":1}}],[\"第二范式\",{\"1\":{\"91\":1}}],[\"第二次查询所返回的结果集跟第一个查询不相同\",{\"1\":{\"75\":1}}],[\"第二次分发到服务器\",{\"1\":{\"42\":1}}],[\"第二次请求跑到服务\",{\"1\":{\"42\":1}}],[\"第二次挥手\",{\"1\":{\"16\":1}}],[\"第二次握手\",{\"1\":{\"11\":1,\"12\":1,\"13\":1}}],[\"并提供其对应的\",{\"1\":{\"721\":1}}],[\"并使它运行\",{\"1\":{\"714\":1}}],[\"并使用这些类\",{\"1\":{\"506\":1}}],[\"并使用公钥a将其加密\",{\"1\":{\"37\":1}}],[\"并持有一个线程thread\",{\"1\":{\"714\":1}}],[\"并调用\",{\"1\":{\"732\":1}}],[\"并调用其模板方法\",{\"1\":{\"678\":1}}],[\"并调用request中的对应的方法\",{\"1\":{\"223\":1}}],[\"并开放出扩展的地方\",{\"1\":{\"677\":1}}],[\"并可以使用get\",{\"1\":{\"676\":1}}],[\"并可重用\",{\"1\":{\"173\":1,\"179\":1}}],[\"并停止处理排队的任务并返回正在等待执行的\",{\"1\":{\"630\":1,\"698\":1}}],[\"并检索计算的结果\",{\"1\":{\"621\":1,\"688\":1}}],[\"并实现\",{\"1\":{\"596\":1}}],[\"并加入到\",{\"1\":{\"585\":1}}],[\"并对null做处理\",{\"1\":{\"556\":1}}],[\"并对\",{\"1\":{\"547\":1}}],[\"并对存储的信息进行操作\",{\"1\":{\"382\":1}}],[\"并转交给\",{\"1\":{\"537\":1}}],[\"并没有将实现留给了java\",{\"1\":{\"507\":1}}],[\"并传递了\",{\"1\":{\"505\":1}}],[\"并返回\",{\"1\":{\"499\":1}}],[\"并返回resultset对象\",{\"1\":{\"201\":1}}],[\"并在常量池中保存\",{\"1\":{\"488\":2}}],[\"并在无需重新编写原来的类的情况下对这些功能进行扩展\",{\"1\":{\"464\":1}}],[\"并通知应用方\",{\"1\":{\"419\":1}}],[\"并通过\",{\"1\":{\"605\":1}}],[\"并通过java对象和\",{\"1\":{\"172\":1}}],[\"并通过隐藏的回滚指针指向\",{\"1\":{\"112\":2}}],[\"并将\",{\"1\":{\"652\":1}}],[\"并将值更新\",{\"1\":{\"617\":1}}],[\"并将值设置进去\",{\"1\":{\"506\":1}}],[\"并将单链表的头指针存放在哈希表的第i个单元中\",{\"1\":{\"576\":1}}],[\"并将elementdata的数据复制到新的内存空间\",{\"1\":{\"573\":1}}],[\"并将原有数组内容复制到新数组中去\",{\"1\":{\"573\":1}}],[\"并将原来的对象放入新的数组中\",{\"1\":{\"558\":1,\"581\":1}}],[\"并将其缓存起来\",{\"1\":{\"507\":1}}],[\"并将其他的\",{\"1\":{\"416\":1}}],[\"并将该字符串放入字符串常量池中\",{\"1\":{\"487\":1}}],[\"并将已经写入的部分数据进行回滚\",{\"1\":{\"407\":1}}],[\"并放弃执行事务\",{\"1\":{\"409\":1}}],[\"并设置其过期时间极短\",{\"1\":{\"395\":1}}],[\"并设置bean的属性\",{\"1\":{\"276\":1}}],[\"并集等一系列直接操作集合的方法\",{\"1\":{\"382\":1}}],[\"并消费消息的程序成为\",{\"1\":{\"322\":1}}],[\"并注入到\",{\"1\":{\"308\":1}}],[\"并处理相应的业务逻辑\",{\"1\":{\"290\":1}}],[\"并为系统搭建一个灵活\",{\"1\":{\"270\":1}}],[\"并与zookeeper服务端建立连接\",{\"1\":{\"251\":1}}],[\"并动态拼接sql的功能\",{\"1\":{\"184\":1}}],[\"并不直接关联\",{\"1\":{\"711\":1}}],[\"并不会在某个线程中执行它\",{\"1\":{\"635\":1,\"703\":1}}],[\"并不会有任何性能损失\",{\"1\":{\"102\":1}}],[\"并不区分是否为公平锁\",{\"1\":{\"615\":1}}],[\"并不执行故障转移\",{\"1\":{\"416\":1}}],[\"并不支持主写从读\",{\"1\":{\"342\":1}}],[\"并不是用户显式设置的\",{\"1\":{\"712\":1}}],[\"并不是说执行了t\",{\"1\":{\"623\":1,\"690\":1}}],[\"并不是完全开源的\",{\"1\":{\"447\":1}}],[\"并不是强一致性的\",{\"1\":{\"432\":1}}],[\"并不是所有的or都是使索引失效\",{\"1\":{\"168\":1}}],[\"并不是一种单独的索引类型\",{\"1\":{\"148\":1}}],[\"并进行相关处理\",{\"1\":{\"141\":1}}],[\"并进入syn\",{\"1\":{\"11\":1}}],[\"并行执行大批次任务\",{\"1\":{\"720\":1}}],[\"并行执行子任务\",{\"1\":{\"720\":1}}],[\"并行读取\",{\"1\":{\"133\":1}}],[\"并行复制\",{\"1\":{\"133\":1}}],[\"并顺序执行该日志中的sql事件\",{\"1\":{\"132\":1}}],[\"并一直持有锁\",{\"1\":{\"119\":1}}],[\"并发工具\",{\"0\":{\"736\":1},\"1\":{\"736\":2}}],[\"并发包\",{\"1\":{\"682\":1}}],[\"并发环境下\",{\"1\":{\"645\":1}}],[\"并发原语体现在\",{\"1\":{\"644\":1}}],[\"并发修改\",{\"1\":{\"598\":1}}],[\"并发局限于应用中\",{\"1\":{\"542\":1}}],[\"并发执行\",{\"1\":{\"435\":1}}],[\"并发执行的各个事务之间不能互相干扰\",{\"1\":{\"101\":1}}],[\"并发和流量等瓶颈的时候\",{\"1\":{\"417\":1}}],[\"并发送告警\",{\"1\":{\"398\":1}}],[\"并发更新数据库场景下\",{\"1\":{\"389\":1}}],[\"并发量不大的场景可以使用数据库的悲观锁\",{\"1\":{\"381\":1}}],[\"并发量高时如果每次都请求数据库操作无疑是种挑战和压力\",{\"1\":{\"381\":1}}],[\"并发能力很强\",{\"1\":{\"350\":1}}],[\"并发能力也是从大到小\",{\"1\":{\"115\":1}}],[\"并发将无从谈起\",{\"1\":{\"117\":1}}],[\"并发度默认是16\",{\"1\":{\"589\":1}}],[\"并发度大小依赖于数组的大小\",{\"1\":{\"548\":1}}],[\"并发度可以理解为程序运行时能够同时更新\",{\"1\":{\"548\":1}}],[\"并发度一般\",{\"1\":{\"114\":1}}],[\"并发度最低\",{\"1\":{\"114\":1}}],[\"并发度也最高\",{\"1\":{\"114\":1}}],[\"并发操作问题\",{\"0\":{\"75\":1}}],[\"并把下面的tls关闭\",{\"1\":{\"61\":1}}],[\"并呈现给用户\",{\"1\":{\"38\":1}}],[\"并请求锁定对方的资源\",{\"1\":{\"118\":1}}],[\"并请求\",{\"1\":{\"38\":1}}],[\"并称\",{\"1\":{\"36\":1}}],[\"并且基于当前值和原始值的比较结果采取不同的处理策略\",{\"1\":{\"721\":1}}],[\"并且提供两种队列的选择\",{\"1\":{\"720\":1}}],[\"并且提供数据持久化和备份策略\",{\"1\":{\"415\":1}}],[\"并且线程池内的阻塞队列已满\",{\"1\":{\"713\":1}}],[\"并且膨胀方向不可逆\",{\"1\":{\"655\":1}}],[\"并且会因实际情况进行膨胀升级\",{\"1\":{\"655\":1}}],[\"并且会根据\",{\"1\":{\"15\":1}}],[\"并且原语的执行必须是连续的\",{\"1\":{\"644\":1}}],[\"并且使用\",{\"1\":{\"648\":1,\"707\":1}}],[\"并且使用netty实现了客户端与服务端的通信\",{\"1\":{\"239\":1}}],[\"并且使得其他线程共享的该volatile变量无效化\",{\"1\":{\"637\":1,\"708\":1}}],[\"并且所有提交的任务完成后返回为\",{\"1\":{\"631\":1,\"699\":1}}],[\"并且当前线程获取锁成功\",{\"1\":{\"614\":1}}],[\"并且返回当前线程在等待过程中有没有中断过\",{\"1\":{\"610\":1}}],[\"并且断开原head节点的next引用即可\",{\"1\":{\"608\":1}}],[\"并且数组的容量大于\",{\"1\":{\"556\":1,\"580\":1}}],[\"并且数组容量小于\",{\"1\":{\"556\":1,\"580\":1}}],[\"并且尽量减少rehash操作的次数\",{\"1\":{\"554\":1,\"578\":1}}],[\"并且decorator\",{\"1\":{\"543\":1}}],[\"并且将\",{\"1\":{\"511\":1}}],[\"并且将自己提前曝光到singletonfactories中\",{\"1\":{\"281\":1}}],[\"并且减少了出错机会\",{\"1\":{\"510\":1}}],[\"并且类可以把自己的数据和方法只让可信的类或者对象操作\",{\"1\":{\"464\":1}}],[\"并且附带一个语句块表示这段语句最终一定被执行\",{\"1\":{\"454\":1}}],[\"并且还取消了\",{\"1\":{\"443\":1}}],[\"并且多个主保存的数据还不能一样\",{\"1\":{\"439\":1}}],[\"并且试着获取下一个redis实例\",{\"1\":{\"437\":1}}],[\"并且设置了过期时间\",{\"1\":{\"435\":1}}],[\"并且增加或减少master时redis\",{\"1\":{\"429\":1}}],[\"并且增加了顺序访问指针\",{\"1\":{\"149\":1}}],[\"并且需要让其它从库节点去复制新主库节点\",{\"1\":{\"415\":1}}],[\"并且它保证在执行事务时\",{\"1\":{\"410\":1}}],[\"并且它们共享一个ip地址\",{\"1\":{\"33\":1}}],[\"并且客户端会从事务状态中退出\",{\"1\":{\"409\":1}}],[\"并且此时队列里有更新库存的操作\",{\"1\":{\"392\":1}}],[\"并且是很小的\",{\"1\":{\"382\":1}}],[\"并且可以通过future的get\",{\"1\":{\"669\":1}}],[\"并且可以像数据库中update一个属性一样只修改某一项属性值\",{\"1\":{\"382\":1}}],[\"并且可自定义存储源\",{\"1\":{\"188\":1}}],[\"并且在需要修改的时候拿到实例修改其参数即可\",{\"1\":{\"721\":1}}],[\"并且在任意给定的时间不会有多个线程是活动的\",{\"1\":{\"672\":1}}],[\"并且在遍历过程中使用一个\",{\"1\":{\"598\":1}}],[\"并且在hashmap中如果k\",{\"1\":{\"595\":1}}],[\"并且在多实例的情况下\",{\"1\":{\"380\":1}}],[\"并且在leader副本所在的broker宕机后\",{\"1\":{\"339\":1}}],[\"并且要求被代理的类必须实现一个接口\",{\"1\":{\"284\":1}}],[\"并且该\",{\"1\":{\"272\":1}}],[\"并且该列上也必须有一定的区分度\",{\"1\":{\"85\":1}}],[\"并且把应用业务逻辑和系统服务分开\",{\"1\":{\"263\":1}}],[\"并且如果服务挂了或者换地址了\",{\"1\":{\"247\":1}}],[\"并且这个代理类的方法以或者增强\",{\"1\":{\"237\":1}}],[\"并且持有一个rpcclient对象\",{\"1\":{\"237\":1}}],[\"并且服务端终于能够提供不同服务了\",{\"1\":{\"232\":1}}],[\"并且建立与server的通信\",{\"1\":{\"223\":1}}],[\"并且与上个版本的代码进行比较差异\",{\"1\":{\"206\":1}}],[\"并且new\",{\"1\":{\"194\":1}}],[\"并且能减少数据的移动\",{\"1\":{\"158\":1}}],[\"并且hash索引将所有的哈希码存储在索引中\",{\"1\":{\"149\":1}}],[\"并且\",{\"1\":{\"117\":1,\"246\":1,\"310\":1,\"546\":1}}],[\"并且io代价高\",{\"1\":{\"80\":1,\"150\":1}}],[\"并且不支持断点续传功能\",{\"1\":{\"33\":1}}],[\"并且去掉重复序列号的数据\",{\"1\":{\"22\":1}}],[\"并重新启动\",{\"1\":{\"18\":1}}],[\"并等待客户的确认\",{\"1\":{\"14\":1}}],[\"并确认收到对方的初始序号值\",{\"1\":{\"12\":1}}],[\"并再相邻节点的链路上传送帧\",{\"1\":{\"8\":1}}],[\"xx\",{\"1\":{\"435\":1,\"499\":1}}],[\"xxx\",{\"1\":{\"251\":4}}],[\"xxxrpcclient\",{\"1\":{\"237\":1}}],[\"xxxserviceimpl>\",{\"1\":{\"229\":1}}],[\"xxxxxxxx\",{\"1\":{\"58\":1}}],[\"x版本其中一个比较大的变化是4\",{\"1\":{\"384\":1}}],[\"x中只支持replica\",{\"1\":{\"338\":1}}],[\"xml配置文件\",{\"1\":{\"506\":1}}],[\"xml或者properties\",{\"1\":{\"270\":1}}],[\"xml文件引入netty\",{\"1\":{\"237\":1}}],[\"xml文件\",{\"0\":{\"205\":1}}],[\"xml文件根元素不是mapper\",{\"1\":{\"204\":1}}],[\"xml文件中的namespace即是mapper接口的类路径\",{\"1\":{\"189\":1}}],[\"xml文件中与java代码分离\",{\"1\":{\"176\":1}}],[\"xml标签解析中已经load过properties\",{\"1\":{\"198\":1}}],[\"xmlutil\",{\"1\":{\"196\":1,\"204\":2}}],[\"xml中的init\",{\"1\":{\"281\":1}}],[\"xml中的resulttype\",{\"1\":{\"199\":1}}],[\"xml中\",{\"1\":{\"199\":1}}],[\"xml中定义的每个sql的resulttype的类型相同\",{\"1\":{\"189\":1}}],[\"xml中定义的每个sql的parametertype类型相同\",{\"1\":{\"189\":1}}],[\"xml中定义的每个sql的id相同\",{\"1\":{\"189\":1}}],[\"xml中配置数据链接池\",{\"1\":{\"176\":1}}],[\"xml映射文件中\",{\"0\":{\"185\":1}}],[\"xml\",{\"1\":{\"71\":2,\"172\":1,\"179\":2,\"204\":10,\"205\":2,\"264\":1,\"268\":3,\"277\":2,\"278\":2,\"300\":1,\"506\":6}}],[\"xhtml+xml\",{\"1\":{\"71\":2}}],[\"xueqiu\",{\"1\":{\"70\":2}}],[\"xunlei\",{\"1\":{\"70\":2}}],[\"xtls\",{\"1\":{\"69\":1,\"70\":1}}],[\"x64\",{\"1\":{\"68\":2}}],[\"xie\",{\"1\":{\"618\":1}}],[\"xingyunblog\",{\"1\":{\"544\":1}}],[\"xinhua\",{\"1\":{\"70\":1}}],[\"xinhuanet\",{\"1\":{\"70\":1}}],[\"xiaomi\",{\"1\":{\"435\":1}}],[\"xiaolincoding\",{\"1\":{\"25\":1}}],[\"ximalaya\",{\"1\":{\"70\":2}}],[\"xixik\",{\"1\":{\"65\":1}}],[\"xn\",{\"1\":{\"61\":3,\"62\":2,\"70\":3}}],[\"xyz\",{\"1\":{\"58\":1,\"71\":1}}],[\"xf\",{\"1\":{\"53\":2,\"58\":1,\"70\":1}}],[\"xss也称\",{\"1\":{\"44\":1}}],[\"x\",{\"1\":{\"11\":3,\"69\":4,\"70\":4,\"342\":1,\"476\":4}}],[\"=expectedmodcount\",{\"1\":{\"598\":1}}],[\"=3\",{\"1\":{\"564\":1}}],[\"=15时\",{\"1\":{\"555\":1}}],[\"=16\",{\"1\":{\"69\":1,\"70\":1}}],[\"=和in可以乱序\",{\"1\":{\"154\":1,\"161\":1}}],[\"=utf\",{\"1\":{\"71\":3}}],[\"=4\",{\"1\":{\"69\":1,\"70\":1}}],[\"=>\",{\"1\":{\"69\":16,\"70\":27,\"71\":8,\"382\":1}}],[\"==null\",{\"1\":{\"595\":1}}],[\"==常用于相同的基本数据类型之间的比较\",{\"1\":{\"476\":1}}],[\"=====使用自定义域名查看配置\",{\"1\":{\"69\":1}}],[\"==========================配置详解==============================\",{\"1\":{\"69\":3}}],[\"===\",{\"1\":{\"69\":9,\"70\":11,\"71\":13}}],[\"==\",{\"0\":{\"476\":1},\"1\":{\"53\":1,\"69\":3,\"70\":4,\"71\":14,\"203\":1,\"244\":1,\"251\":1,\"476\":2,\"488\":6,\"496\":1,\"497\":2,\"498\":1,\"499\":2,\"516\":1,\"555\":1,\"556\":10,\"558\":1,\"559\":6,\"565\":1,\"573\":1,\"579\":1,\"581\":1,\"612\":1,\"616\":2,\"617\":3}}],[\"=\",{\"0\":{\"164\":1},\"1\":{\"11\":5,\"16\":8,\"20\":2,\"52\":7,\"65\":4,\"69\":111,\"70\":163,\"71\":200,\"84\":9,\"117\":1,\"154\":6,\"156\":1,\"157\":2,\"161\":8,\"166\":1,\"167\":1,\"168\":2,\"193\":6,\"194\":3,\"195\":1,\"196\":5,\"197\":5,\"198\":14,\"199\":5,\"200\":13,\"201\":5,\"202\":5,\"203\":7,\"204\":28,\"205\":3,\"216\":13,\"223\":20,\"229\":3,\"230\":31,\"231\":2,\"237\":28,\"244\":29,\"245\":1,\"251\":22,\"258\":5,\"306\":1,\"313\":5,\"314\":3,\"315\":1,\"316\":7,\"317\":3,\"347\":2,\"449\":2,\"473\":1,\"481\":1,\"482\":2,\"488\":14,\"493\":2,\"494\":3,\"496\":2,\"497\":2,\"498\":1,\"499\":18,\"503\":4,\"505\":11,\"506\":30,\"507\":6,\"510\":3,\"514\":1,\"516\":4,\"521\":7,\"522\":7,\"532\":2,\"536\":8,\"543\":1,\"547\":2,\"554\":1,\"555\":9,\"556\":22,\"558\":18,\"559\":40,\"560\":3,\"564\":6,\"565\":4,\"573\":6,\"578\":1,\"579\":4,\"581\":18,\"585\":2,\"594\":5,\"607\":5,\"611\":3,\"612\":8,\"616\":4,\"617\":7,\"623\":1,\"638\":2,\"663\":1,\"684\":2,\"690\":1,\"712\":1,\"714\":3,\"717\":1}}],[\"向前移一位的操作\",{\"1\":{\"571\":1}}],[\"向上转型\",{\"1\":{\"465\":1}}],[\"向下线的\",{\"1\":{\"425\":1}}],[\"向一些队列轮流发送消息\",{\"1\":{\"362\":1}}],[\"向broker请求消费响应的队列中消息\",{\"1\":{\"358\":1}}],[\"向sql语句传参数麻烦\",{\"1\":{\"176\":1}}],[\"向服务端插入数据\",{\"1\":{\"223\":1}}],[\"向服务端的\",{\"1\":{\"38\":1}}],[\"向服务端发送一个确认报文\",{\"1\":{\"11\":1}}],[\"向服务端发送一个同步报文\",{\"1\":{\"11\":1}}],[\"向服务器提交数据\",{\"1\":{\"29\":1}}],[\"向服务器添加数据\",{\"1\":{\"29\":1}}],[\"向服务器不断地发送\",{\"1\":{\"14\":1}}],[\"向主机进程提供通用的数据传输服务\",{\"1\":{\"8\":1}}],[\"j++\",{\"1\":{\"499\":2,\"558\":1,\"581\":1}}],[\"j\",{\"1\":{\"496\":2,\"499\":5,\"558\":4,\"559\":7,\"581\":4}}],[\"jre包含jvm\",{\"1\":{\"444\":1}}],[\"jre是java\",{\"1\":{\"444\":1}}],[\"jre\",{\"1\":{\"444\":1}}],[\"jre和jdk的关系是什么\",{\"0\":{\"444\":1}}],[\"jvm对synchronized的优化有哪些\",{\"0\":{\"654\":1}}],[\"jvm执行start方法\",{\"1\":{\"641\":1}}],[\"jvm在序列化对象时会自动生成一个serialversionuid\",{\"1\":{\"528\":1}}],[\"jvm在序列化和反序列化时仍然都会生成一个serialversionuid\",{\"1\":{\"525\":1}}],[\"jvm在序列化时会根据属性自动生成一个serialversionuid\",{\"1\":{\"525\":1}}],[\"jvm会再根据属性自动生成一个新版serialversionuid\",{\"1\":{\"525\":1}}],[\"jvm会把传来的字节流中的serialversionuid与本地相应实体\",{\"1\":{\"524\":1}}],[\"jvm为每个类管理一个独一无二的class对象\",{\"1\":{\"507\":1}}],[\"jvm为了提升性能和减少内存开销\",{\"1\":{\"487\":1}}],[\"jvm又会回调\",{\"1\":{\"507\":1}}],[\"jvm\",{\"0\":{\"444\":1,\"537\":1},\"1\":{\"380\":1,\"444\":1,\"447\":1,\"449\":1,\"484\":1,\"504\":1,\"510\":1,\"516\":1,\"531\":1,\"533\":2,\"537\":7,\"639\":3,\"644\":1,\"646\":1,\"648\":6,\"651\":1,\"652\":1,\"707\":6,\"733\":1}}],[\"jms\",{\"1\":{\"362\":1}}],[\"jws\",{\"1\":{\"316\":3}}],[\"jws<claims>\",{\"1\":{\"316\":2}}],[\"jwts\",{\"1\":{\"316\":3}}],[\"jwtutils\",{\"0\":{\"316\":1},\"1\":{\"316\":2,\"317\":4}}],[\"jingmoxukong\",{\"1\":{\"311\":1}}],[\"jianshu\",{\"1\":{\"70\":2,\"144\":1}}],[\"jiangren\",{\"1\":{\"48\":1}}],[\"jta\",{\"1\":{\"263\":1}}],[\"jackson2jsonredisserializer<object>\",{\"1\":{\"314\":1}}],[\"jar\",{\"1\":{\"308\":2}}],[\"jar命令从命令行将应用程序作为独立的java应用程序运行\",{\"1\":{\"304\":1}}],[\"java并发编程实战\",{\"1\":{\"717\":1}}],[\"java并发包\",{\"1\":{\"682\":1}}],[\"java开发人员可以通过它充分利用现代服务器上的多处理器\",{\"1\":{\"706\":1}}],[\"java开发手册\",{\"1\":{\"136\":1}}],[\"java1024\",{\"1\":{\"685\":1}}],[\"java线程具有五中基本状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"java集合框架图如下\",{\"1\":{\"569\":1}}],[\"java集合类主要由两个根接口collection和map派生出来的\",{\"1\":{\"569\":1}}],[\"java的开发团队一直在对synchronized优化\",{\"1\":{\"654\":1}}],[\"java的序列化机制是通过在运行时判断类的serialversionuid来验证版本一致性的\",{\"1\":{\"524\":1}}],[\"java的io\",{\"0\":{\"539\":1},\"1\":{\"484\":1}}],[\"java内建支持\",{\"1\":{\"523\":1}}],[\"java对象序列化不仅保留一个对象的数据\",{\"1\":{\"519\":1}}],[\"java对象是保存在jvm的堆内存中的\",{\"1\":{\"518\":1}}],[\"java类里面不一定能直接调用另外的方法\",{\"1\":{\"506\":1}}],[\"java类里面解析xml或properties里面的内容\",{\"1\":{\"506\":1}}],[\"java会进行自动装箱\",{\"1\":{\"499\":1}}],[\"java会自动拆包装为int\",{\"1\":{\"497\":1}}],[\"java常见异常有哪些\",{\"0\":{\"534\":1},\"1\":{\"484\":1}}],[\"java序列化是指把java对象转换为字节序列的过程\",{\"1\":{\"518\":1}}],[\"java序列化与反序列化是什么\",{\"0\":{\"518\":1},\"1\":{\"484\":1}}],[\"java序列化写入不仅是完整的类名\",{\"1\":{\"240\":1}}],[\"java泛型的原理是什么\",{\"0\":{\"511\":1},\"1\":{\"484\":1}}],[\"java反射api有几类\",{\"0\":{\"504\":1},\"1\":{\"484\":1}}],[\"java提出了string\",{\"1\":{\"482\":1}}],[\"java多态的实现原理可看这篇文章\",{\"1\":{\"465\":1}}],[\"java实现多态有\",{\"1\":{\"465\":1}}],[\"java静态变量\",{\"0\":{\"461\":1}}],[\"java中其他多种多样变化的流均是由它们派生出来的\",{\"1\":{\"539\":1}}],[\"java中常量池的概念主要有三个\",{\"1\":{\"487\":1}}],[\"java中的线程池核心实现类是threadpoolexecutor\",{\"1\":{\"711\":1}}],[\"java中的fork\",{\"0\":{\"706\":1}}],[\"java中的大部分同步类\",{\"1\":{\"601\":1}}],[\"java中的泛型基本上都是在编译器这个层次来实现的\",{\"1\":{\"511\":1}}],[\"java中的泛型是什么\",{\"0\":{\"509\":1},\"1\":{\"484\":1}}],[\"java中的锁我们都很熟悉了\",{\"1\":{\"431\":1}}],[\"java中提供了以下四种创建对象的方式\",{\"1\":{\"471\":1}}],[\"java中static方法不能被覆盖\",{\"1\":{\"456\":1}}],[\"java中是否可以覆盖\",{\"0\":{\"456\":1}}],[\"java中\",{\"1\":{\"451\":1,\"477\":1}}],[\"java5新增的队列\",{\"1\":{\"569\":1}}],[\"java5\",{\"1\":{\"450\":1}}],[\"java虚拟机规范讲到\",{\"1\":{\"449\":1}}],[\"java有哪些数据类型\",{\"0\":{\"449\":1}}],[\"java程序无须重新编译便可在多种不同的计算机上运行\",{\"1\":{\"446\":1}}],[\"java语言规范要求equals方法具有以下特性\",{\"1\":{\"476\":1}}],[\"java语言是如何实现多态的\",{\"0\":{\"465\":1}}],[\"java语言通过字节码的方式\",{\"1\":{\"446\":1}}],[\"java语言有哪些特点\",{\"0\":{\"442\":1}}],[\"java文件从编译到运行的示例如图所示\",{\"1\":{\"445\":1}}],[\"java之所以可以\",{\"1\":{\"445\":1}}],[\"javadoc\",{\"1\":{\"444\":1}}],[\"javac\",{\"1\":{\"444\":1}}],[\"java和c++有什么关系\",{\"0\":{\"443\":1}}],[\"java概述\",{\"0\":{\"441\":1}}],[\"javascript\",{\"1\":{\"352\":1}}],[\"java项目中引入curator客户端\",{\"1\":{\"251\":1}}],[\"java自带序列化方式\",{\"1\":{\"240\":1,\"244\":1}}],[\"java基础\",{\"1\":{\"214\":1}}],[\"java原生序列化\",{\"1\":{\"242\":1}}],[\"java原生\",{\"1\":{\"212\":1}}],[\"javazhiyin\",{\"1\":{\"149\":1,\"158\":1,\"599\":1,\"637\":1,\"708\":1}}],[\"java\",{\"0\":{\"440\":1,\"471\":1,\"484\":1,\"527\":1,\"543\":1,\"749\":1},\"1\":{\"98\":1,\"201\":1,\"214\":1,\"242\":1,\"244\":1,\"264\":2,\"268\":2,\"277\":1,\"312\":1,\"350\":2,\"352\":1,\"440\":1,\"442\":7,\"443\":11,\"444\":6,\"445\":1,\"449\":3,\"450\":3,\"451\":1,\"454\":1,\"474\":2,\"483\":4,\"484\":3,\"489\":2,\"493\":4,\"499\":2,\"501\":1,\"503\":1,\"504\":3,\"506\":3,\"507\":1,\"510\":4,\"515\":1,\"521\":2,\"530\":3,\"531\":2,\"532\":1,\"534\":15,\"536\":1,\"544\":2,\"551\":1,\"558\":1,\"560\":1,\"562\":1,\"581\":1,\"598\":2,\"604\":1,\"605\":3,\"607\":1,\"629\":1,\"642\":1,\"644\":1,\"652\":1,\"675\":1,\"682\":2,\"685\":1,\"696\":1,\"723\":1,\"737\":1}}],[\"japan\",{\"1\":{\"62\":1}}],[\"joshua\",{\"1\":{\"515\":1}}],[\"job\",{\"1\":{\"70\":1}}],[\"join框架一个巨大的优势是它使用了工作窃取算法\",{\"1\":{\"706\":1}}],[\"join框架是jdk7中出现的一款高效的工具\",{\"1\":{\"706\":1}}],[\"join框架是java7提供的一个用于并行执行任务的框架\",{\"1\":{\"643\":1}}],[\"join框架是什么\",{\"0\":{\"706\":1}}],[\"join框架的定义\",{\"1\":{\"643\":1}}],[\"join框架需要理解两个点\",{\"1\":{\"643\":1}}],[\"join框架吗\",{\"0\":{\"643\":1}}],[\"join\",{\"0\":{\"733\":1},\"1\":{\"69\":2,\"70\":6,\"71\":3,\"123\":1,\"124\":1,\"623\":1,\"639\":3,\"690\":1,\"733\":1}}],[\"jdb\",{\"1\":{\"444\":1}}],[\"jdbctemplate\",{\"1\":{\"286\":1}}],[\"jdbc编程有哪些不足之处\",{\"0\":{\"176\":1}}],[\"jdbc\",{\"0\":{\"126\":1},\"1\":{\"122\":1,\"127\":1,\"172\":1,\"179\":4,\"205\":1,\"288\":1,\"502\":1,\"506\":3}}],[\"jdo抛出的\",{\"1\":{\"263\":1}}],[\"jdk允许线程池使用方通过threadpoolexecutor的实例来动态设置线程池的核心策略\",{\"1\":{\"721\":1}}],[\"jdk1\",{\"0\":{\"549\":2,\"559\":1,\"591\":1},\"1\":{\"488\":3,\"507\":1,\"509\":1,\"546\":6,\"549\":8,\"553\":1,\"554\":1,\"555\":8,\"557\":5,\"559\":5,\"563\":1,\"564\":3,\"575\":1,\"578\":1,\"579\":5,\"583\":2,\"584\":4,\"591\":2,\"637\":1,\"648\":1,\"707\":1,\"708\":1}}],[\"jdk7\",{\"1\":{\"488\":1}}],[\"jdk6\",{\"1\":{\"488\":1}}],[\"jdk包含jre\",{\"1\":{\"444\":1}}],[\"jdk是\",{\"1\":{\"444\":1}}],[\"jdk\",{\"0\":{\"447\":1},\"1\":{\"223\":1,\"284\":2,\"447\":10,\"510\":2,\"565\":1,\"566\":1,\"583\":2,\"648\":2,\"707\":2}}],[\"jd\",{\"1\":{\"70\":2}}],[\"jdssl\",{\"1\":{\"59\":1,\"61\":1,\"63\":1,\"64\":1,\"68\":2}}],[\"jpa\",{\"1\":{\"307\":2}}],[\"jpa和jdo\",{\"1\":{\"288\":1}}],[\"jp\",{\"1\":{\"57\":1,\"62\":1,\"64\":1}}],[\"jpeg\",{\"1\":{\"32\":1}}],[\"juc\",{\"0\":{\"683\":1}}],[\"justdojava\",{\"1\":{\"48\":1,\"483\":1,\"551\":1}}],[\"juejin\",{\"1\":{\"11\":1,\"16\":1,\"25\":1,\"48\":3,\"311\":1,\"374\":1,\"461\":1,\"526\":1,\"544\":5,\"567\":2,\"599\":1}}],[\"jstl\",{\"1\":{\"299\":1}}],[\"jsp\",{\"1\":{\"299\":1}}],[\"jsphttp\",{\"1\":{\"32\":1}}],[\"jsonobject\",{\"1\":{\"244\":5}}],[\"json序列化器\",{\"1\":{\"244\":1}}],[\"json序列化方式\",{\"1\":{\"244\":1}}],[\"jsonserializer\",{\"1\":{\"244\":2,\"245\":1}}],[\"json\",{\"0\":{\"297\":1},\"1\":{\"69\":3,\"70\":3,\"71\":2,\"212\":1,\"242\":1,\"244\":4,\"294\":1,\"297\":1,\"300\":1}}],[\"js\",{\"1\":{\"4\":2,\"57\":1,\"58\":1,\"60\":1,\"69\":1,\"70\":1,\"318\":1}}],[\"4点的流量\",{\"1\":{\"718\":1}}],[\"4和5的结果也是一样\",{\"1\":{\"555\":1}}],[\"4开始支持\",{\"1\":{\"542\":1}}],[\"4之前的唯一选择\",{\"1\":{\"542\":1}}],[\"4之后\",{\"1\":{\"507\":1}}],[\"4的majority=2\",{\"1\":{\"428\":1}}],[\"49\",{\"0\":{\"426\":1}}],[\"48\",{\"0\":{\"425\":1}}],[\"47\",{\"0\":{\"424\":1}}],[\"4760\",{\"1\":{\"52\":1}}],[\"46\",{\"0\":{\"423\":1}}],[\"4版本开始\",{\"1\":{\"339\":1}}],[\"45124488\",{\"1\":{\"685\":1}}],[\"45102\",{\"1\":{\"52\":2}}],[\"4535042\",{\"1\":{\"465\":1}}],[\"450\",{\"1\":{\"347\":1}}],[\"450ms\",{\"1\":{\"347\":1}}],[\"45\",{\"0\":{\"310\":1,\"422\":1}}],[\"44\",{\"0\":{\"309\":1,\"421\":1}}],[\"4432600\",{\"1\":{\"465\":1}}],[\"4430\",{\"1\":{\"71\":1}}],[\"443端口\",{\"1\":{\"61\":1}}],[\"443\",{\"1\":{\"35\":1,\"37\":1,\"58\":2,\"69\":3,\"70\":3,\"71\":1}}],[\"43\",{\"0\":{\"308\":1,\"420\":1}}],[\"43fad05dcdae3b723c53c226f8181fc5bd47223e\",{\"1\":{\"69\":1}}],[\"41\",{\"0\":{\"306\":1,\"418\":1}}],[\"4102329600000\",{\"1\":{\"71\":1}}],[\"410\",{\"1\":{\"33\":1}}],[\"4byte\",{\"1\":{\"244\":1}}],[\"4个字节\",{\"1\":{\"244\":1}}],[\"4f8\",{\"1\":{\"70\":1}}],[\"4chan\",{\"1\":{\"62\":1}}],[\"4c22\",{\"1\":{\"53\":4,\"69\":2,\"70\":3}}],[\"4小时\",{\"1\":{\"57\":3}}],[\"4kb\",{\"1\":{\"69\":1,\"70\":1}}],[\"4k\",{\"1\":{\"41\":1}}],[\"42\",{\"0\":{\"307\":1,\"419\":1},\"1\":{\"32\":1}}],[\"40\",{\"0\":{\"305\":1,\"417\":1},\"1\":{\"536\":3}}],[\"40232\",{\"1\":{\"149\":1,\"158\":1}}],[\"40241\",{\"1\":{\"144\":1}}],[\"4096\",{\"1\":{\"69\":2,\"70\":2}}],[\"404\",{\"1\":{\"27\":1,\"69\":1,\"70\":1,\"738\":1}}],[\"403\",{\"1\":{\"27\":1,\"69\":1,\"70\":1}}],[\"40000\",{\"1\":{\"251\":1}}],[\"400\",{\"1\":{\"27\":1,\"33\":1,\"71\":1}}],[\"4\",{\"0\":{\"11\":1,\"30\":1,\"76\":1,\"94\":1,\"103\":1,\"116\":1,\"132\":1,\"137\":1,\"149\":1,\"167\":1,\"175\":1,\"241\":1,\"266\":1,\"324\":1,\"354\":1,\"365\":1,\"379\":1,\"558\":1,\"572\":1,\"608\":1,\"623\":1,\"671\":1,\"680\":1,\"690\":1,\"714\":1,\"735\":1},\"1\":{\"32\":1,\"45\":1,\"69\":8,\"70\":9,\"84\":2,\"154\":1,\"155\":2,\"161\":2,\"176\":1,\"177\":1,\"179\":1,\"189\":1,\"198\":1,\"230\":1,\"237\":3,\"244\":1,\"274\":1,\"334\":1,\"340\":1,\"381\":1,\"382\":1,\"402\":1,\"420\":1,\"431\":1,\"435\":1,\"449\":2,\"451\":1,\"482\":1,\"510\":1,\"553\":1,\"555\":4,\"564\":1,\"565\":1,\"579\":1,\"623\":1,\"648\":1,\"672\":1,\"690\":1,\"707\":1,\"714\":7}}],[\"音频等多媒体通信\",{\"1\":{\"10\":1}}],[\"因而可以多配置一些线程\",{\"1\":{\"718\":1}}],[\"因而产生错误和资源浪费\",{\"1\":{\"12\":1}}],[\"因此引入了偏向锁和轻量级锁来降低没有并发竞争时的锁开销\",{\"1\":{\"661\":1}}],[\"因此重量级锁操作的开销比较大\",{\"1\":{\"661\":1}}],[\"因此程序不可能正常终止\",{\"1\":{\"625\":1,\"692\":1}}],[\"因此会根据锁类型不同\",{\"1\":{\"615\":1}}],[\"因此执行了reentrantlock中的tryacquire方法\",{\"1\":{\"615\":1}}],[\"因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素\",{\"1\":{\"576\":1}}],[\"因此需要调用\",{\"1\":{\"573\":1}}],[\"因此java集合大致也可分成list\",{\"1\":{\"569\":1}}],[\"因此新的index就会发生这样的变化\",{\"1\":{\"559\":1}}],[\"因此不能被重写\",{\"1\":{\"468\":1}}],[\"因此不推荐使用\",{\"1\":{\"454\":1}}],[\"因此不适用于数据可靠性要求高的业务\",{\"1\":{\"414\":1}}],[\"因此必须调用操作系统的多线程功能来进行多线程程序设计\",{\"1\":{\"442\":1}}],[\"因此必须首先使用name字段进行等值查询\",{\"1\":{\"153\":1}}],[\"因此采用\",{\"1\":{\"442\":1}}],[\"因此旧master再次恢复的时候\",{\"1\":{\"423\":1}}],[\"因此事件分派器会将该事件交给命令请求处理器处理\",{\"1\":{\"403\":1}}],[\"因此这部分操作通常不会是性能瓶颈\",{\"1\":{\"399\":1}}],[\"因此这种模式的文件保存的信息太多\",{\"1\":{\"89\":1}}],[\"因此支持正向\",{\"1\":{\"382\":1}}],[\"因此redis适合的场景主要局限在较小数据量的高性能操作和运算上\",{\"1\":{\"376\":1}}],[\"因此如果某个类被标记为\",{\"1\":{\"284\":1}}],[\"因此也被称为运行时增强\",{\"1\":{\"284\":1}}],[\"因此也称为编译时增强\",{\"1\":{\"284\":1}}],[\"因此一个rpc请求中\",{\"1\":{\"223\":1}}],[\"因此一共需要四次挥手\",{\"1\":{\"17\":1}}],[\"因此只传递参数不会知道调用那个方法\",{\"1\":{\"223\":1}}],[\"因此可以看出\",{\"1\":{\"615\":1}}],[\"因此可以做过滤\",{\"1\":{\"392\":1}}],[\"因此可以在同时创建多个索引\",{\"1\":{\"159\":1}}],[\"因此可以总结出\",{\"1\":{\"112\":1}}],[\"因此比\",{\"1\":{\"157\":1}}],[\"因此其内部节点相对b\",{\"1\":{\"150\":1}}],[\"因此当数据库只包含成功事务提交的结果时\",{\"1\":{\"101\":1}}],[\"因此在链表节点数量大于8时\",{\"1\":{\"591\":1}}],[\"因此在链表节点数量大于\",{\"1\":{\"549\":1}}],[\"因此在网络传输过程都是request与response格式的数据了\",{\"1\":{\"223\":1}}],[\"因此在相同的查询条件下\",{\"1\":{\"157\":1}}],[\"因此在建立联合索引的时候应该注意索引列的顺序\",{\"1\":{\"153\":1}}],[\"因此在使用中\",{\"1\":{\"95\":1}}],[\"因此在保存的时候需要保存相关的信息\",{\"1\":{\"89\":1}}],[\"因此数据库依据联合索引最左的字段来构建b+树\",{\"1\":{\"84\":1}}],[\"因此\",{\"1\":{\"33\":1,\"268\":1,\"326\":1,\"339\":1,\"340\":1,\"349\":1,\"399\":1,\"410\":1,\"442\":1,\"445\":1,\"446\":1,\"447\":1,\"553\":2,\"557\":1,\"564\":1,\"575\":1,\"577\":1,\"583\":1,\"598\":1,\"665\":1}}],[\"因此经常用于\",{\"1\":{\"10\":2}}],[\"因为使用命名管道的前提\",{\"1\":{\"731\":1}}],[\"因为使用基本类型时会编译出错\",{\"1\":{\"493\":1}}],[\"因为可以在任何时候发送信号给某一进程\",{\"1\":{\"729\":1}}],[\"因为可能会存在多个线程同时进行释放同步状态资源\",{\"1\":{\"613\":1}}],[\"因为可能已经获取了小于3个锁\",{\"1\":{\"437\":1}}],[\"因为可能我们索引的字段非常长\",{\"1\":{\"155\":1}}],[\"因为进程写入数据到内核中的消息队列时\",{\"1\":{\"726\":1}}],[\"因为reentrantreadwritelock也就是读写锁允许多个线程同时对某一资源进行读\",{\"1\":{\"680\":1}}],[\"因为redis单机的读qps在万级\",{\"1\":{\"439\":1}}],[\"因为并不会触发生成多于核心线程数的线程\",{\"1\":{\"673\":1}}],[\"因为object锁是私有变量\",{\"1\":{\"659\":1}}],[\"因为设计者就没按公平锁来设计\",{\"1\":{\"653\":1}}],[\"因为jvm中\",{\"1\":{\"649\":1}}],[\"因为访问静态\",{\"1\":{\"649\":1}}],[\"因为该方法通常容易导致死锁\",{\"1\":{\"640\":1}}],[\"因为该级别锁定整个范围的键\",{\"1\":{\"119\":1}}],[\"因为我们用锁本来就是想让他们互斥的\",{\"1\":{\"627\":1,\"694\":1}}],[\"因为锁被其它线程所占用\",{\"1\":{\"623\":1,\"690\":1}}],[\"因为cpu总的运算能力就那么多\",{\"1\":{\"675\":1}}],[\"因为concurrenthashmap\",{\"1\":{\"588\":1}}],[\"因为c字段是一个范围查询\",{\"1\":{\"84\":1}}],[\"因为元素个数超出threshold而导致rehash\",{\"1\":{\"566\":1,\"583\":1}}],[\"因为获取对象的时候要用到\",{\"1\":{\"560\":1,\"582\":1}}],[\"因为hashtable给整个哈希表加了一把大锁从而实现线程安全\",{\"1\":{\"592\":1}}],[\"因为hash值在与14\",{\"1\":{\"555\":1}}],[\"因为hash索引始终索引的所有列的全部内容\",{\"1\":{\"150\":1}}],[\"因为红黑树需要进行左旋\",{\"1\":{\"553\":1,\"577\":1}}],[\"因为计算机字节\",{\"1\":{\"541\":1}}],[\"因为如果存在\",{\"1\":{\"536\":1}}],[\"因为如果网络出现拥塞的话就不会收到好几个重复的确认\",{\"1\":{\"24\":1}}],[\"因为编译器硬性规定\",{\"1\":{\"535\":1}}],[\"因为序列化是针对对象而言的\",{\"1\":{\"528\":1}}],[\"因为无论对于\",{\"1\":{\"516\":1}}],[\"因为list<object>可以存储任何类型的对象包括string\",{\"1\":{\"514\":1}}],[\"因为非new生成的integer变量指向的是java常量池中的对象\",{\"1\":{\"498\":1}}],[\"因为包装类integer和基本数据类型int比较时\",{\"1\":{\"497\":1}}],[\"因为new生成的是两个对象\",{\"1\":{\"496\":1}}],[\"因为netty的传输都是异步的\",{\"1\":{\"237\":1}}],[\"因为对象时不能直接进行运算的\",{\"1\":{\"494\":1}}],[\"因为泛型在编译时会进行类型擦除\",{\"1\":{\"493\":1}}],[\"因为要存放直接后继和直接前驱以及数据\",{\"1\":{\"571\":1}}],[\"因为要自动拆箱\",{\"1\":{\"493\":1}}],[\"因为要等更多slave重新连接过来\",{\"1\":{\"420\":1}}],[\"因为字符串是不可变的\",{\"1\":{\"491\":1,\"560\":1,\"582\":1}}],[\"因为有\",{\"1\":{\"481\":1}}],[\"因为调用时不指定类型信息\",{\"1\":{\"467\":1}}],[\"因为类调用时需要实例化\",{\"1\":{\"463\":1}}],[\"因为都是类初始化的时候加载的\",{\"1\":{\"459\":1}}],[\"因为方法覆盖是基于运行时动态绑定的\",{\"1\":{\"456\":1}}],[\"因为前面调用过一次\",{\"1\":{\"454\":1}}],[\"因为各种消息都是通过一个channel去发布和监听的\",{\"1\":{\"427\":1}}],[\"因为master\",{\"1\":{\"423\":1}}],[\"因为mybatis使用jdbc来连接数据库\",{\"1\":{\"173\":1}}],[\"因为不需要我们自己再去考虑和编写线程安全的代码\",{\"1\":{\"572\":1}}],[\"因为不需要对回滚进行支持\",{\"1\":{\"411\":1}}],[\"因为不是按照索引值顺序存储的\",{\"1\":{\"150\":1}}],[\"因为程序始终运行在进程中单个线程内\",{\"1\":{\"399\":1}}],[\"因为大多数请求不会是\",{\"1\":{\"399\":1}}],[\"因为等待超时也不是每次都是\",{\"1\":{\"392\":1}}],[\"因为第一种方案存在问题是\",{\"1\":{\"389\":1}}],[\"因为配置信息缓存在内存中\",{\"1\":{\"389\":1}}],[\"因为zk节点间通过zap协议有数据共享\",{\"1\":{\"374\":1}}],[\"因为高峰期过了之后\",{\"1\":{\"348\":1}}],[\"因为主写从读有\",{\"1\":{\"342\":1}}],[\"因为一旦有任务被提交就直接转发给线程或者创建新线程来执行\",{\"1\":{\"673\":1}}],[\"因为一旦leader所在节点异常\",{\"1\":{\"339\":1}}],[\"因为一些重量级的method的成员变量\",{\"1\":{\"507\":1}}],[\"因为一主多从架构下\",{\"1\":{\"439\":1}}],[\"因为一般的系统调用系统函数的话\",{\"1\":{\"377\":1}}],[\"因为一个节点最多只有2个子节点\",{\"1\":{\"80\":1}}],[\"因为跨域访问默认不能获取全部头部信息\",{\"1\":{\"319\":1}}],[\"因为他们能修改服务端的资源\",{\"1\":{\"301\":1}}],[\"因为处理器\",{\"1\":{\"291\":1}}],[\"因为a还没初始化完全\",{\"1\":{\"281\":1}}],[\"因为a的值是一个范围\",{\"1\":{\"84\":1}}],[\"因为自动装配不太精确\",{\"1\":{\"279\":1}}],[\"因为其它序列化方式\",{\"1\":{\"244\":1}}],[\"因为是从硬盘上读取的所以这个过程会比较慢\",{\"1\":{\"379\":1}}],[\"因为是纯内存操作\",{\"1\":{\"376\":1}}],[\"因为是服务器端\",{\"1\":{\"237\":1}}],[\"因为是全限名+方法名的保存和寻找策略\",{\"1\":{\"182\":1}}],[\"因为服务端不会只有一个服务一个方法\",{\"1\":{\"223\":1}}],[\"因为服务器的性能都很好\",{\"1\":{\"43\":1}}],[\"因为在内核中每个消息体都有一个最大长度的限制\",{\"1\":{\"726\":1}}],[\"因为在进行上述操作的时候集合中第\",{\"1\":{\"571\":1}}],[\"因为在jdk\",{\"1\":{\"555\":1}}],[\"因为在单元测试中不再需要单例或jndi查找机制\",{\"1\":{\"270\":1}}],[\"因为在sqlsessionfactory的loadmapperinfo中调用的xmlutils内已经调用过addmapper和addstatement\",{\"1\":{\"197\":1}}],[\"因为在a值确定的情况下b是相对有序的\",{\"1\":{\"84\":1}}],[\"因为sql语句的where条件不一定\",{\"1\":{\"176\":1}}],[\"因为索引需要额外的存储空间和处理\",{\"1\":{\"162\":1}}],[\"因为存在哈希碰撞问题\",{\"1\":{\"150\":1}}],[\"因为存储引擎不再需要进行全表扫描来获取数据\",{\"1\":{\"149\":1}}],[\"因为当一个表的数据量很大时\",{\"1\":{\"140\":1}}],[\"因为复制是异步进行的\",{\"1\":{\"129\":1}}],[\"因为你只要预备好\",{\"1\":{\"128\":1}}],[\"因为很容易产生热点问题\",{\"1\":{\"128\":1}}],[\"因为数据中数据已经存在了\",{\"1\":{\"432\":1}}],[\"因为数据的insert操作\",{\"1\":{\"432\":1}}],[\"因为数据已复制到从服务器\",{\"1\":{\"130\":1}}],[\"因为数据库是有缓存的\",{\"1\":{\"128\":1}}],[\"因为数据在地址栏上不可见\",{\"1\":{\"30\":1}}],[\"因为\",{\"1\":{\"126\":1,\"178\":1,\"179\":1,\"348\":1,\"515\":1,\"547\":1,\"548\":1,\"549\":1,\"559\":1,\"586\":1,\"648\":1,\"707\":1}}],[\"因为还依赖淘宝的\",{\"1\":{\"124\":1}}],[\"因为这个\",{\"1\":{\"667\":1}}],[\"因为这些变量还没有被创建出来\",{\"1\":{\"457\":1}}],[\"因为这里还应该进行优化\",{\"1\":{\"230\":1}}],[\"因为这类软件需求变化频繁\",{\"1\":{\"178\":1}}],[\"因为这类操作对数据本身并没有修改\",{\"1\":{\"108\":1}}],[\"因为这段时间客户端没有发送数据\",{\"1\":{\"16\":1}}],[\"因为隔离级别越低\",{\"1\":{\"102\":1}}],[\"因为同一事务的其他实例在该实例处理其间可能会有新的\",{\"1\":{\"102\":1}}],[\"因为它可以自动地将传入的容量转换为\",{\"1\":{\"555\":1}}],[\"因为它经过了彻底的测试和稳定\",{\"1\":{\"447\":1}}],[\"因为它只用一个\",{\"1\":{\"382\":1}}],[\"因为它是基于\",{\"1\":{\"302\":1}}],[\"因为它们使得索引\",{\"1\":{\"160\":1}}],[\"因为它的性能也不比其他级别好多少\",{\"1\":{\"102\":1}}],[\"因为它必须是它指向的那个表中的值之一\",{\"1\":{\"94\":1}}],[\"因为联合索引首先是按a排序的\",{\"1\":{\"84\":1}}],[\"因为优化器会自动调整a\",{\"1\":{\"84\":1}}],[\"因为innodb数据文件本身是一颗b+tree\",{\"1\":{\"83\":1}}],[\"因为所有辅助索引都引用主索引\",{\"1\":{\"83\":1}}],[\"因为聚集索引构成的\",{\"1\":{\"83\":1}}],[\"因为b树不管叶子节点还是非叶子节点\",{\"1\":{\"80\":1}}],[\"因为端口就65536个\",{\"1\":{\"20\":1}}],[\"因为三次握手已经可以确认双方的发送接收能力正常\",{\"1\":{\"13\":1}}],[\"因公众号开通较晚\",{\"1\":{\"7\":1}}],[\"对每种信号都规定了默认操作\",{\"1\":{\"729\":1}}],[\"对每个key计算crc16值\",{\"1\":{\"429\":1}}],[\"对每个api地址发起fetch请求\",{\"1\":{\"71\":1}}],[\"对某事物缺乏状态的观测\",{\"1\":{\"720\":1}}],[\"对同步队列的补充\",{\"1\":{\"677\":1}}],[\"对同一包内的类和所有子类可见\",{\"1\":{\"451\":1}}],[\"对同一数据的请求发送到同一个队列\",{\"1\":{\"392\":1}}],[\"对运行上下文进行扫描\",{\"1\":{\"659\":1}}],[\"对一个变量unlock操作之前\",{\"1\":{\"650\":1}}],[\"对给定对象加锁\",{\"1\":{\"649\":1}}],[\"对已获得的资源保持不放\",{\"1\":{\"626\":1,\"693\":1}}],[\"对key的hashcode\",{\"1\":{\"556\":1}}],[\"对kafka而言\",{\"1\":{\"341\":1}}],[\"对方法进行加同步锁\",{\"1\":{\"549\":1,\"594\":1}}],[\"对方发送能力和接收能力正常\",{\"1\":{\"12\":2}}],[\"对这段代码可能抛出的异常进行捕获而非向上抛出处理\",{\"1\":{\"535\":1}}],[\"对这个想弄明白的同学可以看这篇java中几种常量池的区分\",{\"1\":{\"487\":1}}],[\"对其进行捕获和处理\",{\"1\":{\"533\":1}}],[\"对内存中的对象进行持久化或网络传输\",{\"1\":{\"519\":1}}],[\"对内存不友好\",{\"1\":{\"386\":1}}],[\"对它进行任何操作\",{\"1\":{\"490\":1}}],[\"对两个对象分别调用equals方法都返回true\",{\"1\":{\"479\":1}}],[\"对称性\",{\"1\":{\"476\":1}}],[\"对不可信的进行信息隐藏\",{\"1\":{\"464\":1}}],[\"对所有类可见\",{\"1\":{\"451\":1}}],[\"对redis的数据节点做失败判定分为主观下线和客观下线两种\",{\"1\":{\"416\":1}}],[\"对cpu不友好\",{\"1\":{\"386\":1}}],[\"对cpu最不友好\",{\"1\":{\"386\":1}}],[\"对服务器的响应时间和吞吐量造成影响\",{\"1\":{\"386\":1}}],[\"对服务器数据进行更新\",{\"1\":{\"29\":1}}],[\"对集合\",{\"1\":{\"382\":1}}],[\"对比\",{\"1\":{\"380\":1}}],[\"对比如下\",{\"1\":{\"9\":1}}],[\"对用户几乎是无感知的\",{\"1\":{\"347\":1}}],[\"对延时敏感的应用而言\",{\"1\":{\"342\":1}}],[\"对各个组件的职责划分的比较清晰\",{\"1\":{\"291\":1}}],[\"对spring容器实例化的bean添加自定义的处理逻辑\",{\"1\":{\"274\":1}}],[\"对sql语句封装\",{\"1\":{\"175\":1}}],[\"对资源的共享方式吗\",{\"0\":{\"680\":1}}],[\"对资源要求较高的应用\",{\"1\":{\"266\":1}}],[\"对资源进行部分修改\",{\"1\":{\"29\":1}}],[\"对字符串去空白符和换行符等\",{\"1\":{\"204\":1,\"313\":1}}],[\"对开发人员编写\",{\"1\":{\"180\":1}}],[\"对开发人员编写sql语句的功底有一定要求\",{\"1\":{\"173\":1}}],[\"对结果集解析麻烦\",{\"1\":{\"176\":1}}],[\"对语句进行分析以及重写\",{\"1\":{\"137\":1}}],[\"对慢查询都怎么优化过\",{\"0\":{\"137\":1}}],[\"对超大分页的解决办法是类似于上面提到的第一种\",{\"1\":{\"136\":1}}],[\"对应于get\",{\"1\":{\"571\":1}}],[\"对应\",{\"1\":{\"271\":1}}],[\"对应服务层\",{\"1\":{\"271\":1}}],[\"对应持久层即\",{\"1\":{\"271\":1}}],[\"对应factory类为value\",{\"1\":{\"200\":1}}],[\"对应的线程池是\",{\"1\":{\"673\":1}}],[\"对应的哈希与高位运算结果\",{\"1\":{\"559\":1}}],[\"对应的队列集合\",{\"1\":{\"362\":1}}],[\"对应的所有队列\",{\"1\":{\"362\":1}}],[\"对应的实现类也会被作为一个处理器对象\",{\"1\":{\"292\":1}}],[\"对应的对象\",{\"1\":{\"244\":1}}],[\"对应的变量不会加上单引号\",{\"1\":{\"181\":1}}],[\"对应的变量自动加上单引号\",{\"1\":{\"181\":1}}],[\"对应的应用场景是什么\",{\"0\":{\"10\":1}}],[\"对应解释下\",{\"1\":{\"112\":1}}],[\"对数据结构做了进一步的优化\",{\"1\":{\"553\":1,\"575\":1}}],[\"对数据进行分片\",{\"1\":{\"417\":1}}],[\"对数据进行对称加密并发送给客户端\",{\"1\":{\"37\":1}}],[\"对数据库造成流量的压力\",{\"1\":{\"397\":1}}],[\"对数据完整性和一致性要求不高\",{\"1\":{\"383\":1}}],[\"对数据加上排他锁\",{\"1\":{\"115\":1}}],[\"对数据加上共享锁\",{\"1\":{\"115\":1}}],[\"对数据作了更新并提交\",{\"1\":{\"103\":1}}],[\"对单表或多表的增删改查\",{\"1\":{\"98\":1}}],[\"对该列数据的范围\",{\"1\":{\"87\":1}}],[\"对性能造成影响\",{\"1\":{\"85\":1}}],[\"对api数组进行遍历\",{\"1\":{\"71\":1}}],[\"对进入数据库的特殊字符\",{\"1\":{\"45\":1}}],[\"对于异常情况下的工作模式\",{\"1\":{\"729\":1}}],[\"对于数据的增删查改互不影响\",{\"1\":{\"727\":1}}],[\"对于内存管理\",{\"1\":{\"727\":1}}],[\"对于当前值大于原始值且当前队列中有待执行任务\",{\"1\":{\"721\":1}}],[\"对于当前值小于当前工作线程数的情况\",{\"1\":{\"721\":1}}],[\"对于获取不到锁的线程\",{\"1\":{\"677\":1}}],[\"对于子类而言它并没有太多的活要做\",{\"1\":{\"609\":1}}],[\"对于java求职者来说\",{\"1\":{\"552\":1}}],[\"对于不想进行序列化的变量\",{\"1\":{\"527\":1}}],[\"对于任意一个对象\",{\"1\":{\"501\":1}}],[\"对于任意一个类\",{\"1\":{\"501\":1}}],[\"对于任意不为null的引用值x和y\",{\"1\":{\"476\":2}}],[\"对于任意不为null的引用值x\",{\"1\":{\"476\":3}}],[\"对于两个非new生成的integer对象\",{\"1\":{\"499\":1}}],[\"对于已经存在的string对象的修改都是重新创建一个新的对象\",{\"1\":{\"481\":1}}],[\"对于hashcode方法\",{\"1\":{\"479\":1}}],[\"对于序列化机制需要明确其实现原理\",{\"1\":{\"471\":1}}],[\"对于clone机制\",{\"1\":{\"471\":1}}],[\"对于初始化后就存在的静态资源来说\",{\"1\":{\"458\":1}}],[\"对于存储相同的数据内容利用redis的数据结构降低外层键的数量\",{\"1\":{\"438\":1}}],[\"对于同一条数据\",{\"1\":{\"431\":1}}],[\"对于映射为不同slot值的key由于keys不支持跨slot查询\",{\"1\":{\"417\":1}}],[\"对于redis的从节点有对节点做主观下线操作\",{\"1\":{\"416\":1}}],[\"对于高并发的流量\",{\"1\":{\"397\":1}}],[\"对于很多用不到的key不用浪费时间进行过期检查\",{\"1\":{\"386\":1}}],[\"对于持久化机制的优化\",{\"1\":{\"384\":1}}],[\"对于求共同好友\",{\"1\":{\"382\":1}}],[\"对于典型的路由功能\",{\"1\":{\"352\":1}}],[\"对于用户而言\",{\"1\":{\"347\":1}}],[\"对于用户直接的操作\",{\"1\":{\"347\":1}}],[\"对于多线程消费我们可以预先设置\",{\"1\":{\"337\":1}}],[\"对于某个\",{\"1\":{\"337\":1}}],[\"对于如何保证消息的顺序性\",{\"1\":{\"335\":1}}],[\"对于这个问题\",{\"1\":{\"334\":1}}],[\"对于这种情况也是通过在\",{\"1\":{\"333\":1}}],[\"对于生产者数据传输导致的数据丢失主常见情况是生产者发送消息给\",{\"1\":{\"333\":1}}],[\"对于一个\",{\"1\":{\"399\":1}}],[\"对于一个消息队列\",{\"1\":{\"331\":1}}],[\"对于一个表而言\",{\"1\":{\"120\":1}}],[\"对于缓存数据更新机制\",{\"1\":{\"188\":1}}],[\"对于关系模型要求高的\",{\"1\":{\"178\":1}}],[\"对于innodb来说\",{\"1\":{\"151\":1}}],[\"对于每一行数据\",{\"1\":{\"149\":1}}],[\"对于需要经常联合查询的表\",{\"1\":{\"140\":1}}],[\"对于字段较多的表\",{\"1\":{\"140\":1}}],[\"对于查询语句\",{\"1\":{\"134\":1}}],[\"对于低性能的sql语句的定位\",{\"1\":{\"134\":1}}],[\"对于特定的事务\",{\"1\":{\"120\":1}}],[\"对于非常容易产生死锁的业务部分\",{\"1\":{\"118\":1}}],[\"对于\",{\"1\":{\"112\":1,\"336\":1,\"449\":1,\"673\":1}}],[\"对于索引\",{\"1\":{\"77\":1}}],[\"对于ddos攻击\",{\"1\":{\"43\":1}}],[\"对于服务器来说\",{\"1\":{\"21\":1}}],[\"对象可以判断任务是否执行成功\",{\"1\":{\"697\":1}}],[\"对象属性修改类型\",{\"1\":{\"683\":1}}],[\"对象头\",{\"1\":{\"662\":1}}],[\"对象之间的相互转换\",{\"1\":{\"629\":1,\"696\":1}}],[\"对象和\",{\"1\":{\"629\":1,\"696\":1}}],[\"对象进行链表遍历\",{\"1\":{\"547\":1}}],[\"对象适配器\",{\"1\":{\"543\":1}}],[\"对象型的是\",{\"1\":{\"527\":1}}],[\"对象序列化可以实现分布式对象\",{\"1\":{\"519\":1}}],[\"对象实例获取\",{\"1\":{\"505\":1}}],[\"对象实例\",{\"1\":{\"505\":1,\"543\":1}}],[\"对象名\",{\"1\":{\"503\":1}}],[\"对象转换成\",{\"1\":{\"493\":1}}],[\"对象创建之后\",{\"1\":{\"490\":1}}],[\"对象的\",{\"1\":{\"505\":1}}],[\"对象的引用地址\",{\"1\":{\"488\":2}}],[\"对象的地址\",{\"1\":{\"488\":1}}],[\"对象相等判断\",{\"0\":{\"475\":1}}],[\"对象传输到页面\",{\"1\":{\"299\":1}}],[\"对象内容进行解析成方法形参\",{\"1\":{\"299\":1}}],[\"对象们给出它们的依赖\",{\"1\":{\"263\":1}}],[\"对象赋值\",{\"1\":{\"204\":1}}],[\"对象\",{\"1\":{\"178\":1,\"244\":2,\"282\":1,\"286\":1,\"290\":1,\"291\":1,\"299\":1,\"481\":1,\"488\":7,\"490\":1,\"505\":2,\"519\":1,\"540\":2,\"543\":1,\"547\":1,\"549\":1,\"594\":1,\"617\":1}}],[\"对象关系映射\",{\"1\":{\"172\":1}}],[\"对象中的变量将不会丢失\",{\"1\":{\"39\":1}}],[\"对象存储特定用户会话所需的属性及配置信息\",{\"1\":{\"39\":1}}],[\"对\",{\"1\":{\"27\":1,\"386\":1,\"401\":1,\"546\":1}}],[\"3的majority=2\",{\"1\":{\"428\":1}}],[\"3主3从\",{\"1\":{\"417\":1}}],[\"3ms\",{\"1\":{\"347\":1}}],[\"39\",{\"0\":{\"304\":1,\"416\":1}}],[\"396982\",{\"1\":{\"52\":1}}],[\"3811437\",{\"1\":{\"469\":1}}],[\"38\",{\"0\":{\"303\":1,\"415\":1}}],[\"37\",{\"0\":{\"302\":1,\"414\":1}}],[\"36\",{\"0\":{\"301\":1,\"413\":1}}],[\"360\",{\"1\":{\"70\":2,\"125\":1}}],[\"3521565\",{\"1\":{\"562\":1}}],[\"35\",{\"0\":{\"300\":1,\"412\":1}}],[\"35em\",{\"1\":{\"71\":1}}],[\"34\",{\"0\":{\"299\":1,\"411\":1}}],[\"32g>=1t\",{\"1\":{\"439\":1}}],[\"32\",{\"0\":{\"297\":1,\"409\":1,\"666\":1},\"1\":{\"449\":2,\"555\":1,\"559\":1}}],[\"32位\",{\"1\":{\"64\":1}}],[\"33\",{\"0\":{\"298\":1,\"410\":1,\"667\":1},\"1\":{\"488\":8}}],[\"3306\",{\"1\":{\"205\":1,\"506\":1}}],[\"333\",{\"1\":{\"70\":2}}],[\"31780525\",{\"1\":{\"599\":1}}],[\"31\",{\"0\":{\"296\":1,\"408\":1,\"665\":1},\"1\":{\"71\":1}}],[\"3d2048\",{\"1\":{\"69\":2,\"70\":3}}],[\"3fed\",{\"1\":{\"69\":2,\"70\":3}}],[\"3kmfi6hp\",{\"1\":{\"70\":6}}],[\"3k大佬\",{\"1\":{\"57\":1}}],[\"3k\",{\"1\":{\"57\":1}}],[\"30326533\",{\"1\":{\"553\":1}}],[\"300\",{\"1\":{\"347\":1}}],[\"300ms\",{\"1\":{\"347\":1}}],[\"30\",{\"0\":{\"295\":1,\"407\":1,\"598\":1,\"664\":1},\"1\":{\"70\":1,\"434\":1,\"435\":4,\"536\":5}}],[\"302表示旧地址a的资源还在\",{\"1\":{\"28\":1}}],[\"302\",{\"1\":{\"27\":1,\"69\":2,\"70\":2}}],[\"301表示旧地址a的资源已经被永久地移除了\",{\"1\":{\"28\":1}}],[\"301和302状态码都表示重定向\",{\"1\":{\"28\":1}}],[\"301\",{\"1\":{\"27\":1,\"69\":2,\"70\":2}}],[\"3\",{\"0\":{\"10\":1,\"29\":1,\"75\":1,\"93\":1,\"102\":1,\"115\":1,\"128\":1,\"131\":1,\"136\":1,\"148\":1,\"166\":1,\"174\":1,\"234\":1,\"265\":1,\"323\":1,\"353\":1,\"364\":1,\"378\":1,\"556\":1,\"571\":1,\"605\":1,\"622\":1,\"670\":1,\"679\":1,\"684\":1,\"689\":1,\"713\":1,\"721\":1,\"734\":1},\"1\":{\"64\":1,\"68\":6,\"69\":9,\"70\":8,\"71\":6,\"79\":1,\"84\":3,\"103\":1,\"112\":1,\"118\":1,\"148\":1,\"154\":2,\"159\":1,\"161\":3,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"183\":1,\"189\":1,\"198\":1,\"230\":1,\"244\":1,\"251\":1,\"274\":1,\"281\":3,\"306\":1,\"340\":2,\"347\":3,\"349\":1,\"369\":1,\"381\":1,\"382\":2,\"386\":1,\"391\":1,\"396\":1,\"407\":1,\"420\":1,\"431\":1,\"432\":1,\"434\":1,\"435\":1,\"465\":2,\"481\":1,\"482\":1,\"488\":11,\"506\":1,\"553\":1,\"555\":1,\"603\":1,\"621\":1,\"623\":2,\"644\":1,\"645\":1,\"648\":1,\"672\":1,\"688\":1,\"690\":2,\"707\":1,\"711\":1,\"713\":1,\"714\":3,\"720\":2,\"721\":1,\"729\":1,\"731\":1}}],[\"应对其进行处理\",{\"1\":{\"530\":1}}],[\"应的概念\",{\"1\":{\"353\":1}}],[\"应使用显式\",{\"1\":{\"278\":1}}],[\"应该使用有界队列\",{\"1\":{\"720\":1}}],[\"应该使用同步队列\",{\"1\":{\"720\":1}}],[\"应该考虑预计的entry数在map及其负载系数\",{\"1\":{\"554\":1,\"578\":1}}],[\"应该选择更高效的序列化工具来降低字节数组大小\",{\"1\":{\"438\":1}}],[\"应该是无状态的\",{\"1\":{\"302\":1}}],[\"应该指定列为not\",{\"1\":{\"160\":1}}],[\"应该根据应用目的按需使用\",{\"1\":{\"9\":1}}],[\"应尽量约定一个相同的顺序访问各表\",{\"1\":{\"120\":1}}],[\"应用读取从节点中的\",{\"1\":{\"342\":1}}],[\"应用有哪些方法\",{\"0\":{\"309\":1}}],[\"应用的各种不同的\",{\"1\":{\"272\":1}}],[\"应用中才有意义\",{\"1\":{\"272\":1}}],[\"应用启动的时候占用资源很少\",{\"1\":{\"266\":1}}],[\"应用也要改\",{\"1\":{\"135\":1}}],[\"应用程序收到\",{\"1\":{\"38\":1}}],[\"应用层可以直接使用原生的数据结构提升性能\",{\"1\":{\"377\":1}}],[\"应用层\",{\"1\":{\"8\":1}}],[\"和通知\",{\"1\":{\"732\":1}}],[\"和软件来源\",{\"1\":{\"731\":1}}],[\"和实际业务场景有所偏离\",{\"1\":{\"718\":1}}],[\"和上一种线程池\",{\"1\":{\"673\":1}}],[\"和最终被唤醒的顺序是不一致的\",{\"1\":{\"653\":1}}],[\"和类级别的\",{\"1\":{\"646\":1}}],[\"和安全失败\",{\"0\":{\"598\":1}}],[\"和hashtable的效率哪个更高\",{\"0\":{\"592\":1}}],[\"和当前遍历的\",{\"1\":{\"585\":1}}],[\"和第\",{\"1\":{\"571\":1}}],[\"和key2\",{\"1\":{\"559\":1}}],[\"和1\",{\"1\":{\"557\":1}}],[\"和jdk1\",{\"1\":{\"553\":1,\"575\":1}}],[\"和指针\",{\"1\":{\"547\":1,\"586\":1}}],[\"和decorator\",{\"1\":{\"543\":1}}],[\"和文件内容无关时\",{\"1\":{\"541\":1}}],[\"和处理流\",{\"1\":{\"539\":1}}],[\"和输出流\",{\"1\":{\"539\":1}}],[\"和非运行时异常\",{\"1\":{\"530\":1}}],[\"和强制类型转换\",{\"1\":{\"510\":1}}],[\"和受检查异常\",{\"0\":{\"531\":1},\"1\":{\"484\":1}}],[\"和重写\",{\"0\":{\"466\":1}}],[\"和静态方法的执行顺序是什么\",{\"0\":{\"461\":1}}],[\"和工具\",{\"1\":{\"444\":1}}],[\"和值\",{\"1\":{\"438\":1}}],[\"和线程池内有效线程的数量\",{\"1\":{\"712\":1}}],[\"和线程数量\",{\"1\":{\"712\":1}}],[\"和线程\",{\"1\":{\"435\":1}}],[\"和请求\",{\"1\":{\"390\":1,\"391\":1}}],[\"和请求的流水线\",{\"1\":{\"33\":1}}],[\"和推\",{\"1\":{\"362\":1}}],[\"和追随者副本\",{\"0\":{\"339\":1}}],[\"和拦截器们\",{\"1\":{\"291\":1}}],[\"和九大组件\",{\"1\":{\"291\":1}}],[\"和$\",{\"0\":{\"181\":1}}],[\"和数据行\",{\"1\":{\"148\":1}}],[\"和分页等操作\",{\"1\":{\"123\":1}}],[\"和悲观并发控制\",{\"1\":{\"116\":1}}],[\"和页级锁\",{\"1\":{\"114\":1}}],[\"和回滚日志\",{\"1\":{\"104\":1}}],[\"和not\",{\"1\":{\"96\":1}}],[\"和表级锁\",{\"1\":{\"92\":1,\"114\":1}}],[\"和辅助索引\",{\"1\":{\"83\":1}}],[\"和用户\",{\"1\":{\"74\":1}}],[\"和轮询类似\",{\"1\":{\"46\":1}}],[\"和get方法类似\",{\"1\":{\"29\":1}}],[\"和内存资源\",{\"1\":{\"14\":1}}],[\"和\",{\"0\":{\"10\":1,\"39\":1,\"40\":1,\"95\":1,\"96\":1,\"175\":1,\"266\":1,\"294\":1,\"295\":1,\"296\":1,\"299\":1,\"310\":1,\"447\":1,\"476\":1,\"495\":1,\"530\":1,\"532\":1,\"533\":1,\"574\":1,\"595\":1,\"597\":1,\"646\":1,\"647\":1,\"648\":1},\"1\":{\"9\":1,\"20\":1,\"40\":1,\"52\":1,\"71\":1,\"74\":1,\"92\":1,\"105\":1,\"108\":1,\"114\":1,\"120\":1,\"178\":1,\"194\":1,\"268\":1,\"279\":1,\"292\":1,\"301\":2,\"310\":1,\"353\":1,\"382\":1,\"384\":1,\"399\":1,\"403\":1,\"435\":1,\"443\":4,\"444\":1,\"447\":1,\"449\":1,\"484\":4,\"488\":1,\"516\":1,\"530\":2,\"546\":2,\"549\":1,\"555\":1,\"559\":1,\"560\":1,\"565\":1,\"571\":1,\"582\":1,\"584\":1,\"601\":1,\"602\":1,\"622\":1,\"643\":1,\"648\":1,\"651\":1,\"673\":3,\"681\":2,\"684\":1,\"689\":1,\"707\":1,\"726\":1,\"727\":1,\"729\":1,\"731\":2}}],[\"最为常用\",{\"1\":{\"560\":1,\"582\":1}}],[\"最经典的就是xml的配置模式\",{\"1\":{\"506\":1}}],[\"最常用的地方就是构造器的重载\",{\"1\":{\"466\":1}}],[\"最常使用的myisam与innodb都支持表级锁定\",{\"1\":{\"114\":1}}],[\"最简单的解决办法延时双删\",{\"1\":{\"391\":1}}],[\"最近使用\",{\"1\":{\"388\":1}}],[\"最新列表\",{\"1\":{\"381\":1}}],[\"最新版本默认支持的是\",{\"1\":{\"353\":1}}],[\"最新版下载地址>>\",{\"1\":{\"60\":1}}],[\"最主要的特点是轻量以及快速\",{\"1\":{\"380\":1}}],[\"最底层\",{\"1\":{\"354\":1}}],[\"最核心的日志并未使用mmap机制\",{\"1\":{\"341\":1}}],[\"最初最核心的两大核心功能\",{\"1\":{\"310\":1}}],[\"最能考验技术水平\",{\"1\":{\"135\":1}}],[\"最重要的优化方式就是使用索引\",{\"1\":{\"134\":1}}],[\"最重要也是最有效的方法就是使用执行计划\",{\"1\":{\"134\":1}}],[\"最多支撑到并发\",{\"1\":{\"121\":1}}],[\"最好申请排他锁\",{\"1\":{\"120\":1}}],[\"最好一次性请求足够级别的锁\",{\"1\":{\"120\":1}}],[\"最终当线程获取不到任务的时候\",{\"1\":{\"711\":1}}],[\"最终汇总每个小任务结果后得到大任务结果的框架\",{\"1\":{\"643\":1}}],[\"最终才进入抛出异常的方法\",{\"1\":{\"537\":1}}],[\"最终\",{\"1\":{\"436\":1}}],[\"最终请求总延时是\",{\"1\":{\"347\":1}}],[\"最终数据没有被删掉\",{\"1\":{\"335\":1}}],[\"最终结果是数据被删除\",{\"1\":{\"335\":1}}],[\"最终成就了\",{\"1\":{\"310\":1}}],[\"最终a也完成了初始化\",{\"1\":{\"281\":1}}],[\"最终将结果集返回给客户端\",{\"1\":{\"88\":1,\"99\":1}}],[\"最终路径\",{\"1\":{\"71\":3}}],[\"最左前缀匹配原则\",{\"1\":{\"161\":1}}],[\"最左前缀原则就是最左优先\",{\"1\":{\"154\":1}}],[\"最左前缀原则的利用也可以显著提高查询效率\",{\"1\":{\"84\":1}}],[\"最左匹配原则都是针对联合索引来说的\",{\"1\":{\"84\":1}}],[\"最左匹配原则的原理\",{\"1\":{\"84\":1}}],[\"最左优先\",{\"1\":{\"84\":1}}],[\"最低级别\",{\"1\":{\"76\":1}}],[\"最后执行\",{\"1\":{\"638\":1}}],[\"最后通过hash\",{\"1\":{\"555\":1,\"579\":1}}],[\"最后只保留原始类型\",{\"1\":{\"493\":1}}],[\"最后\",{\"0\":{\"550\":1,\"561\":1},\"1\":{\"432\":1,\"507\":1}}],[\"最后又将模型数据通过\",{\"1\":{\"299\":1}}],[\"最后三个才可用\",{\"1\":{\"272\":1}}],[\"最后返回是否成功这个结果\",{\"1\":{\"714\":1}}],[\"最后返回结果\",{\"1\":{\"200\":1}}],[\"最后返回封装好的数据对象list\",{\"1\":{\"198\":1}}],[\"最后调用acquirequeued\",{\"1\":{\"605\":1}}],[\"最后调用\",{\"1\":{\"193\":1}}],[\"最后由mybatis框架执行sql并将结果映射为java对象并返回\",{\"1\":{\"172\":1}}],[\"最后一个字符存储使用了多长的空间\",{\"1\":{\"95\":1}}],[\"最后一个字段\",{\"1\":{\"71\":1}}],[\"最后一次ack包丢失\",{\"0\":{\"15\":1}}],[\"最后都清除设置的超时定时器\",{\"1\":{\"71\":1}}],[\"最基本的dos攻击过程如下\",{\"1\":{\"43\":1}}],[\"最大任务执行时间\",{\"1\":{\"720\":1}}],[\"最大核心大小\",{\"1\":{\"720\":1}}],[\"最大努力送达型事务\",{\"1\":{\"126\":1}}],[\"最大的好处是读不加锁\",{\"1\":{\"112\":1}}],[\"最大原因\",{\"1\":{\"80\":1}}],[\"最大超时时间是动态计算的\",{\"1\":{\"22\":1}}],[\"最大60字节\",{\"1\":{\"9\":1}}],[\"最长报文段寿命\",{\"1\":{\"16\":1}}],[\"最下面一层没有什么具体内容\",{\"1\":{\"8\":1}}],[\"慢查询等\",{\"1\":{\"417\":1}}],[\"慢查询的优化首先要搞明白慢的原因是什么\",{\"1\":{\"137\":1}}],[\"慢查询的统计主要由运维在做\",{\"1\":{\"137\":1}}],[\"慢死了慢死了\",{\"1\":{\"347\":1}}],[\"慢开始\",{\"1\":{\"24\":2}}],[\"慢\",{\"1\":{\"9\":1}}],[\"快恢复\",{\"1\":{\"24\":1}}],[\"快重传规定\",{\"1\":{\"24\":1}}],[\"快重传\",{\"1\":{\"24\":1}}],[\"快速失败\",{\"1\":{\"598\":1}}],[\"快速随机访问就是通过元素的序号快速获取元素对象\",{\"1\":{\"571\":1}}],[\"快速的检索出对应的\",{\"1\":{\"477\":1}}],[\"快速搭建\",{\"1\":{\"304\":1}}],[\"快速订阅访问入口\",{\"1\":{\"71\":1}}],[\"快速恢复\",{\"1\":{\"24\":1}}],[\"快速重传\",{\"1\":{\"24\":1}}],[\"快\",{\"1\":{\"9\":1}}],[\"会发生从内核态拷贝数据到用户态的过程\",{\"1\":{\"726\":1}}],[\"会发生从用户态拷贝数据到内核态的过程\",{\"1\":{\"726\":1}}],[\"会发生什么\",{\"0\":{\"15\":1}}],[\"会分成一个一个独立的数据单元\",{\"1\":{\"726\":1}}],[\"会阻塞当前线程\",{\"1\":{\"679\":1}}],[\"会带来许多的性能开销\",{\"1\":{\"661\":1}}],[\"会带来严重的锁竞争问题\",{\"1\":{\"548\":1}}],[\"会确保锁的释放\",{\"1\":{\"648\":1,\"707\":1}}],[\"会使得所有对\",{\"1\":{\"646\":1}}],[\"会使用大于等于该值的最小的2的幂指数作为实际并发度\",{\"1\":{\"548\":1,\"589\":1}}],[\"会给cpu带来非常大的执行开销\",{\"1\":{\"645\":1}}],[\"会帮助我们实现出\",{\"1\":{\"644\":1}}],[\"会另起一条线程执行thread的run方法\",{\"1\":{\"641\":1}}],[\"会启动一个线程并使线程进入了就绪状态\",{\"1\":{\"635\":1,\"703\":1}}],[\"会释放互斥锁\",{\"1\":{\"633\":1,\"701\":1}}],[\"会释放同步状态\",{\"1\":{\"611\":1}}],[\"会解除阻塞\",{\"1\":{\"633\":2,\"701\":2}}],[\"会调用到内部类sync的lock方法\",{\"1\":{\"615\":1}}],[\"会调用unparksuccessor\",{\"1\":{\"611\":1}}],[\"会调用integer类的静态方法valueof\",{\"1\":{\"499\":1}}],[\"会把\",{\"1\":{\"635\":1,\"703\":1}}],[\"会把自己设置为头结点\",{\"1\":{\"608\":1}}],[\"会把发生的异常传递给它\",{\"1\":{\"537\":1}}],[\"会唤醒后继节点\",{\"1\":{\"608\":1}}],[\"会通过tryacquire获取锁\",{\"1\":{\"606\":1}}],[\"会去判断state是否为0\",{\"1\":{\"602\":1}}],[\"会用新的v覆盖掉旧的v\",{\"1\":{\"595\":1}}],[\"会尝试获取锁\",{\"1\":{\"585\":1}}],[\"会默认在将指定的元素追加到此列表的末尾\",{\"1\":{\"571\":1}}],[\"会取大于或等于这个数的\",{\"1\":{\"555\":1}}],[\"会从无锁\",{\"1\":{\"546\":1}}],[\"会从要切换到的新master\",{\"1\":{\"427\":1}}],[\"会顺着调用栈去查找看是否有可以处理异常的代码\",{\"1\":{\"537\":1}}],[\"会执行线程的相应准备工作\",{\"1\":{\"635\":1,\"703\":1}}],[\"会执行框架aqs的后续逻辑\",{\"1\":{\"615\":1}}],[\"会执行addwaiter\",{\"1\":{\"607\":1}}],[\"会执行\",{\"1\":{\"536\":1}}],[\"会进行泛型检查\",{\"1\":{\"516\":1}}],[\"会由java代码创建出字节码组装而成的methodaccessorimpl\",{\"1\":{\"507\":1}}],[\"会由于使用频率低的字段的存在而变慢\",{\"1\":{\"140\":1}}],[\"会创建出nativemethodaccessorimpl\",{\"1\":{\"507\":1}}],[\"会直接去调methodaccessor\",{\"1\":{\"507\":1}}],[\"会直接在缓存中取出使用\",{\"1\":{\"499\":1}}],[\"会直接返回缓存的引用\",{\"1\":{\"490\":1}}],[\"会在堆中new出一个对象来存储\",{\"1\":{\"499\":1}}],[\"会在字符串常量池中进行缓存\",{\"1\":{\"490\":1}}],[\"会在响应头有加入这行代码\",{\"1\":{\"31\":1}}],[\"会造成hashcode的值不同\",{\"1\":{\"480\":1}}],[\"会造成一定的数据库压力\",{\"1\":{\"421\":1}}],[\"会先计算对象的\",{\"1\":{\"478\":1}}],[\"会对static变量进行初始化\",{\"1\":{\"457\":1}}],[\"会影响服务器的效率\",{\"1\":{\"435\":1}}],[\"会等待failover\",{\"1\":{\"427\":1}}],[\"会等待3秒\",{\"1\":{\"15\":1}}],[\"会考虑slave的一些信息\",{\"1\":{\"426\":1}}],[\"会以每\",{\"1\":{\"425\":1}}],[\"会被分成一个一个独立的消息体\",{\"1\":{\"731\":1}}],[\"会被替换为\",{\"1\":{\"511\":1}}],[\"会被作为一个slave挂到新的master上去\",{\"1\":{\"423\":1}}],[\"会被划分为多个\",{\"1\":{\"323\":1}}],[\"会产生一个\",{\"1\":{\"403\":3}}],[\"会产生不同的事件\",{\"1\":{\"403\":1}}],[\"会产生\",{\"1\":{\"403\":1}}],[\"会浪费一定的时间去移动和请求\",{\"1\":{\"377\":1}}],[\"会重传消息\",{\"1\":{\"359\":1}}],[\"会重新排序\",{\"1\":{\"9\":1}}],[\"会导致业务系统不可用\",{\"1\":{\"432\":1}}],[\"会导致短时间大量请求落在数据库上\",{\"1\":{\"395\":1}}],[\"会导致\",{\"1\":{\"356\":1}}],[\"会导致大量行的改动\",{\"1\":{\"89\":1}}],[\"会主动从\",{\"1\":{\"323\":1}}],[\"会继续提供读写服务\",{\"1\":{\"323\":1}}],[\"会继续使用这一条已经建立的连接\",{\"1\":{\"31\":1}}],[\"会负责把数据同步到所有\",{\"1\":{\"323\":1}}],[\"会选举一个\",{\"1\":{\"323\":1}}],[\"会选择使用\",{\"1\":{\"284\":1}}],[\"会返回一个哈希值\",{\"1\":{\"479\":1}}],[\"会返回一个\",{\"1\":{\"290\":1}}],[\"会根据生产者的配置丢弃或者退回给生产者\",{\"1\":{\"357\":1}}],[\"会根据逻辑\",{\"1\":{\"290\":1}}],[\"会根据\",{\"1\":{\"290\":1}}],[\"会覆盖\",{\"1\":{\"267\":1}}],[\"会立刻返回\",{\"1\":{\"237\":1}}],[\"会经过此方法增强\",{\"1\":{\"223\":1}}],[\"会有两个宏定义\",{\"1\":{\"726\":1}}],[\"会有另一个取代它\",{\"1\":{\"672\":1}}],[\"会有\",{\"1\":{\"331\":1}}],[\"会有理解的偏差与代码上的不完善\",{\"1\":{\"206\":1}}],[\"会有一个数据迁移的过程\",{\"1\":{\"128\":1}}],[\"会降低增\",{\"1\":{\"147\":1}}],[\"会定期将业务中的慢查询反馈给我们\",{\"1\":{\"137\":1}}],[\"会极大影响你的\",{\"1\":{\"121\":1}}],[\"会出现死锁\",{\"1\":{\"114\":2}}],[\"会将线程放入等待序列\",{\"1\":{\"639\":1}}],[\"会将链表转化为红黑树进行存储\",{\"1\":{\"549\":1,\"591\":1}}],[\"会将\",{\"1\":{\"488\":1}}],[\"会将该线程置为阻塞状态\",{\"1\":{\"639\":1}}],[\"会将该\",{\"1\":{\"403\":1}}],[\"会将连接应答处理器与\",{\"1\":{\"403\":1}}],[\"会将脏数据刷到缓存\",{\"1\":{\"389\":1}}],[\"会将数据写入本地磁盘\",{\"1\":{\"323\":1}}],[\"会将扫描到该注解的类\",{\"1\":{\"292\":1}}],[\"会将sql中的\",{\"1\":{\"181\":1}}],[\"会将较少的访问频率很高的字段放到一个表里去\",{\"1\":{\"128\":1}}],[\"会将原记录放入\",{\"1\":{\"112\":1}}],[\"会将此信息存入到\",{\"1\":{\"40\":1}}],[\"会自动进行管理\",{\"1\":{\"677\":1}}],[\"会自动重连的\",{\"1\":{\"422\":1}}],[\"会自动重连\",{\"1\":{\"420\":1}}],[\"会自动转移到slave\",{\"1\":{\"419\":1}}],[\"会自动提交了\",{\"1\":{\"332\":1}}],[\"会自动当成\",{\"1\":{\"272\":1}}],[\"会自动按\",{\"1\":{\"112\":1}}],[\"会自动将请求者转到新位置\",{\"1\":{\"27\":1}}],[\"会比其他两种模式大很多\",{\"1\":{\"108\":1}}],[\"会看到同样的数据行\",{\"1\":{\"102\":1}}],[\"会记录语句而不是逐行记录\",{\"1\":{\"89\":1}}],[\"会保存在额外的文件中\",{\"1\":{\"77\":1}}],[\"会话管理中使用\",{\"1\":{\"663\":1}}],[\"会话状态管理\",{\"1\":{\"39\":1}}],[\"会话层\",{\"1\":{\"8\":1}}],[\"有两个信号是应用进程无法捕捉和忽略的\",{\"1\":{\"729\":1,\"731\":1}}],[\"有两种限定通配符\",{\"1\":{\"512\":1}}],[\"有两种数据丢失的情况\",{\"1\":{\"423\":1}}],[\"有专门处理查询请求的线程池\",{\"1\":{\"718\":1}}],[\"有点像是把任务都当做\",{\"1\":{\"718\":1}}],[\"有点类似于aop\",{\"1\":{\"274\":1}}],[\"有的线程优先把自己负责的任务执行完了\",{\"1\":{\"643\":1}}],[\"有的话写入到pullrequesttable\",{\"1\":{\"367\":1}}],[\"有的话立即推送\",{\"1\":{\"367\":1}}],[\"有机会再次被cpu调用以进入到运行状态\",{\"1\":{\"623\":1,\"690\":1}}],[\"有多种锁状态\",{\"1\":{\"546\":1}}],[\"有许多不同的格式\",{\"1\":{\"519\":1}}],[\"有许多原因促成了泛型的出现\",{\"1\":{\"510\":1}}],[\"有这么两个缺点\",{\"1\":{\"510\":1}}],[\"有缓存会快很多\",{\"1\":{\"502\":1}}],[\"有更多的类和一些错误修复\",{\"1\":{\"447\":1}}],[\"有加锁就得有解锁\",{\"1\":{\"434\":1}}],[\"有加密机制\",{\"1\":{\"35\":1}}],[\"有一段这样的代码\",{\"1\":{\"605\":1}}],[\"有一定的延时\",{\"1\":{\"430\":1}}],[\"有一个user表\",{\"1\":{\"215\":1}}],[\"有效解决重排序问题\",{\"1\":{\"650\":1}}],[\"有效应对大并发量的读操作\",{\"1\":{\"415\":1}}],[\"有效期不同\",{\"1\":{\"41\":1}}],[\"有数据丢失\",{\"1\":{\"383\":1}}],[\"有五种常用数据类型\",{\"1\":{\"382\":1}}],[\"有丰富的\",{\"1\":{\"380\":1}}],[\"有\",{\"1\":{\"367\":1}}],[\"有三种模式\",{\"1\":{\"361\":1}}],[\"有三种格式\",{\"1\":{\"89\":1,\"108\":1}}],[\"有较低的概率丢失数据\",{\"1\":{\"350\":1}}],[\"有可能导致这个问题\",{\"1\":{\"566\":1,\"583\":1}}],[\"有可能还未被处理\",{\"1\":{\"337\":1}}],[\"有可能失败\",{\"1\":{\"223\":1}}],[\"有状态的bean在多线程环境下不安全\",{\"1\":{\"282\":1}}],[\"有状态对象\",{\"1\":{\"282\":1}}],[\"有状态就是有数据存储功能\",{\"1\":{\"282\":1}}],[\"有部分注入\",{\"1\":{\"267\":1}}],[\"有关系\",{\"1\":{\"251\":1}}],[\"有着与新手对同样问题的疑惑\",{\"1\":{\"206\":1}}],[\"有实现类\",{\"1\":{\"193\":1,\"194\":2}}],[\"有联合查询和嵌套查询两种方式\",{\"1\":{\"186\":1,\"187\":1}}],[\"有哪些实现方式\",{\"0\":{\"284\":1}}],[\"有哪些动态sql\",{\"0\":{\"184\":1}}],[\"有哪些优缺点\",{\"0\":{\"98\":1}}],[\"有时为了适应某些需求\",{\"1\":{\"506\":1}}],[\"有时也称为异步阻塞\",{\"1\":{\"403\":1}}],[\"有时也译为传输层\",{\"1\":{\"8\":1}}],[\"有时候会出现两个select\",{\"1\":{\"157\":1}}],[\"有了namespace\",{\"1\":{\"185\":1,\"191\":1}}],[\"有了索引下推优化\",{\"1\":{\"156\":1}}],[\"有了序列号能够将接收到的数据根据序列号排序\",{\"1\":{\"22\":1}}],[\"有用到中间件么\",{\"1\":{\"142\":1}}],[\"有大量的\",{\"1\":{\"141\":1}}],[\"有共享锁和排他锁\",{\"1\":{\"115\":1}}],[\"有些人提到在使用\",{\"1\":{\"447\":1}}],[\"有些服务在一段时间内成功率有波动\",{\"1\":{\"398\":1}}],[\"有些行业要求备份和原数据不能在同一个地方\",{\"1\":{\"130\":1}}],[\"有些事务尚未完成就被迫中断\",{\"1\":{\"101\":1}}],[\"有些资料也称为扇出\",{\"1\":{\"80\":1}}],[\"有什么用\",{\"0\":{\"704\":1}}],[\"有什么问题\",{\"1\":{\"560\":1}}],[\"有什么优缺点\",{\"0\":{\"350\":1}}],[\"有什么区别\",{\"0\":{\"95\":1,\"285\":1,\"294\":1,\"495\":1,\"574\":1,\"597\":1,\"647\":1},\"1\":{\"484\":1}}],[\"有什么好处\",{\"0\":{\"78\":1,\"491\":1},\"1\":{\"484\":1}}],[\"有tls加密\",{\"1\":{\"61\":1}}],[\"有域名\",{\"1\":{\"61\":1}}],[\"有序性\",{\"1\":{\"650\":1}}],[\"有序集合\",{\"1\":{\"378\":1}}],[\"有序\",{\"1\":{\"9\":1}}],[\"不做任何处理\",{\"1\":{\"729\":1}}],[\"不做业务逻辑处理\",{\"1\":{\"371\":1}}],[\"不像管道是无格式的字节流数据\",{\"1\":{\"726\":1}}],[\"不适合进程间频繁地交换数据\",{\"1\":{\"725\":1}}],[\"不必为了维护两者的一致\",{\"1\":{\"712\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"668\":1}}],[\"不仅备份及时\",{\"1\":{\"130\":1}}],[\"不管jvm的内存空间是否充足\",{\"1\":{\"665\":1}}],[\"不管是匿名管道还是命名管道\",{\"1\":{\"731\":1}}],[\"不管是否有线程在aqs的fifo队列中排队等待\",{\"1\":{\"616\":1}}],[\"不管是服务提供者还是\",{\"1\":{\"251\":1}}],[\"不管是哪种数据库\",{\"1\":{\"134\":1}}],[\"不让两者直接关联\",{\"1\":{\"713\":1}}],[\"不让出cpu\",{\"1\":{\"661\":1}}],[\"不让其访问数据库\",{\"1\":{\"395\":1}}],[\"不代表你就会先被唤醒\",{\"1\":{\"653\":1}}],[\"不剥夺条件\",{\"1\":{\"626\":1,\"693\":1}}],[\"不为空则需要新建一个\",{\"1\":{\"585\":1}}],[\"不直接用红黑树\",{\"0\":{\"577\":1},\"1\":{\"553\":1}}],[\"不推荐使用\",{\"1\":{\"549\":1,\"594\":1}}],[\"不应该尝试捕获这个异常\",{\"1\":{\"533\":1}}],[\"不显示指定serialversionuid的情况会导致什么问题\",{\"1\":{\"525\":1}}],[\"不安全\",{\"1\":{\"510\":1}}],[\"不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时\",{\"1\":{\"490\":1}}],[\"不变性\",{\"1\":{\"490\":1}}],[\"不允许有两个完全相同的对象\",{\"1\":{\"480\":1}}],[\"不考虑要创建多少对象或者说根本就不创建任何对象\",{\"1\":{\"455\":1}}],[\"不考虑主机b的接受能力\",{\"1\":{\"22\":1}}],[\"不提供\",{\"1\":{\"443\":1}}],[\"不提供请求\",{\"1\":{\"417\":1}}],[\"不提供数据持久化和备份策略\",{\"1\":{\"414\":1}}],[\"不保证数据的强一致性\",{\"1\":{\"417\":1}}],[\"不保证数据的可靠性\",{\"1\":{\"414\":1}}],[\"不保存表的具体行数\",{\"1\":{\"92\":1}}],[\"不负责命令处理\",{\"1\":{\"404\":1}}],[\"不去访问数据库\",{\"1\":{\"398\":1}}],[\"不去等待任何返回\",{\"1\":{\"330\":1}}],[\"不存在所得竞争关系\",{\"1\":{\"659\":1}}],[\"不存在两个线程同时竞争锁\",{\"1\":{\"657\":1}}],[\"不存在布隆过滤器中\",{\"1\":{\"395\":1}}],[\"不存在对应的序列化器\",{\"1\":{\"244\":1}}],[\"不断轮询发现可以取到值了\",{\"1\":{\"392\":1}}],[\"不想再从其他地方获取\",{\"1\":{\"384\":1}}],[\"不重复访客\",{\"1\":{\"382\":1}}],[\"不行\",{\"1\":{\"380\":1}}],[\"不在网络i\",{\"1\":{\"377\":1}}],[\"不过\",{\"1\":{\"341\":1}}],[\"不过它仅仅在基于\",{\"1\":{\"272\":1}}],[\"不过理论上\",{\"1\":{\"102\":1}}],[\"不需传host\",{\"1\":{\"251\":1}}],[\"不需要陷入内核态或者系统调用\",{\"1\":{\"731\":1}}],[\"不需要手动获取锁和释放锁\",{\"1\":{\"647\":1}}],[\"不需要手动开关连接\",{\"1\":{\"173\":1}}],[\"不需要像\",{\"1\":{\"559\":1}}],[\"不需要再次计算\",{\"1\":{\"491\":1}}],[\"不需要重新计算\",{\"1\":{\"482\":1,\"560\":1,\"582\":1}}],[\"不需要对过期的数据做额外的处理\",{\"1\":{\"386\":1}}],[\"不需要维护这个代码\",{\"1\":{\"346\":1}}],[\"不需要\",{\"1\":{\"35\":1,\"510\":1}}],[\"不删服务名\",{\"1\":{\"251\":1}}],[\"不引入log4j会有控制台会有warn\",{\"1\":{\"251\":1}}],[\"不用担心没有释放锁而导致死锁问题\",{\"1\":{\"648\":1,\"707\":1}}],[\"不用红黑树\",{\"1\":{\"553\":1}}],[\"不用每一次都要在代码里面去new或者做其他的事情\",{\"1\":{\"506\":1}}],[\"不用一直轮询\",{\"1\":{\"432\":1}}],[\"不用转化\",{\"1\":{\"244\":1}}],[\"不用来保存数据而是保存数据的索引\",{\"1\":{\"149\":1}}],[\"不够高效\",{\"1\":{\"240\":1}}],[\"不够通用\",{\"1\":{\"240\":1}}],[\"不再执行下面的代码\",{\"1\":{\"452\":1}}],[\"不再执行循环\",{\"1\":{\"452\":1}}],[\"不再需要程序员进行手动删除\",{\"1\":{\"443\":1}}],[\"不再鸡肋\",{\"1\":{\"232\":1}}],[\"不再与特定的service\",{\"1\":{\"225\":1}}],[\"不详解\",{\"1\":{\"199\":1}}],[\"不\",{\"1\":{\"179\":1}}],[\"不一定\",{\"1\":{\"152\":1}}],[\"不一致\",{\"1\":{\"103\":1}}],[\"不一致的状态\",{\"1\":{\"101\":1}}],[\"不同进程的虚拟内存映射到不同的物理内存中\",{\"1\":{\"727\":1}}],[\"不同类型的处理\",{\"1\":{\"510\":1}}],[\"不同则在链表中插入\",{\"1\":{\"479\":1}}],[\"不同步效率和rdb相同\",{\"1\":{\"383\":1}}],[\"不同步\",{\"1\":{\"383\":1}}],[\"不同配置文件中存在同名bean\",{\"1\":{\"280\":1}}],[\"不同在于其存储作用域为mapper\",{\"1\":{\"188\":1}}],[\"不同\",{\"1\":{\"178\":1,\"269\":1}}],[\"不同的自定义同步器争用共享资源的方式也不同\",{\"1\":{\"680\":1}}],[\"不同的哈希值取余之后的结果可能是相同的\",{\"1\":{\"479\":1}}],[\"不同的节点如果出现了元数据的变更之后u不断地i将元数据发送给其他节点让其他节点进行数据变更\",{\"1\":{\"430\":1}}],[\"不同的事件对应着不同的操作\",{\"1\":{\"403\":1}}],[\"不同的抽象软件结构的视角\",{\"1\":{\"283\":1}}],[\"不同的网络连接\",{\"1\":{\"237\":1}}],[\"不同的网络方式有着不同的实现\",{\"1\":{\"237\":1}}],[\"不同的service需要进行不同的封装\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"不同的xml映射文件\",{\"0\":{\"191\":1},\"1\":{\"185\":1,\"191\":1}}],[\"不同的xml映射文件id是否可以重复\",{\"0\":{\"185\":1}}],[\"不同的\",{\"1\":{\"157\":1}}],[\"不同的分库分表中间件都有什么优点和缺点\",{\"0\":{\"122\":1}}],[\"不同的程序访问一组表的时候\",{\"1\":{\"120\":1}}],[\"不同点\",{\"1\":{\"28\":1,\"175\":1,\"406\":1}}],[\"不是所有的\",{\"1\":{\"648\":1,\"707\":1}}],[\"不是\",{\"0\":{\"578\":1},\"1\":{\"489\":1,\"554\":1}}],[\"不是集中在一个地方\",{\"1\":{\"430\":1}}],[\"不是为了取代\",{\"1\":{\"310\":1}}],[\"不是beans根元素的\",{\"1\":{\"204\":1}}],[\"不是聚簇索引\",{\"1\":{\"148\":1}}],[\"不是索引键那么innodb将完成表锁\",{\"1\":{\"117\":1}}],[\"不是随着事务的提交才写入的\",{\"1\":{\"106\":1}}],[\"不会发生互斥现象\",{\"1\":{\"649\":1}}],[\"不会造成死锁\",{\"1\":{\"647\":1}}],[\"不会造成线程的阻塞\",{\"1\":{\"646\":1}}],[\"不会造成数据不一致问题\",{\"1\":{\"644\":1}}],[\"不会造成过多的压力而造成瓶颈\",{\"1\":{\"366\":1}}],[\"不会倒置\",{\"1\":{\"559\":1}}],[\"不会出现环形链表的问题\",{\"1\":{\"564\":1,\"583\":1}}],[\"不会出现类型不匹配的问题\",{\"1\":{\"511\":1}}],[\"不会出现死锁的情况\",{\"1\":{\"436\":1}}],[\"不会出现死锁\",{\"1\":{\"114\":1}}],[\"不会引发竞争\",{\"1\":{\"482\":1}}],[\"不会为即将发布的版本提供长期支持\",{\"1\":{\"447\":1}}],[\"不会在自己本地落地磁盘了\",{\"1\":{\"420\":1}}],[\"不会对事务进行中断\",{\"1\":{\"410\":1}}],[\"不会对应用程序或者数据库的现有设计造成任\",{\"1\":{\"179\":1}}],[\"不会对应用程序或者数据库的现有设计造成任何影响\",{\"1\":{\"173\":1}}],[\"不会被其他客户端发送来的命令请求所打断\",{\"1\":{\"407\":1}}],[\"不会同时读或写\",{\"1\":{\"404\":1}}],[\"不会\",{\"1\":{\"373\":1,\"528\":1}}],[\"不会超时\",{\"1\":{\"372\":1}}],[\"不会导致不可用\",{\"1\":{\"350\":1}}],[\"不会丢失数据\",{\"1\":{\"350\":1}}],[\"不会覆盖\",{\"1\":{\"267\":1}}],[\"不会由线程安全问题\",{\"1\":{\"237\":1}}],[\"不会再次进行回表查询\",{\"1\":{\"152\":1}}],[\"不会记录\",{\"1\":{\"108\":1}}],[\"不会进行解析查询语句\",{\"1\":{\"99\":1}}],[\"不支持高效的随机元素访问\",{\"1\":{\"571\":1}}],[\"不支持字符串变量\",{\"1\":{\"443\":1}}],[\"不支持缺省参数函数\",{\"1\":{\"443\":1}}],[\"不支持操作符重载\",{\"1\":{\"443\":1}}],[\"不支持多重继承\",{\"1\":{\"443\":1}}],[\"不支持多数据库空间\",{\"1\":{\"417\":1}}],[\"不支持嵌套树状复制结构\",{\"1\":{\"417\":1}}],[\"不支持基于依赖的注解\",{\"1\":{\"266\":1}}],[\"不支持国际化\",{\"1\":{\"266\":1}}],[\"不支持此xml标签解析\",{\"1\":{\"204\":1}}],[\"不支持数据库无关性\",{\"1\":{\"175\":1}}],[\"不支持范围查询\",{\"1\":{\"150\":1}}],[\"不支持全文索引\",{\"1\":{\"92\":1}}],[\"不支持\",{\"0\":{\"588\":1},\"1\":{\"92\":2,\"443\":1,\"548\":1,\"731\":1}}],[\"不使用任何修饰符\",{\"1\":{\"451\":1}}],[\"不使用平衡二叉树的原因如下\",{\"1\":{\"80\":1}}],[\"不使用流量控制和拥塞控制\",{\"1\":{\"9\":1}}],[\"不带端口号默认80\",{\"1\":{\"71\":1}}],[\"不带端口号默认443\",{\"1\":{\"71\":1}}],[\"不能相互访问\",{\"1\":{\"731\":1}}],[\"不能保证原子性\",{\"1\":{\"646\":1}}],[\"不能保存数据\",{\"1\":{\"282\":2}}],[\"不能在多线程下发生并发修改\",{\"1\":{\"598\":1}}],[\"不能依赖于这个异常是否抛出而进行并发操作的编程\",{\"1\":{\"598\":1}}],[\"不能修饰抽象类\",{\"1\":{\"470\":1}}],[\"不能修饰类和方法\",{\"1\":{\"527\":1}}],[\"不能修饰类\",{\"1\":{\"451\":2}}],[\"不能根据返回值类型来区分重载的方法\",{\"1\":{\"467\":1}}],[\"不能\",{\"1\":{\"458\":1,\"470\":1}}],[\"不能出现你加的锁\",{\"1\":{\"431\":1}}],[\"不能将一个很大的键值对象如hash\",{\"1\":{\"417\":1}}],[\"不能缓解读压力\",{\"1\":{\"417\":1}}],[\"不能解决读写分离问题\",{\"1\":{\"416\":1}}],[\"不能用作海量数据的高性能读写\",{\"1\":{\"376\":1}}],[\"不能防止sql\",{\"1\":{\"181\":1}}],[\"不能随意更换数据库\",{\"1\":{\"173\":1,\"180\":1}}],[\"不能自平衡\",{\"1\":{\"80\":1,\"150\":1}}],[\"不能被其他事务所干扰\",{\"1\":{\"74\":1}}],[\"不能被服务器所理解\",{\"1\":{\"27\":1}}],[\"不能发挥某些高性能服务器的优势\",{\"1\":{\"46\":1}}],[\"不要忘记点个赞~\",{\"1\":{\"550\":1}}],[\"不要共享可变对象的引用\",{\"1\":{\"473\":1}}],[\"不要超过自己每秒能处理的最大请求数量就\",{\"1\":{\"348\":1}}],[\"不要着急\",{\"1\":{\"345\":1}}],[\"不要新建索引\",{\"1\":{\"161\":1}}],[\"不要太大\",{\"1\":{\"121\":1}}],[\"不要使用加锁\",{\"1\":{\"120\":1}}],[\"不要申请超过实际需要的锁级别\",{\"1\":{\"120\":1}}],[\"不要直接使用原生sql\",{\"1\":{\"45\":1}}],[\"不要一开始就发送大量的数据\",{\"1\":{\"24\":1}}],[\"不可以\",{\"1\":{\"514\":1,\"515\":1}}],[\"不可变对象不能被写\",{\"1\":{\"482\":1}}],[\"不可变对象最大的好处是线程安全\",{\"1\":{\"472\":1}}],[\"不可变对象指对象一旦被创建\",{\"1\":{\"472\":1}}],[\"不可变分为引用不可变和对象不可变\",{\"1\":{\"454\":1}}],[\"不可重入\",{\"1\":{\"435\":1}}],[\"不可重复读侧重于修改\",{\"1\":{\"103\":1}}],[\"不可重复读的发生\",{\"1\":{\"76\":1}}],[\"不可重复读是指在对于数据库中的某个数据\",{\"1\":{\"75\":1}}],[\"不可重复读\",{\"0\":{\"103\":1},\"1\":{\"75\":1,\"76\":1,\"102\":1,\"103\":1}}],[\"不可能存在的key就直接返回错误提示\",{\"1\":{\"395\":1}}],[\"不可认为一种好于另一种\",{\"1\":{\"116\":1}}],[\"不可泄漏\",{\"1\":{\"37\":1}}],[\"不可靠传输\",{\"1\":{\"9\":1}}],[\"不返回报文实体主体部分\",{\"1\":{\"29\":1}}],[\"无视队列顺序直接去抢锁\",{\"1\":{\"680\":1}}],[\"无非是对于共享资源state的获取和释放\",{\"1\":{\"678\":1}}],[\"无锁\",{\"1\":{\"655\":1}}],[\"无疑这是浪费性能的\",{\"1\":{\"553\":1,\"577\":1}}],[\"无磁盘化复制\",{\"1\":{\"420\":1}}],[\"无中心架构\",{\"1\":{\"417\":1}}],[\"无需子类锁关心\",{\"1\":{\"677\":1}}],[\"无需再做任何同步操作\",{\"1\":{\"656\":1}}],[\"无需任何代码支持\",{\"1\":{\"523\":1}}],[\"无需查询最新的列表\",{\"1\":{\"381\":1}}],[\"无需设置自定义域名\",{\"1\":{\"69\":1}}],[\"无一例外\",{\"1\":{\"373\":1}}],[\"无限次重试的意思\",{\"1\":{\"334\":1}}],[\"无状态\",{\"1\":{\"363\":1}}],[\"无状态对象\",{\"1\":{\"282\":1}}],[\"无状态就是一次操作\",{\"1\":{\"282\":1}}],[\"无状态bean和有状态bean\",{\"1\":{\"282\":1}}],[\"无论你开几个模拟的多线程该任务都不可能得到加速\",{\"1\":{\"675\":1}}],[\"无论原来是什么东西\",{\"1\":{\"519\":1}}],[\"无论常量池中有没有\",{\"1\":{\"488\":1}}],[\"无论元数据\",{\"1\":{\"361\":1}}],[\"无论是否抛出异常\",{\"1\":{\"454\":1}}],[\"无论是本地内存做缓存还是使用\",{\"1\":{\"389\":1}}],[\"无论是原来的b服务还是新增的日志文件存储服务或日志邮件发送服务\",{\"1\":{\"345\":1}}],[\"无论是想入住的还是想看房的都不可以\",{\"1\":{\"115\":1}}],[\"无论是响应时间还是耗电量都有大幅度上升\",{\"1\":{\"36\":1}}],[\"无论成功或失败\",{\"1\":{\"71\":2}}],[\"无uuid项\",{\"1\":{\"71\":1}}],[\"无10011错误\",{\"1\":{\"71\":1}}],[\"无法判断\",{\"1\":{\"588\":1}}],[\"无法\",{\"1\":{\"560\":1}}],[\"无法等待锁释放\",{\"1\":{\"435\":1}}],[\"无法根据统计区分冷热数据\",{\"1\":{\"417\":1}}],[\"无法完全适配\",{\"1\":{\"401\":1}}],[\"无法完成请求\",{\"1\":{\"27\":1}}],[\"无法直接执行这个处理器\",{\"1\":{\"291\":1}}],[\"无法处理\",{\"1\":{\"281\":1}}],[\"无法自动装配\",{\"1\":{\"279\":1}}],[\"无法得到data的类型\",{\"1\":{\"244\":1}}],[\"无法做到数据库无关性\",{\"1\":{\"178\":1}}],[\"无法充分发挥磁盘顺序读和预读的高效特性\",{\"1\":{\"80\":1}}],[\"无法注册或已经不免费\",{\"1\":{\"66\":1}}],[\"无法免费注册link域名\",{\"1\":{\"63\":1}}],[\"无法运行bat后缀文件问题\",{\"1\":{\"63\":1}}],[\"无法优选ip\",{\"1\":{\"61\":1}}],[\"无域名\",{\"1\":{\"61\":1}}],[\"无加密\",{\"1\":{\"35\":1}}],[\"无序\",{\"1\":{\"9\":1}}],[\"无连接\",{\"1\":{\"9\":1}}],[\"无留言功能\",{\"1\":{\"7\":1}}],[\"是随进程的创建而建立\",{\"1\":{\"726\":1}}],[\"是直接申请线程执行\",{\"1\":{\"713\":1}}],[\"是允许的\",{\"1\":{\"649\":1}}],[\"是依赖于\",{\"1\":{\"648\":1,\"707\":1}}],[\"是依赖数据库的唯一性来实现资源锁定\",{\"1\":{\"432\":1}}],[\"是object的方法\",{\"1\":{\"633\":1,\"701\":1}}],[\"是openjdk\",{\"1\":{\"447\":1}}],[\"是thread类的静态方法\",{\"1\":{\"633\":1,\"701\":1}}],[\"是true\",{\"1\":{\"476\":2}}],[\"是true时\",{\"1\":{\"476\":1}}],[\"是程序执行的最小单位\",{\"1\":{\"622\":1,\"689\":1}}],[\"是则需要将\",{\"1\":{\"617\":1}}],[\"是则调用xmlutil\",{\"1\":{\"196\":1}}],[\"是抢占模式\",{\"1\":{\"616\":1}}],[\"是clh变体的fifo双端队列\",{\"1\":{\"614\":1}}],[\"是单向链表\",{\"1\":{\"602\":1}}],[\"是单进程程序\",{\"1\":{\"410\":1}}],[\"是弱一致的\",{\"1\":{\"590\":1}}],[\"是线程数可以无限扩展\",{\"1\":{\"673\":1}}],[\"是线程不安全的\",{\"1\":{\"563\":1}}],[\"是线程安全的\",{\"1\":{\"282\":1}}],[\"是1的话索引变成\",{\"1\":{\"559\":1}}],[\"是0的话索引没变\",{\"1\":{\"559\":1}}],[\"是根据概率统计而选择的\",{\"1\":{\"553\":1}}],[\"是因为它们本身正是基于时间执行任务的\",{\"1\":{\"673\":1}}],[\"是因为泊松分布\",{\"1\":{\"553\":1}}],[\"是因为字节码文件由十六进制值组成\",{\"1\":{\"445\":1}}],[\"是面试必考点\",{\"1\":{\"552\":1}}],[\"是面向连接\",{\"1\":{\"10\":1}}],[\"是使用\",{\"1\":{\"549\":1}}],[\"是使用社区自研的基于raft的共识算法\",{\"1\":{\"327\":1}}],[\"是性能提升的关键\",{\"1\":{\"548\":1,\"590\":1}}],[\"是映射的value是\",{\"1\":{\"548\":1,\"588\":1}}],[\"是用于多线程的\",{\"1\":{\"548\":1,\"588\":1}}],[\"是用\",{\"1\":{\"547\":1,\"586\":1}}],[\"是jdk1\",{\"1\":{\"542\":1}}],[\"是电脑中表示信息含义的最小单位\",{\"1\":{\"541\":1}}],[\"是由若干条指令组成的\",{\"1\":{\"644\":1}}],[\"是由volatile修饰的\",{\"1\":{\"604\":1}}],[\"是由\",{\"1\":{\"533\":1,\"546\":1,\"584\":1}}],[\"是由实际应用发展总结出来的\",{\"1\":{\"8\":1}}],[\"是exception\",{\"1\":{\"531\":1}}],[\"是只读字符串\",{\"1\":{\"490\":1}}],[\"是如何处理异常的\",{\"0\":{\"537\":1},\"1\":{\"484\":1}}],[\"是如何配合的呢\",{\"0\":{\"40\":1}}],[\"是安全的\",{\"1\":{\"482\":1}}],[\"是在一个类里面\",{\"1\":{\"466\":1}}],[\"是在\",{\"1\":{\"454\":1,\"733\":1}}],[\"是在强大的\",{\"1\":{\"310\":1}}],[\"是编译执行的语言\",{\"1\":{\"445\":1}}],[\"是完全面向对象的语言\",{\"1\":{\"443\":1}}],[\"是完全基于\",{\"1\":{\"310\":1}}],[\"是5s\",{\"1\":{\"437\":1}}],[\"是与连接应答处理器关联\",{\"1\":{\"403\":1}}],[\"是最基本的数据类型吗\",{\"0\":{\"489\":1},\"1\":{\"484\":1}}],[\"是最新的也是目前最好的多路复用技术\",{\"1\":{\"403\":1}}],[\"是最小超键\",{\"1\":{\"93\":1}}],[\"是set的可排序版\",{\"1\":{\"382\":1}}],[\"是sqlsessionfactory的实现类\",{\"1\":{\"195\":1}}],[\"是专业的缓存服务\",{\"1\":{\"380\":1}}],[\"是内存对象\",{\"1\":{\"380\":1}}],[\"是已知性能最快的key\",{\"1\":{\"376\":1}}],[\"是producer太多了\",{\"1\":{\"370\":1}}],[\"是阿里巴巴开源的分布式消息中间件\",{\"1\":{\"362\":1}}],[\"是业内标准的\",{\"1\":{\"350\":1}}],[\"是很好的选择\",{\"1\":{\"350\":1}}],[\"是指系统大部分时间在跟i\",{\"1\":{\"718\":1}}],[\"是指一个操作是不可中断的\",{\"1\":{\"682\":1}}],[\"是指选举集群\",{\"1\":{\"327\":1}}],[\"是指\",{\"1\":{\"327\":1}}],[\"是指主题分区的所有数据都保存在\",{\"1\":{\"327\":1}}],[\"是指事务包含所有操作要么全部成功\",{\"1\":{\"74\":1}}],[\"是没有映射的\",{\"1\":{\"548\":1,\"588\":1}}],[\"是没有泛型这个概念的\",{\"1\":{\"511\":1}}],[\"是没有\",{\"1\":{\"323\":1}}],[\"是分散放在多个机器上的\",{\"1\":{\"323\":1}}],[\"是一条\",{\"1\":{\"644\":1}}],[\"是一种无锁的非阻塞算法的实现\",{\"1\":{\"644\":1}}],[\"是一种硬件对并发的支持\",{\"1\":{\"644\":1}}],[\"是一种高效但是线程安全的集合\",{\"1\":{\"570\":1}}],[\"是一种可重入锁\",{\"1\":{\"546\":1,\"584\":1}}],[\"是一种用于统计基数的数据集合类型\",{\"1\":{\"382\":1}}],[\"是一系列框架的有序集合\",{\"1\":{\"310\":1}}],[\"是一个支持两个附加操作的队列\",{\"1\":{\"713\":1}}],[\"是一个锁框架\",{\"1\":{\"677\":1}}],[\"是一个把大任务分割成若干个小任务\",{\"1\":{\"643\":1}}],[\"是一个受检查异常\",{\"1\":{\"533\":1}}],[\"是一个典型的\",{\"1\":{\"490\":1}}],[\"是一个参考模型并且是完全开源的\",{\"1\":{\"447\":1}}],[\"是一个\",{\"1\":{\"382\":1,\"533\":1}}],[\"是一个键值\",{\"1\":{\"382\":1}}],[\"是一个队列模型的消息中间件\",{\"1\":{\"362\":1}}],[\"是一个分布式系统\",{\"1\":{\"325\":1}}],[\"是一个分布式协调应用\",{\"1\":{\"250\":1}}],[\"是一个节点\",{\"1\":{\"323\":1}}],[\"是一个代码生成的类库\",{\"1\":{\"284\":1}}],[\"是一个强大\",{\"1\":{\"175\":1}}],[\"是一个小巧\",{\"1\":{\"175\":1}}],[\"是一个全表映射的框架\",{\"1\":{\"175\":1}}],[\"是一个半自动映射的框架\",{\"1\":{\"175\":1}}],[\"是一个定长字段\",{\"1\":{\"95\":1}}],[\"是为了解决微服务架构中服务治理而提供的一系列功能的开发框架\",{\"1\":{\"310\":1}}],[\"是为了让人们更容易的使用\",{\"1\":{\"310\":1}}],[\"是为了实现事务的原子性而出现的产物\",{\"1\":{\"107\":1}}],[\"是为了实现事务的持久性而出现的产物\",{\"1\":{\"106\":1}}],[\"是具体的环境标识名称\",{\"1\":{\"305\":1}}],[\"是的话就返回遍历\",{\"1\":{\"598\":1}}],[\"是的\",{\"1\":{\"302\":1}}],[\"是无状态的吗\",{\"0\":{\"302\":1}}],[\"是基于经典的\",{\"1\":{\"403\":1}}],[\"是基于\",{\"1\":{\"403\":1}}],[\"是基于类开发\",{\"1\":{\"299\":1}}],[\"是基于方法开发\",{\"1\":{\"299\":1}}],[\"是怎么被执行\",{\"1\":{\"291\":1}}],[\"是请求的入口\",{\"1\":{\"291\":1}}],[\"是个逻辑上的\",{\"1\":{\"290\":1}}],[\"是返回的数据对象\",{\"1\":{\"290\":1}}],[\"是非线程安全的\",{\"1\":{\"282\":1}}],[\"是非聚集索引\",{\"1\":{\"92\":1}}],[\"是web框架的一个很好的替代品\",{\"1\":{\"263\":1}}],[\"是轻量的\",{\"1\":{\"263\":1}}],[\"是轻量级框架\",{\"1\":{\"175\":1}}],[\"是哪个\",{\"1\":{\"244\":1}}],[\"是不是有人会问\",{\"1\":{\"528\":1}}],[\"是不是有消耗资源的\",{\"1\":{\"141\":1}}],[\"是不错的选择\",{\"1\":{\"350\":1}}],[\"是不安全的\",{\"1\":{\"301\":1}}],[\"是不变类\",{\"1\":{\"282\":1}}],[\"是不能重载的\",{\"1\":{\"182\":1}}],[\"是原值传入\",{\"1\":{\"181\":2}}],[\"是\",{\"1\":{\"181\":2,\"295\":1,\"442\":1,\"511\":1,\"546\":1,\"559\":1,\"648\":2,\"707\":2}}],[\"是拼接符\",{\"1\":{\"181\":1}}],[\"是占位符\",{\"1\":{\"181\":1}}],[\"是重量级框架\",{\"1\":{\"175\":1}}],[\"是b\",{\"1\":{\"149\":1}}],[\"是数据库管理系统中一个排序的数据结构\",{\"1\":{\"146\":1}}],[\"是load了不需要的数据列\",{\"1\":{\"137\":1}}],[\"是查询条件没有命中索引\",{\"1\":{\"137\":1}}],[\"是3个线程以及之间的关联\",{\"1\":{\"132\":1}}],[\"是有个自旋次数的\",{\"1\":{\"645\":1}}],[\"是有不少公司在用的\",{\"1\":{\"126\":1}}],[\"是有索引键的列\",{\"1\":{\"117\":1}}],[\"是限制性最强的隔离级别\",{\"1\":{\"119\":1}}],[\"是并发控制主要采用的技术手段\",{\"1\":{\"116\":1}}],[\"是通过继承的方式做的动态代理\",{\"1\":{\"284\":1}}],[\"是通过保存数据在某个时间点的快照来实现的\",{\"1\":{\"111\":1}}],[\"是通过行锁和间隙锁的组合\",{\"1\":{\"110\":1}}],[\"是记录所有数据库表结构变更\",{\"1\":{\"108\":1}}],[\"是变长的\",{\"1\":{\"95\":1}}],[\"是聚集索引\",{\"1\":{\"92\":1}}],[\"是常见的mysql性能优化手段\",{\"1\":{\"84\":1}}],[\"是匹配不到\",{\"1\":{\"84\":1}}],[\"是当多个用户并发访问数据库时\",{\"1\":{\"74\":1}}],[\"是连接\",{\"1\":{\"40\":1}}],[\"是服务器发送到用户浏览器并保存在本地的一小块数据\",{\"1\":{\"39\":1}}],[\"是服务器端的状态\",{\"0\":{\"21\":1}}],[\"是主动断开连接的一方会进入的状态\",{\"1\":{\"21\":1}}],[\"是报文段在网络上存活的最长时间\",{\"1\":{\"18\":1}}],[\"是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段\",{\"1\":{\"712\":1}}],[\"是对需要进行数据操作的\",{\"1\":{\"549\":1}}],[\"是对一个已存在的流的连接和封装\",{\"1\":{\"539\":1}}],[\"是对象和类概念的主要特性\",{\"1\":{\"464\":1}}],[\"是对\",{\"1\":{\"14\":1}}],[\"是否要根据新状态\",{\"1\":{\"714\":1}}],[\"是否要改变线程池的现阶段状态\",{\"1\":{\"714\":1}}],[\"是否与其线程\",{\"1\":{\"652\":1}}],[\"是否等于\",{\"1\":{\"617\":1}}],[\"是否支持快速随机访问\",{\"1\":{\"571\":1}}],[\"是否保证线程安全\",{\"1\":{\"571\":1}}],[\"是否强制要求调用者必须处理此异常\",{\"1\":{\"531\":1}}],[\"是否相等\",{\"0\":{\"516\":1},\"1\":{\"585\":1}}],[\"是否采用inflation和15这个数字都可以在jvm参数中调整\",{\"1\":{\"507\":1}}],[\"是否多线程安全\",{\"1\":{\"481\":1}}],[\"是否能作用在\",{\"0\":{\"450\":3}}],[\"是否会存在线程并发安全问题\",{\"0\":{\"405\":1}}],[\"是否存在\",{\"1\":{\"395\":1}}],[\"是否发送cookie信息\",{\"1\":{\"319\":1}}],[\"是否安全的界限\",{\"1\":{\"301\":1}}],[\"是否可被重写\",{\"0\":{\"468\":1}}],[\"是否可以在static环境中访问非static变量\",{\"0\":{\"457\":1}}],[\"是否可以被\",{\"1\":{\"200\":1}}],[\"是否可靠\",{\"1\":{\"9\":1}}],[\"是否缺失\",{\"1\":{\"141\":1}}],[\"是否在扫描额外的记录\",{\"1\":{\"138\":1}}],[\"是否执行\",{\"1\":{\"99\":1}}],[\"是否使用索引\",{\"1\":{\"88\":1,\"99\":1}}],[\"是否需要证书\",{\"1\":{\"35\":1}}],[\"是否有序\",{\"1\":{\"9\":1}}],[\"是否连接\",{\"1\":{\"9\":1}}],[\"2次均失败之后才会进入fifo队列等待\",{\"1\":{\"616\":1}}],[\"2将新创建的空hash表赋值给实例变量table\",{\"1\":{\"566\":1}}],[\"2处的tab\",{\"1\":{\"565\":1}}],[\"2代码的情况\",{\"1\":{\"565\":1}}],[\"2以后都冲突在table\",{\"1\":{\"564\":1}}],[\"2倍\",{\"1\":{\"559\":1}}],[\"2^31\",{\"1\":{\"558\":1,\"581\":1}}],[\"2^30\",{\"1\":{\"558\":1,\"581\":1}}],[\"2^64\",{\"1\":{\"382\":1}}],[\"2个哨兵都运行着\",{\"1\":{\"428\":1}}],[\"2个哨兵的majority就是2\",{\"1\":{\"428\":1}}],[\"2的majority=2\",{\"1\":{\"428\":1}}],[\"2k\",{\"1\":{\"348\":5}}],[\"28051453\",{\"1\":{\"483\":1}}],[\"28\",{\"0\":{\"293\":1,\"405\":1,\"596\":1}}],[\"282a36\",{\"1\":{\"70\":1}}],[\"27\",{\"0\":{\"292\":1,\"404\":1,\"595\":1,\"654\":1}}],[\"25\",{\"0\":{\"290\":1,\"402\":1,\"593\":1,\"652\":1}}],[\"256\",{\"1\":{\"69\":2,\"70\":3}}],[\"2byte\",{\"1\":{\"244\":2}}],[\"29\",{\"0\":{\"294\":1,\"406\":1,\"597\":1,\"663\":1},\"1\":{\"161\":2,\"544\":1}}],[\"2961819202\",{\"1\":{\"69\":1,\"70\":1,\"71\":1}}],[\"26\",{\"0\":{\"291\":1,\"403\":1,\"594\":1},\"1\":{\"157\":1,\"474\":1}}],[\"2这种查询条件没有办法利用索引\",{\"1\":{\"84\":1}}],[\"2秒后触发\",{\"1\":{\"71\":1}}],[\"2a01\",{\"1\":{\"70\":1}}],[\"2f\",{\"1\":{\"69\":2,\"70\":3}}],[\"24\",{\"0\":{\"289\":1,\"401\":1,\"592\":1,\"651\":1},\"1\":{\"69\":1,\"70\":1,\"311\":1}}],[\"22\",{\"0\":{\"287\":1,\"399\":1,\"590\":1,\"649\":1},\"1\":{\"69\":1,\"230\":1}}],[\"2181\",{\"1\":{\"251\":1}}],[\"21859\",{\"1\":{\"52\":1}}],[\"21\",{\"0\":{\"59\":1,\"286\":1,\"398\":1,\"589\":1,\"648\":1},\"1\":{\"59\":1,\"483\":1}}],[\"23\",{\"0\":{\"288\":1,\"400\":1,\"591\":1,\"650\":1},\"1\":{\"32\":1,\"510\":1}}],[\"2018\",{\"1\":{\"737\":1}}],[\"2015\",{\"1\":{\"544\":1}}],[\"2014\",{\"1\":{\"161\":2}}],[\"2017\",{\"1\":{\"126\":1}}],[\"2019\",{\"1\":{\"48\":1,\"311\":1,\"402\":1,\"435\":1,\"474\":1,\"483\":2,\"551\":1,\"618\":1}}],[\"2086\",{\"1\":{\"69\":2,\"70\":1}}],[\"2082\",{\"1\":{\"69\":2,\"70\":1}}],[\"2083\",{\"1\":{\"69\":2,\"70\":1}}],[\"2087\",{\"1\":{\"58\":1,\"69\":2,\"70\":1}}],[\"2053\",{\"1\":{\"69\":2,\"70\":1,\"71\":1}}],[\"2052\",{\"1\":{\"58\":1,\"69\":2,\"70\":1}}],[\"2099\",{\"1\":{\"71\":1}}],[\"2095\",{\"1\":{\"69\":2,\"70\":1}}],[\"2096\",{\"1\":{\"58\":2,\"69\":2,\"70\":1}}],[\"209242\",{\"1\":{\"52\":3,\"65\":2}}],[\"2023vpn\",{\"1\":{\"59\":1}}],[\"2023\",{\"0\":{\"59\":1,\"63\":1},\"1\":{\"59\":1,\"63\":1,\"69\":1}}],[\"2024\",{\"0\":{\"55\":1},\"1\":{\"69\":1,\"70\":1,\"71\":1}}],[\"2020\",{\"1\":{\"25\":1,\"48\":1,\"166\":1,\"343\":1,\"675\":1,\"723\":1}}],[\"20\",{\"0\":{\"46\":1,\"191\":1,\"285\":1,\"397\":1,\"588\":1,\"647\":1},\"1\":{\"69\":1,\"136\":3,\"167\":1,\"536\":2,\"555\":2,\"579\":1}}],[\"2009\",{\"1\":{\"567\":1}}],[\"200ms\",{\"1\":{\"347\":1}}],[\"2000\",{\"1\":{\"71\":1,\"121\":1}}],[\"20000\",{\"1\":{\"69\":2,\"70\":2}}],[\"2001\",{\"1\":{\"69\":1,\"70\":1}}],[\"200\",{\"1\":{\"27\":1,\"32\":1,\"64\":1,\"69\":2,\"70\":3,\"71\":1,\"121\":1,\"223\":1,\"347\":2}}],[\"2msl\",{\"0\":{\"18\":1},\"1\":{\"18\":5,\"21\":1}}],[\"2\",{\"0\":{\"9\":1,\"28\":1,\"58\":1,\"74\":1,\"92\":1,\"101\":1,\"114\":1,\"122\":1,\"130\":1,\"135\":1,\"147\":1,\"165\":1,\"173\":1,\"227\":1,\"264\":1,\"322\":1,\"352\":1,\"363\":1,\"377\":1,\"555\":1,\"570\":1,\"604\":1,\"621\":1,\"669\":1,\"678\":1,\"683\":1,\"688\":1,\"711\":1,\"712\":2,\"713\":1,\"714\":1,\"719\":1,\"721\":2,\"733\":1},\"1\":{\"16\":1,\"19\":2,\"52\":2,\"61\":1,\"69\":18,\"70\":20,\"71\":3,\"79\":1,\"84\":8,\"98\":1,\"103\":1,\"112\":1,\"118\":1,\"126\":1,\"148\":1,\"154\":2,\"159\":1,\"161\":3,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"183\":1,\"188\":1,\"189\":1,\"198\":1,\"230\":1,\"244\":1,\"274\":1,\"275\":1,\"281\":2,\"334\":1,\"339\":1,\"340\":2,\"342\":1,\"349\":1,\"364\":1,\"369\":1,\"381\":1,\"382\":2,\"386\":1,\"391\":1,\"396\":1,\"407\":1,\"420\":2,\"422\":1,\"431\":1,\"432\":1,\"434\":1,\"435\":1,\"449\":3,\"465\":1,\"467\":1,\"481\":1,\"482\":1,\"488\":14,\"499\":1,\"506\":1,\"553\":1,\"555\":9,\"564\":1,\"603\":1,\"621\":1,\"623\":2,\"645\":1,\"648\":1,\"653\":1,\"662\":1,\"672\":1,\"675\":1,\"688\":1,\"690\":2,\"707\":1,\"708\":1,\"711\":1,\"713\":2,\"714\":7,\"718\":1,\"720\":2,\"721\":1,\"729\":1,\"731\":1}}],[\"尽快恢复缓存数据\",{\"1\":{\"396\":1}}],[\"尽可能的减少冗余字段\",{\"1\":{\"140\":1}}],[\"尽可能的固定顺序的获取表中的行\",{\"1\":{\"120\":1}}],[\"尽可能做到一次锁定所需要的所有资源\",{\"1\":{\"118\":1}}],[\"尽可能屏蔽传输介质和通信手段的差异\",{\"1\":{\"8\":1}}],[\"尽量保证\",{\"1\":{\"350\":1}}],[\"尽量的扩展索引\",{\"1\":{\"161\":1}}],[\"尽量选择区分度高的列作为索引\",{\"1\":{\"161\":1}}],[\"尽量使用相等条件访问数据\",{\"1\":{\"120\":1}}],[\"尽量使用索引去访问数据\",{\"1\":{\"120\":1}}],[\"尽量约定以相同的顺序访问表\",{\"1\":{\"118\":1}}],[\"尽量不要在同一个事务中使用多种存储引擎\",{\"1\":{\"109\":1}}],[\"尽最大努力的数据传输服务\",{\"1\":{\"8\":1}}],[\"但功能一点儿都不一样\",{\"1\":{\"731\":1}}],[\"但还未结束\",{\"1\":{\"729\":1}}],[\"但两者用途完全不一样\",{\"1\":{\"729\":1}}],[\"但由于引起线程销毁的可能性有很多\",{\"1\":{\"714\":1}}],[\"但没有剩余可用资源\",{\"1\":{\"678\":1}}],[\"但同样地\",{\"1\":{\"598\":1}}],[\"但同时刻只有一个实例对外提供服务\",{\"1\":{\"414\":1}}],[\"但可以向前和向后遍历集合中的元素\",{\"1\":{\"597\":1}}],[\"但可以被重载\",{\"1\":{\"468\":1}}],[\"但增加了计算的时间\",{\"1\":{\"576\":1}}],[\"但实现原理一样\",{\"1\":{\"555\":1,\"579\":1}}],[\"但实际底层实现采用的是长轮询机制\",{\"1\":{\"365\":1}}],[\"但实际上\",{\"1\":{\"326\":1}}],[\"但提高查找成本\",{\"1\":{\"554\":1,\"578\":1}}],[\"但在遍历过程中\",{\"1\":{\"548\":1,\"590\":1}}],[\"但在并发量高的场合中\",{\"1\":{\"381\":1}}],[\"但并不是每个节点都需要获得同步支持的\",{\"1\":{\"546\":1}}],[\"但并不执行\",{\"1\":{\"404\":1}}],[\"但好在程序直观简单\",{\"1\":{\"542\":1}}],[\"但值为我们显示指定的值\",{\"1\":{\"525\":1}}],[\"但jdk1\",{\"1\":{\"494\":1,\"557\":1}}],[\"但对资源进行写操作时是不安全的\",{\"1\":{\"482\":1}}],[\"但却要冒多线程不安全的风险\",{\"1\":{\"481\":1}}],[\"但其数组中的person实例却是可变的\",{\"1\":{\"473\":1}}],[\"但有时我们只想为特定域分配单一存储空间\",{\"1\":{\"455\":1}}],[\"但允许一个类实现多个接口\",{\"1\":{\"443\":1}}],[\"但允许有空值\",{\"1\":{\"79\":1,\"148\":1}}],[\"但此时线程\",{\"1\":{\"435\":1}}],[\"但此时哨兵1没了就只有1个哨兵了了\",{\"1\":{\"428\":1}}],[\"但线程\",{\"1\":{\"435\":2}}],[\"但缺点也比较明显\",{\"1\":{\"421\":1}}],[\"但这样\",{\"1\":{\"667\":1}}],[\"但这样会需要额外写代码实现\",{\"1\":{\"412\":1}}],[\"但这在实际开发中是不可能的\",{\"1\":{\"525\":1}}],[\"但这种处理方式是有问题的\",{\"1\":{\"395\":1}}],[\"但批量指令并非原子化的操作\",{\"1\":{\"407\":1}}],[\"但\",{\"1\":{\"407\":1,\"447\":1}}],[\"但也解决了线程并发安全等问题\",{\"1\":{\"406\":1}}],[\"但nameserver集群只要有一个节点就可用\",{\"1\":{\"374\":1}}],[\"但每个broker都会定时向所有nameserver上报路由信息和心跳\",{\"1\":{\"374\":1}}],[\"但高水位值无法保证leader连续变更场景下的数据一致性\",{\"1\":{\"339\":1}}],[\"但长时间的不同步可能就需要深入排查了\",{\"1\":{\"339\":1}}],[\"但很难维护\",{\"1\":{\"287\":1}}],[\"但必须描述如何创建它们\",{\"1\":{\"265\":1}}],[\"但更是由于这样\",{\"1\":{\"206\":1}}],[\"但另外一个表的查询是通过select配置的\",{\"1\":{\"186\":1,\"187\":1}}],[\"但sql语句优化容易\",{\"1\":{\"175\":1}}],[\"但sql语句优化困难\",{\"1\":{\"175\":1}}],[\"但会多消耗性能\",{\"1\":{\"175\":1}}],[\"但进行检索时\",{\"1\":{\"161\":1}}],[\"但如果是多写的情况\",{\"1\":{\"116\":1}}],[\"但如果该事务需要回滚\",{\"1\":{\"109\":1}}],[\"但速度慢\",{\"1\":{\"114\":1}}],[\"但冲突多\",{\"1\":{\"114\":1}}],[\"但加锁的开销也最大\",{\"1\":{\"114\":1}}],[\"但你可以通过查询通用日志来查看\",{\"1\":{\"108\":1}}],[\"但不能保证数据的原子性\",{\"1\":{\"709\":1}}],[\"但不一定就能保证很高的性能\",{\"1\":{\"341\":1}}],[\"但不影响正常使用\",{\"1\":{\"251\":1}}],[\"但不支持它的使用\",{\"1\":{\"443\":1}}],[\"但不支持预处理器功能\",{\"1\":{\"443\":1}}],[\"但不支持\",{\"1\":{\"124\":1}}],[\"但不是\",{\"1\":{\"102\":1}}],[\"但不保证数据传输的可靠性\",{\"1\":{\"8\":1}}],[\"但它与\",{\"1\":{\"443\":1}}],[\"但它在一个表只允许出现一个\",{\"1\":{\"94\":1}}],[\"但它大幅增加了中间人攻击的成本\",{\"1\":{\"36\":1}}],[\"但只能在向前方向上遍历集合中的元素\",{\"1\":{\"597\":1}}],[\"但只能有一个\",{\"1\":{\"87\":1}}],[\"但只返回少数的行\",{\"1\":{\"138\":1}}],[\"但只返回报文首部\",{\"1\":{\"29\":1}}],[\"但b值不可以\",{\"1\":{\"84\":1}}],[\"但随着虚拟主机技术的发展\",{\"1\":{\"33\":1}}],[\"但从\",{\"1\":{\"31\":1}}],[\"但任务结束就中断连接\",{\"1\":{\"31\":1}}],[\"但依然不是get和post本身的区别\",{\"1\":{\"30\":1}}],[\"但请求者应继续使用原有位置来进行以后的请求\",{\"1\":{\"27\":1}}],[\"但接下来并不执行慢开始算法\",{\"1\":{\"24\":1}}],[\"但是便捷高效的共享内存通信\",{\"1\":{\"731\":1}}],[\"但是最核心的是3个\",{\"1\":{\"720\":1}}],[\"但是最近几年都没更新了\",{\"1\":{\"123\":1}}],[\"但是因为threadlocalmap生命周期和thread是一样的\",{\"1\":{\"665\":1}}],[\"但是它的功能比\",{\"1\":{\"681\":1}}],[\"但是它也存在缺点\",{\"1\":{\"661\":1}}],[\"但是它扫描了所有的索引\",{\"1\":{\"157\":1}}],[\"但是看到的虽然是a\",{\"1\":{\"645\":1}}],[\"但是队列里的任务得执行完毕\",{\"1\":{\"630\":1,\"698\":1}}],[\"但是当有两个线程的时候就不一样了\",{\"1\":{\"622\":1,\"689\":1}}],[\"但是线程不能独立执行\",{\"1\":{\"620\":1,\"687\":1}}],[\"但是一般不推荐使用该种方式\",{\"1\":{\"640\":1}}],[\"但是一个线程崩溃整个进程都死掉\",{\"1\":{\"620\":1,\"687\":1}}],[\"但是一直没有使用\",{\"1\":{\"386\":1}}],[\"但是由于tryacquire需要自定义同步器实现\",{\"1\":{\"615\":1}}],[\"但是由于索引覆盖\",{\"1\":{\"136\":1}}],[\"但是具体是如何加锁的呢\",{\"1\":{\"614\":1}}],[\"但是该方法对中断不敏感\",{\"1\":{\"610\":1}}],[\"但是二叉查找树在特殊情况下会变成一条线性结构\",{\"1\":{\"553\":1}}],[\"但是新增节点的效率变慢了\",{\"1\":{\"553\":1,\"577\":1}}],[\"但是字符流处理文本要比字节流处理文本要方便\",{\"1\":{\"541\":1}}],[\"但是呢\",{\"1\":{\"536\":1}}],[\"但是你一旦对一段代码加上try\",{\"1\":{\"535\":1}}],[\"但是你要知道的是innodb\",{\"1\":{\"102\":1}}],[\"但是又违反域或方法的可见性声明\",{\"1\":{\"534\":1}}],[\"但是除此之外的是\",{\"1\":{\"511\":1}}],[\"但是取出来的时候却将其强制转换为\",{\"1\":{\"510\":1}}],[\"但是接口却是对类局部\",{\"1\":{\"469\":1}}],[\"但是长整型\",{\"1\":{\"450\":1}}],[\"但是实际中会考虑计算机高效存储因素\",{\"1\":{\"449\":1}}],[\"但是实际上master还运行着\",{\"1\":{\"423\":1}}],[\"但是redis内部针对不同类型存在编码的概念\",{\"1\":{\"438\":1}}],[\"但是java的锁只能保证单机的时候有效\",{\"1\":{\"431\":1}}],[\"但是可能client还没来得及切换到新的master\",{\"1\":{\"423\":1}}],[\"但是如果都用这样的参数配置的话\",{\"1\":{\"718\":1}}],[\"但是如果要在指定位置\",{\"1\":{\"571\":1}}],[\"但是如果发现有相同\",{\"1\":{\"478\":1}}],[\"但是如果是机器1宕机了\",{\"1\":{\"428\":1}}],[\"但是如果没有找到对应的offset\",{\"1\":{\"420\":1,\"422\":1}}],[\"但是如果查询条件是a\",{\"1\":{\"84\":1}}],[\"但是仍然不能解决缓存预热问题\",{\"1\":{\"414\":1}}],[\"但是每个节点存储的数据是一样的\",{\"1\":{\"413\":1}}],[\"但是每个库的表结构都一样\",{\"1\":{\"128\":1}}],[\"但是这些优化都是在虚拟机层面实现的\",{\"1\":{\"648\":1,\"707\":1}}],[\"但是这个时候\",{\"1\":{\"428\":1}}],[\"但是这个方案会有一个缺点就是会对业务代码造成大量的侵入\",{\"1\":{\"393\":1}}],[\"但是这种一般较少用\",{\"1\":{\"128\":1}}],[\"但是这种顺序是相对的\",{\"1\":{\"84\":1}}],[\"但是数据库更新失败\",{\"1\":{\"389\":1}}],[\"但是数据可靠性确是最低的\",{\"1\":{\"330\":1}}],[\"但是很多没有设置过期时间的数据也会越来越多\",{\"1\":{\"388\":1}}],[\"但是还是加锁了\",{\"1\":{\"667\":1}}],[\"但是还是只计算为一次\",{\"1\":{\"382\":1}}],[\"但是还没完成更新的时候\",{\"1\":{\"392\":1}}],[\"但是还没执行定期删除\",{\"1\":{\"386\":1}}],[\"但是zk集群当挂了一半以上的节点就没法使用了\",{\"1\":{\"374\":1}}],[\"但是我们可以尽量减少\",{\"1\":{\"424\":1}}],[\"但是我们也必须注意到它的代价\",{\"1\":{\"162\":1}}],[\"但是我没搞懂为啥是16次\",{\"1\":{\"373\":1}}],[\"但是问题是\",{\"1\":{\"349\":1}}],[\"但是系统是直接基于\",{\"1\":{\"348\":1}}],[\"但是系统管理员\",{\"1\":{\"103\":1}}],[\"但是单线程吞吐量太低\",{\"1\":{\"337\":1}}],[\"但是此时需要注意重复消费问题\",{\"1\":{\"332\":1}}],[\"但是采用pull的方式也有一个缺点\",{\"1\":{\"324\":1}}],[\"但是只有当一个消息已经被所有\",{\"1\":{\"323\":1}}],[\"但是总比没有好呀\",{\"1\":{\"281\":1}}],[\"但是灵活的前提是\",{\"1\":{\"178\":1}}],[\"但是id却都是1\",{\"1\":{\"157\":1}}],[\"但是b树因为其分支结点同样存储着数据\",{\"1\":{\"150\":1}}],[\"但是突然之间\",{\"1\":{\"141\":1}}],[\"但是大部分的请求\",{\"1\":{\"128\":1}}],[\"但是确实相比于\",{\"1\":{\"127\":1}}],[\"但是确实有一个很大的问题就是社区最新的维护都在\",{\"1\":{\"125\":1}}],[\"但是在我们调用concurrenthashmap\",{\"1\":{\"588\":1}}],[\"但是在我们调用\",{\"1\":{\"548\":1}}],[\"但是在运行时却找不到了\",{\"1\":{\"533\":1}}],[\"但是在jdk7中输出的是false\",{\"1\":{\"488\":1}}],[\"但是在这种模式下每台\",{\"1\":{\"417\":1}}],[\"但是在删除缓存的阶段出错了没有删除成功\",{\"1\":{\"393\":1}}],[\"但是在某些情况下是需要在bean中对ioc容器进行操作的\",{\"1\":{\"274\":1}}],[\"但是在事务提交之前并不释放共享锁\",{\"1\":{\"119\":1}}],[\"但是在语句执行完以后释放共享锁\",{\"1\":{\"119\":1}}],[\"但是\",{\"1\":{\"98\":1,\"108\":1,\"140\":1,\"155\":1,\"269\":1,\"345\":1,\"348\":1,\"444\":1,\"447\":1,\"555\":1,\"633\":1,\"672\":1,\"701\":1}}],[\"但是三者有一些差别\",{\"1\":{\"97\":1}}],[\"但是没有顺序\",{\"1\":{\"80\":1,\"150\":1}}],[\"但是拒绝提供服务\",{\"1\":{\"27\":1}}],[\"但是客户端出现故障了怎么办\",{\"0\":{\"19\":1}}],[\"但是会做出应答\",{\"1\":{\"17\":1}}],[\"但是服务端可能还要给客户端发送数据\",{\"1\":{\"16\":1}}],[\"但是服务端到客户端的连接还未释放\",{\"1\":{\"16\":1}}],[\"但是已经进入\",{\"1\":{\"12\":1}}],[\"但是比较复杂\",{\"1\":{\"8\":1}}],[\"u0000\",{\"1\":{\"449\":1}}],[\"u0040www\",{\"1\":{\"69\":2}}],[\"uri\",{\"1\":{\"293\":1,\"296\":1}}],[\"uri等信息\",{\"1\":{\"293\":1}}],[\"url=jdbc\",{\"1\":{\"205\":1}}],[\"url=$\",{\"1\":{\"70\":6,\"71\":2}}],[\"url\",{\"1\":{\"64\":1,\"69\":9,\"70\":18,\"71\":22,\"196\":3,\"198\":3,\"204\":2}}],[\"utm\",{\"1\":{\"618\":2}}],[\"utf8\",{\"1\":{\"204\":2}}],[\"utf\",{\"1\":{\"204\":2,\"205\":1}}],[\"utils\",{\"0\":{\"752\":1}}],[\"utils包下类\",{\"0\":{\"204\":1}}],[\"util包下的集合类都是快速失败的\",{\"1\":{\"598\":1}}],[\"util\",{\"1\":{\"201\":1,\"598\":1,\"604\":1,\"605\":3,\"607\":1,\"682\":2}}],[\"utc\",{\"1\":{\"70\":1}}],[\"utc<\",{\"1\":{\"69\":1}}],[\"updatedata\",{\"1\":{\"391\":1}}],[\"update>\",{\"1\":{\"205\":1}}],[\"update方法\",{\"1\":{\"205\":1}}],[\"update等四种标签的哪种\",{\"1\":{\"204\":1}}],[\"update等自定义方法\",{\"1\":{\"201\":1}}],[\"update标签\",{\"1\":{\"199\":1}}],[\"update将为此多付出4\",{\"1\":{\"162\":1}}],[\"update\",{\"1\":{\"71\":3,\"108\":1,\"112\":1,\"117\":2,\"197\":2,\"200\":2,\"201\":2,\"204\":5,\"205\":3,\"604\":1,\"607\":2}}],[\"upgrade\",{\"1\":{\"69\":1,\"70\":1}}],[\"upgradeheader\",{\"1\":{\"69\":3,\"70\":3}}],[\"uk\",{\"1\":{\"70\":1}}],[\"unlock\",{\"1\":{\"647\":1,\"648\":1,\"707\":1}}],[\"unlock会调用内部类sync的release方法\",{\"1\":{\"615\":1}}],[\"unlink\",{\"1\":{\"400\":1}}],[\"unparksuccessor\",{\"1\":{\"611\":1,\"617\":1}}],[\"unchecked\",{\"1\":{\"559\":1}}],[\"uncommitted级别下\",{\"1\":{\"119\":1}}],[\"uncommitted\",{\"1\":{\"76\":1,\"102\":1}}],[\"unboxing\",{\"1\":{\"493\":1}}],[\"unwatch命令可以取消watch对所有key的监控\",{\"1\":{\"409\":1}}],[\"unwatch\",{\"1\":{\"408\":1}}],[\"unsafe\",{\"1\":{\"607\":1,\"644\":2,\"684\":4}}],[\"unsafestringify\",{\"1\":{\"69\":2,\"70\":2}}],[\"unsupportedoperationexception\",{\"1\":{\"605\":1}}],[\"unstable\",{\"1\":{\"402\":1}}],[\"unit\",{\"1\":{\"230\":2,\"669\":1,\"697\":1}}],[\"unix等一般采用面向过程开发\",{\"1\":{\"463\":1}}],[\"unix\",{\"1\":{\"161\":1}}],[\"unixtime\",{\"1\":{\"161\":1}}],[\"unique索引或primary\",{\"1\":{\"159\":1}}],[\"unique\",{\"1\":{\"87\":1,\"94\":2,\"159\":1}}],[\"uniqueaddressesnotls\",{\"1\":{\"71\":2}}],[\"uniqueaddresses\",{\"1\":{\"71\":2}}],[\"under\",{\"1\":{\"553\":1}}],[\"undefined\",{\"1\":{\"69\":1,\"70\":1}}],[\"undolog\",{\"1\":{\"112\":1}}],[\"undo\",{\"0\":{\"107\":1},\"1\":{\"104\":4,\"105\":2,\"107\":3,\"112\":6}}],[\"until\",{\"1\":{\"69\":1}}],[\"uint8array\",{\"1\":{\"69\":17,\"70\":21}}],[\"ud\",{\"1\":{\"71\":7}}],[\"udemy\",{\"1\":{\"62\":1}}],[\"udacity\",{\"1\":{\"62\":1}}],[\"udpsizebuffer\",{\"1\":{\"69\":3,\"70\":3}}],[\"udpsize\",{\"1\":{\"69\":4,\"70\":4}}],[\"udpstreamwrite\",{\"1\":{\"69\":5,\"70\":5}}],[\"udpdata\",{\"1\":{\"69\":2,\"70\":2}}],[\"udppakcetlength\",{\"1\":{\"69\":3,\"70\":3}}],[\"udp\",{\"0\":{\"10\":1},\"1\":{\"8\":1,\"9\":3,\"10\":1,\"69\":13,\"70\":13,\"731\":1}}],[\"uat\",{\"1\":{\"305\":1}}],[\"ua\",{\"1\":{\"62\":1,\"71\":2}}],[\"uuidregex\",{\"1\":{\"69\":2,\"70\":2}}],[\"uuids\",{\"1\":{\"69\":2,\"70\":6}}],[\"uuid就能看到vless节点url和clash\",{\"1\":{\"61\":1}}],[\"uuid\",{\"1\":{\"60\":1,\"61\":1,\"69\":20,\"70\":21,\"71\":16,\"108\":1,\"216\":1,\"435\":1}}],[\"uuid生成\",{\"1\":{\"60\":1}}],[\"uuid=\",{\"1\":{\"71\":1}}],[\"uuid=$\",{\"1\":{\"70\":1}}],[\"uuid=你的uuid\",{\"1\":{\"58\":1}}],[\"uuid=uuid\",{\"1\":{\"57\":1,\"58\":1}}],[\"uuid=9afa0f97\",{\"1\":{\"53\":1}}],[\"usages\",{\"1\":{\"553\":1}}],[\"usually\",{\"1\":{\"399\":1}}],[\"using\",{\"1\":{\"71\":1,\"157\":1,\"399\":1,\"559\":1}}],[\"us\",{\"1\":{\"52\":1,\"65\":2,\"70\":1}}],[\"uses\",{\"1\":{\"399\":1}}],[\"useid\",{\"1\":{\"230\":2}}],[\"useunicode=true\",{\"1\":{\"205\":1}}],[\"useful\",{\"1\":{\"70\":2}}],[\"used\",{\"1\":{\"70\":2,\"388\":2,\"553\":1}}],[\"userbyuserid\",{\"1\":{\"216\":2,\"223\":2,\"237\":1}}],[\"username=root\",{\"1\":{\"205\":1}}],[\"username=jinqiao\",{\"1\":{\"32\":1}}],[\"username\",{\"1\":{\"198\":3,\"204\":2,\"216\":2,\"223\":1,\"316\":5}}],[\"userinfo\",{\"1\":{\"71\":3}}],[\"useridarray\",{\"1\":{\"70\":6}}],[\"userids\",{\"1\":{\"70\":5}}],[\"userid\",{\"1\":{\"41\":1,\"69\":21,\"70\":29}}],[\"useragent\",{\"1\":{\"71\":11}}],[\"useragentheader\",{\"1\":{\"71\":4}}],[\"user=username\",{\"1\":{\"70\":1}}],[\"useruuid\",{\"1\":{\"69\":2,\"70\":4}}],[\"userservice\",{\"1\":{\"216\":4,\"223\":6,\"229\":4,\"230\":9,\"237\":4}}],[\"userservice里暂时只有一个功能\",{\"1\":{\"215\":1}}],[\"userserviceimpl\",{\"1\":{\"215\":1,\"216\":3,\"223\":2,\"229\":1,\"230\":2}}],[\"users\",{\"1\":{\"69\":1}}],[\"user\",{\"1\":{\"32\":1,\"69\":3,\"70\":2,\"71\":3,\"159\":1,\"216\":11,\"223\":10,\"237\":1,\"521\":12,\"522\":10,\"553\":1}}],[\"use\",{\"1\":{\"3\":1,\"4\":2,\"69\":2,\"70\":7,\"399\":1,\"553\":2}}],[\"u\",{\"1\":{\"16\":4,\"465\":1}}],[\"如键盘\",{\"1\":{\"731\":1}}],[\"如获取资源失败入队\",{\"1\":{\"680\":1}}],[\"如reentrantlock\",{\"1\":{\"680\":1}}],[\"如redis\",{\"1\":{\"42\":1}}],[\"如map\",{\"1\":{\"597\":1}}],[\"如mysql\",{\"1\":{\"432\":1}}],[\"如源码所示\",{\"1\":{\"595\":1}}],[\"如二进制流\",{\"1\":{\"518\":1}}],[\"如list<\",{\"1\":{\"512\":1}}],[\"如这个例子\",{\"1\":{\"510\":1}}],[\"如下代码所示\",{\"1\":{\"712\":1}}],[\"如下\",{\"1\":{\"665\":1}}],[\"如下所示\",{\"1\":{\"560\":1}}],[\"如下表所示\",{\"1\":{\"449\":1}}],[\"如下图所示\",{\"1\":{\"546\":1,\"559\":1}}],[\"如下图\",{\"1\":{\"112\":1,\"384\":1}}],[\"如hash\",{\"1\":{\"438\":1}}],[\"如监控\",{\"1\":{\"418\":1}}],[\"如使用mset\",{\"1\":{\"417\":1}}],[\"如电源故障导致的宕机\",{\"1\":{\"407\":1}}],[\"如电商网站商品的浏览量\",{\"1\":{\"381\":1}}],[\"如在设计键时\",{\"1\":{\"438\":1}}],[\"如在95~100\",{\"1\":{\"398\":1}}],[\"如在微博中的共同好友\",{\"1\":{\"381\":1}}],[\"如把每个key的失效时间都加个随机值\",{\"1\":{\"396\":1}}],[\"如activemq\",{\"1\":{\"381\":1}}],[\"如apache\",{\"1\":{\"31\":1}}],[\"如全局id\",{\"1\":{\"381\":1}}],[\"如京东的月度销量榜单\",{\"1\":{\"381\":1}}],[\"如group\",{\"1\":{\"362\":1}}],[\"如持久化\",{\"1\":{\"352\":1}}],[\"如某个核心服务或数据库等\",{\"1\":{\"345\":1}}],[\"如日志\",{\"1\":{\"345\":1}}],[\"如服务发现注册\",{\"1\":{\"310\":1}}],[\"如服务器验证用户登录便是由会话层完成的\",{\"1\":{\"8\":1}}],[\"如你想使用\",{\"1\":{\"307\":1}}],[\"如关闭数据源自动配置功能\",{\"1\":{\"306\":1}}],[\"如开启注解\",{\"1\":{\"304\":1}}],[\"如jta\",{\"1\":{\"288\":1}}],[\"如javascript文件\",{\"1\":{\"31\":1}}],[\"如原数据类型\",{\"1\":{\"279\":1}}],[\"如zookeeper\",{\"1\":{\"250\":1}}],[\"如有数据\",{\"1\":{\"216\":1}}],[\"如semaphore\",{\"1\":{\"601\":1,\"680\":1}}],[\"如select\",{\"1\":{\"204\":1}}],[\"如spring\",{\"1\":{\"304\":1}}],[\"如simple\",{\"1\":{\"157\":1}}],[\"如code中注释\",{\"1\":{\"199\":1}}],[\"如const\",{\"1\":{\"157\":1}}],[\"如ehcache\",{\"1\":{\"188\":1}}],[\"如explain\",{\"1\":{\"157\":1}}],[\"如互联网项目\",{\"1\":{\"172\":1}}],[\"如using\",{\"1\":{\"157\":1}}],[\"如以下例子\",{\"1\":{\"157\":1,\"521\":1}}],[\"如=\",{\"1\":{\"150\":1}}],[\"如图中用数组括起来的第一列\",{\"1\":{\"479\":1}}],[\"如图\",{\"1\":{\"112\":1}}],[\"如何动态指定队列长度\",{\"1\":{\"721\":1}}],[\"如何同时维护线程和执行任务的呢\",{\"1\":{\"711\":1}}],[\"如何调度线程来执行任务\",{\"1\":{\"711\":1}}],[\"如何合理配置线程池参数\",{\"0\":{\"675\":1}}],[\"如何\",{\"1\":{\"665\":1}}],[\"如何创建线程实例并运行\",{\"0\":{\"638\":1}}],[\"如何创建索引\",{\"0\":{\"159\":1}}],[\"如何避免线程死锁\",{\"0\":{\"627\":1,\"694\":1}}],[\"如何避免死锁\",{\"0\":{\"624\":1,\"691\":1},\"1\":{\"627\":1,\"694\":1}}],[\"如何避免sql注入\",{\"0\":{\"45\":1}}],[\"如何唤醒lz后面介绍\",{\"1\":{\"611\":1}}],[\"如何解决这些问题呢\",{\"1\":{\"563\":1}}],[\"如何解决主从架构数据丢失的问题\",{\"0\":{\"424\":1}}],[\"如何获取反射中的class对象\",{\"0\":{\"503\":1},\"1\":{\"484\":1}}],[\"如何检查重复\",{\"1\":{\"478\":1}}],[\"如何选择\",{\"1\":{\"395\":1}}],[\"如何选择合适的持久化方式\",{\"0\":{\"384\":1}}],[\"如何让rocketmq保证消息的顺序消费\",{\"0\":{\"368\":1}}],[\"如何保证缓存与数据库双写时的数据一致性\",{\"0\":{\"389\":1}}],[\"如何保证rabbitmq消息队列的高可用\",{\"0\":{\"361\":1}}],[\"如何保证消费者处理消费的顺序性\",{\"0\":{\"337\":1},\"1\":{\"335\":1}}],[\"如何保证消息的可靠性\",{\"0\":{\"356\":1}}],[\"如何保证消息的顺序性\",{\"0\":{\"335\":1}}],[\"如何保证消息可靠性传输等\",{\"1\":{\"349\":1}}],[\"如何保证消息不被重复消费\",{\"1\":{\"349\":1}}],[\"如何保证消息在\",{\"0\":{\"336\":1},\"1\":{\"335\":1}}],[\"如何保证高可用\",{\"0\":{\"323\":1}}],[\"如何理解ioc和di\",{\"0\":{\"270\":1}}],[\"如何分散服务提供者的压力\",{\"1\":{\"257\":1}}],[\"如何设计一个注册中心\",{\"1\":{\"250\":1}}],[\"如何设计并完成自己的协议\",{\"1\":{\"243\":1}}],[\"如何提升这个rpc的性能\",{\"1\":{\"236\":1}}],[\"如何使服务端返回值的类型多样\",{\"1\":{\"222\":1}}],[\"如何使客户端请求远程方法支持多种\",{\"1\":{\"222\":1}}],[\"如何优化\",{\"1\":{\"142\":1}}],[\"如何优化关联查询\",{\"0\":{\"139\":1}}],[\"如何优化查询过程中的数据访问\",{\"0\":{\"138\":1}}],[\"如何定位及优化sql语句的性能问题\",{\"0\":{\"134\":1}}],[\"如何实现mysql的读写分离\",{\"0\":{\"131\":1}}],[\"如何对数据库如何进行垂直拆分或水平拆分的\",{\"0\":{\"128\":1}}],[\"如何把语句给到预处理器\",{\"1\":{\"88\":1,\"99\":1}}],[\"如何考虑分布式\",{\"0\":{\"42\":1}}],[\"如何防范\",{\"0\":{\"14\":1}}],[\"如跟踪分析用户行为等\",{\"1\":{\"39\":1}}],[\"如用户自定义设置\",{\"1\":{\"39\":1}}],[\"如用户登录状态\",{\"1\":{\"39\":1}}],[\"如保持用户的登录状态\",{\"1\":{\"39\":1}}],[\"如409\",{\"1\":{\"33\":1}}],[\"如应用需要把\",{\"1\":{\"28\":1}}],[\"如改变网页目录结构\",{\"1\":{\"28\":1}}],[\"如此保证服务端能够正常关闭\",{\"1\":{\"18\":1}}],[\"如增加最大半连接数\",{\"1\":{\"14\":1}}],[\"如果进程从消息队列中读取了消息体\",{\"1\":{\"726\":1}}],[\"如果想相互通信\",{\"1\":{\"725\":1}}],[\"如果想要命中索引\",{\"1\":{\"153\":1}}],[\"如果gettask结果为null则跳出循环\",{\"1\":{\"714\":1}}],[\"如果get一个在这个链表中不存在的key时\",{\"1\":{\"564\":1}}],[\"如果get一个在此链表中不存在的key时\",{\"1\":{\"564\":1}}],[\"如果正在执行任务\",{\"1\":{\"714\":1}}],[\"如果workercount\",{\"1\":{\"713\":4}}],[\"如果工作线程数量达到线程池初始的最大数\",{\"1\":{\"672\":1}}],[\"如果长时间没有往线程池中提交任务\",{\"1\":{\"672\":1}}],[\"如果阻塞队列已满\",{\"1\":{\"671\":1}}],[\"如果非核心线程在keepalivetime内没有运行任务\",{\"1\":{\"670\":1}}],[\"如果无限制的创建\",{\"1\":{\"668\":1}}],[\"如果锁被其他线程长时间占用\",{\"1\":{\"661\":1}}],[\"如果得到锁\",{\"1\":{\"661\":1}}],[\"如果还不能获得锁\",{\"1\":{\"661\":1}}],[\"如果还没有正常获取到要使用的对象\",{\"1\":{\"652\":1}}],[\"如果还有其它服务接口暴露呢\",{\"1\":{\"226\":1}}],[\"如果对一个变量进行lock操作\",{\"1\":{\"650\":1}}],[\"如果对多个变量操作时\",{\"1\":{\"645\":1}}],[\"如果对语句的优化已经无法进行\",{\"1\":{\"137\":1}}],[\"如果直接调用thread的run\",{\"1\":{\"641\":1}}],[\"如果任务不需要返回结果或抛出异常推荐使用\",{\"1\":{\"629\":1,\"696\":1}}],[\"如果申请不到\",{\"1\":{\"627\":1,\"694\":1}}],[\"如果队列中没有线程就利用\",{\"1\":{\"617\":1}}],[\"如果处于排队等候机制中的线程一直无法获取锁\",{\"1\":{\"614\":1}}],[\"如果其前驱节点\",{\"1\":{\"612\":1}}],[\"如果threadlocal\",{\"1\":{\"665\":1}}],[\"如果tryacquire返回false\",{\"1\":{\"610\":1}}],[\"如果tailoffset的node和expect的node地址是相同的\",{\"1\":{\"607\":1}}],[\"如果后继节点获得锁成功\",{\"1\":{\"608\":1}}],[\"如果共享资源被占用\",{\"1\":{\"602\":1}}],[\"如果被请求的共享资源空闲\",{\"1\":{\"602\":1}}],[\"如果集合发生变化时修改modcount值刚好又设置为了expectedmodcount值\",{\"1\":{\"598\":1}}],[\"如果遍历过程中对集合对象的内容进行了修改\",{\"1\":{\"598\":1}}],[\"如果map\",{\"1\":{\"588\":1}}],[\"如果master过期了一个key\",{\"1\":{\"420\":1}}],[\"如果master和slave网络连接断掉了\",{\"1\":{\"420\":1,\"422\":1}}],[\"如果master\",{\"1\":{\"419\":1}}],[\"如果自旋重试的次数超过\",{\"1\":{\"585\":1}}],[\"如果自己设置了并发度\",{\"1\":{\"548\":1,\"589\":1}}],[\"如果最低要求的存储能力>arraylist已有的存储能力\",{\"1\":{\"573\":1}}],[\"如果此时另一个线程执行get\",{\"1\":{\"566\":1}}],[\"如果此时一个读请求过来\",{\"1\":{\"392\":1}}],[\"如果计算出来的索引位置是相同的\",{\"1\":{\"565\":1,\"583\":1}}],[\"如果发生了\",{\"1\":{\"558\":1,\"581\":1}}],[\"如果发现要过期了\",{\"1\":{\"394\":1,\"396\":1}}],[\"如果发现队列中已经有了该数据的更新缓存的请求了\",{\"1\":{\"392\":1}}],[\"如果发现数据不在缓存中\",{\"1\":{\"392\":1}}],[\"如果发现查询需要扫描大量的数据\",{\"1\":{\"138\":1}}],[\"如果链表节点大于\",{\"1\":{\"556\":1,\"580\":1}}],[\"如果大于8但是数组容量小于64\",{\"1\":{\"556\":1}}],[\"如果大于\",{\"1\":{\"556\":1,\"580\":1,\"721\":1}}],[\"如果冲突后是链表\",{\"1\":{\"556\":1,\"580\":1}}],[\"如果冲突后\",{\"1\":{\"556\":1,\"580\":1}}],[\"如果冲突了\",{\"1\":{\"556\":1,\"580\":1}}],[\"如果数组是空的\",{\"1\":{\"556\":1,\"580\":1}}],[\"如果数据需要变化时\",{\"1\":{\"473\":1}}],[\"如果数据量很少\",{\"1\":{\"413\":1}}],[\"如果数据库中有很多这种使用不到的过期键\",{\"1\":{\"386\":1}}],[\"如果数据库中的对应数据改变的之后\",{\"1\":{\"379\":1}}],[\"如果数据库系统\",{\"1\":{\"101\":1}}],[\"如果初始容量大于最大条目数除以负载因子\",{\"1\":{\"554\":1,\"578\":1}}],[\"如果内存空间紧张而对时间效率要求不高\",{\"1\":{\"554\":1,\"578\":1}}],[\"如果内存空间很多而又对时间效率要求很高\",{\"1\":{\"554\":1,\"578\":1}}],[\"如果传入的是个空数组则最小容量取默认容量与mincapacity之间的最大值\",{\"1\":{\"573\":1}}],[\"如果传入的是\",{\"1\":{\"549\":1,\"594\":1}}],[\"如果传输的数据比较大\",{\"1\":{\"23\":1}}],[\"如果变化发生在已遍历过的部分\",{\"1\":{\"548\":1,\"590\":1}}],[\"如果并发度设置的过大\",{\"1\":{\"548\":1}}],[\"如果并发度设置的过小\",{\"1\":{\"548\":1}}],[\"如果面试官不满意\",{\"1\":{\"548\":1,\"588\":1}}],[\"如果concurrenthashmap\",{\"1\":{\"548\":1}}],[\"如果consumer和queue不对等\",{\"0\":{\"371\":1}}],[\"如果都不满足\",{\"1\":{\"547\":1,\"585\":1}}],[\"如果重试的次数达到了\",{\"1\":{\"547\":1}}],[\"如果重发指定次数之后\",{\"1\":{\"15\":1}}],[\"如果获取对象锁失败\",{\"1\":{\"651\":1}}],[\"如果获取锁失败\",{\"1\":{\"606\":1}}],[\"如果获取不到则阻塞节点中对应的线程\",{\"1\":{\"605\":1}}],[\"如果获取不到锁\",{\"1\":{\"432\":1}}],[\"如果获取失败则调用doacquireshared\",{\"1\":{\"612\":1}}],[\"如果获取失败\",{\"1\":{\"585\":1,\"605\":1}}],[\"如果获取失败肯定就有其他线程存在竞争\",{\"1\":{\"547\":1}}],[\"如果运行时异常\",{\"1\":{\"535\":1}}],[\"如果强制要求调用者必须进行处理\",{\"1\":{\"531\":1}}],[\"如果我们进一步分析\",{\"1\":{\"555\":1}}],[\"如果我们的类写完后不再修改\",{\"1\":{\"525\":1}}],[\"如果我们创建了一个\",{\"1\":{\"336\":1}}],[\"如果显示指定了\",{\"1\":{\"525\":1}}],[\"如果相同则反序列化成功\",{\"1\":{\"525\":1}}],[\"如果相同就认为是一致的\",{\"1\":{\"524\":1}}],[\"如果jvm堆不存在了\",{\"1\":{\"518\":1}}],[\"如果构建泛型实例时使用了泛型语法\",{\"1\":{\"511\":1}}],[\"如果下次再有相同的值\",{\"1\":{\"499\":1}}],[\"如果下次创建同样的对象时\",{\"1\":{\"490\":1}}],[\"如果存在直接返回该常量\",{\"1\":{\"488\":2}}],[\"如果存在\",{\"1\":{\"487\":1}}],[\"如果存在自动将\",{\"1\":{\"40\":1}}],[\"如果字符串是可变的\",{\"1\":{\"482\":2}}],[\"如果每一次声明一个string都创建一个string对象\",{\"1\":{\"482\":1}}],[\"如果判断相同则会进行覆盖\",{\"1\":{\"480\":1}}],[\"如果判定某个\",{\"1\":{\"395\":1}}],[\"如果两者相同\",{\"1\":{\"478\":1}}],[\"如果两个变量的值不在此区间\",{\"1\":{\"499\":1}}],[\"如果两个变量的值在区间\",{\"1\":{\"499\":1}}],[\"如果两个对象相等\",{\"1\":{\"479\":1}}],[\"如果两个哨兵实例\",{\"1\":{\"428\":1}}],[\"如果两个表中一个较小\",{\"1\":{\"96\":1}}],[\"如果x\",{\"1\":{\"476\":1}}],[\"如果==是比较的两个对象\",{\"1\":{\"476\":1}}],[\"如果==比较的是基本数据类型\",{\"1\":{\"476\":1}}],[\"如果定义为\",{\"1\":{\"470\":1}}],[\"如果您想开发企业\",{\"1\":{\"447\":1}}],[\"如果您发现这个项目很好用\",{\"1\":{\"70\":1}}],[\"如果读并发继续增加的话\",{\"1\":{\"439\":1}}],[\"如果读取的进度已经跟上了master\",{\"1\":{\"132\":1}}],[\"如果现在有个读超高并发的系统\",{\"0\":{\"439\":1}}],[\"如果成功获取锁\",{\"1\":{\"437\":1}}],[\"如果线程池正在停止\",{\"1\":{\"714\":1}}],[\"如果线程池长度超过处理需要\",{\"1\":{\"672\":1}}],[\"如果线程是空闲状态则可以安全回收\",{\"1\":{\"714\":1}}],[\"如果线程c在读数据\",{\"1\":{\"667\":1}}],[\"如果线程\",{\"1\":{\"435\":2}}],[\"如果第一个选举出的哨兵切换失败了\",{\"1\":{\"427\":1}}],[\"如果第一个字符不是斜杠\",{\"1\":{\"71\":1}}],[\"如果上面两个条件都相同\",{\"1\":{\"426\":1}}],[\"如果slave\",{\"1\":{\"426\":1}}],[\"如果说一旦所有的slave\",{\"1\":{\"424\":1}}],[\"如果出现网络故障断开连接了\",{\"1\":{\"422\":1}}],[\"如果key已过期\",{\"1\":{\"421\":1}}],[\"如果主从复制过程中\",{\"1\":{\"420\":1}}],[\"如果主机a\",{\"1\":{\"22\":1}}],[\"如果这样\",{\"1\":{\"536\":1}}],[\"如果这是slave\",{\"1\":{\"420\":1}}],[\"如果这个值是null\",{\"1\":{\"714\":1}}],[\"如果这个值是非空的\",{\"1\":{\"714\":1}}],[\"如果这个线程异常结束\",{\"1\":{\"672\":1}}],[\"如果这个连接不做任何事情会造成不必要的线程开销\",{\"1\":{\"542\":1}}],[\"如果这个时间客户端向\",{\"1\":{\"403\":1}}],[\"如果这个\",{\"1\":{\"337\":1}}],[\"如果这个宕机的\",{\"1\":{\"323\":1}}],[\"如果这个bean已经实现了beanfactoryaware接口\",{\"1\":{\"274\":1}}],[\"如果故障转移发生了\",{\"1\":{\"419\":1}}],[\"如果服务端收到有exec\",{\"1\":{\"408\":1}}],[\"如果服务端重发的\",{\"1\":{\"18\":1}}],[\"如果事务执行前key被改动\",{\"1\":{\"408\":1}}],[\"如果缓在某一个时刻出现大规模的key失效\",{\"1\":{\"396\":1}}],[\"如果布隆过滤器判定某个\",{\"1\":{\"395\":1}}],[\"如果超时了就直接读旧值\",{\"1\":{\"392\":1}}],[\"如果超过了这个时间会被认为是丢包了\",{\"1\":{\"22\":1}}],[\"如果请求等待的时间超过一定时长\",{\"1\":{\"392\":1}}],[\"如果请求还在等待时间范围内\",{\"1\":{\"392\":1}}],[\"如果先更新缓存成功\",{\"1\":{\"389\":1}}],[\"如果执行的太少\",{\"1\":{\"386\":1}}],[\"如果执行的太频繁\",{\"1\":{\"386\":1}}],[\"如果过期\",{\"1\":{\"386\":1}}],[\"如果过期则执行删除并返回\",{\"1\":{\"386\":1}}],[\"如果redis被当做一个持久化存储使用\",{\"1\":{\"385\":1}}],[\"如果redis被当做缓存使用\",{\"1\":{\"385\":1}}],[\"如果一致则可以直接使用此对象\",{\"1\":{\"652\":1}}],[\"如果一直循环执行\",{\"1\":{\"645\":1}}],[\"如果一开始就用红黑树结构\",{\"1\":{\"553\":1,\"577\":1}}],[\"如果一秒内宕机\",{\"1\":{\"383\":1}}],[\"如果一个线程获得了锁\",{\"1\":{\"656\":1}}],[\"如果一个进程内有多个线程\",{\"1\":{\"620\":1,\"687\":1}}],[\"如果一个集合被声明为\",{\"1\":{\"516\":1}}],[\"如果一个不可重入锁被再次加锁\",{\"1\":{\"435\":1}}],[\"如果一个锁支持一个线程多次加锁\",{\"1\":{\"435\":1}}],[\"如果一个得到锁的线程在执行任务的过程中挂掉\",{\"1\":{\"434\":1}}],[\"如果一个slave跟master断开连接已经超过了down\",{\"1\":{\"426\":1}}],[\"如果一个master被认为odown了\",{\"1\":{\"426\":1}}],[\"如果一个master被标记为主观下线\",{\"1\":{\"425\":1}}],[\"如果一个实例\",{\"1\":{\"425\":1}}],[\"如果一个客户端跟\",{\"1\":{\"403\":1}}],[\"如果一个键已经过期\",{\"1\":{\"386\":1}}],[\"如果一个bean不知道属于哪个层\",{\"1\":{\"271\":1}}],[\"如果一个服务有多个提供者支持\",{\"1\":{\"257\":1}}],[\"如果一个服务端要提供多个服务的接口\",{\"1\":{\"229\":1}}],[\"如果只重写了equals方法\",{\"1\":{\"480\":1}}],[\"如果只需要统计数据的二值状态\",{\"1\":{\"382\":1}}],[\"如果只把很长字段的前面的公共部分作为一个索引\",{\"1\":{\"155\":1}}],[\"如果设置返回1说明获取锁成功\",{\"1\":{\"381\":1}}],[\"如果broker主动推送消息的话有可能push速度快\",{\"1\":{\"366\":1}}],[\"如果bean实现了beanfactoryaware接口\",{\"1\":{\"274\":1}}],[\"如果bean实现了beanclassloaderaware接口\",{\"1\":{\"274\":1}}],[\"如果bean实现了beannameaware接口\",{\"1\":{\"274\":1}}],[\"如果做集群消费\",{\"1\":{\"362\":1}}],[\"如果做广播消费\",{\"1\":{\"362\":1}}],[\"如果新系统需要数据\",{\"1\":{\"346\":1}}],[\"如果按照原来的逻辑\",{\"1\":{\"345\":1}}],[\"如果i\",{\"1\":{\"341\":2}}],[\"如果消息没有按序消费\",{\"1\":{\"335\":1}}],[\"如果该线程现在不是独占锁的状态\",{\"1\":{\"714\":1}}],[\"如果该方法返回了true\",{\"1\":{\"605\":1}}],[\"如果该方法的累计调用次数>15\",{\"1\":{\"507\":1}}],[\"如果该方法的累计调用次数<=15\",{\"1\":{\"507\":1}}],[\"如果该字符串已经存在了\",{\"1\":{\"482\":1}}],[\"如果该\",{\"1\":{\"334\":1}}],[\"如果该处理逻辑中有对单例状态的修改\",{\"1\":{\"282\":1}}],[\"如果没满足这个条件\",{\"1\":{\"333\":1}}],[\"如果没有释放消息队列或者没有关闭操作系统\",{\"1\":{\"726\":1}}],[\"如果没有的话\",{\"1\":{\"722\":1}}],[\"如果没有哈希冲突直接放在对应的数组下标里\",{\"1\":{\"556\":1,\"580\":1}}],[\"如果没有相符的hashcode\",{\"1\":{\"478\":1}}],[\"如果没有redisha系统\",{\"1\":{\"415\":1}}],[\"如果没有过期则返回正常信息给客户端\",{\"1\":{\"386\":1}}],[\"如果没有namespace\",{\"1\":{\"185\":1,\"191\":1}}],[\"如果没有配置namespace\",{\"1\":{\"185\":1,\"191\":1}}],[\"如果没有使用索引下推技术\",{\"1\":{\"156\":1}}],[\"如果没有找到\",{\"1\":{\"357\":1,\"488\":2}}],[\"如果没有找到匹配项\",{\"1\":{\"71\":2}}],[\"如果没有找到说明用户没有登录或者登录失效\",{\"1\":{\"40\":1}}],[\"如果没有\",{\"1\":{\"38\":1}}],[\"如果leader宕机了\",{\"1\":{\"330\":1}}],[\"如果p1再次出现冲突\",{\"1\":{\"576\":1}}],[\"如果p=h\",{\"1\":{\"576\":1}}],[\"如果push的速度太慢\",{\"1\":{\"324\":1}}],[\"如果push的速度太快\",{\"1\":{\"324\":1}}],[\"如果ping后是绿色或黄色\",{\"1\":{\"62\":1}}],[\"如果某个redis实例有故障\",{\"1\":{\"419\":1}}],[\"如果某个键的过期时间已经到了\",{\"1\":{\"386\":1}}],[\"如果某个系统不需要这条数据了\",{\"1\":{\"346\":1}}],[\"如果某个\",{\"1\":{\"323\":1}}],[\"如果视图使用\",{\"1\":{\"299\":1}}],[\"如果当前数组的长度小于\",{\"1\":{\"553\":1,\"575\":1}}],[\"如果当前存在事务\",{\"1\":{\"289\":4}}],[\"如果当前没有事务\",{\"1\":{\"289\":4}}],[\"如果目标类没有实现接口\",{\"1\":{\"284\":1}}],[\"如果属性的类型与\",{\"1\":{\"278\":1}}],[\"如果实现了自定义的销毁方法\",{\"1\":{\"276\":1}}],[\"如果实现了disposablebean的destroy方法\",{\"1\":{\"276\":1}}],[\"如果实现了beanfactorypostprocessor接口的afterpropertiesset方法\",{\"1\":{\"274\":1}}],[\"如果通过aware接口声明了依赖关系\",{\"1\":{\"274\":1}}],[\"如果你又提交了新的任务\",{\"1\":{\"672\":1}}],[\"如果你创建了一个threadlocal变量\",{\"1\":{\"663\":1}}],[\"如果你只用try去处理普通异常却不加以catch处理\",{\"1\":{\"535\":1}}],[\"如果你的服务器上部署的不止一个应用\",{\"1\":{\"717\":1}}],[\"如果你的代码尝试不用实例来访问非static的变量\",{\"1\":{\"457\":1}}],[\"如果你的数据量很大\",{\"1\":{\"413\":1}}],[\"如果你的bean有多种状态的话\",{\"1\":{\"282\":1}}],[\"如果你使用了mq\",{\"1\":{\"345\":1}}],[\"如果你在\",{\"1\":{\"272\":1}}],[\"如果你对列进行了\",{\"1\":{\"167\":1}}],[\"如果为首节点则不断尝试获取同步状态\",{\"1\":{\"611\":1}}],[\"如果为\",{\"1\":{\"547\":2,\"585\":2}}],[\"如果为文件\",{\"1\":{\"196\":1}}],[\"如果为路径则递归loadmappersinfo\",{\"1\":{\"196\":1}}],[\"如果配置了namespace\",{\"1\":{\"185\":1,\"191\":1}}],[\"如果用于equals比较的对象信息没有被修改的话\",{\"1\":{\"476\":1}}],[\"如果用\",{\"1\":{\"178\":1}}],[\"如果需要回收核心线程数\",{\"1\":{\"722\":1}}],[\"如果需要回滚\",{\"1\":{\"104\":1}}],[\"如果需要预热的话可以调用下面的两个方法\",{\"1\":{\"722\":1}}],[\"如果需要自定义同步器一般的方式是这样\",{\"1\":{\"678\":1}}],[\"如果需要访问当前线程\",{\"1\":{\"621\":1,\"688\":1}}],[\"如果需要\",{\"1\":{\"443\":1}}],[\"如果需要缓存1t+的数据\",{\"1\":{\"439\":1}}],[\"如果需要缓存能够支持更复杂的结构和操作\",{\"1\":{\"378\":1}}],[\"如果需要传一个字符串或者一个dog\",{\"1\":{\"219\":1}}],[\"如果需要实现支持多种数据库的软件\",{\"1\":{\"178\":1}}],[\"如果能将数据库记录封装成pojo对象解析比较方便\",{\"1\":{\"176\":1}}],[\"如果项目需要支持多种数据库\",{\"1\":{\"175\":1}}],[\"如果or连接的是同一个字段\",{\"1\":{\"168\":1}}],[\"如果使用reentrantlock\",{\"1\":{\"667\":1}}],[\"如果使用不当没有\",{\"1\":{\"647\":1}}],[\"如果使用基本类型的话\",{\"1\":{\"493\":1}}],[\"如果使用的是\",{\"1\":{\"391\":1}}],[\"如果使用\",{\"1\":{\"346\":1,\"347\":1,\"510\":1}}],[\"如果使用数据库链接池可解决此问题\",{\"1\":{\"176\":1}}],[\"如果使用函数在索引列\",{\"1\":{\"166\":1}}],[\"如果使用了索引下推技术\",{\"1\":{\"156\":1}}],[\"如果符合条件\",{\"1\":{\"156\":1}}],[\"如果age的值也相等\",{\"1\":{\"153\":1}}],[\"如果name相同\",{\"1\":{\"153\":1}}],[\"如果全部命中了索引\",{\"1\":{\"152\":1}}],[\"如果把所有同一内部节点的关键字存放在同一盘块中\",{\"1\":{\"150\":1}}],[\"如果不希望任务被拒绝\",{\"1\":{\"673\":1}}],[\"如果不一致\",{\"1\":{\"652\":1}}],[\"如果不为空则判断传入的\",{\"1\":{\"585\":1}}],[\"如果不对它减1而直接操作\",{\"1\":{\"555\":1}}],[\"如果不显示指定serialversionuid\",{\"1\":{\"525\":1}}],[\"如果不通过直接抛出异常\",{\"1\":{\"507\":1}}],[\"如果不存在\",{\"1\":{\"487\":1}}],[\"如果不存在就直接返回\",{\"1\":{\"395\":1}}],[\"如果不同的话\",{\"1\":{\"478\":1}}],[\"如果不同程序会并发存取多个表\",{\"1\":{\"118\":1}}],[\"如果不考虑\",{\"1\":{\"399\":1}}],[\"如果不进行预热\",{\"1\":{\"397\":1}}],[\"如果不采用给缓存设置过期时间策略\",{\"1\":{\"390\":1}}],[\"如果不能\",{\"1\":{\"278\":1}}],[\"如果不符合\",{\"1\":{\"156\":1}}],[\"如果不是running\",{\"1\":{\"713\":1}}],[\"如果不是\",{\"1\":{\"141\":1}}],[\"如果有其他线程刚好在尝试获取锁\",{\"1\":{\"653\":1}}],[\"如果有的话\",{\"1\":{\"633\":1,\"701\":1}}],[\"如果有则不会尝试获取锁\",{\"1\":{\"617\":1}}],[\"如果有多个线程会访问到集合\",{\"1\":{\"572\":1}}],[\"如果有\",{\"1\":{\"537\":1}}],[\"如果有恶意攻击者不断请求系统中不存在的数据\",{\"1\":{\"395\":1}}],[\"如果有两个方法需要调用呢\",{\"1\":{\"219\":1}}],[\"如果有大量重复键值得情况下\",{\"1\":{\"150\":1}}],[\"如果有些字段的使用频率很低\",{\"1\":{\"140\":1}}],[\"如果有错误\",{\"1\":{\"71\":1}}],[\"如果是则更改为新的值\",{\"1\":{\"644\":1}}],[\"如果是链表结构\",{\"1\":{\"547\":1}}],[\"如果是红黑树结构\",{\"1\":{\"547\":1}}],[\"如果是首节点\",{\"1\":{\"547\":1}}],[\"如果是普通异常\",{\"1\":{\"535\":1}}],[\"如果是基本类型的包装类\",{\"1\":{\"503\":1}}],[\"如果是读高并发的话\",{\"1\":{\"439\":1}}],[\"如果是海量数据\",{\"1\":{\"413\":1}}],[\"如果是客户端要从\",{\"1\":{\"403\":1}}],[\"如果是客户端要写数据到\",{\"1\":{\"403\":1}}],[\"如果是客户端要连接\",{\"1\":{\"403\":1}}],[\"如果是单线程则可以规避进程内频繁的线程切换开销\",{\"1\":{\"399\":1}}],[\"如果是用做内存数据库\",{\"1\":{\"384\":1}}],[\"如果是数据比较重要\",{\"1\":{\"384\":1}}],[\"如果是数据不那么敏感\",{\"1\":{\"384\":1}}],[\"如果是覆盖索引的话\",{\"1\":{\"151\":1}}],[\"如果是\",{\"1\":{\"141\":1}}],[\"如果是的话可以进行横向或者纵向的分表\",{\"1\":{\"137\":1}}],[\"如果是两次握手\",{\"1\":{\"12\":1}}],[\"如果业务处理不好可以用分布式事务锁或者使用乐观锁\",{\"1\":{\"118\":1}}],[\"如果要与不同主机的进程间通信\",{\"1\":{\"731\":1}}],[\"如果要双向通信\",{\"1\":{\"731\":1}}],[\"如果要访问当前线程\",{\"1\":{\"621\":1,\"688\":1}}],[\"如果要想进行数据库的连接\",{\"1\":{\"506\":1}}],[\"如果要想使用application\",{\"1\":{\"305\":2}}],[\"如果要支撑大规模的\",{\"1\":{\"350\":1}}],[\"如果要执行更新操作\",{\"1\":{\"112\":1}}],[\"如果要建立聚簇索引\",{\"1\":{\"86\":1}}],[\"如果表没有主键\",{\"1\":{\"112\":1}}],[\"如果在新表的数组索引位置相同\",{\"1\":{\"559\":1}}],[\"如果在高并发的情况下\",{\"1\":{\"396\":1}}],[\"如果在事务中混合使用了事务型和非事务型的表\",{\"1\":{\"109\":1}}],[\"如果在设计不良的程序中忽略了检查\",{\"1\":{\"45\":1}}],[\"如果查询语句使用了not\",{\"1\":{\"96\":1}}],[\"如果查询的两个表大小相当\",{\"1\":{\"96\":1}}],[\"如果确定某个字段的值的长度\",{\"1\":{\"95\":1}}],[\"如果建立\",{\"1\":{\"84\":2,\"154\":2,\"161\":2}}],[\"如果指定的key存在\",{\"1\":{\"82\":1}}],[\"如果\",{\"0\":{\"536\":1},\"1\":{\"69\":1,\"117\":1,\"346\":1,\"399\":2,\"484\":1,\"537\":1,\"555\":1,\"617\":2}}],[\"如果找到匹配的proxyip\",{\"1\":{\"71\":2}}],[\"如果找到\",{\"1\":{\"40\":1,\"357\":1}}],[\"如果证书没有问题\",{\"1\":{\"37\":1}}],[\"如果证书不是可信机构颁布\",{\"1\":{\"37\":1}}],[\"如果客户端由于某些原因获取锁失败\",{\"1\":{\"437\":1}}],[\"如果客户端可以等待锁释放就无法使用\",{\"1\":{\"435\":1}}],[\"如果客户端没有主动释放锁\",{\"1\":{\"431\":1}}],[\"如果客户端与服务器之间出现通讯故障并导致网络断开\",{\"1\":{\"407\":1}}],[\"如果客户端已经准备好接受数据后\",{\"1\":{\"403\":1}}],[\"如果客户端再次访问这个服务器上的网页\",{\"1\":{\"31\":1}}],[\"如果客户端浏览器访问的某个html或其他类型的\",{\"1\":{\"31\":1}}],[\"如果客户端向服务端发送数据\",{\"1\":{\"15\":1}}],[\"如果三次握手阶段\",{\"1\":{\"19\":1}}],[\"如果已经建立了连接\",{\"0\":{\"19\":1}}],[\"如果未接受到\",{\"1\":{\"14\":1}}],[\"如果接收到客户端的\",{\"1\":{\"14\":1}}],[\"如果同意建立连接\",{\"1\":{\"11\":1}}],[\"如\",{\"0\":{\"607\":1},\"1\":{\"10\":1,\"19\":1,\"166\":1,\"301\":1,\"362\":1,\"415\":1,\"444\":1,\"472\":1,\"511\":1,\"527\":1,\"539\":1,\"555\":1,\"564\":1,\"623\":1,\"690\":1,\"731\":1}}],[\"如加密解密\",{\"1\":{\"8\":1}}],[\"如域名系统dns\",{\"1\":{\"8\":1}}],[\"七层网络体系结构各层的主要功能\",{\"1\":{\"8\":1}}],[\"1位置\",{\"1\":{\"566\":1}}],[\"1处的if\",{\"1\":{\"565\":1}}],[\"1再赋值给n的目的是另找到的目标值大于或等于原值\",{\"1\":{\"555\":1}}],[\"1相与\",{\"1\":{\"555\":1}}],[\"1st\",{\"1\":{\"556\":1}}],[\"1s\",{\"1\":{\"347\":2}}],[\"1producer需要等待isr中的所有follower都确认接收到数据后才算一次发送完成\",{\"1\":{\"330\":1}}],[\"1px\",{\"1\":{\"70\":1}}],[\"1分别是什么意思\",{\"0\":{\"330\":1}}],[\"1以上\",{\"1\":{\"161\":1}}],[\"1a0dab\",{\"1\":{\"70\":1}}],[\"1978198479659022715l\",{\"1\":{\"594\":1}}],[\"1986\",{\"1\":{\"157\":1}}],[\"19\",{\"0\":{\"45\":1,\"190\":1,\"284\":1,\"396\":1,\"587\":1,\"646\":1}}],[\"1875015\",{\"1\":{\"685\":1}}],[\"18次\",{\"1\":{\"373\":1}}],[\"18\",{\"0\":{\"44\":1,\"163\":1,\"189\":1,\"283\":1,\"342\":1,\"395\":1,\"586\":1,\"645\":1},\"1\":{\"69\":4,\"70\":4,\"159\":1,\"551\":1}}],[\"1v1的模式黑客无法占上风\",{\"1\":{\"43\":1}}],[\"1支持的特性\",{\"1\":{\"34\":1}}],[\"1支持长连接\",{\"1\":{\"33\":1}}],[\"1和\",{\"0\":{\"34\":1}}],[\"1的头部\",{\"1\":{\"34\":1}}],[\"1的解析是基于文本\",{\"1\":{\"34\":1}}],[\"1的请求消息和响应消息都应支持host头域\",{\"1\":{\"33\":1}}],[\"1的区别\",{\"0\":{\"33\":1}}],[\"1中新增了24个错误状态响应码\",{\"1\":{\"33\":1}}],[\"1中默认开启connection\",{\"1\":{\"33\":1}}],[\"1则在请求头引入了range头域\",{\"1\":{\"33\":1}}],[\"1则引入了更多的缓存控制策略\",{\"1\":{\"33\":1}}],[\"1起\",{\"1\":{\"31\":1}}],[\"17524833145151l\",{\"1\":{\"200\":1}}],[\"175\",{\"1\":{\"168\":1}}],[\"170\",{\"1\":{\"70\":1}}],[\"1712021855314\",{\"1\":{\"55\":1}}],[\"17\",{\"0\":{\"24\":1,\"43\":1,\"162\":1,\"188\":1,\"282\":1,\"341\":1,\"394\":1,\"585\":1,\"644\":1},\"1\":{\"69\":2,\"70\":2,\"435\":1}}],[\"16扩充为\",{\"1\":{\"559\":1}}],[\"163\",{\"1\":{\"70\":1}}],[\"16\",{\"0\":{\"23\":1,\"42\":1,\"161\":1,\"187\":1,\"281\":1,\"340\":1,\"393\":1,\"584\":1,\"643\":1},\"1\":{\"48\":1,\"69\":4,\"70\":5,\"159\":2,\"343\":1,\"449\":2,\"546\":2,\"555\":5,\"579\":2,\"737\":1}}],[\"1500\",{\"1\":{\"70\":2}}],[\"15px\",{\"1\":{\"70\":3}}],[\"1537628\",{\"1\":{\"25\":1}}],[\"15\",{\"0\":{\"22\":1,\"41\":1,\"89\":1,\"160\":1,\"186\":1,\"280\":1,\"339\":1,\"390\":1,\"583\":1,\"642\":1},\"1\":{\"69\":3,\"70\":2,\"551\":1,\"555\":1}}],[\"14952074175\",{\"1\":{\"60\":1}}],[\"14\",{\"0\":{\"21\":1,\"40\":1,\"88\":1,\"159\":1,\"185\":1,\"279\":1,\"338\":1,\"389\":1,\"582\":1,\"641\":1,\"709\":1},\"1\":{\"69\":1,\"70\":1,\"505\":4}}],[\"13390538\",{\"1\":{\"685\":1}}],[\"13335\",{\"1\":{\"52\":3,\"65\":2}}],[\"132585\",{\"1\":{\"52\":1}}],[\"132203\",{\"1\":{\"52\":1}}],[\"13\",{\"0\":{\"20\":1,\"39\":1,\"87\":1,\"158\":1,\"184\":1,\"278\":1,\"335\":1,\"388\":1,\"581\":1,\"640\":1,\"708\":1},\"1\":{\"32\":1,\"69\":1,\"70\":1,\"343\":1,\"348\":1,\"555\":1}}],[\"12690630\",{\"1\":{\"723\":1}}],[\"12638546\",{\"1\":{\"25\":1}}],[\"128和127\",{\"1\":{\"499\":1}}],[\"128~127\",{\"1\":{\"499\":1}}],[\"128~127之内\",{\"1\":{\"499\":1}}],[\"128\",{\"1\":{\"499\":4}}],[\"128到127之间\",{\"1\":{\"499\":1}}],[\"12版本上为set指令增加了可选参数\",{\"1\":{\"435\":1}}],[\"127之间时\",{\"1\":{\"499\":1}}],[\"127\",{\"1\":{\"216\":1,\"223\":1,\"237\":1,\"251\":2,\"499\":3}}],[\"123f\",{\"1\":{\"70\":1}}],[\"12小时\",{\"1\":{\"57\":4}}],[\"120秒的时间\",{\"1\":{\"43\":1}}],[\"12\",{\"0\":{\"19\":1,\"38\":1,\"86\":1,\"157\":1,\"183\":1,\"277\":1,\"387\":1,\"580\":1,\"639\":1,\"707\":1},\"1\":{\"32\":1,\"69\":2,\"70\":2,\"71\":1,\"348\":2,\"382\":1,\"435\":1,\"551\":1,\"555\":1,\"579\":1,\"618\":1,\"718\":1}}],[\"12秒后重新发送syn+ack包\",{\"1\":{\"15\":1}}],[\"1msl\",{\"1\":{\"18\":2}}],[\"115200512\",{\"1\":{\"685\":1}}],[\"1111位置处是不可能存储数据的\",{\"1\":{\"555\":1}}],[\"1110\",{\"1\":{\"555\":1}}],[\"1101\",{\"1\":{\"555\":1}}],[\"1190000039258680\",{\"1\":{\"685\":1}}],[\"1190000010162647\",{\"1\":{\"544\":1}}],[\"1190000023716306\",{\"1\":{\"343\":1}}],[\"1190000021494676\",{\"1\":{\"37\":1,\"48\":1}}],[\"1190000021815671\",{\"1\":{\"25\":1}}],[\"11693260\",{\"1\":{\"483\":1}}],[\"1162213\",{\"1\":{\"438\":1}}],[\"112\",{\"1\":{\"32\":1}}],[\"11\",{\"0\":{\"18\":1,\"37\":1,\"85\":1,\"112\":1,\"156\":1,\"182\":1,\"273\":1,\"331\":1,\"361\":1,\"386\":1,\"579\":1,\"638\":1,\"706\":1},\"1\":{\"48\":1,\"69\":1,\"70\":1,\"474\":1,\"555\":1,\"564\":1}}],[\"105321401\",{\"1\":{\"685\":1}}],[\"109809836\",{\"1\":{\"544\":1}}],[\"1099511627776\",{\"1\":{\"71\":2}}],[\"10829368\",{\"1\":{\"544\":1}}],[\"10853\",{\"1\":{\"343\":1}}],[\"10856177\",{\"1\":{\"48\":1}}],[\"10765839\",{\"1\":{\"537\":1}}],[\"10万次读写操作\",{\"1\":{\"376\":1}}],[\"104778621\",{\"1\":{\"144\":2}}],[\"104483455\",{\"1\":{\"25\":1}}],[\"1001\",{\"1\":{\"555\":1}}],[\"100\",{\"1\":{\"70\":1,\"223\":1,\"230\":1,\"499\":2,\"622\":1,\"689\":1,\"717\":1}}],[\"10000\",{\"1\":{\"231\":1,\"396\":1,\"496\":2,\"497\":2,\"498\":1}}],[\"100000\",{\"1\":{\"136\":1,\"316\":1}}],[\"1000000\",{\"1\":{\"136\":2}}],[\"10001\",{\"1\":{\"157\":1}}],[\"1000\",{\"1\":{\"69\":1,\"71\":1,\"121\":1,\"230\":1,\"251\":1,\"391\":1}}],[\"10px\",{\"1\":{\"70\":2}}],[\"1011\",{\"1\":{\"555\":1}}],[\"101681073\",{\"1\":{\"544\":1}}],[\"101\",{\"1\":{\"69\":1,\"70\":1}}],[\"1024tools\",{\"1\":{\"60\":1}}],[\"1024\",{\"1\":{\"38\":1,\"71\":2}}],[\"10\",{\"0\":{\"17\":1,\"36\":1,\"84\":1,\"111\":1,\"155\":1,\"181\":1,\"272\":1,\"330\":1,\"360\":1,\"385\":1,\"578\":1,\"637\":1,\"705\":1},\"1\":{\"19\":1,\"64\":1,\"69\":1,\"70\":1,\"95\":2,\"136\":3,\"157\":1,\"223\":1,\"237\":1,\"316\":1,\"338\":1,\"350\":2,\"424\":1,\"425\":2,\"426\":1,\"536\":2,\"544\":1,\"555\":1}}],[\"1\",{\"0\":{\"8\":1,\"27\":1,\"54\":1,\"57\":1,\"73\":1,\"91\":1,\"100\":1,\"113\":1,\"121\":1,\"129\":1,\"134\":1,\"146\":1,\"164\":1,\"172\":1,\"220\":1,\"263\":1,\"321\":1,\"330\":1,\"351\":1,\"362\":1,\"376\":1,\"553\":1,\"569\":1,\"603\":1,\"620\":1,\"668\":1,\"677\":1,\"682\":1,\"687\":1,\"711\":1,\"716\":1,\"732\":1},\"1\":{\"11\":3,\"16\":7,\"20\":2,\"31\":2,\"32\":4,\"33\":1,\"52\":3,\"61\":1,\"68\":2,\"69\":21,\"70\":23,\"71\":22,\"75\":2,\"79\":1,\"84\":7,\"98\":1,\"103\":1,\"112\":4,\"117\":1,\"118\":1,\"148\":1,\"154\":2,\"155\":8,\"157\":2,\"159\":1,\"161\":3,\"167\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"183\":2,\"188\":1,\"189\":1,\"193\":1,\"196\":1,\"198\":1,\"202\":2,\"205\":1,\"216\":1,\"223\":2,\"230\":1,\"237\":2,\"244\":6,\"251\":4,\"258\":1,\"274\":1,\"275\":1,\"281\":1,\"330\":1,\"334\":2,\"340\":2,\"348\":1,\"349\":1,\"353\":1,\"364\":1,\"369\":1,\"377\":1,\"381\":1,\"382\":3,\"386\":1,\"391\":1,\"396\":1,\"399\":1,\"407\":1,\"420\":1,\"424\":1,\"431\":1,\"432\":1,\"434\":1,\"435\":3,\"449\":4,\"465\":1,\"467\":1,\"481\":1,\"482\":1,\"499\":3,\"506\":1,\"510\":3,\"544\":1,\"547\":1,\"551\":1,\"553\":2,\"555\":11,\"556\":3,\"558\":2,\"559\":5,\"564\":3,\"565\":7,\"566\":3,\"571\":2,\"573\":2,\"579\":2,\"581\":2,\"583\":4,\"585\":1,\"603\":1,\"605\":2,\"606\":1,\"616\":2,\"617\":2,\"621\":1,\"623\":2,\"629\":1,\"645\":1,\"648\":1,\"653\":1,\"662\":1,\"672\":1,\"675\":1,\"688\":1,\"690\":2,\"696\":1,\"707\":1,\"708\":1,\"711\":1,\"714\":3,\"717\":1,\"720\":1,\"721\":1,\"728\":2,\"729\":1,\"731\":1}}],[\"老规矩\",{\"1\":{\"7\":1}}],[\"今天先来看下第一期\",{\"1\":{\"7\":1}}],[\"n为table的长度\",{\"1\":{\"555\":1,\"579\":1}}],[\"n个这样的master节点就可以支持1t+的海量数据的存储了\",{\"1\":{\"439\":1}}],[\"nx\",{\"1\":{\"435\":1}}],[\"nx|xx\",{\"1\":{\"435\":1}}],[\"n>=1\",{\"1\":{\"416\":1}}],[\"nil\",{\"1\":{\"409\":1}}],[\"nio一般适用于连接数目多且连接比较短\",{\"1\":{\"542\":1}}],[\"nio\",{\"0\":{\"542\":1},\"1\":{\"484\":1,\"542\":1}}],[\"niosocketchannel\",{\"1\":{\"237\":1}}],[\"nioserversocketchannel\",{\"1\":{\"237\":1}}],[\"nioeventloopgroup\",{\"1\":{\"237\":5}}],[\"nip\",{\"1\":{\"71\":2}}],[\"nsert\",{\"1\":{\"162\":1}}],[\"n棵子tree的节点包含n个关键字\",{\"1\":{\"149\":1}}],[\"n域名\",{\"1\":{\"71\":1}}],[\"n$\",{\"1\":{\"71\":1}}],[\"n组织\",{\"1\":{\"71\":1}}],[\"n<tg\",{\"1\":{\"71\":3}}],[\"n国家\",{\"1\":{\"71\":1}}],[\"nv2ray\",{\"1\":{\"70\":1}}],[\"num\",{\"1\":{\"494\":4,\"511\":5}}],[\"numberformatexception\",{\"1\":{\"499\":1,\"531\":1,\"532\":3,\"534\":1}}],[\"number\",{\"1\":{\"69\":1,\"70\":5,\"510\":1,\"554\":3,\"578\":3}}],[\"nullpointexception\",{\"1\":{\"531\":1}}],[\"nullpointerexception\",{\"1\":{\"493\":1,\"534\":1}}],[\"null\",{\"0\":{\"588\":1},\"1\":{\"69\":12,\"70\":17,\"71\":12,\"93\":1,\"94\":2,\"112\":1,\"157\":1,\"160\":1,\"197\":1,\"198\":2,\"200\":1,\"201\":1,\"202\":1,\"203\":2,\"204\":6,\"223\":1,\"230\":1,\"237\":3,\"244\":5,\"251\":3,\"313\":6,\"317\":1,\"386\":1,\"395\":1,\"443\":1,\"476\":1,\"481\":1,\"493\":2,\"499\":1,\"506\":3,\"507\":2,\"527\":1,\"547\":1,\"548\":16,\"555\":1,\"556\":11,\"558\":3,\"559\":16,\"560\":3,\"565\":3,\"579\":1,\"581\":3,\"585\":1,\"588\":15,\"594\":1,\"607\":1,\"611\":1,\"612\":1,\"617\":1,\"653\":1,\"714\":2}}],[\"n\",{\"1\":{\"69\":1,\"70\":3,\"71\":12,\"337\":2,\"399\":2,\"546\":1,\"549\":1,\"553\":2,\"555\":18,\"556\":6,\"559\":3,\"565\":1,\"571\":3,\"575\":1,\"577\":1,\"584\":1,\"591\":1}}],[\"nested\",{\"1\":{\"289\":1}}],[\"never\",{\"1\":{\"289\":1}}],[\"nekobox\",{\"1\":{\"71\":1}}],[\"nextc\",{\"1\":{\"616\":3,\"617\":3}}],[\"nextwaiter\",{\"1\":{\"603\":1}}],[\"next永远不会为空\",{\"1\":{\"564\":1}}],[\"next导致了next指向了节点a\",{\"1\":{\"564\":1}}],[\"nextint\",{\"1\":{\"216\":1,\"258\":1}}],[\"nextboolean\",{\"1\":{\"216\":1}}],[\"next\",{\"1\":{\"70\":1,\"110\":1,\"203\":2,\"204\":1,\"506\":3,\"546\":1,\"547\":1,\"556\":2,\"558\":5,\"559\":9,\"564\":7,\"581\":5,\"586\":2,\"598\":1,\"603\":1,\"607\":1,\"612\":1}}],[\"need\",{\"1\":{\"69\":5,\"70\":3}}],[\"newfixedthreadpool\",{\"1\":{\"672\":1}}],[\"newcachedthreadpool\",{\"1\":{\"672\":1}}],[\"newcap\",{\"1\":{\"559\":8}}],[\"newcapacity\",{\"1\":{\"558\":5,\"573\":6,\"581\":5}}],[\"newtalbe\",{\"1\":{\"564\":1}}],[\"newtab\",{\"1\":{\"559\":7}}],[\"newtable\",{\"1\":{\"558\":8,\"564\":1,\"581\":8}}],[\"newthr\",{\"1\":{\"559\":6}}],[\"newnode\",{\"1\":{\"556\":2,\"565\":2}}],[\"newuser\",{\"1\":{\"521\":2}}],[\"new创建新对象\",{\"1\":{\"471\":1}}],[\"new的时候才会产生的东西\",{\"1\":{\"458\":1}}],[\"newproxyinstance\",{\"1\":{\"200\":1,\"223\":1}}],[\"newinstance\",{\"1\":{\"194\":1,\"200\":6,\"203\":1,\"505\":3,\"506\":1,\"507\":2,\"522\":2}}],[\"newaddressesnotlscsv\",{\"1\":{\"71\":2}}],[\"newaddressesnotlsapi\",{\"1\":{\"71\":2}}],[\"newaddressescsv\",{\"1\":{\"71\":5}}],[\"newaddressesapi\",{\"1\":{\"71\":4}}],[\"newapi\",{\"1\":{\"71\":3}}],[\"newlines\",{\"1\":{\"70\":1}}],[\"newheaders\",{\"1\":{\"69\":6,\"70\":6}}],[\"new\",{\"1\":{\"69\":37,\"70\":46,\"71\":18,\"193\":1,\"194\":5,\"195\":3,\"196\":2,\"197\":2,\"198\":5,\"200\":4,\"201\":1,\"203\":5,\"204\":3,\"216\":10,\"223\":10,\"229\":2,\"230\":20,\"237\":18,\"244\":10,\"245\":4,\"251\":11,\"258\":1,\"268\":1,\"289\":1,\"314\":6,\"315\":2,\"316\":1,\"319\":1,\"473\":1,\"484\":1,\"488\":10,\"493\":2,\"496\":2,\"497\":1,\"498\":1,\"499\":4,\"503\":1,\"505\":1,\"506\":2,\"507\":2,\"510\":1,\"516\":2,\"521\":6,\"522\":6,\"532\":1,\"543\":3,\"558\":1,\"559\":1,\"560\":3,\"581\":1,\"605\":1,\"607\":1,\"616\":1,\"617\":2,\"623\":2,\"635\":1,\"638\":3,\"663\":1,\"684\":1,\"690\":2,\"703\":1,\"712\":1}}],[\"newguid\",{\"1\":{\"69\":1,\"70\":1}}],[\"newschedulethreadpool\",{\"1\":{\"672\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"672\":1}}],[\"newstate\",{\"1\":{\"604\":1}}],[\"newspaper\",{\"1\":{\"70\":1}}],[\"news\",{\"1\":{\"65\":1,\"70\":9}}],[\"nettyclienthandler\",{\"1\":{\"237\":1,\"245\":1}}],[\"nettyclientinitializer\",{\"1\":{\"237\":1,\"245\":1}}],[\"netty客户端初始化\",{\"1\":{\"237\":1}}],[\"netty的自带的解码编码支持传输这种结构\",{\"1\":{\"237\":1}}],[\"nettyserverinitializer\",{\"1\":{\"237\":2}}],[\"netty服务端启动了\",{\"1\":{\"237\":1}}],[\"nettyrpcserverhandler\",{\"1\":{\"237\":2}}],[\"nettyrpcserver\",{\"1\":{\"237\":1}}],[\"nettyrpcclient\",{\"1\":{\"237\":4,\"251\":1}}],[\"netty\",{\"1\":{\"237\":5}}],[\"netty<\",{\"1\":{\"237\":1}}],[\"netty高性能网络框架的使用\",{\"1\":{\"235\":1}}],[\"netease\",{\"1\":{\"70\":3}}],[\"netlify\",{\"1\":{\"60\":1}}],[\"netuuid=9afa0f97\",{\"1\":{\"53\":1}}],[\"networking\",{\"1\":{\"70\":3}}],[\"network\",{\"1\":{\"48\":1,\"69\":4,\"399\":1}}],[\"net\",{\"1\":{\"20\":2,\"25\":1,\"53\":2,\"60\":2,\"62\":3,\"65\":1,\"70\":2,\"110\":1,\"144\":3,\"465\":1,\"483\":2,\"544\":3,\"599\":1,\"618\":1,\"685\":2,\"723\":1}}],[\"nanos\",{\"1\":{\"612\":1}}],[\"native\",{\"1\":{\"507\":1,\"684\":1}}],[\"national\",{\"1\":{\"70\":1}}],[\"nacos等\",{\"1\":{\"250\":1}}],[\"nasn\",{\"1\":{\"71\":1}}],[\"navigator\",{\"1\":{\"70\":1}}],[\"navbar\",{\"1\":{\"5\":1}}],[\"nameserver也会延时30s才知道\",{\"1\":{\"374\":1}}],[\"nameserver是ap\",{\"1\":{\"374\":1}}],[\"nameserver\",{\"1\":{\"363\":1}}],[\"nameserver等\",{\"1\":{\"362\":1}}],[\"namespace=\",{\"1\":{\"199\":1,\"205\":1}}],[\"namespace+id自然也就不同\",{\"1\":{\"191\":1}}],[\"namespace+id自然也不同\",{\"1\":{\"185\":1}}],[\"namespace\",{\"1\":{\"188\":1,\"199\":6,\"204\":9,\"251\":1}}],[\"namespace不同\",{\"1\":{\"185\":1,\"191\":1}}],[\"namesilo\",{\"1\":{\"60\":1,\"66\":1}}],[\"name可自己命名\",{\"1\":{\"159\":1}}],[\"name是要增加索引的表名\",{\"1\":{\"159\":1}}],[\"name=\",{\"1\":{\"70\":8,\"268\":1,\"277\":3,\"521\":3,\"522\":2}}],[\"name=true`\",{\"1\":{\"70\":1,\"71\":2}}],[\"name\",{\"1\":{\"69\":1,\"70\":2,\"153\":1,\"157\":1,\"159\":9,\"205\":1,\"268\":1,\"277\":2,\"317\":1,\"506\":3,\"507\":1,\"510\":1,\"521\":6,\"522\":8}}],[\"nginx\",{\"1\":{\"42\":2,\"71\":9}}],[\"nt5\",{\"1\":{\"32\":1}}],[\"nosuchfieldexception\",{\"1\":{\"534\":1}}],[\"nosuchmethodexception\",{\"1\":{\"223\":1,\"230\":1,\"237\":1,\"534\":1}}],[\"noclassdeffounderror\",{\"0\":{\"533\":1},\"1\":{\"484\":1,\"533\":1}}],[\"noargsconstructor\",{\"1\":{\"216\":1,\"230\":1}}],[\"no=\",{\"1\":{\"157\":1}}],[\"nonfairtryacquire\",{\"1\":{\"616\":2}}],[\"nonfairsync\",{\"1\":{\"605\":1,\"616\":1}}],[\"nonlockingrediscachewriter\",{\"1\":{\"314\":1}}],[\"nonrepeatable\",{\"1\":{\"102\":1}}],[\"nonemptylines\",{\"1\":{\"71\":2}}],[\"none\",{\"1\":{\"70\":2}}],[\"novel\",{\"1\":{\"70\":1}}],[\"now\",{\"1\":{\"69\":2,\"70\":2,\"71\":2}}],[\"nowcoder\",{\"1\":{\"25\":1}}],[\"no\",{\"1\":{\"69\":5,\"70\":5,\"278\":1,\"383\":1,\"388\":1,\"554\":1,\"578\":1}}],[\"nomal\",{\"1\":{\"69\":1,\"70\":1}}],[\"node即为上面clh变体队列中的节点\",{\"1\":{\"603\":1}}],[\"node<k\",{\"1\":{\"556\":5,\"559\":8,\"586\":2}}],[\"nodes\",{\"1\":{\"553\":3}}],[\"nodes映射关系\",{\"1\":{\"385\":1}}],[\"node会在内存中创建一个backlog\",{\"1\":{\"422\":1}}],[\"node会在内存中常见一个backlog\",{\"1\":{\"420\":1}}],[\"node都来重新连接\",{\"1\":{\"420\":1,\"422\":1}}],[\"node有网络故障\",{\"1\":{\"420\":1}}],[\"node如果跟master\",{\"1\":{\"420\":1}}],[\"node第一次连接master\",{\"1\":{\"420\":1}}],[\"node仅仅会复制给slave部分缺少的数据\",{\"1\":{\"420\":1}}],[\"node重新连接master\",{\"1\":{\"420\":1}}],[\"node的时候\",{\"1\":{\"420\":1}}],[\"node上\",{\"1\":{\"419\":1}}],[\"node挂掉了\",{\"1\":{\"419\":1}}],[\"node\",{\"1\":{\"69\":1,\"70\":1,\"417\":2,\"420\":4,\"422\":1,\"506\":2,\"547\":2,\"549\":1,\"554\":1,\"559\":1,\"578\":1,\"585\":1,\"586\":1,\"591\":1,\"603\":1,\"605\":4,\"607\":15,\"610\":1,\"611\":3,\"612\":8,\"617\":4}}],[\"notifyall\",{\"1\":{\"633\":1,\"648\":1,\"701\":1,\"707\":1,\"733\":1}}],[\"notify\",{\"1\":{\"633\":1,\"701\":1,\"732\":3}}],[\"notlsresponsebody\",{\"1\":{\"71\":6}}],[\"notls\",{\"1\":{\"71\":7}}],[\"notls订阅生成\",{\"1\":{\"71\":1}}],[\"note\",{\"1\":{\"70\":1,\"110\":1,\"144\":1}}],[\"not\",{\"0\":{\"170\":2},\"1\":{\"69\":12,\"70\":9,\"94\":1,\"96\":1,\"204\":2,\"289\":1,\"313\":3,\"399\":1,\"738\":1}}],[\"noexit\",{\"1\":{\"69\":1,\"70\":1}}],[\"normally\",{\"1\":{\"69\":1}}],[\"normal\",{\"1\":{\"1\":1}}],[\"o交互\",{\"1\":{\"718\":1}}],[\"o在很短的时间就可以完成\",{\"1\":{\"717\":1}}],[\"o处理完毕时\",{\"1\":{\"623\":1,\"690\":1}}],[\"o请求时\",{\"1\":{\"623\":1,\"690\":1}}],[\"oldthr\",{\"1\":{\"559\":4}}],[\"oldtab\",{\"1\":{\"559\":7}}],[\"oldtable\",{\"1\":{\"558\":2,\"581\":2}}],[\"oldcap\",{\"1\":{\"559\":10}}],[\"oldcapacity\",{\"1\":{\"558\":2,\"573\":3,\"581\":2}}],[\"oldvalue\",{\"1\":{\"556\":3}}],[\"occur\",{\"1\":{\"554\":1,\"578\":1}}],[\"occurrences\",{\"1\":{\"553\":1}}],[\"occurred\",{\"1\":{\"70\":1}}],[\"o是a的实例\",{\"1\":{\"534\":1}}],[\"oschina\",{\"1\":{\"465\":1}}],[\"osi七层模型\",{\"1\":{\"8\":2}}],[\"o上浪费过多的时间\",{\"1\":{\"377\":1}}],[\"o多路复用技术的实现\",{\"1\":{\"377\":1}}],[\"o通道启用了ssl\",{\"1\":{\"341\":1}}],[\"o通道使用普通的plaintext\",{\"1\":{\"341\":1}}],[\"oop\",{\"1\":{\"283\":3}}],[\"oos\",{\"1\":{\"216\":3,\"223\":3,\"230\":3,\"244\":4,\"521\":2,\"522\":2}}],[\"obj\",{\"1\":{\"244\":12,\"476\":2,\"506\":3,\"507\":2,\"521\":2,\"522\":2}}],[\"objectfieldoffset\",{\"1\":{\"684\":1}}],[\"objectfactory\",{\"1\":{\"281\":1}}],[\"objectmonitor\",{\"1\":{\"662\":2}}],[\"objectvalue\",{\"1\":{\"560\":2}}],[\"objectinput\",{\"1\":{\"522\":1}}],[\"objectinputstream\",{\"1\":{\"216\":6,\"223\":6,\"230\":2,\"237\":4,\"244\":2,\"251\":4,\"521\":2,\"522\":2}}],[\"objectoutput\",{\"1\":{\"522\":1}}],[\"objectoutputstream\",{\"1\":{\"216\":7,\"223\":7,\"230\":2,\"237\":5,\"244\":2,\"251\":5,\"521\":2,\"522\":2}}],[\"objectlist\",{\"1\":{\"514\":2}}],[\"object中hashcode是根据对象的存储地址转换而形成的一个哈希值\",{\"1\":{\"480\":1}}],[\"objects\",{\"1\":{\"244\":5,\"594\":1}}],[\"objectserializer\",{\"1\":{\"244\":2}}],[\"object类型也行\",{\"1\":{\"237\":1}}],[\"objectdecoder\",{\"1\":{\"237\":1}}],[\"objectencoder\",{\"1\":{\"237\":1}}],[\"object>\",{\"1\":{\"229\":2,\"230\":10,\"251\":1,\"314\":2,\"506\":2,\"560\":1}}],[\"object\",{\"1\":{\"69\":1,\"70\":8,\"197\":8,\"198\":4,\"200\":8,\"202\":6,\"204\":1,\"223\":8,\"229\":1,\"230\":4,\"237\":2,\"244\":12,\"251\":2,\"283\":1,\"291\":1,\"313\":1,\"314\":1,\"317\":3,\"391\":1,\"454\":1,\"476\":1,\"493\":1,\"505\":2,\"506\":1,\"507\":4,\"510\":1,\"511\":6,\"521\":1,\"555\":1,\"560\":3,\"573\":1,\"579\":1,\"594\":3,\"629\":1,\"639\":2,\"696\":1,\"732\":4}}],[\"ois\",{\"1\":{\"216\":2,\"223\":2,\"230\":2,\"244\":3,\"521\":2,\"522\":2}}],[\"o线程最终的目的是将这些事件写入到中继日志中\",{\"1\":{\"132\":1}}],[\"o\",{\"1\":{\"132\":1,\"162\":1,\"223\":2,\"399\":5,\"400\":2,\"401\":7,\"553\":4,\"571\":3,\"575\":2,\"577\":2,\"639\":2,\"717\":1}}],[\"o复杂度为o\",{\"1\":{\"80\":1}}],[\"ognl\",{\"1\":{\"299\":1}}],[\"og\",{\"1\":{\"70\":8}}],[\"our\",{\"1\":{\"70\":1}}],[\"outofmemoryerror\",{\"1\":{\"534\":1}}],[\"outof\",{\"1\":{\"338\":1}}],[\"out\",{\"1\":{\"193\":2,\"195\":1,\"196\":4,\"198\":1,\"204\":1,\"216\":6,\"223\":9,\"230\":6,\"231\":1,\"237\":7,\"244\":11,\"251\":5,\"258\":1,\"316\":2,\"317\":3,\"488\":6,\"494\":1,\"496\":1,\"497\":2,\"498\":1,\"499\":2,\"505\":2,\"506\":2,\"516\":1,\"521\":2,\"522\":3,\"532\":2,\"536\":2,\"560\":2,\"638\":2,\"675\":1}}],[\"outputstreamwriter\",{\"1\":{\"540\":1}}],[\"outputstream\",{\"1\":{\"539\":2,\"540\":1}}],[\"output\",{\"1\":{\"70\":6,\"521\":1,\"522\":2}}],[\"outbound\",{\"1\":{\"69\":1,\"70\":2}}],[\"overflow\",{\"1\":{\"616\":1}}],[\"overhead\",{\"1\":{\"554\":1,\"578\":1}}],[\"overloading\",{\"1\":{\"466\":1}}],[\"overload\",{\"0\":{\"466\":1},\"1\":{\"465\":1}}],[\"override\",{\"0\":{\"456\":1,\"466\":1,\"468\":1},\"1\":{\"196\":1,\"197\":6,\"198\":2,\"199\":1,\"200\":1,\"201\":3,\"202\":1,\"203\":1,\"216\":1,\"223\":2,\"230\":4,\"237\":9,\"244\":8,\"245\":1,\"251\":2,\"258\":2,\"317\":3,\"318\":1,\"319\":1,\"481\":1,\"521\":1,\"522\":1,\"638\":2}}],[\"over\",{\"1\":{\"70\":3}}],[\"otherwise\",{\"1\":{\"69\":1,\"70\":2,\"184\":1}}],[\"other\",{\"1\":{\"69\":1,\"70\":1,\"506\":1}}],[\"owner\",{\"1\":{\"653\":1}}],[\"owned\",{\"1\":{\"70\":2}}],[\"own\",{\"1\":{\"69\":1,\"70\":1}}],[\"once\",{\"1\":{\"442\":1}}],[\"onclick=\",{\"1\":{\"70\":2}}],[\"online\",{\"1\":{\"70\":14,\"71\":2}}],[\"onlyifabsent\",{\"1\":{\"556\":2}}],[\"only模式时\",{\"1\":{\"407\":1}}],[\"only\",{\"1\":{\"69\":3,\"70\":2,\"553\":1}}],[\"one\",{\"1\":{\"69\":1,\"70\":3}}],[\"on\",{\"1\":{\"69\":2,\"70\":1,\"155\":1,\"159\":1,\"399\":1,\"553\":1,\"594\":1,\"607\":1}}],[\"onflashdrive\",{\"1\":{\"57\":1}}],[\"ok\",{\"1\":{\"32\":1,\"71\":6,\"348\":2}}],[\"operations\",{\"1\":{\"554\":3,\"578\":3}}],[\"openjdk\",{\"0\":{\"447\":1},\"1\":{\"447\":8}}],[\"openmessaging\",{\"1\":{\"362\":1}}],[\"opensession\",{\"1\":{\"194\":1}}],[\"openclash转换订阅网址\",{\"1\":{\"60\":1}}],[\"open\",{\"1\":{\"14\":1,\"69\":6,\"70\":5}}],[\"opsforvalue\",{\"1\":{\"316\":2}}],[\"opsession方法创建sqlsession对象\",{\"1\":{\"193\":1}}],[\"opsession\",{\"1\":{\"193\":1,\"194\":1,\"196\":3}}],[\"optimizer\",{\"1\":{\"156\":1}}],[\"options\",{\"1\":{\"29\":1,\"317\":1}}],[\"opt\",{\"1\":{\"69\":1,\"70\":1}}],[\"optlength\",{\"1\":{\"69\":4,\"70\":4}}],[\"offers\",{\"1\":{\"554\":1,\"578\":1}}],[\"offlinepartition\",{\"1\":{\"340\":1}}],[\"official\",{\"1\":{\"70\":2}}],[\"offset越靠后\",{\"1\":{\"426\":1}}],[\"offset开始继续复制\",{\"1\":{\"420\":1,\"422\":1}}],[\"offset就是保存在backlog中的\",{\"1\":{\"420\":1,\"422\":1}}],[\"offset还有一个master\",{\"1\":{\"420\":1}}],[\"offset\",{\"0\":{\"328\":1},\"1\":{\"69\":19,\"70\":19,\"332\":5,\"422\":1,\"426\":1}}],[\"of\",{\"1\":{\"5\":1,\"43\":1,\"69\":2,\"70\":6,\"71\":4,\"329\":1,\"553\":6,\"554\":5,\"578\":5,\"607\":1}}],[\"oriented\",{\"1\":{\"283\":2}}],[\"origin\",{\"1\":{\"71\":1,\"317\":2}}],[\"originalsql\",{\"1\":{\"201\":9}}],[\"original\",{\"1\":{\"69\":1,\"70\":1,\"201\":1}}],[\"orm框架\",{\"0\":{\"192\":1}}],[\"orm\",{\"1\":{\"178\":1,\"179\":1}}],[\"or导致索引是在特定情况下的\",{\"1\":{\"168\":1}}],[\"or引起的索引失效\",{\"0\":{\"168\":1}}],[\"order\",{\"1\":{\"155\":1}}],[\"org<\",{\"1\":{\"71\":1}}],[\"org\",{\"1\":{\"61\":5,\"62\":5,\"69\":1,\"70\":4,\"71\":4,\"251\":1,\"268\":1,\"553\":1}}],[\"oracle\",{\"0\":{\"447\":1},\"1\":{\"57\":1,\"76\":1,\"102\":1,\"447\":10,\"506\":3}}],[\"or\",{\"1\":{\"4\":2,\"69\":2,\"70\":7,\"168\":1,\"263\":1,\"399\":2,\"553\":1}}],[\"hmsr=toutiao\",{\"1\":{\"618\":1}}],[\"hitail\",{\"1\":{\"559\":6}}],[\"hihead\",{\"1\":{\"559\":3}}],[\"higher\",{\"1\":{\"554\":1,\"578\":1}}],[\"high属性可以设置并保存在私有系统属性中\",{\"1\":{\"499\":1}}],[\"high\",{\"1\":{\"499\":7}}],[\"hibernatetemplate\",{\"1\":{\"286\":1}}],[\"hibernate\",{\"0\":{\"175\":1},\"1\":{\"175\":5,\"178\":3,\"263\":1,\"288\":1}}],[\"hibernate属于全自动orm映射工具\",{\"1\":{\"174\":1}}],[\"h\",{\"1\":{\"449\":1,\"499\":3,\"555\":22,\"579\":18,\"611\":4,\"617\":1}}],[\"hyperloglog\",{\"1\":{\"382\":6}}],[\"hy2sub\",{\"1\":{\"71\":1}}],[\"hy2url\",{\"1\":{\"71\":2}}],[\"hw\",{\"1\":{\"339\":1}}],[\"hs512\",{\"1\":{\"316\":1}}],[\"hql\",{\"1\":{\"175\":1}}],[\"h1>\",{\"1\":{\"71\":1}}],[\"hugecapacity\",{\"1\":{\"573\":1}}],[\"hugedomains\",{\"1\":{\"62\":1}}],[\"hupu\",{\"1\":{\"70\":2}}],[\"h2>$\",{\"1\":{\"70\":1}}],[\"href=\",{\"1\":{\"70\":10,\"71\":2}}],[\"hr\",{\"1\":{\"53\":2,\"58\":1,\"70\":1}}],[\"hk\",{\"1\":{\"52\":5,\"57\":1,\"58\":1,\"62\":2,\"71\":1}}],[\"happen\",{\"1\":{\"650\":1}}],[\"happens\",{\"1\":{\"646\":1}}],[\"hagersten队列\",{\"1\":{\"602\":1}}],[\"handling\",{\"1\":{\"544\":1}}],[\"handlerinterceptor\",{\"1\":{\"317\":3}}],[\"handlerexceptionresolver\",{\"1\":{\"291\":1}}],[\"handlerexecutionchain\",{\"1\":{\"291\":1}}],[\"handleresultsets\",{\"1\":{\"198\":1,\"203\":3}}],[\"handler来调用真正的处理器开处理请求\",{\"1\":{\"290\":1}}],[\"handleradapter组件中讲到过\",{\"1\":{\"292\":1}}],[\"handleradapter\",{\"1\":{\"290\":2,\"291\":1}}],[\"handlermapping\",{\"1\":{\"290\":1,\"291\":1,\"292\":1}}],[\"handler\",{\"1\":{\"237\":1,\"290\":2,\"291\":4,\"317\":5,\"403\":1}}],[\"handle\",{\"1\":{\"69\":2,\"70\":1}}],[\"handles\",{\"1\":{\"69\":1,\"70\":3}}],[\"handletcpoutbound\",{\"1\":{\"69\":2,\"70\":2}}],[\"handleudpoutbound\",{\"1\":{\"69\":2,\"70\":2}}],[\"hardly\",{\"1\":{\"399\":1}}],[\"ha\",{\"1\":{\"323\":2}}],[\"haicoder\",{\"1\":{\"110\":1,\"144\":1}}],[\"hao123\",{\"1\":{\"70\":2}}],[\"have\",{\"1\":{\"69\":4,\"70\":3}}],[\"hasqueuedpredecessors\",{\"1\":{\"616\":1,\"617\":2}}],[\"hasnext\",{\"1\":{\"204\":1,\"506\":3}}],[\"hassos\",{\"1\":{\"71\":2}}],[\"hasincomingdata\",{\"1\":{\"69\":5,\"70\":5}}],[\"has\",{\"1\":{\"69\":9,\"70\":8,\"71\":1}}],[\"haserror\",{\"1\":{\"69\":8,\"70\":9}}],[\"hash冲突加剧\",{\"1\":{\"591\":1}}],[\"hash值\",{\"1\":{\"585\":1}}],[\"hash表要\",{\"1\":{\"564\":1}}],[\"hash表长度可得\",{\"1\":{\"564\":1}}],[\"hash算法就是用key\",{\"1\":{\"564\":1,\"565\":1}}],[\"hash算法最后的值以0来计算\",{\"1\":{\"560\":1}}],[\"hash函数是指把一个大范围映射到一个小范围\",{\"1\":{\"560\":1}}],[\"hash1\",{\"1\":{\"559\":1}}],[\"hashing\",{\"1\":{\"555\":1,\"579\":1}}],[\"hashtable是使用synchronized来实现线程安全的\",{\"1\":{\"593\":1}}],[\"hashtable\",{\"1\":{\"547\":1,\"549\":4,\"570\":1,\"586\":1}}],[\"hashentry<k\",{\"1\":{\"587\":1}}],[\"hashentry\",{\"1\":{\"546\":4,\"547\":3,\"584\":3,\"585\":3}}],[\"hashseed\",{\"1\":{\"555\":1,\"579\":1}}],[\"hashset的底层其实就是hashmap\",{\"1\":{\"595\":1}}],[\"hashset会假设对象没有重复出现\",{\"1\":{\"478\":1}}],[\"hashset\",{\"0\":{\"595\":1},\"1\":{\"478\":4,\"569\":1,\"570\":1}}],[\"hashseparator\",{\"1\":{\"70\":2}}],[\"hashcode发生了改变\",{\"1\":{\"560\":1}}],[\"hashcodes\",{\"1\":{\"553\":2}}],[\"hashcode\",{\"0\":{\"479\":1,\"480\":1},\"1\":{\"477\":2,\"478\":5,\"491\":2,\"555\":7,\"560\":4,\"579\":5,\"582\":3,\"585\":1}}],[\"hashmap为什么线程不安全\",{\"0\":{\"583\":1}}],[\"hashmap默认加载因子是多少\",{\"0\":{\"578\":1}}],[\"hashmap中采用的是\",{\"1\":{\"576\":1}}],[\"hashmap用的哪种\",{\"0\":{\"576\":1}}],[\"hashmap面试指南\",{\"1\":{\"562\":1}}],[\"hashmap面试小抄\",{\"0\":{\"552\":1}}],[\"hashmap扩容拾遗\",{\"1\":{\"562\":1}}],[\"hashmap的loadfactor为什么是0\",{\"1\":{\"562\":1}}],[\"hashmap的table属性引用新的entry数组\",{\"1\":{\"558\":1,\"581\":1}}],[\"hashmap的底层数据结构是什么\",{\"0\":{\"575\":1},\"1\":{\"553\":1}}],[\"hashmap数组的长度为什么是\",{\"1\":{\"555\":1}}],[\"hashmap\",{\"0\":{\"491\":1,\"579\":1,\"580\":1,\"581\":1,\"595\":1},\"1\":{\"377\":2,\"484\":1,\"491\":1,\"546\":1,\"547\":1,\"548\":2,\"549\":3,\"552\":3,\"553\":2,\"554\":1,\"555\":2,\"556\":1,\"557\":1,\"558\":3,\"560\":3,\"561\":2,\"562\":1,\"563\":2,\"564\":1,\"569\":1,\"570\":1,\"575\":2,\"578\":1,\"581\":2,\"582\":2,\"583\":2,\"584\":1,\"586\":1,\"594\":3}}],[\"hashmap<list<string>\",{\"1\":{\"560\":1}}],[\"hashmap<string\",{\"1\":{\"230\":1,\"506\":1}}],[\"hashmap<>\",{\"1\":{\"194\":1,\"200\":1,\"230\":3,\"251\":1,\"560\":1}}],[\"hashmap存储\",{\"1\":{\"188\":1}}],[\"hash索引在查询等值时非常快\",{\"1\":{\"150\":1}}],[\"hash索引\",{\"1\":{\"79\":1,\"148\":1,\"149\":1}}],[\"hasharray\",{\"1\":{\"70\":2}}],[\"hashbuffer\",{\"1\":{\"70\":2}}],[\"hashhex\",{\"1\":{\"70\":6}}],[\"hash\",{\"0\":{\"150\":1,\"563\":1,\"577\":1},\"1\":{\"42\":2,\"80\":1,\"128\":2,\"149\":1,\"150\":1,\"378\":1,\"382\":4,\"399\":1,\"429\":1,\"430\":1,\"438\":1,\"545\":1,\"547\":5,\"549\":2,\"552\":1,\"553\":2,\"555\":6,\"556\":13,\"558\":2,\"559\":5,\"563\":1,\"565\":3,\"579\":3,\"580\":1,\"581\":2,\"585\":1,\"586\":1}}],[\"half\",{\"1\":{\"14\":1}}],[\"however\",{\"1\":{\"69\":1}}],[\"how\",{\"1\":{\"69\":1,\"70\":1,\"723\":1}}],[\"hong\",{\"1\":{\"52\":1,\"70\":1}}],[\"homed\",{\"1\":{\"33\":1}}],[\"hosts\",{\"1\":{\"71\":3}}],[\"hostmonit\",{\"1\":{\"60\":1}}],[\"host=\",{\"1\":{\"71\":1}}],[\"host=$\",{\"1\":{\"69\":2,\"70\":4,\"71\":2}}],[\"host=伪装域名\",{\"1\":{\"58\":2}}],[\"host=vless\",{\"1\":{\"53\":2}}],[\"hostnames\",{\"1\":{\"69\":3,\"70\":3}}],[\"hostname\",{\"1\":{\"33\":1,\"69\":15,\"70\":17,\"71\":1}}],[\"host头处理\",{\"1\":{\"33\":1}}],[\"host\",{\"1\":{\"32\":1,\"69\":8,\"70\":5,\"71\":28,\"219\":1,\"223\":4,\"225\":1,\"237\":7,\"251\":8}}],[\"heavy\",{\"1\":{\"620\":1,\"687\":1}}],[\"head节点表示获取锁成功的节点\",{\"1\":{\"608\":1}}],[\"header2\",{\"1\":{\"319\":1}}],[\"header1\",{\"1\":{\"319\":1}}],[\"headers\",{\"1\":{\"69\":9,\"70\":17,\"71\":12,\"317\":1}}],[\"header=\",{\"1\":{\"52\":2,\"65\":2}}],[\"header\",{\"1\":{\"34\":1,\"69\":1,\"70\":12,\"71\":3}}],[\"head>\",{\"1\":{\"32\":1,\"70\":1,\"71\":1}}],[\"head\",{\"1\":{\"27\":1,\"29\":1,\"70\":1,\"301\":1,\"611\":1,\"612\":1}}],[\"height\",{\"1\":{\"70\":2,\"168\":1}}],[\"height=\",{\"1\":{\"70\":1}}],[\"help\",{\"1\":{\"612\":1}}],[\"hel4\",{\"0\":{\"71\":1},\"1\":{\"71\":2}}],[\"hel3\",{\"0\":{\"70\":1},\"1\":{\"70\":2}}],[\"hel3的\",{\"1\":{\"53\":1}}],[\"hel2\",{\"0\":{\"69\":1},\"1\":{\"69\":2}}],[\"hello\",{\"1\":{\"32\":1,\"69\":1,\"70\":1,\"449\":1,\"482\":2,\"503\":1,\"560\":2}}],[\"here\",{\"1\":{\"5\":1,\"69\":2,\"70\":1,\"268\":1}}],[\"httpmessageconverter\",{\"1\":{\"297\":1}}],[\"httprequesthandler\",{\"1\":{\"291\":1,\"292\":1}}],[\"http2\",{\"0\":{\"34\":1},\"1\":{\"34\":2}}],[\"http1\",{\"0\":{\"33\":1,\"34\":1},\"1\":{\"33\":4,\"34\":2}}],[\"http请求报文和响应报文的格式\",{\"0\":{\"32\":1}}],[\"http协议的长连接和短连接\",{\"1\":{\"31\":1}}],[\"http常见的状态码有哪些\",{\"0\":{\"27\":1}}],[\"httpservletresponse\",{\"1\":{\"317\":3}}],[\"httpservletrequest\",{\"1\":{\"317\":3}}],[\"https是现行架构下最安全的解决方案\",{\"1\":{\"36\":1}}],[\"https协议是由ssl+http协议构建的可进行加密传输\",{\"1\":{\"36\":1}}],[\"https\",{\"0\":{\"35\":1,\"36\":1},\"1\":{\"10\":1,\"11\":1,\"16\":1,\"25\":7,\"35\":1,\"36\":3,\"37\":4,\"48\":7,\"53\":2,\"55\":1,\"57\":1,\"58\":3,\"59\":1,\"60\":8,\"63\":1,\"64\":2,\"65\":2,\"68\":6,\"69\":7,\"70\":21,\"71\":10,\"110\":1,\"144\":5,\"149\":1,\"158\":1,\"251\":1,\"311\":2,\"343\":2,\"374\":1,\"435\":1,\"438\":1,\"461\":1,\"465\":1,\"469\":1,\"483\":3,\"526\":1,\"537\":1,\"544\":13,\"551\":1,\"562\":1,\"567\":3,\"599\":4,\"618\":4,\"637\":1,\"675\":1,\"682\":1,\"685\":5,\"708\":1,\"723\":3,\"737\":1}}],[\"http\",{\"0\":{\"29\":1,\"35\":1},\"1\":{\"10\":1,\"21\":2,\"31\":1,\"32\":2,\"33\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":3,\"39\":2,\"65\":1,\"69\":1,\"70\":2,\"71\":2,\"272\":5,\"293\":1,\"300\":1,\"301\":2,\"302\":1,\"311\":1,\"343\":1,\"474\":1,\"483\":3,\"544\":1,\"548\":1,\"551\":1,\"553\":1,\"567\":1,\"590\":1,\"618\":1,\"685\":1,\"723\":1}}],[\"htmlhead\",{\"1\":{\"70\":2}}],[\"html>`\",{\"1\":{\"70\":1}}],[\"html>\",{\"1\":{\"32\":1,\"71\":2}}],[\"html或\",{\"1\":{\"28\":1}}],[\"html\",{\"1\":{\"3\":1,\"25\":2,\"38\":4,\"48\":1,\"69\":1,\"70\":4,\"71\":4,\"110\":1,\"144\":1,\"149\":1,\"158\":1,\"251\":1,\"269\":1,\"311\":2,\"318\":1,\"343\":1,\"469\":1,\"474\":1,\"483\":4,\"537\":1,\"544\":2,\"551\":1,\"562\":1,\"567\":2,\"599\":2,\"618\":1,\"637\":1,\"675\":1,\"685\":1,\"708\":1,\"723\":2}}],[\"png\",{\"1\":{\"682\":1}}],[\"pc\",{\"1\":{\"620\":1,\"687\":1}}],[\"pconline\",{\"1\":{\"70\":2}}],[\"p=2197\",{\"1\":{\"618\":1}}],[\"p1=h\",{\"1\":{\"576\":1}}],[\"p5qm2uj1uiwyongfvprbcg\",{\"1\":{\"544\":1}}],[\"pd\",{\"1\":{\"506\":4}}],[\"pdf\",{\"0\":{\"49\":1,\"50\":1,\"741\":1},\"1\":{\"49\":1,\"50\":1}}],[\"px\",{\"1\":{\"435\":2}}],[\"python\",{\"1\":{\"352\":1}}],[\"phantom\",{\"1\":{\"102\":1}}],[\"php\",{\"1\":{\"59\":1,\"63\":1,\"352\":1}}],[\"php改成\",{\"1\":{\"28\":1}}],[\"ps\",{\"1\":{\"71\":1}}],[\"psub\",{\"1\":{\"71\":1}}],[\"p>\",{\"1\":{\"71\":3}}],[\"p>`\",{\"1\":{\"70\":1}}],[\"pb\",{\"1\":{\"71\":1}}],[\"ppfv2tl9veojd\",{\"1\":{\"71\":1}}],[\"pptv\",{\"1\":{\"70\":2}}],[\"pthread\",{\"1\":{\"661\":1}}],[\"pt\",{\"1\":{\"70\":7}}],[\"pf\",{\"1\":{\"70\":1}}],[\"placed\",{\"1\":{\"559\":1}}],[\"platform\",{\"1\":{\"70\":25}}],[\"plain\",{\"1\":{\"69\":1,\"70\":1,\"71\":6,\"553\":1}}],[\"please\",{\"1\":{\"70\":2,\"71\":1}}],[\"pvlesswstls\",{\"1\":{\"69\":3}}],[\"pub\",{\"1\":{\"346\":1}}],[\"publish\",{\"1\":{\"326\":1,\"376\":1}}],[\"publisher\",{\"1\":{\"70\":1}}],[\"public\",{\"1\":{\"70\":1,\"193\":2,\"194\":3,\"195\":3,\"196\":5,\"197\":9,\"198\":5,\"199\":12,\"200\":9,\"201\":6,\"202\":4,\"203\":4,\"204\":11,\"205\":2,\"216\":8,\"223\":14,\"230\":24,\"237\":15,\"244\":11,\"245\":1,\"251\":12,\"258\":5,\"268\":2,\"277\":2,\"313\":6,\"314\":3,\"315\":2,\"316\":5,\"317\":4,\"318\":2,\"319\":3,\"391\":1,\"451\":1,\"476\":1,\"481\":1,\"488\":1,\"494\":4,\"499\":2,\"505\":4,\"506\":8,\"507\":2,\"511\":4,\"521\":6,\"522\":8,\"532\":3,\"536\":2,\"556\":1,\"573\":1,\"595\":1,\"605\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1,\"617\":2,\"638\":4}}],[\"push模式很难适应消费速率不同的消费者\",{\"1\":{\"324\":1}}],[\"pushdown=off\",{\"1\":{\"156\":1}}],[\"push\",{\"0\":{\"324\":1},\"1\":{\"69\":3,\"70\":3,\"71\":1,\"362\":1}}],[\"pullrequestholdservice\",{\"1\":{\"367\":1}}],[\"pull\",{\"0\":{\"324\":1},\"1\":{\"69\":1,\"70\":1,\"329\":1,\"339\":1,\"362\":1}}],[\"put和get并发时\",{\"0\":{\"566\":1},\"1\":{\"583\":1}}],[\"put完成后\",{\"1\":{\"565\":1}}],[\"puttreeval\",{\"1\":{\"556\":1}}],[\"putval\",{\"1\":{\"556\":2}}],[\"put方法\",{\"0\":{\"556\":1}}],[\"putagunagainsthisheadpulledmytriggernowhesdead\",{\"1\":{\"71\":2}}],[\"put\",{\"0\":{\"585\":1},\"1\":{\"29\":2,\"194\":1,\"200\":1,\"229\":2,\"230\":5,\"251\":1,\"295\":1,\"301\":1,\"317\":1,\"319\":1,\"506\":1,\"547\":2,\"548\":1,\"554\":1,\"556\":2,\"560\":2,\"565\":2,\"578\":1,\"583\":1,\"588\":1,\"595\":1}}],[\"pengmaster\",{\"1\":{\"685\":1}}],[\"people\",{\"1\":{\"62\":3,\"156\":2}}],[\"permalink\",{\"1\":{\"90\":1,\"146\":1}}],[\"persion\",{\"1\":{\"473\":1}}],[\"persistent\",{\"1\":{\"33\":1,\"251\":1}}],[\"persons是不可变对象的引用\",{\"1\":{\"473\":1}}],[\"persons\",{\"1\":{\"473\":1}}],[\"person\",{\"1\":{\"277\":7,\"473\":1}}],[\"personal\",{\"1\":{\"70\":1}}],[\"per\",{\"1\":{\"4\":1,\"399\":1}}],[\"ping\",{\"1\":{\"244\":1,\"425\":3}}],[\"ping检测后\",{\"1\":{\"62\":1}}],[\"pipeline\",{\"1\":{\"237\":7,\"245\":5}}],[\"pipelining\",{\"1\":{\"33\":1,\"399\":1}}],[\"pipe\",{\"1\":{\"69\":1}}],[\"pipeto\",{\"1\":{\"69\":4,\"70\":4}}],[\"pixiv\",{\"1\":{\"62\":1}}],[\"pratice\",{\"1\":{\"675\":1,\"723\":1}}],[\"price\",{\"1\":{\"505\":9}}],[\"primitive\",{\"1\":{\"489\":1}}],[\"primary\",{\"1\":{\"94\":1,\"157\":3,\"159\":1}}],[\"primay\",{\"1\":{\"87\":1}}],[\"priority相同\",{\"1\":{\"426\":1}}],[\"priority越低\",{\"1\":{\"426\":1}}],[\"print\",{\"1\":{\"494\":1,\"496\":1,\"499\":2}}],[\"printf\",{\"1\":{\"237\":1}}],[\"printstacktrace\",{\"1\":{\"195\":1,\"198\":2,\"202\":1,\"204\":1,\"216\":3,\"223\":2,\"230\":4,\"237\":5,\"244\":2,\"251\":1,\"521\":2,\"522\":2,\"532\":1}}],[\"println\",{\"1\":{\"193\":2,\"195\":1,\"196\":4,\"198\":1,\"204\":3,\"216\":6,\"223\":9,\"230\":6,\"231\":1,\"237\":6,\"244\":3,\"251\":5,\"258\":1,\"316\":2,\"317\":3,\"488\":6,\"497\":2,\"498\":1,\"505\":2,\"506\":2,\"516\":1,\"521\":2,\"522\":1,\"532\":3,\"536\":2,\"560\":2,\"638\":2,\"675\":1}}],[\"private\",{\"1\":{\"194\":1,\"196\":2,\"197\":2,\"198\":4,\"199\":5,\"200\":6,\"201\":3,\"202\":1,\"203\":1,\"204\":2,\"205\":4,\"216\":3,\"223\":9,\"230\":10,\"237\":9,\"244\":1,\"251\":11,\"258\":1,\"277\":3,\"316\":1,\"451\":1,\"481\":1,\"499\":2,\"505\":1,\"506\":1,\"511\":3,\"521\":2,\"522\":2,\"573\":4,\"594\":3,\"604\":1,\"607\":2,\"612\":1,\"616\":1,\"684\":3,\"712\":1,\"714\":1}}],[\"producer端如何保证消息不丢失\",{\"1\":{\"369\":1}}],[\"producer端\",{\"1\":{\"369\":1}}],[\"producer发送消息到broker\",{\"1\":{\"357\":1}}],[\"producer发送数据\",{\"0\":{\"330\":1}}],[\"producer通过路由键将交换器和队列绑定起来\",{\"1\":{\"357\":1}}],[\"producer声明一个队列并设置好相关属性\",{\"1\":{\"357\":1}}],[\"producer声明一个交换器并设置好相关属性\",{\"1\":{\"357\":1}}],[\"producer先连接到broker\",{\"1\":{\"357\":1,\"358\":1}}],[\"producer\",{\"1\":{\"333\":1,\"334\":2,\"362\":2,\"363\":1}}],[\"producers\",{\"1\":{\"322\":2}}],[\"programming\",{\"1\":{\"283\":2}}],[\"propagate\",{\"1\":{\"603\":1}}],[\"propagation\",{\"1\":{\"289\":7}}],[\"props\",{\"1\":{\"195\":2}}],[\"propertydescriptor\",{\"1\":{\"506\":1}}],[\"property\",{\"1\":{\"499\":1,\"506\":1}}],[\"property>\",{\"1\":{\"268\":1,\"277\":3}}],[\"property=\",{\"1\":{\"70\":8}}],[\"properties用于uat环境\",{\"1\":{\"305\":1}}],[\"properties用于测试环境\",{\"1\":{\"305\":1}}],[\"properties用于开发环境\",{\"1\":{\"305\":1}}],[\"properties文件中添加spring\",{\"1\":{\"305\":2}}],[\"properties文件\",{\"1\":{\"305\":3}}],[\"properties\",{\"1\":{\"193\":1,\"194\":1,\"205\":1,\"506\":1}}],[\"prototype\",{\"1\":{\"269\":1,\"272\":1}}],[\"protobuf\",{\"1\":{\"212\":1,\"242\":1,\"244\":1}}],[\"protocols\",{\"1\":{\"69\":1,\"70\":1}}],[\"protocol\",{\"1\":{\"69\":3,\"70\":6,\"71\":1}}],[\"protected\",{\"1\":{\"194\":1,\"200\":1,\"237\":3,\"244\":2,\"245\":1,\"451\":1,\"604\":3,\"605\":1,\"616\":1,\"617\":2}}],[\"pro\",{\"1\":{\"144\":1}}],[\"provideserviceinterface\",{\"1\":{\"230\":3,\"251\":1}}],[\"providers\",{\"1\":{\"70\":1}}],[\"provider\",{\"1\":{\"70\":3}}],[\"providing\",{\"1\":{\"70\":1}}],[\"profiles\",{\"1\":{\"305\":2}}],[\"profile\",{\"1\":{\"70\":1,\"71\":3,\"305\":2}}],[\"project\",{\"0\":{\"750\":1},\"1\":{\"70\":1}}],[\"promise\",{\"1\":{\"69\":1,\"70\":4,\"71\":2}}],[\"promise<import\",{\"1\":{\"70\":1}}],[\"promise<void>\",{\"1\":{\"69\":2,\"70\":4}}],[\"promise<boolean>\",{\"1\":{\"69\":1}}],[\"promise<response>\",{\"1\":{\"69\":1,\"70\":2}}],[\"processworkerexit\",{\"1\":{\"714\":1}}],[\"processlist\",{\"1\":{\"141\":1}}],[\"processes\",{\"1\":{\"70\":1}}],[\"processวเลสheader\",{\"1\":{\"70\":2}}],[\"processing\",{\"1\":{\"70\":1}}],[\"processvlessheader\",{\"1\":{\"69\":2}}],[\"process\",{\"1\":{\"69\":1,\"70\":2,\"132\":1,\"620\":2,\"687\":2}}],[\"proxyhostsurl\",{\"1\":{\"71\":3}}],[\"proxyhosts\",{\"1\":{\"71\":9}}],[\"proxyresponse\",{\"1\":{\"69\":3,\"70\":3}}],[\"proxyurl\",{\"1\":{\"69\":2,\"70\":2}}],[\"proxy\",{\"1\":{\"69\":5,\"70\":4,\"123\":1,\"125\":1,\"127\":1,\"200\":2,\"223\":5,\"284\":1}}],[\"proxyip=$\",{\"1\":{\"71\":4}}],[\"proxyip=推荐几个\",{\"1\":{\"57\":1}}],[\"proxyips\",{\"1\":{\"69\":3,\"71\":7}}],[\"proxyip\",{\"1\":{\"57\":7,\"69\":6,\"71\":10}}],[\"problem\",{\"1\":{\"63\":1,\"343\":1}}],[\"pred指针指向尾节点tail\",{\"1\":{\"607\":1}}],[\"pred\",{\"1\":{\"607\":5}}],[\"predecessor\",{\"1\":{\"603\":1,\"612\":1}}],[\"prev\",{\"1\":{\"603\":1,\"607\":1}}],[\"preferred\",{\"1\":{\"340\":2}}],[\"preferredreplicapartition\",{\"1\":{\"340\":1}}],[\"prefers\",{\"1\":{\"70\":1}}],[\"prehandle\",{\"1\":{\"298\":1,\"317\":1}}],[\"pre>\",{\"1\":{\"70\":2}}],[\"prepare方法\",{\"1\":{\"201\":1}}],[\"preparestatement\",{\"1\":{\"201\":2}}],[\"preparedstatememnt执行qeuery返回resulttype对象\",{\"1\":{\"198\":1}}],[\"preparedstatememnt是java\",{\"1\":{\"198\":1}}],[\"preparedstatement\",{\"1\":{\"198\":4,\"201\":12,\"202\":2}}],[\"prepare\",{\"1\":{\"70\":2,\"198\":1,\"201\":2}}],[\"present是一个至始至终都相同的虚值\",{\"1\":{\"595\":1}}],[\"present\",{\"1\":{\"69\":2,\"595\":1}}],[\"press\",{\"1\":{\"69\":1,\"70\":1}}],[\"pre\",{\"1\":{\"53\":1,\"70\":4}}],[\"pow\",{\"1\":{\"553\":1}}],[\"powershell\",{\"1\":{\"69\":1,\"70\":1}}],[\"poisson\",{\"1\":{\"553\":2}}],[\"pointcut\",{\"1\":{\"285\":2}}],[\"pooling\",{\"1\":{\"675\":1,\"723\":1}}],[\"pool将不能够实现\",{\"1\":{\"482\":1}}],[\"pool的概念\",{\"1\":{\"482\":1}}],[\"pool\",{\"1\":{\"482\":2,\"639\":1}}],[\"poll\",{\"1\":{\"403\":1}}],[\"policy\",{\"1\":{\"251\":2,\"388\":1}}],[\"populatebean\",{\"1\":{\"281\":1}}],[\"popularity\",{\"1\":{\"70\":1}}],[\"popular\",{\"1\":{\"70\":4}}],[\"pong\",{\"1\":{\"244\":1}}],[\"pom文件中引入fastjson包\",{\"1\":{\"244\":1}}],[\"pom\",{\"1\":{\"237\":1}}],[\"pojo\",{\"1\":{\"493\":2}}],[\"pojo类\",{\"1\":{\"230\":1}}],[\"pojo映射成数据库中的记录\",{\"1\":{\"172\":1}}],[\"possible\",{\"1\":{\"157\":2}}],[\"posthandle\",{\"1\":{\"298\":1,\"317\":2}}],[\"postprocessafterinitialization去做一些bean初始化之后的自定义工作\",{\"1\":{\"274\":1}}],[\"post请求不是\",{\"1\":{\"30\":1}}],[\"post比get安全\",{\"1\":{\"30\":1}}],[\"post\",{\"1\":{\"11\":1,\"16\":1,\"25\":1,\"29\":3,\"48\":3,\"69\":1,\"70\":1,\"295\":1,\"301\":1,\"311\":1,\"317\":1,\"319\":1,\"374\":1,\"461\":1,\"526\":1,\"544\":5,\"567\":2,\"599\":1,\"618\":1}}],[\"portlet\",{\"1\":{\"269\":1,\"272\":5}}],[\"portlet是能够生成语义代码\",{\"1\":{\"269\":1}}],[\"port绑定\",{\"1\":{\"225\":1}}],[\"portal\",{\"1\":{\"70\":2}}],[\"portbuffer\",{\"1\":{\"69\":2,\"70\":2}}],[\"portindex\",{\"1\":{\"69\":4,\"70\":4,\"71\":2}}],[\"port\",{\"1\":{\"69\":14,\"70\":12,\"71\":16,\"219\":1,\"223\":4,\"230\":5,\"237\":9,\"251\":11}}],[\"portremote\",{\"1\":{\"69\":10,\"70\":12}}],[\"portwithrandomlog\",{\"1\":{\"69\":3,\"70\":3}}],[\"port==\",{\"1\":{\"52\":3,\"65\":2}}],[\"paginationinnerinterceptor\",{\"1\":{\"315\":1}}],[\"pagecache缓存\",{\"1\":{\"329\":1}}],[\"pages方式部署可参考此视频教程\",{\"1\":{\"69\":1}}],[\"pages1\",{\"0\":{\"53\":1},\"1\":{\"53\":1}}],[\"pages\",{\"0\":{\"2\":1,\"745\":1},\"1\":{\"53\":1,\"69\":6,\"70\":4,\"71\":4,\"318\":1}}],[\"page\",{\"1\":{\"1\":1,\"2\":1,\"4\":1,\"71\":1}}],[\"panda\",{\"1\":{\"70\":2}}],[\"padding\",{\"1\":{\"70\":2}}],[\"padstart\",{\"1\":{\"70\":3}}],[\"pair\",{\"1\":{\"70\":1}}],[\"package\",{\"1\":{\"69\":1,\"70\":1}}],[\"password=root\",{\"1\":{\"205\":1}}],[\"password=1234\",{\"1\":{\"32\":1}}],[\"password\",{\"1\":{\"198\":3,\"204\":2}}],[\"pass\",{\"1\":{\"69\":2,\"70\":2}}],[\"parkandcheckinterrupt\",{\"1\":{\"612\":1}}],[\"park\",{\"1\":{\"602\":1}}],[\"part\",{\"1\":{\"544\":1}}],[\"parties\",{\"1\":{\"681\":1}}],[\"partition\",{\"1\":{\"323\":8,\"334\":4,\"336\":4,\"337\":1,\"340\":1}}],[\"partitions命令\",{\"1\":{\"340\":1}}],[\"partitions\",{\"1\":{\"157\":1}}],[\"partial\",{\"1\":{\"33\":1}}],[\"parts\",{\"1\":{\"71\":18}}],[\"parsedouble\",{\"1\":{\"532\":1}}],[\"parseclaimsjws\",{\"1\":{\"316\":2}}],[\"parserbuilder\",{\"1\":{\"316\":1}}],[\"parser\",{\"1\":{\"316\":2}}],[\"parseint\",{\"1\":{\"251\":1,\"499\":2}}],[\"parseaddress\",{\"1\":{\"251\":2}}],[\"parseobject\",{\"1\":{\"244\":2}}],[\"parsesymbol方法\",{\"1\":{\"201\":1}}],[\"parsesymbol\",{\"1\":{\"201\":3}}],[\"parsefloat\",{\"1\":{\"71\":1}}],[\"parse\",{\"1\":{\"71\":1}}],[\"paramstype\",{\"1\":{\"244\":2}}],[\"paramstypes\",{\"1\":{\"223\":2}}],[\"params\",{\"1\":{\"223\":2}}],[\"parames\",{\"1\":{\"202\":5}}],[\"parameterannotations\",{\"1\":{\"507\":1}}],[\"parametertypes\",{\"1\":{\"507\":1}}],[\"parameter作为参数\",{\"1\":{\"202\":1}}],[\"parameterhandler\",{\"1\":{\"198\":4,\"202\":2}}],[\"parameter参数交给executor调用参数处理方法处理\",{\"1\":{\"197\":1}}],[\"parameter\",{\"0\":{\"202\":1},\"1\":{\"197\":11,\"198\":5,\"202\":10,\"553\":1}}],[\"parameters\",{\"1\":{\"71\":1}}],[\"parampreparedstatement\",{\"1\":{\"202\":4}}],[\"paramconnection\",{\"1\":{\"201\":4}}],[\"paramclass\",{\"1\":{\"197\":1}}],[\"param注解\",{\"1\":{\"183\":2}}],[\"param\",{\"1\":{\"69\":33,\"70\":34,\"201\":3,\"204\":5,\"313\":4,\"506\":2}}],[\"pattern\",{\"1\":{\"201\":5}}],[\"pathvariable\",{\"0\":{\"296\":1},\"1\":{\"296\":1}}],[\"path=$\",{\"1\":{\"71\":2}}],[\"path=\",{\"1\":{\"69\":2,\"70\":4,\"71\":1}}],[\"path=路径\",{\"1\":{\"58\":2}}],[\"path\",{\"1\":{\"69\":5,\"70\":6,\"71\":20,\"251\":4,\"607\":1}}],[\"pathname\",{\"1\":{\"69\":2,\"70\":2,\"71\":3}}],[\"patch\",{\"1\":{\"29\":1}}],[\"p\",{\"1\":{\"25\":1,\"48\":1,\"144\":1,\"311\":1,\"469\":1,\"483\":1,\"537\":1,\"544\":2,\"551\":1,\"556\":10,\"562\":1,\"565\":1,\"576\":1,\"599\":1,\"612\":4,\"685\":1,\"723\":1,\"728\":1,\"731\":2}}],[\"e7\",{\"1\":{\"544\":1}}],[\"e5\",{\"1\":{\"544\":3}}],[\"effective\",{\"1\":{\"515\":1}}],[\"esc\",{\"1\":{\"402\":1}}],[\"established\",{\"1\":{\"12\":4}}],[\"either\",{\"1\":{\"399\":1}}],[\"evict\",{\"1\":{\"556\":2}}],[\"eviction\",{\"1\":{\"388\":1}}],[\"ever\",{\"1\":{\"554\":1,\"578\":1}}],[\"everysec\",{\"1\":{\"383\":1}}],[\"every\",{\"1\":{\"2\":1,\"3\":1}}],[\"even\",{\"1\":{\"69\":1,\"399\":1}}],[\"eventloopgroup\",{\"1\":{\"237\":4}}],[\"event\",{\"1\":{\"69\":6,\"70\":5,\"403\":1}}],[\"erlang\",{\"1\":{\"350\":2,\"353\":1}}],[\"err\",{\"1\":{\"69\":7,\"70\":9,\"204\":2,\"532\":1}}],[\"error|null\",{\"1\":{\"70\":1}}],[\"error\",{\"0\":{\"530\":1},\"1\":{\"69\":45,\"70\":44,\"71\":20,\"484\":1,\"493\":1,\"514\":1,\"530\":4,\"533\":1,\"616\":1,\"617\":1,\"640\":1,\"684\":1}}],[\"epoch\",{\"1\":{\"427\":2}}],[\"epoch机制\",{\"1\":{\"339\":1}}],[\"epoll\",{\"1\":{\"403\":2}}],[\"ephemeral\",{\"1\":{\"251\":1}}],[\"equalsignorecase\",{\"1\":{\"506\":1}}],[\"equals方法主要用于两个对象之间\",{\"1\":{\"476\":1}}],[\"equals\",{\"0\":{\"476\":1,\"479\":1,\"480\":1},\"1\":{\"200\":1,\"203\":3,\"204\":3,\"316\":1,\"476\":9,\"478\":2,\"483\":1,\"532\":1,\"556\":2,\"560\":2,\"582\":2}}],[\"eq\",{\"1\":{\"157\":1}}],[\"egon1\",{\"1\":{\"157\":1}}],[\"etrunia\",{\"1\":{\"156\":3}}],[\"etc\",{\"1\":{\"20\":1,\"69\":1,\"70\":1}}],[\"election命令\",{\"1\":{\"340\":1}}],[\"electronics\",{\"1\":{\"70\":1}}],[\"elename\",{\"1\":{\"204\":4}}],[\"elementdata\",{\"1\":{\"573\":9}}],[\"elementiterator\",{\"1\":{\"204\":1,\"506\":3}}],[\"element\",{\"1\":{\"204\":10,\"506\":7,\"571\":1}}],[\"else\",{\"1\":{\"69\":9,\"70\":6,\"71\":17,\"196\":1,\"198\":1,\"200\":1,\"201\":1,\"203\":2,\"204\":2,\"244\":2,\"316\":1,\"317\":1,\"532\":1,\"556\":3,\"559\":8,\"605\":1,\"616\":2,\"617\":1}}],[\"eyny\",{\"1\":{\"70\":2}}],[\"emp\",{\"1\":{\"157\":1}}],[\"employees\",{\"1\":{\"157\":1}}],[\"empty\",{\"1\":{\"69\":2,\"70\":1,\"204\":2,\"313\":3,\"573\":1}}],[\"em><\",{\"1\":{\"71\":1}}],[\"email\",{\"1\":{\"70\":1}}],[\"emoji=true\",{\"1\":{\"70\":1,\"71\":2}}],[\"early\",{\"1\":{\"70\":1}}],[\"earlydata\",{\"1\":{\"69\":4,\"70\":7}}],[\"earlydataheader\",{\"1\":{\"69\":5,\"70\":5}}],[\"each\",{\"1\":{\"69\":1,\"70\":1}}],[\"e\",{\"1\":{\"69\":2,\"70\":4,\"195\":2,\"198\":6,\"202\":2,\"203\":11,\"204\":2,\"216\":6,\"223\":5,\"230\":8,\"237\":7,\"244\":4,\"251\":4,\"346\":1,\"506\":2,\"521\":4,\"522\":4,\"532\":2,\"536\":2,\"556\":12,\"558\":9,\"559\":16,\"564\":6,\"571\":3,\"573\":3,\"581\":9,\"595\":3}}],[\"eu\",{\"1\":{\"61\":5,\"62\":3,\"70\":3}}],[\"edureka\",{\"1\":{\"268\":2,\"277\":2}}],[\"ed=2560\",{\"1\":{\"71\":2}}],[\"ed=2048\",{\"1\":{\"69\":4}}],[\"edtunnel<\",{\"1\":{\"70\":1}}],[\"edtunnel\",{\"1\":{\"70\":9}}],[\"edgetunnel\",{\"1\":{\"60\":1,\"61\":1,\"71\":8}}],[\"ed\",{\"1\":{\"53\":1,\"70\":3,\"71\":2}}],[\"ecn\",{\"1\":{\"52\":1}}],[\"enq\",{\"1\":{\"607\":3}}],[\"enqueue\",{\"1\":{\"69\":4,\"70\":3}}],[\"ensureexplicitcapacity\",{\"1\":{\"573\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"573\":2}}],[\"en\",{\"1\":{\"553\":1}}],[\"enough\",{\"1\":{\"553\":1}}],[\"enhancement\",{\"1\":{\"483\":1}}],[\"enum\",{\"1\":{\"204\":1,\"450\":1}}],[\"entries\",{\"1\":{\"554\":2,\"578\":2}}],[\"entry<k\",{\"1\":{\"558\":2,\"581\":2,\"586\":1}}],[\"entry\",{\"1\":{\"203\":8,\"558\":6,\"581\":6}}],[\"entrtyclass\",{\"1\":{\"203\":2}}],[\"engineer\",{\"1\":{\"157\":1}}],[\"engine\",{\"1\":{\"70\":2}}],[\"encode类\",{\"1\":{\"244\":1}}],[\"encodeuricomponent\",{\"1\":{\"70\":7,\"71\":12}}],[\"encode\",{\"1\":{\"70\":1,\"244\":1}}],[\"encoder\",{\"1\":{\"70\":2}}],[\"encoding=\",{\"1\":{\"205\":1}}],[\"encoding\",{\"1\":{\"32\":1,\"71\":1}}],[\"encryption=none\",{\"1\":{\"69\":2,\"70\":3,\"71\":2}}],[\"enablecaching\",{\"1\":{\"314\":1}}],[\"enableautoconfiguration\",{\"1\":{\"306\":1}}],[\"enabled\",{\"1\":{\"70\":1}}],[\"enable\",{\"1\":{\"69\":2}}],[\"envadd\",{\"1\":{\"71\":2}}],[\"environment缩写\",{\"1\":{\"444\":1}}],[\"environment\",{\"1\":{\"69\":1}}],[\"env\",{\"1\":{\"69\":4,\"70\":5,\"71\":34}}],[\"endswith\",{\"1\":{\"196\":1}}],[\"endps\",{\"1\":{\"71\":7}}],[\"endian\",{\"1\":{\"69\":1,\"70\":1}}],[\"end\",{\"0\":{\"47\":1},\"1\":{\"69\":3,\"70\":2,\"157\":1}}],[\"existing\",{\"1\":{\"556\":1}}],[\"exists导致索引失效\",{\"0\":{\"170\":1}}],[\"exists都比not\",{\"1\":{\"96\":1}}],[\"exists\",{\"0\":{\"96\":1},\"1\":{\"96\":1}}],[\"exit\",{\"1\":{\"454\":1}}],[\"ex\",{\"1\":{\"317\":2,\"435\":2,\"684\":2}}],[\"exceeded\",{\"1\":{\"616\":1,\"617\":1}}],[\"exceptiontypes\",{\"1\":{\"507\":1}}],[\"exceptioncaught\",{\"1\":{\"237\":2}}],[\"exceptions\",{\"1\":{\"69\":1,\"70\":1}}],[\"exception\",{\"0\":{\"530\":1},\"1\":{\"69\":1,\"70\":1,\"198\":1,\"204\":1,\"237\":5,\"244\":2,\"245\":1,\"251\":2,\"317\":4,\"417\":1,\"484\":1,\"505\":1,\"506\":2,\"507\":1,\"530\":4,\"544\":1,\"598\":3,\"640\":1,\"684\":1}}],[\"exclusive\",{\"1\":{\"601\":1,\"603\":1,\"605\":2,\"607\":1,\"610\":1,\"617\":3,\"680\":1}}],[\"excludepathpatterns\",{\"1\":{\"318\":1}}],[\"exclude\",{\"1\":{\"306\":1}}],[\"exchange\",{\"1\":{\"355\":1}}],[\"exchange交换器\",{\"0\":{\"355\":1}}],[\"excalidraw\",{\"1\":{\"69\":2,\"70\":2}}],[\"example\",{\"1\":{\"69\":1,\"70\":2}}],[\"expect\",{\"1\":{\"604\":1,\"607\":2}}],[\"expected\",{\"1\":{\"553\":1,\"554\":1,\"578\":1}}],[\"exp\",{\"1\":{\"553\":1}}],[\"expr还可以是字符串\",{\"1\":{\"450\":1}}],[\"expr\",{\"1\":{\"450\":3}}],[\"express\",{\"1\":{\"70\":1}}],[\"exposedheaders\",{\"1\":{\"319\":1}}],[\"exponentialbackoffretry\",{\"1\":{\"251\":1}}],[\"export\",{\"1\":{\"69\":1,\"70\":3,\"71\":1}}],[\"explain\",{\"1\":{\"157\":1}}],[\"expires\",{\"1\":{\"388\":3}}],[\"expires来做为缓存判断的标准\",{\"1\":{\"33\":1}}],[\"expire\",{\"1\":{\"71\":3,\"434\":1,\"435\":1}}],[\"expire=$\",{\"1\":{\"71\":3}}],[\"expire=\",{\"1\":{\"71\":1}}],[\"exec\",{\"1\":{\"409\":2}}],[\"exec执行事务块内命令\",{\"1\":{\"408\":1}}],[\"executeupdate\",{\"1\":{\"201\":1}}],[\"executequery\",{\"1\":{\"201\":1}}],[\"execute\",{\"0\":{\"697\":1},\"1\":{\"200\":3,\"230\":1,\"669\":1,\"697\":1}}],[\"executor和executors的区别\",{\"0\":{\"676\":1}}],[\"executorservice接口继承了executor接口并进行了扩展\",{\"1\":{\"676\":1}}],[\"executors\",{\"1\":{\"629\":3,\"676\":1,\"696\":3}}],[\"executor\",{\"0\":{\"198\":1},\"1\":{\"194\":1,\"197\":5,\"198\":2,\"676\":1,\"711\":1}}],[\"executioncontext\",{\"1\":{\"69\":1,\"70\":1}}],[\"exe\",{\"1\":{\"68\":1}}],[\"externalizabledemo1\",{\"1\":{\"522\":1}}],[\"externalizable\",{\"1\":{\"522\":1}}],[\"externalizable继承自serializable\",{\"1\":{\"522\":1}}],[\"externalizable接口\",{\"1\":{\"484\":1}}],[\"extends\",{\"0\":{\"513\":1},\"1\":{\"237\":3,\"244\":2,\"245\":1,\"484\":1,\"507\":1,\"511\":1,\"512\":1,\"513\":1,\"587\":1,\"605\":1,\"616\":1,\"638\":1,\"714\":1}}],[\"extensions\",{\"1\":{\"3\":1}}],[\"extsts的子查询依然能用到表上的索引\",{\"1\":{\"96\":1}}],[\"extracted\",{\"1\":{\"70\":1}}],[\"extra\",{\"1\":{\"5\":1,\"157\":2}}],[\"rmi\",{\"1\":{\"519\":1}}],[\"rr\",{\"1\":{\"404\":1}}],[\"rdb文件生成完毕之后\",{\"1\":{\"420\":1}}],[\"rdb方式更适合做数据的备份\",{\"1\":{\"384\":1}}],[\"rdb\",{\"1\":{\"383\":1,\"399\":1}}],[\"rpcservice简单版本的实现\",{\"1\":{\"230\":1}}],[\"rpcserver\",{\"1\":{\"216\":1,\"223\":1,\"230\":9,\"237\":1}}],[\"rpcresponse中需要加入datatype字段\",{\"1\":{\"244\":1}}],[\"rpcresponse\",{\"1\":{\"223\":10,\"230\":4,\"237\":13,\"244\":3,\"251\":3}}],[\"rpcrequest\",{\"1\":{\"223\":6,\"230\":3,\"237\":5,\"244\":3,\"251\":1}}],[\"rpc需要经过网络传输\",{\"1\":{\"223\":1}}],[\"rpcclientproxy\",{\"1\":{\"231\":1,\"237\":5}}],[\"rpcclient\",{\"1\":{\"216\":1,\"223\":1,\"237\":4,\"251\":3}}],[\"rpc过程\",{\"0\":{\"210\":1}}],[\"rpc的基本概念\",{\"1\":{\"208\":1}}],[\"rpc的概念\",{\"0\":{\"207\":1}}],[\"rproxyip\",{\"1\":{\"71\":8}}],[\"robin\",{\"1\":{\"404\":1}}],[\"rocketmq是靠消息重试机制解决这个问题的\",{\"1\":{\"374\":1}}],[\"rocketmq是什么\",{\"0\":{\"362\":1}}],[\"rocketmq追求的是ap\",{\"1\":{\"374\":1}}],[\"rocketmq只需要一个轻量级的维护元数据信息的组件\",{\"1\":{\"374\":1}}],[\"rocketmq为什么自研nameserver而不用zk\",{\"0\":{\"374\":1}}],[\"rocketmq中的消息只会在commitlog被删除的时候才会消失\",{\"1\":{\"372\":1}}],[\"rocketmq的消息堆积如何处理\",{\"0\":{\"370\":1}}],[\"rocketmq如何保证消息不丢失\",{\"0\":{\"369\":1}}],[\"rocketmq没有真正意义的push\",{\"1\":{\"365\":1}}],[\"rocketmq消费消息是push还是pull\",{\"0\":{\"365\":1}}],[\"rocketmq消费模式有几种\",{\"0\":{\"364\":1}}],[\"rocketmq由哪些角色组成\",{\"0\":{\"363\":1}}],[\"rocketmq\",{\"0\":{\"350\":1},\"1\":{\"350\":5,\"362\":2}}],[\"round\",{\"1\":{\"404\":1}}],[\"roundloadbalance\",{\"1\":{\"258\":1}}],[\"routing\",{\"1\":{\"2\":1}}],[\"rootelement\",{\"1\":{\"204\":4}}],[\"root\",{\"1\":{\"204\":2,\"251\":2,\"506\":3,\"507\":1}}],[\"rows\",{\"1\":{\"157\":3}}],[\"row\",{\"1\":{\"92\":1,\"108\":2,\"112\":3,\"114\":1}}],[\"row级别下\",{\"1\":{\"89\":1}}],[\"row和mixed\",{\"1\":{\"89\":1}}],[\"rtt\",{\"1\":{\"70\":1}}],[\"rfc4648\",{\"1\":{\"69\":1,\"70\":1}}],[\"rs\",{\"1\":{\"69\":1,\"70\":1}}],[\"rst\",{\"1\":{\"20\":1}}],[\"race\",{\"1\":{\"567\":1}}],[\"rarely\",{\"1\":{\"553\":1}}],[\"radix\",{\"1\":{\"499\":2}}],[\"radio\",{\"1\":{\"70\":1}}],[\"rabbitmq如何将消息可靠投递到消费者\",{\"0\":{\"360\":1}}],[\"rabbitmq从队列中删除已经确定的消息\",{\"1\":{\"358\":1}}],[\"rabbitmq到消费者\",{\"1\":{\"356\":1}}],[\"rabbitmq自身\",{\"1\":{\"356\":1}}],[\"rabbitmq的内部对象\",{\"1\":{\"355\":1}}],[\"rabbitmq就是\",{\"1\":{\"353\":1}}],[\"rabbitmq除了原生支持amqp协议\",{\"1\":{\"352\":1}}],[\"rabbitmq使用一些机制来保证可靠性\",{\"1\":{\"352\":1}}],[\"rabbitmq特点\",{\"0\":{\"352\":1}}],[\"rabbitmq服务器是用erlang语言编写的\",{\"1\":{\"351\":1}}],[\"rabbitmq是实现了高级消息队列协议\",{\"1\":{\"351\":1}}],[\"rabbitmq是什么\",{\"0\":{\"351\":1}}],[\"rabbitmq\",{\"0\":{\"350\":1},\"1\":{\"350\":3,\"352\":4,\"353\":4,\"356\":1,\"361\":1,\"381\":1}}],[\"range\",{\"1\":{\"128\":3,\"157\":1,\"162\":1}}],[\"ranking\",{\"1\":{\"70\":1}}],[\"randomloadbalance\",{\"1\":{\"258\":1}}],[\"randomuuid\",{\"1\":{\"216\":1}}],[\"randomproxyip\",{\"1\":{\"71\":4}}],[\"randomhostname\",{\"1\":{\"69\":3,\"70\":3}}],[\"random\",{\"1\":{\"69\":3,\"70\":3,\"71\":4,\"216\":5,\"258\":4,\"388\":2,\"396\":1,\"553\":1}}],[\"rate\",{\"1\":{\"69\":1,\"70\":1}}],[\"ramdom\",{\"1\":{\"69\":1,\"70\":1}}],[\"rawtypes\",{\"1\":{\"559\":1}}],[\"rawclientdata\",{\"1\":{\"69\":6,\"70\":6}}],[\"rawdataindex\",{\"1\":{\"69\":3,\"70\":4}}],[\"raw\",{\"1\":{\"57\":1,\"58\":2,\"69\":2,\"70\":2,\"71\":6,\"682\":1}}],[\"rule\",{\"1\":{\"554\":1,\"578\":1}}],[\"ruby\",{\"1\":{\"352\":1}}],[\"rur0dw5uzww=\",{\"1\":{\"70\":1}}],[\"runworker方法的执行过程如下\",{\"1\":{\"714\":1}}],[\"runstate\",{\"1\":{\"712\":2}}],[\"running\",{\"1\":{\"623\":1,\"638\":2,\"639\":4,\"690\":1,\"712\":1}}],[\"runnable接口\",{\"1\":{\"629\":1,\"696\":1}}],[\"runnable规定\",{\"1\":{\"621\":1,\"688\":1}}],[\"runnable和callable的区别\",{\"1\":{\"621\":1,\"688\":1}}],[\"runnable\",{\"0\":{\"629\":1,\"696\":1},\"1\":{\"230\":1,\"623\":1,\"629\":4,\"638\":4,\"639\":2,\"690\":1,\"696\":4,\"714\":2}}],[\"run方法不可以\",{\"1\":{\"621\":1,\"688\":1}}],[\"run方法\",{\"1\":{\"367\":1}}],[\"runtimeexception\",{\"1\":{\"198\":1,\"203\":4,\"244\":2,\"530\":1,\"531\":2}}],[\"runtime\",{\"1\":{\"69\":1,\"70\":1,\"230\":1,\"444\":1,\"675\":1}}],[\"run\",{\"0\":{\"635\":2,\"703\":2},\"1\":{\"69\":1,\"70\":1,\"230\":1,\"426\":1,\"442\":1,\"635\":4,\"638\":5,\"640\":1,\"703\":4}}],[\"russia\",{\"1\":{\"62\":1}}],[\"r\",{\"1\":{\"69\":1,\"70\":1,\"71\":3,\"79\":1,\"148\":1,\"612\":3}}],[\"rweek\",{\"1\":{\"58\":2,\"71\":1}}],[\"reetrantlock主要依靠aqs维护一个阻塞队列\",{\"1\":{\"666\":1}}],[\"reetrantlock实现依赖于aqs\",{\"1\":{\"666\":1}}],[\"reetrantlock是一个可重入的独占锁\",{\"1\":{\"666\":1}}],[\"reentrantreadwritelock是readwritelock接口的一个具体实现\",{\"1\":{\"667\":1}}],[\"reentrantreadwritelock\",{\"1\":{\"601\":1,\"680\":1}}],[\"reentrantlock类线程对象可以注册在指定的condition中\",{\"1\":{\"648\":1,\"707\":1}}],[\"reentrantlock类的reentrantlock\",{\"1\":{\"648\":1,\"707\":1}}],[\"reentrantlock默认情况是非公平的\",{\"1\":{\"648\":1,\"707\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"648\":1,\"707\":1}}],[\"reentrantlock增加了一些高级功能\",{\"1\":{\"648\":1,\"707\":1}}],[\"reentrantlock中公平锁和非公平锁在底层是相同的\",{\"1\":{\"605\":1}}],[\"reentrantlock等\",{\"1\":{\"601\":1}}],[\"reentrantlock\",{\"0\":{\"615\":1,\"648\":1},\"1\":{\"546\":2,\"549\":1,\"584\":1,\"587\":1,\"605\":1,\"617\":1,\"618\":1,\"648\":5,\"681\":1,\"707\":5}}],[\"rehash操作将不会发生\",{\"1\":{\"554\":1,\"578\":1}}],[\"rehash\",{\"1\":{\"554\":2,\"559\":1,\"578\":2}}],[\"re\",{\"1\":{\"316\":2}}],[\"reuest需要抽象\",{\"1\":{\"219\":1}}],[\"reuse\",{\"1\":{\"20\":2}}],[\"reuseaddr\",{\"1\":{\"20\":1}}],[\"reflected\",{\"1\":{\"554\":1,\"578\":1}}],[\"reflec\",{\"1\":{\"504\":3}}],[\"reflflectasm工具类\",{\"1\":{\"502\":1}}],[\"ref\",{\"1\":{\"157\":4}}],[\"refer\",{\"1\":{\"71\":1}}],[\"referer\",{\"1\":{\"69\":1,\"70\":1}}],[\"referencetype\",{\"1\":{\"489\":1,\"493\":1}}],[\"reference\",{\"1\":{\"5\":1}}],[\"redlock的原理\",{\"0\":{\"437\":1}}],[\"redlock官方推荐\",{\"1\":{\"436\":1}}],[\"redlock也就是\",{\"1\":{\"436\":1}}],[\"redlock是一种算法\",{\"1\":{\"436\":1}}],[\"redis官方给出的\",{\"1\":{\"439\":1}}],[\"redis单主的瓶颈不在于读写的并发\",{\"1\":{\"439\":1}}],[\"redis单副本\",{\"1\":{\"413\":1,\"414\":1}}],[\"redis对外提供了string\",{\"1\":{\"438\":1}}],[\"redis本质是一个数据结构服务器\",{\"1\":{\"438\":1}}],[\"redis本质上是一个key\",{\"1\":{\"376\":1}}],[\"redis如何做内存优化\",{\"0\":{\"438\":1}}],[\"redisson完成了对redlock算法封装\",{\"1\":{\"436\":1}}],[\"redisserializationcontext\",{\"1\":{\"314\":1}}],[\"redis实现分布式锁\",{\"0\":{\"433\":1}}],[\"redis哨兵是怎么工作的\",{\"0\":{\"425\":1}}],[\"redis主从架构数据会丢失吗\",{\"0\":{\"423\":1}}],[\"redis加入了一个新特性来解决主从不一致导致读取到过期数据问题\",{\"1\":{\"421\":1}}],[\"redis高可用方案具体怎么实施\",{\"0\":{\"419\":1}}],[\"redis3\",{\"1\":{\"417\":1}}],[\"redis数据节点中slave节点作为备份节点不提供服务\",{\"1\":{\"416\":1}}],[\"redis复制中断后\",{\"1\":{\"415\":1}}],[\"redis自研的高可用解决方案\",{\"1\":{\"418\":1}}],[\"redis自研\",{\"1\":{\"413\":1}}],[\"redis多副本\",{\"1\":{\"413\":1,\"415\":1}}],[\"redis常见使用方式有哪些\",{\"0\":{\"413\":1}}],[\"redis可以保证脚本内的命令一次性\",{\"1\":{\"412\":1}}],[\"redis可单独部署\",{\"1\":{\"380\":1}}],[\"redis服务器会在重新启动时执行一系列必要的一致性检测\",{\"1\":{\"407\":1}}],[\"redis事务其他实现\",{\"0\":{\"412\":1}}],[\"redis事务支持隔离性吗\",{\"0\":{\"410\":1}}],[\"redis事务功能是通过multi\",{\"1\":{\"409\":1}}],[\"redis事务相关命令\",{\"0\":{\"409\":1}}],[\"redis事务的三个阶段\",{\"0\":{\"408\":1}}],[\"redis事务的概念\",{\"0\":{\"407\":1}}],[\"redis事务中所有命令都会序列化\",{\"1\":{\"407\":1}}],[\"redis事务中如果有某一条命令执行失败\",{\"1\":{\"407\":1}}],[\"redis这一类复杂的网络\",{\"1\":{\"401\":1}}],[\"redis在\",{\"1\":{\"400\":1}}],[\"redis真的是单线程\",{\"0\":{\"400\":1}}],[\"redis真正的性能瓶颈在于网络\",{\"1\":{\"399\":1}}],[\"redis不仅仅提供了简单的\",{\"1\":{\"399\":1}}],[\"redis选择单线程可以说是多方博弈之后的一种权衡\",{\"1\":{\"399\":1}}],[\"redis选择多线程模型\",{\"1\":{\"399\":1}}],[\"redis选择了单线程的\",{\"1\":{\"399\":1}}],[\"redisrunning\",{\"1\":{\"399\":1}}],[\"redisis\",{\"1\":{\"399\":1}}],[\"redis为什么不支持事务回滚\",{\"0\":{\"411\":1}}],[\"redis为什么这么快\",{\"0\":{\"377\":1}}],[\"redis为何选择单线程\",{\"0\":{\"399\":1}}],[\"redis集群来避免\",{\"1\":{\"396\":1}}],[\"redisv4\",{\"1\":{\"388\":2,\"400\":2}}],[\"redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘\",{\"1\":{\"407\":1}}],[\"redis会触发内存淘汰策略\",{\"1\":{\"388\":1}}],[\"redis会周期性的随机测试一批设置了过期时间的key并进行处理\",{\"1\":{\"386\":1}}],[\"redis内存淘汰策略\",{\"0\":{\"388\":1}}],[\"redis过期键的删除策略\",{\"0\":{\"386\":1}}],[\"redis持久化数据和缓存怎么做扩容\",{\"0\":{\"385\":1}}],[\"redis持久化机制\",{\"0\":{\"383\":1}}],[\"redis4\",{\"1\":{\"384\":2}}],[\"redis就会启动aof文件的内容压缩\",{\"1\":{\"383\":1}}],[\"redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\",{\"1\":{\"383\":1}}],[\"redis启动之初会读取该文件重新构建数据\",{\"1\":{\"383\":1}}],[\"redishash\",{\"1\":{\"382\":1}}],[\"redis列表结构\",{\"1\":{\"381\":1}}],[\"redis有专门的管理工具可以查看缓存数据\",{\"1\":{\"380\":1}}],[\"redis有诸多可以直接应用的优化数据结构的实现\",{\"1\":{\"377\":1}}],[\"redis相比memcached来说\",{\"1\":{\"378\":1}}],[\"redis相比memcached有哪些优势\",{\"0\":{\"378\":1}}],[\"redis提供了两种不同的持久化方法可以将数据存储在磁盘中\",{\"1\":{\"383\":1}}],[\"redis提供了发布\",{\"1\":{\"381\":1}}],[\"redis提供了键过期功能\",{\"1\":{\"381\":1}}],[\"redis提供的哈希\",{\"1\":{\"381\":1}}],[\"redis提供的incr命令来实现计数器功能\",{\"1\":{\"381\":1}}],[\"redis提供的有序集合数据类构能实现各种复杂的排行榜应用\",{\"1\":{\"381\":1}}],[\"redis提供主从同步机制\",{\"1\":{\"378\":1}}],[\"redis提高数据库容量的办法有两种\",{\"1\":{\"377\":1}}],[\"redis支持多线程主要就是两个原因\",{\"1\":{\"401\":1}}],[\"redis支持服务器端的数据操作\",{\"1\":{\"378\":1}}],[\"redis支持数据落地持久化存储\",{\"1\":{\"378\":1}}],[\"redis支持更为丰富的数据类型\",{\"1\":{\"378\":1}}],[\"redis直接自己构建了\",{\"1\":{\"377\":1}}],[\"redis使用多线程模式\",{\"1\":{\"399\":1}}],[\"redis使用多路复用io技术\",{\"1\":{\"377\":1}}],[\"redis使用单线程的多路\",{\"1\":{\"378\":1}}],[\"redis使用单个线程处理请求\",{\"1\":{\"377\":1}}],[\"redis是单线程机制\",{\"1\":{\"414\":1}}],[\"redis是一个数据库\",{\"1\":{\"399\":1}}],[\"redis是完全的纯内存操作\",{\"1\":{\"399\":1}}],[\"redis是不断的删除一些过期数据\",{\"1\":{\"388\":1}}],[\"redis是使用内存\",{\"1\":{\"377\":1}}],[\"redis是什么\",{\"0\":{\"376\":1}}],[\"redis还支持\",{\"1\":{\"376\":1}}],[\"redis的几种常见使用方式包括\",{\"1\":{\"413\":1}}],[\"redis的事务并不是我们传统意义上理解的事务\",{\"1\":{\"407\":1}}],[\"redis的线程模型包括redis\",{\"1\":{\"403\":1}}],[\"redis的性能有两个方向\",{\"1\":{\"401\":1}}],[\"redis的性能非常出色\",{\"1\":{\"376\":1}}],[\"redis的单线程模式会导致系统消耗很多\",{\"1\":{\"401\":1}}],[\"redis的网络\",{\"1\":{\"401\":1}}],[\"redis的版本中两个重要的节点\",{\"1\":{\"400\":1}}],[\"redis的实现变得更加复杂\",{\"1\":{\"399\":1}}],[\"redis的话\",{\"1\":{\"399\":1}}],[\"redis的核心网络模型选择用单线程来实现\",{\"1\":{\"399\":1}}],[\"redis的过期删除策略就是\",{\"1\":{\"386\":1}}],[\"redis的数据类型有哪些\",{\"0\":{\"382\":1}}],[\"redis的常用场景有哪些\",{\"0\":{\"381\":1}}],[\"redis的速度比memcached快很多\",{\"1\":{\"378\":1}}],[\"redis的vm\",{\"1\":{\"377\":1}}],[\"redis的所有操作都是原子性的\",{\"1\":{\"376\":1}}],[\"redis能读的速度是110000次\",{\"1\":{\"376\":1}}],[\"rediscacheconfiguration\",{\"1\":{\"314\":4}}],[\"rediscachewriter\",{\"1\":{\"314\":4}}],[\"rediscachemanager\",{\"1\":{\"314\":3}}],[\"redisconf\",{\"1\":{\"402\":1}}],[\"redisconfig\",{\"1\":{\"314\":1}}],[\"redisconnectionfactory\",{\"1\":{\"314\":1}}],[\"redistemplate<>\",{\"1\":{\"314\":1}}],[\"redistemplate<string\",{\"1\":{\"314\":2,\"316\":1}}],[\"redistemplate\",{\"1\":{\"314\":12,\"316\":3}}],[\"redis\",{\"0\":{\"314\":1,\"379\":1,\"380\":1,\"387\":1,\"401\":1,\"402\":1,\"404\":1,\"405\":1,\"406\":1,\"429\":1,\"430\":1},\"1\":{\"135\":1,\"342\":2,\"377\":1,\"380\":6,\"388\":1,\"389\":1,\"391\":5,\"393\":2,\"396\":1,\"399\":1,\"400\":1,\"401\":1,\"402\":2,\"403\":13,\"405\":1,\"406\":1,\"407\":3,\"409\":1,\"410\":2,\"411\":2,\"413\":3,\"416\":5,\"417\":9,\"429\":2,\"430\":1,\"432\":3,\"435\":3,\"436\":2,\"439\":1}}],[\"redirect产生的场景\",{\"1\":{\"417\":1}}],[\"redirect\",{\"1\":{\"69\":4,\"70\":3,\"417\":1}}],[\"redolog\",{\"1\":{\"106\":1}}],[\"redo\",{\"0\":{\"106\":1},\"1\":{\"104\":1,\"105\":2,\"106\":3}}],[\"requirenon\",{\"1\":{\"594\":1}}],[\"requires\",{\"1\":{\"289\":1}}],[\"required类似的操作\",{\"1\":{\"289\":1}}],[\"required\",{\"1\":{\"71\":2,\"289\":1}}],[\"requst\",{\"1\":{\"244\":1}}],[\"requestparam\",{\"0\":{\"296\":1},\"1\":{\"296\":1}}],[\"requesttoviewnametranslator\",{\"1\":{\"291\":1}}],[\"requestmapping\",{\"0\":{\"293\":1,\"295\":1},\"1\":{\"291\":1,\"292\":1,\"293\":1,\"295\":3}}],[\"request内有效\",{\"1\":{\"269\":1}}],[\"request的构建\",{\"1\":{\"223\":1}}],[\"request序列化\",{\"1\":{\"210\":1}}],[\"requests\",{\"1\":{\"70\":1,\"399\":1}}],[\"request\",{\"1\":{\"33\":1,\"69\":17,\"70\":25,\"71\":6,\"212\":1,\"223\":9,\"225\":1,\"229\":1,\"230\":7,\"237\":10,\"244\":11,\"251\":4,\"269\":1,\"272\":1,\"299\":2,\"317\":7}}],[\"reject\",{\"1\":{\"71\":1}}],[\"regular\",{\"1\":{\"553\":1}}],[\"regex的正则匹配类\",{\"1\":{\"201\":1}}],[\"regex\",{\"1\":{\"71\":3}}],[\"registry\",{\"1\":{\"318\":2,\"319\":2}}],[\"register\",{\"1\":{\"60\":1,\"251\":3}}],[\"region==\",{\"1\":{\"52\":2}}],[\"renren\",{\"1\":{\"70\":2}}],[\"rendered\",{\"1\":{\"3\":1}}],[\"review\",{\"1\":{\"70\":1}}],[\"reviewing\",{\"1\":{\"70\":1}}],[\"reverse\",{\"1\":{\"69\":1,\"70\":1}}],[\"relay\",{\"1\":{\"132\":1,\"133\":2}}],[\"rel=\",{\"1\":{\"70\":1}}],[\"relevant\",{\"1\":{\"70\":2}}],[\"release中会调用tryrelease方法\",{\"1\":{\"615\":1}}],[\"release\",{\"1\":{\"611\":1}}],[\"releaselock\",{\"1\":{\"69\":2,\"70\":2}}],[\"releaseshared\",{\"1\":{\"613\":1}}],[\"releases\",{\"1\":{\"68\":3,\"251\":1,\"617\":2}}],[\"reputmessageservice\",{\"1\":{\"367\":1}}],[\"repl\",{\"1\":{\"420\":2}}],[\"replicas\",{\"1\":{\"334\":1,\"338\":3}}],[\"replication\",{\"1\":{\"334\":1,\"415\":1}}],[\"replica\",{\"0\":{\"339\":2},\"1\":{\"323\":6,\"334\":1,\"340\":1}}],[\"replaceall\",{\"1\":{\"196\":1,\"201\":1}}],[\"replace\",{\"1\":{\"69\":2,\"70\":2,\"71\":2}}],[\"repository\",{\"1\":{\"271\":1}}],[\"repo=repository\",{\"1\":{\"70\":1}}],[\"repeatable\",{\"1\":{\"76\":2,\"102\":3,\"120\":1}}],[\"removal\",{\"1\":{\"553\":1}}],[\"removeall\",{\"1\":{\"574\":1}}],[\"remove\",{\"1\":{\"70\":2}}],[\"remotechunkcount++\",{\"1\":{\"69\":1,\"70\":1}}],[\"remotechunkcount\",{\"1\":{\"69\":2,\"70\":2}}],[\"remotesockettows\",{\"1\":{\"69\":3,\"70\":3}}],[\"remotesocket\",{\"1\":{\"69\":8,\"70\":8}}],[\"remotesocketwapper\",{\"1\":{\"69\":4,\"70\":4}}],[\"remote\",{\"1\":{\"69\":7,\"70\":11}}],[\"reactor\",{\"1\":{\"403\":2}}],[\"reassign\",{\"1\":{\"340\":1}}],[\"reassignpartition\",{\"1\":{\"340\":1}}],[\"reason\",{\"1\":{\"69\":6,\"70\":6}}],[\"readwritelock\",{\"1\":{\"680\":1}}],[\"readwritelock是一个读写锁接口\",{\"1\":{\"667\":1}}],[\"readwritelock是什么\",{\"0\":{\"667\":1}}],[\"readexternal\",{\"1\":{\"522\":1}}],[\"reader\",{\"1\":{\"506\":2,\"539\":1,\"543\":2}}],[\"readbytes\",{\"1\":{\"244\":1}}],[\"readshort\",{\"1\":{\"244\":2}}],[\"readint\",{\"1\":{\"216\":1,\"244\":1}}],[\"readobject\",{\"1\":{\"216\":1,\"223\":2,\"230\":1,\"237\":1,\"244\":1,\"251\":1,\"521\":1,\"522\":2}}],[\"readmapperxml\",{\"1\":{\"196\":2,\"204\":2}}],[\"read级别下\",{\"1\":{\"119\":1}}],[\"read隔离级别\",{\"1\":{\"102\":1}}],[\"read\",{\"1\":{\"69\":1,\"70\":3,\"76\":6,\"102\":8,\"120\":2,\"204\":1,\"506\":1,\"521\":1,\"522\":1}}],[\"readable\",{\"1\":{\"69\":5,\"70\":8,\"403\":8}}],[\"readablestream\",{\"1\":{\"69\":3,\"70\":2}}],[\"readablestreamcancel\",{\"1\":{\"69\":5,\"70\":2}}],[\"readablewebsocketstream\",{\"1\":{\"69\":3,\"70\":3}}],[\"readystate\",{\"1\":{\"69\":5,\"70\":5}}],[\"ready\",{\"1\":{\"69\":7,\"70\":7}}],[\"real\",{\"1\":{\"69\":2,\"70\":2}}],[\"retailer\",{\"1\":{\"70\":1}}],[\"retailers\",{\"1\":{\"70\":1}}],[\"retail\",{\"1\":{\"70\":1}}],[\"rethinkdns\",{\"1\":{\"70\":1}}],[\"retries=max\",{\"1\":{\"334\":1}}],[\"retries\",{\"1\":{\"70\":1,\"547\":1}}],[\"retrypolicy\",{\"1\":{\"251\":2}}],[\"retry\",{\"1\":{\"69\":9,\"70\":9,\"373\":1}}],[\"retransmit\",{\"1\":{\"24\":1}}],[\"returntype\",{\"1\":{\"200\":3,\"507\":1}}],[\"return\",{\"0\":{\"452\":1,\"536\":1},\"1\":{\"69\":40,\"70\":43,\"71\":18,\"194\":1,\"195\":2,\"196\":1,\"197\":4,\"198\":3,\"199\":6,\"200\":6,\"201\":4,\"203\":2,\"204\":11,\"216\":1,\"223\":7,\"230\":4,\"237\":7,\"244\":10,\"251\":7,\"258\":2,\"268\":1,\"313\":10,\"314\":2,\"315\":1,\"316\":4,\"317\":2,\"319\":1,\"452\":1,\"476\":1,\"481\":1,\"484\":1,\"499\":3,\"505\":1,\"507\":1,\"521\":2,\"522\":2,\"536\":8,\"555\":5,\"556\":3,\"558\":1,\"559\":2,\"573\":3,\"579\":4,\"581\":1,\"595\":1,\"607\":3,\"611\":2,\"612\":1,\"613\":2,\"616\":4,\"617\":4}}],[\"returns\",{\"1\":{\"69\":6,\"70\":13}}],[\"resule\",{\"1\":{\"629\":1,\"696\":1}}],[\"resulttype=\",{\"1\":{\"199\":1,\"205\":2}}],[\"resulttype\",{\"1\":{\"199\":6,\"204\":5}}],[\"resulttype等属性\",{\"1\":{\"197\":1}}],[\"resultsethandler\",{\"1\":{\"198\":4,\"203\":2}}],[\"resultset\",{\"0\":{\"203\":1},\"1\":{\"198\":3,\"201\":2,\"203\":11}}],[\"result\",{\"1\":{\"60\":1,\"200\":4,\"203\":4,\"251\":3}}],[\"resize\",{\"1\":{\"556\":4,\"558\":1,\"559\":4,\"564\":1,\"566\":1,\"580\":1,\"581\":1}}],[\"resizing\",{\"1\":{\"553\":3}}],[\"res\",{\"1\":{\"507\":4}}],[\"resynchronization的时候\",{\"1\":{\"420\":1}}],[\"resynchronization\",{\"1\":{\"420\":1}}],[\"rest安全吗\",{\"0\":{\"303\":1}}],[\"rest\",{\"0\":{\"300\":1,\"301\":1,\"302\":1},\"1\":{\"300\":3,\"301\":1,\"302\":4,\"303\":1}}],[\"restful\",{\"1\":{\"294\":1,\"300\":1}}],[\"restcontroller\",{\"0\":{\"294\":1},\"1\":{\"294\":1,\"297\":1}}],[\"resources\",{\"1\":{\"308\":1}}],[\"resource\",{\"1\":{\"70\":1,\"317\":1,\"682\":1}}],[\"resolve\",{\"1\":{\"237\":1}}],[\"resolves\",{\"1\":{\"69\":1,\"70\":4}}],[\"resolver\",{\"1\":{\"69\":1,\"70\":2}}],[\"resp\",{\"1\":{\"69\":2,\"70\":2}}],[\"response需要抽象\",{\"1\":{\"219\":1}}],[\"responsebody\",{\"1\":{\"71\":2,\"294\":1,\"297\":2}}],[\"responsetext\",{\"1\":{\"71\":2}}],[\"responses\",{\"1\":{\"71\":2}}],[\"response\",{\"1\":{\"69\":12,\"70\":15,\"71\":29,\"212\":1,\"223\":5,\"230\":2,\"237\":9,\"244\":9,\"251\":3,\"317\":9}}],[\"reset\",{\"1\":{\"15\":1}}],[\"recently\",{\"1\":{\"388\":1}}],[\"recipes<\",{\"1\":{\"251\":1}}],[\"recruitment\",{\"1\":{\"70\":2}}],[\"recovery\",{\"1\":{\"24\":1}}],[\"recycle\",{\"1\":{\"20\":1}}],[\"recv\",{\"1\":{\"14\":1,\"15\":1}}],[\"recv状态\",{\"1\":{\"11\":1}}],[\"dpdk\",{\"1\":{\"401\":2}}],[\"dlq\",{\"1\":{\"373\":1}}],[\"dls\",{\"1\":{\"71\":7}}],[\"driver=com\",{\"1\":{\"205\":1}}],[\"drivermanager\",{\"1\":{\"198\":1,\"506\":2}}],[\"driver\",{\"1\":{\"198\":3,\"204\":2,\"205\":1,\"502\":1,\"506\":1}}],[\"drop\",{\"0\":{\"97\":1}}],[\"d的顺序可以任意调整\",{\"1\":{\"154\":1,\"161\":1}}],[\"dbpass\",{\"1\":{\"506\":2}}],[\"dbuser\",{\"1\":{\"506\":2}}],[\"dburl\",{\"1\":{\"506\":2}}],[\"dbdriver\",{\"1\":{\"506\":2}}],[\"db\",{\"1\":{\"144\":1,\"198\":4,\"204\":8,\"205\":4,\"388\":4,\"391\":1,\"399\":1}}],[\"dbms\",{\"1\":{\"116\":1,\"181\":1}}],[\"d是用不到索引的\",{\"1\":{\"84\":1,\"154\":1,\"161\":1}}],[\"d+\",{\"1\":{\"71\":1}}],[\"d\",{\"1\":{\"71\":4,\"84\":2,\"154\":3,\"161\":3}}],[\"ddd\",{\"1\":{\"70\":1}}],[\"ddos则是采用分布式的方法\",{\"1\":{\"43\":1}}],[\"ddos全称distributed\",{\"1\":{\"43\":1}}],[\"dmxlc3m=\",{\"1\":{\"70\":1}}],[\"dmg\",{\"1\":{\"68\":1}}],[\"dubbo\",{\"1\":{\"236\":1}}],[\"duboo基本功能\",{\"0\":{\"209\":1}}],[\"dump\",{\"1\":{\"132\":1,\"729\":2}}],[\"during\",{\"1\":{\"70\":1}}],[\"due\",{\"1\":{\"69\":1,\"70\":1,\"553\":1}}],[\"dao层\",{\"1\":{\"271\":1}}],[\"dao\",{\"1\":{\"271\":1}}],[\"dao接口的工作原理是jdk动态代理\",{\"1\":{\"182\":1}}],[\"dao接口即mapper接口\",{\"1\":{\"182\":1}}],[\"dao接口里的方法\",{\"0\":{\"182\":1},\"1\":{\"182\":1}}],[\"daily\",{\"1\":{\"70\":1}}],[\"dark\",{\"1\":{\"70\":2}}],[\"daliy\",{\"1\":{\"70\":1}}],[\"day\",{\"1\":{\"70\":2}}],[\"datasource\",{\"0\":{\"748\":1}}],[\"datasourceautoconfiguration\",{\"1\":{\"306\":1}}],[\"datatype\",{\"1\":{\"244\":3}}],[\"datacenter\",{\"1\":{\"71\":2}}],[\"datacenterindex\",{\"1\":{\"71\":2}}],[\"data=$\",{\"1\":{\"70\":1}}],[\"dataview\",{\"1\":{\"69\":5,\"70\":5}}],[\"data\",{\"1\":{\"69\":8,\"70\":15,\"71\":3,\"82\":2,\"108\":1,\"216\":1,\"223\":6,\"230\":1,\"307\":1,\"391\":2}}],[\"date=\",{\"1\":{\"157\":1}}],[\"date\",{\"1\":{\"32\":1,\"70\":2,\"71\":1,\"166\":1,\"316\":1}}],[\"dn\",{\"1\":{\"64\":1}}],[\"dnsqueryresult\",{\"1\":{\"69\":5,\"70\":5}}],[\"dnschecker\",{\"1\":{\"62\":1}}],[\"dns\",{\"1\":{\"10\":1,\"38\":2,\"69\":9,\"70\":15}}],[\"dynadot\",{\"1\":{\"60\":1}}],[\"dynv6\",{\"1\":{\"53\":3}}],[\"dfa49bfcd88b\",{\"1\":{\"53\":4,\"69\":2,\"70\":3}}],[\"divided\",{\"1\":{\"554\":1,\"578\":1}}],[\"dimensions\",{\"1\":{\"493\":1}}],[\"dict\",{\"1\":{\"388\":1}}],[\"di\",{\"1\":{\"270\":2}}],[\"diamond\",{\"1\":{\"124\":1}}],[\"dianyou\",{\"1\":{\"70\":2}}],[\"dianping\",{\"1\":{\"70\":2}}],[\"dirname\",{\"1\":{\"196\":5}}],[\"dir\",{\"1\":{\"196\":2}}],[\"dirty\",{\"1\":{\"102\":1}}],[\"direction\",{\"1\":{\"69\":1}}],[\"directory\",{\"1\":{\"2\":1,\"70\":1}}],[\"distribution\",{\"1\":{\"553\":2}}],[\"distributed\",{\"1\":{\"435\":1,\"436\":1,\"553\":1}}],[\"distinct\",{\"1\":{\"155\":2,\"161\":1}}],[\"diskless\",{\"1\":{\"420\":2}}],[\"discardoldestpolicy\",{\"1\":{\"670\":1}}],[\"discardpolicy\",{\"1\":{\"670\":1}}],[\"discard和watch\",{\"1\":{\"409\":1}}],[\"discard\",{\"1\":{\"408\":2}}],[\"discuss\",{\"1\":{\"25\":1}}],[\"dispaterservlet\",{\"1\":{\"290\":1}}],[\"dispatcherservlet\",{\"1\":{\"290\":3,\"291\":3}}],[\"disposition\",{\"1\":{\"71\":3}}],[\"digest\",{\"1\":{\"70\":1}}],[\"digitalocean\",{\"1\":{\"57\":1,\"62\":1}}],[\"different\",{\"1\":{\"69\":1,\"70\":1}}],[\"dingyue\",{\"1\":{\"58\":1}}],[\"doreleaseshared\",{\"1\":{\"613\":1}}],[\"doacquireshared\",{\"1\":{\"612\":2}}],[\"do\",{\"1\":{\"558\":1,\"559\":1,\"581\":1,\"732\":1}}],[\"dolphin0520\",{\"1\":{\"469\":1}}],[\"down\",{\"1\":{\"425\":1,\"426\":1}}],[\"download=$\",{\"1\":{\"71\":3}}],[\"download\",{\"1\":{\"68\":2,\"70\":2}}],[\"dongzl\",{\"1\":{\"343\":1}}],[\"doquery中\",{\"1\":{\"198\":1}}],[\"doquery\",{\"1\":{\"197\":1,\"198\":2}}],[\"double\",{\"1\":{\"449\":2,\"489\":1,\"493\":2,\"532\":1,\"559\":1}}],[\"douban\",{\"1\":{\"70\":4}}],[\"doupdate\",{\"1\":{\"197\":1,\"198\":2}}],[\"douyin\",{\"1\":{\"70\":2}}],[\"dohurl\",{\"1\":{\"69\":1,\"70\":4}}],[\"domains\",{\"1\":{\"69\":1,\"70\":1}}],[\"domains查看\",{\"1\":{\"61\":1}}],[\"domain\",{\"1\":{\"60\":1,\"69\":1,\"70\":1}}],[\"doc\",{\"1\":{\"506\":2}}],[\"dockone\",{\"1\":{\"343\":1}}],[\"dockkkk\",{\"1\":{\"57\":1,\"58\":1}}],[\"document\",{\"1\":{\"204\":3,\"506\":1}}],[\"documentation\",{\"1\":{\"71\":1}}],[\"doctype\",{\"1\":{\"71\":1}}],[\"docs\",{\"1\":{\"5\":1}}],[\"dos攻击现在基本没啥作用了\",{\"1\":{\"43\":1}}],[\"dos\",{\"1\":{\"14\":1}}],[\"dead\",{\"1\":{\"623\":1,\"690\":1}}],[\"deafult\",{\"1\":{\"193\":1}}],[\"decrease\",{\"1\":{\"554\":1,\"578\":1}}],[\"decoration\",{\"1\":{\"70\":1}}],[\"decoding\",{\"1\":{\"70\":1}}],[\"decode类\",{\"1\":{\"244\":1}}],[\"decoded\",{\"1\":{\"70\":1}}],[\"decodes\",{\"1\":{\"70\":1}}],[\"decode\",{\"1\":{\"69\":3,\"70\":4,\"244\":1}}],[\"design\",{\"1\":{\"300\":1}}],[\"deserialize\",{\"1\":{\"244\":6}}],[\"description\",{\"1\":{\"70\":3,\"205\":2}}],[\"dependency\",{\"1\":{\"270\":1}}],[\"dependency>\",{\"1\":{\"237\":1,\"251\":1}}],[\"dependent\",{\"1\":{\"157\":1}}],[\"del和expire实现的分布式锁还是存在着一些问题\",{\"1\":{\"435\":1}}],[\"del\",{\"1\":{\"434\":1,\"435\":1}}],[\"deliver\",{\"1\":{\"399\":1}}],[\"delivery\",{\"1\":{\"70\":1}}],[\"delkey\",{\"1\":{\"391\":2}}],[\"delayedworkqueue\",{\"1\":{\"673\":3}}],[\"delay\",{\"1\":{\"69\":1,\"70\":1,\"420\":1}}],[\"delete与truncate的区别\",{\"0\":{\"97\":1}}],[\"delete\",{\"1\":{\"29\":3,\"104\":1,\"108\":1,\"162\":1,\"200\":1,\"295\":1,\"301\":1,\"319\":1}}],[\"de\",{\"1\":{\"65\":2}}],[\"development\",{\"1\":{\"69\":1,\"70\":1,\"300\":1,\"444\":1}}],[\"developer\",{\"1\":{\"25\":1,\"70\":1,\"438\":1}}],[\"dev\",{\"1\":{\"61\":1,\"69\":3,\"70\":2,\"71\":7,\"305\":2}}],[\"dedyn\",{\"1\":{\"57\":10,\"71\":4}}],[\"denial\",{\"1\":{\"43\":1}}],[\"definitions\",{\"1\":{\"268\":1}}],[\"deflate\",{\"1\":{\"32\":1,\"71\":1}}],[\"defaulthandler\",{\"1\":{\"670\":1}}],[\"defaultcapacity\",{\"1\":{\"573\":1}}],[\"defaultcacheconfig\",{\"1\":{\"314\":1}}],[\"defaults\",{\"1\":{\"559\":1}}],[\"defaultsqlsessionfactory\",{\"1\":{\"195\":1,\"196\":3}}],[\"defaultsqlsession\",{\"1\":{\"194\":1,\"196\":1,\"197\":2}}],[\"defaultmessagestore\",{\"1\":{\"367\":1}}],[\"defaultresultsethandler\",{\"1\":{\"198\":1,\"203\":2}}],[\"defaultparameterhandler\",{\"1\":{\"198\":1,\"202\":2}}],[\"default\",{\"1\":{\"5\":2,\"69\":3,\"70\":4,\"71\":1,\"87\":1,\"200\":1,\"204\":3,\"244\":2,\"451\":1,\"553\":1,\"554\":1,\"559\":4,\"573\":1,\"578\":1}}],[\"details\",{\"1\":{\"2\":1,\"25\":1,\"144\":2,\"483\":1,\"544\":3,\"599\":1,\"618\":1,\"685\":2,\"723\":1}}],[\"md4\",{\"1\":{\"560\":1}}],[\"md5等等\",{\"1\":{\"560\":1}}],[\"md5\",{\"1\":{\"95\":1}}],[\"mp\",{\"1\":{\"544\":1}}],[\"mpconfig\",{\"1\":{\"315\":1}}],[\"mget\",{\"1\":{\"417\":1}}],[\"mget目前只支持具有相同slot值的key执行批量操作\",{\"1\":{\"417\":1}}],[\"mgtv\",{\"1\":{\"70\":2}}],[\"mmap的创建和销毁成本可能是不一样的\",{\"1\":{\"341\":1}}],[\"mmap虽然避免了不必要的拷贝\",{\"1\":{\"341\":1}}],[\"mq将已消费的消息删除\",{\"1\":{\"360\":1}}],[\"mq将消息push给client\",{\"1\":{\"360\":1}}],[\"mq将消息持久化后\",{\"1\":{\"359\":1}}],[\"mqtt3\",{\"1\":{\"353\":1}}],[\"mqtt等多种消息\",{\"1\":{\"352\":1}}],[\"mq也可以不用慌忙\",{\"1\":{\"345\":1}}],[\"mq的本质就是业务的排队\",{\"1\":{\"345\":1}}],[\"mq\",{\"0\":{\"344\":1},\"1\":{\"331\":1,\"337\":2,\"343\":1,\"346\":6,\"347\":2,\"348\":6,\"350\":3}}],[\"mvc\",{\"0\":{\"291\":1,\"299\":1},\"1\":{\"271\":1,\"286\":1,\"290\":1,\"291\":3,\"292\":3,\"297\":1,\"299\":3,\"310\":1}}],[\"mvc框架\",{\"1\":{\"263\":1}}],[\"mvcc只在committed\",{\"1\":{\"120\":1}}],[\"mvcc\",{\"0\":{\"111\":1,\"112\":1},\"1\":{\"111\":2,\"112\":4}}],[\"mn\",{\"1\":{\"80\":1}}],[\"myrunnable\",{\"1\":{\"638\":4}}],[\"myrpc版本6\",{\"0\":{\"255\":1}}],[\"myrpc版本5\",{\"0\":{\"248\":1}}],[\"myrpc版本4\",{\"0\":{\"241\":1}}],[\"myrpc版本3\",{\"0\":{\"234\":1}}],[\"myrpc版本1\",{\"0\":{\"220\":1}}],[\"myrpcversion2\",{\"1\":{\"230\":4}}],[\"myrpc\",{\"0\":{\"227\":1},\"1\":{\"251\":1}}],[\"myrpcfromzero\",{\"0\":{\"206\":1}}],[\"mythread\",{\"1\":{\"623\":1,\"638\":6,\"690\":1}}],[\"mytoken\",{\"1\":{\"71\":5}}],[\"mytoken=\",{\"1\":{\"71\":1}}],[\"mymethod\",{\"1\":{\"507\":3}}],[\"my\",{\"1\":{\"465\":1}}],[\"mywebconfig\",{\"1\":{\"318\":1}}],[\"mywebconfiguration\",{\"0\":{\"318\":1}}],[\"myinterceptor\",{\"0\":{\"317\":1},\"1\":{\"317\":1,\"318\":3}}],[\"myisam无论主键索引还是二级索引都是非聚簇索引\",{\"1\":{\"151\":1}}],[\"myisam采用表级锁\",{\"1\":{\"114\":1}}],[\"myisam和innodb存储引擎使用的锁\",{\"1\":{\"114\":1}}],[\"myisam和innodb实现btree索引方式的区别\",{\"0\":{\"81\":1}}],[\"myisam引擎\",{\"1\":{\"114\":1}}],[\"myisam\",{\"0\":{\"82\":1},\"1\":{\"92\":9}}],[\"mystudent\",{\"1\":{\"268\":1}}],[\"mysql将根据第一个索引列赋一个名称\",{\"1\":{\"159\":1}}],[\"mysql会一直向右匹配直到遇到范围查询\",{\"1\":{\"154\":1,\"161\":1}}],[\"mysql使用索引时需要索引有序\",{\"1\":{\"153\":1}}],[\"mysql使用b+tree\",{\"1\":{\"149\":1}}],[\"mysql可以使用多个字段同时建立一个索引\",{\"1\":{\"153\":1}}],[\"mysql有哪几种索引类型\",{\"0\":{\"148\":1}}],[\"mysql索引的建立对于mysql的高效运行是很重要的\",{\"1\":{\"146\":1}}],[\"mysql索引连环18问\",{\"1\":{\"146\":1}}],[\"mysqld\",{\"1\":{\"141\":2}}],[\"mysql数据库cpu飙升到500\",{\"0\":{\"141\":1}}],[\"mysql并不是跳过offset行\",{\"1\":{\"136\":1}}],[\"mysql提供了explain命令来查看语句的执行计划\",{\"1\":{\"134\":1}}],[\"mysql主从同步延时问题如何解决\",{\"0\":{\"133\":1}}],[\"mysql主从同步的目的\",{\"0\":{\"130\":1}}],[\"mysql主从复制流程和原理\",{\"0\":{\"132\":1}}],[\"mysql服务器层不管理事务\",{\"1\":{\"109\":1}}],[\"mysql的查询优化器会帮你优化成索引可以识别的形式\",{\"1\":{\"154\":1,\"161\":1}}],[\"mysql的mvcc可以实现事务中的查询不用加锁\",{\"1\":{\"120\":1}}],[\"mysql的\",{\"1\":{\"108\":1}}],[\"mysql的binlog有有几种录入格式\",{\"0\":{\"89\":1}}],[\"mysql事务日志介绍下\",{\"0\":{\"105\":1}}],[\"mysql基础\",{\"1\":{\"90\":1}}],[\"mysql不会进行解析查询语句\",{\"1\":{\"88\":1}}],[\"mysql执行查询的过程\",{\"0\":{\"88\":1}}],[\"mysql中是如何实现事务隔离的\",{\"0\":{\"110\":1}}],[\"mysql中的in语句是把外表和内表作hash\",{\"1\":{\"96\":1}}],[\"mysql中的索引可以以一定顺序引用多列\",{\"1\":{\"84\":1}}],[\"mysql中\",{\"0\":{\"96\":1}}],[\"mysql中myisam与innodb的区别\",{\"0\":{\"73\":1}}],[\"mysql\",{\"0\":{\"72\":1,\"80\":1,\"92\":1,\"95\":1,\"99\":1,\"144\":1,\"145\":1},\"1\":{\"72\":1,\"76\":1,\"90\":2,\"92\":2,\"99\":2,\"102\":3,\"106\":1,\"107\":1,\"108\":3,\"110\":4,\"112\":1,\"133\":1,\"144\":3,\"145\":1,\"146\":1,\"156\":1,\"157\":2,\"205\":2,\"348\":4,\"391\":1,\"393\":2,\"502\":1,\"506\":2}}],[\"mydecode\",{\"1\":{\"244\":1,\"245\":1}}],[\"myencode\",{\"1\":{\"244\":1,\"245\":1}}],[\"mybaits\",{\"0\":{\"179\":1}}],[\"mybaits的优缺点\",{\"0\":{\"173\":1}}],[\"mybatisplusinterceptor\",{\"1\":{\"315\":4}}],[\"mybatisplus相关配置\",{\"1\":{\"315\":1}}],[\"mybatisplus\",{\"0\":{\"315\":1}}],[\"mybatis总结\",{\"1\":{\"192\":2}}],[\"mybatis的xml映射文件中\",{\"0\":{\"191\":1}}],[\"mybatis的一级\",{\"0\":{\"188\":1}}],[\"mybatis实现一对多有几种方式\",{\"0\":{\"187\":1}}],[\"mybatis实现一对一有几种方式\",{\"0\":{\"186\":1}}],[\"mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind\",{\"1\":{\"190\":1}}],[\"mybatis提供了9种动态sql标签\",{\"1\":{\"184\":1}}],[\"mybatis动态sql可以让我们在xml映射文件内\",{\"1\":{\"190\":1}}],[\"mybatis动态sql可以在xml映射文件内\",{\"1\":{\"184\":1}}],[\"mybatis动态sql是做什么的\",{\"0\":{\"190\":1}}],[\"mybatis动态sql有什么用\",{\"0\":{\"184\":1}}],[\"mybatis运行时会使用jdk动态代理为dao接口生成代理proxy对象\",{\"1\":{\"182\":1}}],[\"mybatis在处理时\",{\"1\":{\"181\":1}}],[\"mybatis在处理\",{\"1\":{\"181\":1}}],[\"mybatis与hibernate有哪些不同\",{\"0\":{\"178\":1}}],[\"mybatis编程步骤是什么样的\",{\"0\":{\"177\":1}}],[\"mybatis自动将sql执行结果映射至java对象\",{\"1\":{\"176\":1}}],[\"mybatis自动将java对象映射至sql语句\",{\"1\":{\"176\":1}}],[\"mybatis是如何解决这些问题的\",{\"0\":{\"176\":1}}],[\"mybatis是一个半orm\",{\"1\":{\"172\":1}}],[\"mybatis是什么\",{\"0\":{\"172\":1}}],[\"mybatis\",{\"0\":{\"171\":1,\"175\":1,\"180\":1},\"1\":{\"171\":1,\"172\":1,\"175\":5,\"178\":4,\"179\":2}}],[\"myclass\",{\"1\":{\"507\":3}}],[\"mycat\",{\"0\":{\"127\":1},\"1\":{\"122\":1}}],[\"mycf2hj\",{\"1\":{\"53\":1,\"70\":1}}],[\"mycf2hj1\",{\"1\":{\"53\":2}}],[\"mycf2hj2\",{\"1\":{\"53\":1}}],[\"millisecond\",{\"1\":{\"435\":1}}],[\"milliseconds的10倍\",{\"1\":{\"426\":1}}],[\"milliseconds\",{\"1\":{\"316\":1,\"425\":1,\"426\":2,\"435\":1}}],[\"million\",{\"1\":{\"399\":1,\"553\":1}}],[\"mixed\",{\"1\":{\"89\":1,\"108\":1}}],[\"misc\",{\"1\":{\"499\":1,\"555\":1,\"579\":1,\"644\":1}}],[\"missing\",{\"1\":{\"71\":1}}],[\"mismatch\",{\"1\":{\"69\":1,\"70\":1}}],[\"miaoko\",{\"1\":{\"71\":1}}],[\"mincapacity\",{\"1\":{\"573\":12}}],[\"minimize\",{\"1\":{\"554\":1,\"578\":1}}],[\"minibatis\",{\"1\":{\"205\":4}}],[\"min\",{\"1\":{\"70\":1,\"334\":1,\"424\":4,\"499\":1,\"556\":2}}],[\"mk\",{\"1\":{\"70\":1,\"71\":1}}],[\"mcdrolzetqg\",{\"1\":{\"69\":1}}],[\"mutex\",{\"1\":{\"594\":5,\"661\":1}}],[\"much\",{\"1\":{\"399\":1}}],[\"multacom\",{\"1\":{\"71\":1}}],[\"multi执行之后\",{\"1\":{\"409\":1}}],[\"multi命令用于开启一个事务\",{\"1\":{\"409\":1}}],[\"multi之外的请求\",{\"1\":{\"408\":1}}],[\"multipart\",{\"1\":{\"291\":1}}],[\"multipartresolver\",{\"1\":{\"291\":1}}],[\"multimode\",{\"1\":{\"71\":1}}],[\"multimedia\",{\"1\":{\"70\":1}}],[\"multi\",{\"1\":{\"33\":1,\"408\":1}}],[\"mux`\",{\"1\":{\"69\":1,\"70\":1}}],[\"mux\",{\"1\":{\"69\":1,\"70\":1}}],[\"must\",{\"1\":{\"69\":1}}],[\"m\",{\"1\":{\"65\":1,\"594\":7}}],[\"medium=toutiao\",{\"1\":{\"618\":1}}],[\"media\",{\"1\":{\"70\":5}}],[\"me\",{\"1\":{\"544\":1}}],[\"merge\",{\"1\":{\"157\":1}}],[\"memcache不支持数据持久存储\",{\"1\":{\"378\":1}}],[\"memcached使用多线程的非阻塞io模式\",{\"1\":{\"378\":1}}],[\"memcached没有原生的集群模式\",{\"1\":{\"378\":1}}],[\"memcached所有的值均是简单的字符串\",{\"1\":{\"378\":1}}],[\"memcached\",{\"0\":{\"406\":1},\"1\":{\"135\":1,\"406\":1}}],[\"memeroy\",{\"1\":{\"377\":1}}],[\"memory\",{\"1\":{\"92\":1,\"399\":1}}],[\"meituan\",{\"1\":{\"70\":2,\"483\":1,\"618\":1,\"675\":2,\"723\":2}}],[\"messaging\",{\"1\":{\"70\":2}}],[\"messages两个维度\",{\"1\":{\"338\":1}}],[\"messages\",{\"1\":{\"329\":1}}],[\"messagetobyteencoder\",{\"1\":{\"244\":1}}],[\"messagetype\",{\"1\":{\"244\":12}}],[\"message\",{\"1\":{\"69\":17,\"70\":17,\"71\":2,\"223\":2}}],[\"means\",{\"1\":{\"69\":1}}],[\"meanwhile\",{\"1\":{\"4\":1}}],[\"methodaccessorimpl\",{\"1\":{\"507\":1}}],[\"methodaccessor就是上面提到的所有同名method共享的一个实例\",{\"1\":{\"507\":1}}],[\"methodaccessor\",{\"1\":{\"507\":2}}],[\"methods\",{\"1\":{\"317\":1}}],[\"method属性\",{\"1\":{\"275\":1}}],[\"methodname\",{\"1\":{\"223\":2}}],[\"method\",{\"1\":{\"69\":3,\"70\":4,\"71\":2,\"200\":12,\"223\":8,\"230\":4,\"237\":4,\"504\":1,\"505\":4,\"506\":1,\"507\":6,\"519\":1}}],[\"meta\",{\"1\":{\"308\":1}}],[\"meta版本下载地址\",{\"1\":{\"68\":1}}],[\"meta配置\",{\"1\":{\"61\":2}}],[\"mask\",{\"1\":{\"559\":1}}],[\"master就不会再接收任何请求了\",{\"1\":{\"424\":1}}],[\"master就宕机了\",{\"1\":{\"423\":1}}],[\"master在内存中直接创建rdb\",{\"1\":{\"420\":1}}],[\"master在每个事务更新数据完成之前\",{\"1\":{\"132\":1}}],[\"master和slave都会保存一个replica\",{\"1\":{\"420\":1,\"422\":1}}],[\"master和slave进程是否正常工作\",{\"1\":{\"419\":1}}],[\"master如果发现有多个slave\",{\"1\":{\"420\":1,\"422\":1}}],[\"master会将这个rdb发送给slave\",{\"1\":{\"420\":1}}],[\"master会启动一个后台线程\",{\"1\":{\"420\":1}}],[\"master\",{\"1\":{\"129\":1,\"406\":2,\"413\":4,\"416\":3,\"420\":1,\"422\":1,\"425\":5,\"426\":1,\"682\":1}}],[\"may\",{\"1\":{\"499\":1}}],[\"maybe\",{\"1\":{\"69\":2,\"70\":2}}],[\"maven\",{\"1\":{\"237\":1,\"244\":1}}],[\"mamajustkilledaman\",{\"1\":{\"71\":5}}],[\"mafengwo\",{\"1\":{\"70\":2}}],[\"mandatory\",{\"1\":{\"289\":1}}],[\"manager\",{\"1\":{\"70\":1}}],[\"manual\",{\"1\":{\"69\":2,\"70\":2}}],[\"major\",{\"1\":{\"70\":1}}],[\"mailinator\",{\"1\":{\"567\":1}}],[\"maillazy\",{\"1\":{\"71\":1}}],[\"mail\",{\"1\":{\"70\":1}}],[\"mainly\",{\"1\":{\"399\":1}}],[\"main中为创建流程\",{\"1\":{\"193\":1}}],[\"main\",{\"0\":{\"193\":1},\"1\":{\"57\":1,\"58\":2,\"60\":1,\"69\":1,\"70\":1,\"71\":6,\"156\":3,\"193\":2,\"216\":2,\"223\":2,\"230\":2,\"494\":2,\"505\":1,\"506\":1,\"521\":1,\"522\":1,\"532\":2,\"635\":1,\"703\":1}}],[\"maximum\",{\"1\":{\"499\":1,\"554\":1,\"555\":2,\"558\":1,\"559\":4,\"578\":1,\"581\":1,\"616\":1,\"617\":1}}],[\"maximumpoolsize\",{\"1\":{\"230\":2,\"670\":1,\"675\":1,\"713\":2,\"720\":1}}],[\"max\",{\"1\":{\"70\":1,\"237\":1,\"338\":3,\"417\":1,\"424\":3,\"467\":2,\"499\":3,\"547\":1,\"558\":1,\"559\":2,\"573\":2,\"581\":1,\"672\":1,\"673\":1}}],[\"markword\",{\"1\":{\"662\":1}}],[\"mark\",{\"1\":{\"656\":2}}],[\"markdown\",{\"1\":{\"2\":2,\"3\":2}}],[\"margin\",{\"1\":{\"70\":2,\"71\":1}}],[\"map代表的是存储key\",{\"1\":{\"569\":1}}],[\"map不是collection的子接口\",{\"1\":{\"569\":1}}],[\"map四种接口体系\",{\"1\":{\"569\":1}}],[\"map还有其他方法吗\",{\"0\":{\"594\":1},\"1\":{\"549\":1}}],[\"mapping\",{\"1\":{\"556\":1}}],[\"mapping信息并及时更新\",{\"1\":{\"417\":1}}],[\"mappingjackson2httpmessageconverter\",{\"1\":{\"297\":1}}],[\"mappedstatement>的key使用的\",{\"1\":{\"191\":1}}],[\"mapper>\",{\"1\":{\"205\":1}}],[\"mapper文件后缀\",{\"1\":{\"204\":1}}],[\"mapperproxy<>\",{\"1\":{\"200\":1}}],[\"mapperproxy<t>\",{\"1\":{\"200\":3}}],[\"mapperproxy\",{\"1\":{\"200\":8}}],[\"mapperproxyfactory\",{\"1\":{\"194\":2,\"200\":4}}],[\"mapperproxyfactory<t>\",{\"1\":{\"194\":3,\"200\":4}}],[\"mapperproxyfactory<\",{\"1\":{\"194\":2,\"200\":1}}],[\"mapperproxyfactory类中维护着map<class<\",{\"1\":{\"194\":1}}],[\"mapperinterface\",{\"1\":{\"200\":12}}],[\"mapper注册类\",{\"1\":{\"200\":1}}],[\"mapperfile\",{\"1\":{\"196\":3}}],[\"mapperstatement对象\",{\"1\":{\"200\":1}}],[\"mapperstatement\",{\"0\":{\"199\":1},\"1\":{\"197\":2,\"198\":9,\"199\":2,\"200\":1,\"201\":8,\"203\":8,\"204\":3}}],[\"mapperstatement>的key使用的\",{\"1\":{\"185\":1}}],[\"mappers\",{\"1\":{\"194\":3,\"196\":4,\"200\":3}}],[\"mapperregister\",{\"1\":{\"194\":5,\"200\":1}}],[\"mapper\",{\"0\":{\"200\":1},\"1\":{\"189\":1,\"193\":2,\"194\":2,\"196\":3,\"200\":5,\"204\":6,\"205\":5}}],[\"mapper接口中的方法\",{\"1\":{\"193\":1}}],[\"mapper接口方法的输出参数类型和mapper\",{\"1\":{\"189\":1}}],[\"mapper接口方法的输入参数类型和mapper\",{\"1\":{\"189\":1}}],[\"mapper接口方法名和mapper\",{\"1\":{\"189\":1}}],[\"mapper接口是没有实现类的\",{\"1\":{\"182\":1}}],[\"map中获取服务端的实现类\",{\"1\":{\"230\":1}}],[\"map<k\",{\"1\":{\"594\":4}}],[\"map<string\",{\"1\":{\"229\":2,\"230\":9,\"251\":1,\"506\":1}}],[\"map<\",{\"1\":{\"204\":1,\"313\":1}}],[\"map<class<\",{\"1\":{\"194\":1,\"200\":1}}],[\"map\",{\"0\":{\"380\":1,\"756\":1},\"1\":{\"69\":1,\"70\":3,\"71\":3,\"204\":5,\"229\":1,\"313\":5,\"380\":6,\"554\":1,\"578\":1,\"586\":1,\"594\":1,\"595\":1}}],[\"matcher\",{\"1\":{\"201\":4}}],[\"match\",{\"1\":{\"71\":12}}],[\"matter\",{\"1\":{\"69\":1}}],[\"math\",{\"1\":{\"69\":5,\"70\":4,\"71\":10,\"396\":1,\"499\":2,\"573\":1}}],[\"makereadablewebsocketstream\",{\"1\":{\"69\":2,\"70\":2}}],[\"mac版本\",{\"1\":{\"68\":1}}],[\"malaysia\",{\"1\":{\"62\":1}}],[\"mset\",{\"1\":{\"506\":3}}],[\"ms\",{\"1\":{\"347\":1,\"350\":3,\"639\":1}}],[\"ms这个维度\",{\"1\":{\"338\":1}}],[\"ms和延迟条数replica\",{\"1\":{\"338\":1}}],[\"msgmnb\",{\"1\":{\"726\":1}}],[\"msgmax\",{\"1\":{\"726\":1}}],[\"msg\",{\"1\":{\"71\":4,\"237\":5,\"244\":5}}],[\"msie5\",{\"1\":{\"32\":1}}],[\"msl\",{\"1\":{\"16\":1,\"18\":1}}],[\"most\",{\"1\":{\"554\":1,\"578\":1}}],[\"moved\",{\"1\":{\"547\":1,\"585\":1}}],[\"mozilla\",{\"1\":{\"71\":1}}],[\"mozila\",{\"1\":{\"32\":1}}],[\"modification\",{\"1\":{\"598\":3}}],[\"modifiers\",{\"1\":{\"507\":1}}],[\"modifiedrequest\",{\"1\":{\"69\":2,\"70\":2}}],[\"modified\",{\"1\":{\"33\":1,\"69\":1,\"70\":1}}],[\"mod\",{\"1\":{\"564\":1,\"565\":1}}],[\"modcount++\",{\"1\":{\"573\":1}}],[\"modcount\",{\"1\":{\"554\":1,\"573\":1,\"578\":1,\"598\":2}}],[\"module\",{\"1\":{\"354\":1}}],[\"modb\",{\"1\":{\"144\":1}}],[\"modelandview\",{\"1\":{\"290\":1,\"291\":1,\"299\":1,\"317\":3}}],[\"model\",{\"1\":{\"282\":1,\"290\":2}}],[\"mode=html\",{\"1\":{\"71\":1}}],[\"mode\",{\"1\":{\"70\":1,\"605\":1,\"607\":2}}],[\"monitor对象存在于每个java对象的对象头中\",{\"1\":{\"651\":1}}],[\"monitor\",{\"1\":{\"651\":1}}],[\"monitorexit\",{\"1\":{\"651\":4}}],[\"monitorenter\",{\"1\":{\"651\":4}}],[\"month\",{\"1\":{\"70\":2}}],[\"mon\",{\"1\":{\"32\":1}}],[\"more\",{\"1\":{\"2\":1,\"70\":1,\"553\":1,\"720\":1}}],[\"ft\",{\"1\":{\"559\":3}}],[\"ftp文件传输\",{\"1\":{\"10\":1}}],[\"fff\",{\"1\":{\"70\":1}}],[\"f0f0f0\",{\"1\":{\"70\":2}}],[\"fdn=false\",{\"1\":{\"70\":1,\"71\":2}}],[\"fp=randomized\",{\"1\":{\"70\":1}}],[\"fp=random\",{\"1\":{\"69\":1,\"70\":2,\"71\":1}}],[\"float\",{\"1\":{\"449\":2,\"467\":1,\"489\":1,\"493\":2,\"554\":1,\"559\":3,\"578\":1}}],[\"floor\",{\"1\":{\"69\":2,\"70\":2,\"71\":6}}],[\"flashmap\",{\"1\":{\"291\":1}}],[\"flashmapmanager\",{\"1\":{\"291\":1}}],[\"flatmap\",{\"1\":{\"70\":5}}],[\"flushdb\",{\"1\":{\"400\":1}}],[\"flushall\",{\"1\":{\"400\":1}}],[\"flush或close之后\",{\"1\":{\"188\":1}}],[\"flush\",{\"1\":{\"69\":1,\"70\":1,\"216\":2,\"223\":2,\"230\":1,\"237\":1,\"244\":1,\"251\":1}}],[\"f\",{\"1\":{\"69\":5,\"70\":7,\"547\":4,\"585\":4}}],[\"fair\",{\"1\":{\"648\":1,\"707\":1}}],[\"fairsync\",{\"1\":{\"617\":1}}],[\"failure\",{\"1\":{\"607\":1}}],[\"fail\",{\"0\":{\"598\":2},\"1\":{\"223\":1,\"230\":1,\"237\":1,\"598\":2}}],[\"failed\",{\"1\":{\"70\":1,\"612\":3}}],[\"fails\",{\"1\":{\"70\":1}}],[\"fanyilun\",{\"1\":{\"544\":1}}],[\"factor的值\",{\"1\":{\"554\":1,\"578\":1}}],[\"factor为负载因子\",{\"1\":{\"554\":1,\"578\":1}}],[\"factorial\",{\"1\":{\"553\":1}}],[\"factories\",{\"1\":{\"308\":2}}],[\"factor\",{\"1\":{\"334\":1,\"554\":4,\"559\":1,\"578\":4}}],[\"factory\",{\"1\":{\"314\":2}}],[\"family\",{\"1\":{\"70\":1,\"71\":1}}],[\"fa\",{\"1\":{\"70\":4}}],[\"false表示新增线程前需要判断当前活动线程数是否少于maximumpoolsize\",{\"1\":{\"714\":1}}],[\"false\",{\"1\":{\"69\":13,\"70\":10,\"71\":3,\"316\":1,\"317\":1,\"449\":1,\"488\":4,\"496\":1,\"498\":1,\"499\":1,\"548\":1,\"556\":1,\"611\":1,\"612\":2,\"613\":1,\"616\":1,\"617\":2,\"722\":1}}],[\"fastjson可以读出基本数据类型\",{\"1\":{\"244\":1}}],[\"fast\",{\"0\":{\"598\":1},\"1\":{\"24\":2,\"598\":1,\"607\":1}}],[\"future\",{\"1\":{\"676\":1,\"697\":3}}],[\"further\",{\"1\":{\"71\":1}}],[\"fulfilled\",{\"1\":{\"71\":2}}],[\"fulltext\",{\"1\":{\"159\":1}}],[\"fully\",{\"1\":{\"69\":1}}],[\"full\",{\"1\":{\"5\":1,\"69\":1,\"70\":1,\"71\":1,\"79\":1,\"148\":1,\"607\":1}}],[\"function\",{\"1\":{\"69\":17,\"70\":25,\"71\":5,\"532\":3}}],[\"fetching\",{\"1\":{\"71\":3}}],[\"fetch\",{\"1\":{\"69\":4,\"70\":5,\"71\":9}}],[\"features\",{\"1\":{\"3\":1}}],[\"fxxk\",{\"1\":{\"57\":10,\"71\":4}}],[\"frequency\",{\"1\":{\"553\":1}}],[\"frequent\",{\"1\":{\"399\":1}}],[\"frequently\",{\"1\":{\"388\":1}}],[\"free\",{\"1\":{\"53\":2,\"58\":1,\"60\":1,\"70\":1,\"617\":3}}],[\"framework\",{\"1\":{\"265\":1}}],[\"frameborder=\",{\"1\":{\"70\":1}}],[\"frist\",{\"1\":{\"69\":1,\"70\":1}}],[\"front\",{\"1\":{\"155\":1}}],[\"frontmatter\",{\"1\":{\"4\":1}}],[\"fromserializer\",{\"1\":{\"314\":1}}],[\"from\",{\"1\":{\"53\":1,\"69\":5,\"70\":12,\"71\":1,\"117\":1,\"136\":5,\"152\":1,\"155\":2,\"156\":1,\"157\":4,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"205\":2,\"521\":1,\"522\":1}}],[\"follows\",{\"1\":{\"553\":1}}],[\"follower副本只是采用拉\",{\"1\":{\"339\":1}}],[\"follower从leader同步数据有一些延迟\",{\"1\":{\"338\":1}}],[\"follower\",{\"0\":{\"339\":1},\"1\":{\"323\":7,\"333\":1,\"334\":4}}],[\"fos\",{\"1\":{\"521\":2}}],[\"foo2\",{\"1\":{\"506\":3}}],[\"foo\",{\"1\":{\"506\":5}}],[\"fontawesome\",{\"1\":{\"70\":2}}],[\"font\",{\"1\":{\"70\":5,\"71\":1}}],[\"foundproxyip\",{\"1\":{\"71\":8}}],[\"foundation\",{\"1\":{\"70\":1}}],[\"found\",{\"1\":{\"69\":1,\"70\":3,\"738\":1}}],[\"fofa日志\",{\"1\":{\"52\":1}}],[\"fofa\",{\"0\":{\"52\":1,\"743\":1},\"1\":{\"65\":2}}],[\"fork\",{\"1\":{\"643\":2,\"706\":2}}],[\"for循环中的e\",{\"1\":{\"564\":1}}],[\"for循环后\",{\"1\":{\"558\":1,\"581\":1}}],[\"forpath\",{\"1\":{\"251\":4,\"258\":1}}],[\"forname\",{\"1\":{\"198\":1,\"203\":1,\"204\":1,\"237\":1,\"502\":1,\"503\":2,\"505\":2,\"506\":3,\"507\":2,\"533\":1}}],[\"foreach\",{\"1\":{\"184\":1}}],[\"foreign\",{\"1\":{\"87\":1,\"94\":1}}],[\"form\",{\"1\":{\"70\":1}}],[\"format\",{\"1\":{\"71\":5}}],[\"formattedaddress\",{\"1\":{\"71\":2}}],[\"formatteddate\",{\"1\":{\"70\":3}}],[\"format=clash`\",{\"1\":{\"70\":2}}],[\"forum\",{\"1\":{\"70\":1}}],[\"forwarded\",{\"1\":{\"69\":1,\"70\":1}}],[\"forbidden\",{\"1\":{\"52\":2,\"65\":2,\"69\":1,\"70\":1}}],[\"for\",{\"1\":{\"2\":1,\"4\":1,\"5\":1,\"69\":17,\"70\":23,\"71\":6,\"117\":2,\"196\":1,\"202\":1,\"203\":1,\"204\":1,\"230\":1,\"244\":1,\"251\":1,\"399\":1,\"499\":1,\"506\":4,\"553\":1,\"556\":3,\"558\":1,\"559\":1,\"581\":1,\"612\":1}}],[\"fifo\",{\"1\":{\"602\":1,\"672\":1}}],[\"fieldtype\",{\"1\":{\"203\":5}}],[\"fields\",{\"1\":{\"203\":2}}],[\"fields表\",{\"1\":{\"34\":1}}],[\"field\",{\"1\":{\"203\":14,\"382\":1,\"504\":1,\"507\":1,\"534\":1}}],[\"filtered\",{\"1\":{\"157\":2}}],[\"filter\",{\"1\":{\"71\":1,\"299\":1}}],[\"filereader\",{\"1\":{\"539\":1}}],[\"fileinputstream\",{\"1\":{\"521\":1,\"522\":1,\"543\":1}}],[\"fileoutputstream\",{\"1\":{\"521\":2,\"522\":1}}],[\"filename=$\",{\"1\":{\"71\":3}}],[\"filename\",{\"1\":{\"71\":12,\"195\":4,\"204\":3}}],[\"file\",{\"1\":{\"2\":1,\"3\":1,\"4\":1,\"5\":1,\"196\":13,\"204\":2,\"403\":1,\"521\":6,\"522\":6}}],[\"filesystem\",{\"1\":{\"329\":1}}],[\"files\",{\"1\":{\"2\":1}}],[\"fixedthreadpool\",{\"1\":{\"673\":4}}],[\"fixedthreadpool是一个典型且优秀的线程池\",{\"1\":{\"672\":1}}],[\"fix\",{\"1\":{\"69\":1,\"70\":1}}],[\"firsttask参数用于指定新增的线程执行的第一个任务\",{\"1\":{\"714\":1}}],[\"firsttask用它来保存传入的第一个任务\",{\"1\":{\"714\":1}}],[\"firsttask\",{\"1\":{\"714\":2}}],[\"firstspring\",{\"1\":{\"268\":1}}],[\"first\",{\"1\":{\"69\":1,\"70\":1,\"159\":2,\"553\":1}}],[\"findsystemclass\",{\"1\":{\"533\":1}}],[\"finding\",{\"1\":{\"70\":1}}],[\"final类型\",{\"1\":{\"499\":2}}],[\"final类型的\",{\"1\":{\"469\":1}}],[\"finalize\",{\"1\":{\"454\":6}}],[\"finalize的区别\",{\"0\":{\"454\":1}}],[\"final<\",{\"1\":{\"237\":1}}],[\"final\",{\"0\":{\"454\":1,\"470\":1},\"1\":{\"194\":2,\"196\":1,\"197\":2,\"199\":1,\"200\":5,\"201\":2,\"203\":1,\"204\":1,\"230\":1,\"237\":2,\"251\":1,\"284\":1,\"313\":1,\"316\":1,\"454\":6,\"470\":2,\"481\":2,\"490\":2,\"499\":3,\"506\":4,\"554\":1,\"555\":2,\"556\":3,\"559\":1,\"578\":1,\"579\":1,\"586\":2,\"587\":1,\"594\":3,\"604\":3,\"605\":4,\"607\":1,\"610\":1,\"611\":1,\"612\":3,\"613\":1,\"616\":6,\"617\":5,\"684\":2,\"712\":1,\"714\":2,\"721\":1}}],[\"finally\",{\"0\":{\"454\":1,\"535\":1,\"536\":2},\"1\":{\"69\":1,\"70\":1,\"71\":1,\"237\":1,\"454\":2,\"484\":3,\"536\":7,\"612\":1,\"648\":1,\"707\":1,\"714\":1}}],[\"fin丢失\",{\"1\":{\"19\":1}}],[\"fin\",{\"1\":{\"17\":2,\"18\":5}}],[\"fin=1\",{\"1\":{\"16\":2}}],[\"swap\",{\"1\":{\"644\":1}}],[\"switch\",{\"0\":{\"450\":1},\"1\":{\"69\":2,\"70\":2,\"156\":1,\"200\":1,\"244\":2,\"450\":1}}],[\"small\",{\"1\":{\"553\":1}}],[\"s变量和s2变量地址指向的是不同的对象\",{\"1\":{\"488\":2}}],[\"s4\",{\"1\":{\"488\":6}}],[\"s3变量和s4变量地址指向的是相同的对象\",{\"1\":{\"488\":1}}],[\"s3变量和s4变量地址指向的是不同的对象\",{\"1\":{\"488\":1}}],[\"s3\",{\"1\":{\"488\":9}}],[\"s2\",{\"1\":{\"488\":6}}],[\"sdk\",{\"1\":{\"444\":1}}],[\"sdown\",{\"1\":{\"426\":1}}],[\"s1\",{\"1\":{\"157\":2}}],[\"s\",{\"1\":{\"70\":1,\"376\":2,\"399\":1,\"488\":9,\"499\":2,\"507\":1,\"532\":5,\"544\":1,\"649\":1}}],[\"sky\",{\"1\":{\"70\":1}}],[\"skip\",{\"1\":{\"69\":3,\"70\":1}}],[\"snapshot\",{\"1\":{\"383\":1}}],[\"snion\",{\"1\":{\"157\":1}}],[\"sni\",{\"1\":{\"71\":7}}],[\"sni=$\",{\"1\":{\"69\":1,\"70\":2,\"71\":1}}],[\"sn\",{\"1\":{\"70\":1}}],[\"snmp等\",{\"1\":{\"10\":1}}],[\"salve\",{\"1\":{\"427\":1}}],[\"salve开启一个i\",{\"1\":{\"132\":1}}],[\"save操作\",{\"1\":{\"420\":1,\"422\":1}}],[\"saxreader\",{\"1\":{\"204\":5,\"506\":2}}],[\"sans\",{\"1\":{\"70\":1,\"71\":1}}],[\"safepoint\",{\"1\":{\"662\":1}}],[\"safe\",{\"0\":{\"598\":1},\"1\":{\"598\":1}}],[\"safely\",{\"1\":{\"70\":1}}],[\"safeclosewebsocket\",{\"1\":{\"69\":7,\"70\":7}}],[\"says\",{\"1\":{\"69\":1}}],[\"sample\",{\"1\":{\"32\":1}}],[\"slot信息等\",{\"1\":{\"430\":1}}],[\"slot的成本是非常低的\",{\"1\":{\"429\":1}}],[\"slot移动到其他master上去\",{\"1\":{\"429\":1}}],[\"slot移动部分过去\",{\"1\":{\"429\":1}}],[\"slot让node的增加和移除很简单\",{\"1\":{\"429\":1}}],[\"slot\",{\"1\":{\"429\":3,\"507\":1}}],[\"slow\",{\"1\":{\"24\":1}}],[\"sleep方法\",{\"1\":{\"633\":1,\"701\":1}}],[\"sleep\",{\"0\":{\"632\":1,\"700\":1},\"1\":{\"391\":1,\"633\":3,\"639\":3,\"701\":3}}],[\"slave优先级\",{\"1\":{\"426\":1}}],[\"slave发送\",{\"1\":{\"425\":1}}],[\"slave以及其他\",{\"1\":{\"425\":1}}],[\"slaves\",{\"1\":{\"424\":5}}],[\"slave的复制是异步的\",{\"1\":{\"423\":1}}],[\"slave不会过期key\",{\"1\":{\"420\":1}}],[\"slave也会同步这些数据\",{\"1\":{\"420\":1}}],[\"slave会让master从上次的replica\",{\"1\":{\"420\":1,\"422\":1}}],[\"slave会先写入本地磁盘\",{\"1\":{\"420\":1}}],[\"slave会发起psync\",{\"1\":{\"415\":1}}],[\"slave在集群中充当\",{\"1\":{\"417\":1}}],[\"slave\",{\"1\":{\"129\":1,\"132\":1,\"416\":1,\"420\":1,\"425\":1,\"426\":1}}],[\"slicedbufferstring\",{\"1\":{\"69\":5,\"70\":6}}],[\"slicedbuffer\",{\"1\":{\"69\":2,\"70\":2}}],[\"slice\",{\"1\":{\"69\":14,\"70\":14,\"71\":2}}],[\"sl\",{\"1\":{\"64\":1}}],[\"sb\",{\"1\":{\"62\":1}}],[\"src引用了旧的entry数组\",{\"1\":{\"558\":1,\"581\":1}}],[\"src=\",{\"1\":{\"70\":2}}],[\"src\",{\"1\":{\"60\":1,\"204\":6,\"313\":7,\"558\":4,\"581\":4}}],[\"spring这样做的好处是\",{\"1\":{\"506\":1}}],[\"spring组件扫描\",{\"1\":{\"306\":1}}],[\"springboot\",{\"1\":{\"311\":2}}],[\"springbootconfiguration\",{\"1\":{\"306\":1}}],[\"springbootapplication\",{\"1\":{\"306\":2}}],[\"springboot包括许多有用的非功能特性\",{\"1\":{\"304\":1}}],[\"springboot会配置一个嵌入式tomcat服务器\",{\"1\":{\"304\":1}}],[\"springboot项目可以打包成jar文件\",{\"1\":{\"304\":1}}],[\"springframework\",{\"1\":{\"298\":1}}],[\"springmvc\",{\"0\":{\"290\":1}}],[\"spring事务定义的传播规则\",{\"0\":{\"289\":1}}],[\"spring使用工厂模式通过\",{\"1\":{\"286\":1}}],[\"spring使用threadlocal解决线程安全问题\",{\"1\":{\"282\":1}}],[\"spring的处理程序映射机制包括处理程序拦截器\",{\"1\":{\"298\":1}}],[\"spring的单例对象的初始化主要分为三步\",{\"1\":{\"281\":1}}],[\"spring的web框架是个精心设计的框架\",{\"1\":{\"263\":1}}],[\"spring对循环依赖的处理有三种情况\",{\"1\":{\"281\":1}}],[\"spring中出现同名bean怎么办\",{\"0\":{\"280\":1}}],[\"springioc容器也提供了该功能\",{\"1\":{\"274\":1}}],[\"spring通过配置文件\",{\"1\":{\"270\":1}}],[\"spring通过控制反转实现了松散耦合\",{\"1\":{\"263\":1}}],[\"spring5已经没有了\",{\"1\":{\"269\":1}}],[\"spring支持面向切面的编程\",{\"1\":{\"263\":1}}],[\"spring框架的事务管理有哪些优点\",{\"0\":{\"288\":1}}],[\"spring框架\",{\"0\":{\"262\":1}}],[\"spring\",{\"0\":{\"264\":1,\"268\":1,\"269\":1,\"272\":1,\"273\":1,\"277\":1,\"278\":1,\"281\":1,\"282\":1,\"285\":1,\"286\":1,\"287\":1,\"291\":1,\"299\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"310\":3,\"751\":1},\"1\":{\"179\":1,\"263\":4,\"264\":3,\"265\":1,\"268\":3,\"269\":1,\"271\":2,\"272\":2,\"277\":1,\"278\":4,\"284\":1,\"285\":2,\"286\":6,\"290\":1,\"291\":4,\"292\":3,\"297\":1,\"299\":3,\"304\":4,\"305\":1,\"306\":1,\"307\":3,\"308\":9,\"310\":26,\"506\":3}}],[\"spreading\",{\"1\":{\"70\":1}}],[\"spoiler>`\",{\"1\":{\"71\":1}}],[\"spoiler>入口\",{\"1\":{\"71\":1}}],[\"spoiler>\",{\"1\":{\"71\":1}}],[\"spoiler>$\",{\"1\":{\"71\":1}}],[\"spoiler>城市\",{\"1\":{\"71\":1}}],[\"sports\",{\"1\":{\"70\":2}}],[\"space\",{\"1\":{\"70\":1,\"554\":2,\"578\":2}}],[\"split\",{\"1\":{\"69\":1,\"70\":8,\"71\":17,\"251\":1,\"559\":1}}],[\"speedindex\",{\"1\":{\"71\":2}}],[\"speedtest\",{\"1\":{\"60\":1}}],[\"spec\",{\"1\":{\"69\":1,\"70\":1}}],[\"sp\",{\"1\":{\"58\":1,\"71\":1}}],[\"sg\",{\"1\":{\"57\":1,\"62\":1,\"69\":2,\"71\":1}}],[\"sum\",{\"1\":{\"644\":1}}],[\"summary\",{\"1\":{\"70\":1}}],[\"sun\",{\"1\":{\"499\":1,\"510\":1,\"555\":1,\"579\":1}}],[\"sunion等操作支持不友好\",{\"1\":{\"417\":1}}],[\"suning\",{\"1\":{\"70\":2}}],[\"suppresswarnings\",{\"1\":{\"559\":1}}],[\"supported\",{\"1\":{\"289\":1}}],[\"supports\",{\"1\":{\"289\":1}}],[\"support\",{\"1\":{\"3\":1,\"69\":4,\"70\":4,\"71\":2}}],[\"super\",{\"0\":{\"513\":1},\"1\":{\"317\":2,\"481\":1,\"484\":1,\"512\":1,\"513\":1}}],[\"suffix\",{\"1\":{\"196\":1,\"204\":1}}],[\"successfully\",{\"1\":{\"71\":1}}],[\"success\",{\"1\":{\"69\":2,\"70\":1,\"223\":2,\"230\":1,\"237\":1}}],[\"submit方法向线程池添加任务\",{\"1\":{\"671\":1}}],[\"submit\",{\"0\":{\"697\":1},\"1\":{\"669\":1,\"697\":1}}],[\"subquery\",{\"1\":{\"157\":1}}],[\"subparts\",{\"1\":{\"71\":6}}],[\"subname\",{\"1\":{\"71\":1}}],[\"subapi\",{\"1\":{\"71\":1}}],[\"subupdatetime\",{\"1\":{\"71\":4}}],[\"subconfig\",{\"1\":{\"71\":6}}],[\"subconvertercontent\",{\"1\":{\"71\":4}}],[\"subconverterurl\",{\"1\":{\"71\":6}}],[\"subconverterresponse\",{\"1\":{\"71\":15}}],[\"subconverter\",{\"1\":{\"71\":8}}],[\"subscribe\",{\"1\":{\"70\":2,\"326\":1,\"376\":1}}],[\"subscription\",{\"1\":{\"70\":1,\"71\":3}}],[\"subbestip\",{\"1\":{\"70\":6}}],[\"sublink\",{\"1\":{\"70\":2}}],[\"sublimetext汉化高亮win这里下载\",{\"1\":{\"68\":1}}],[\"sublimetext\",{\"1\":{\"68\":1}}],[\"subtle\",{\"1\":{\"70\":1}}],[\"subdomain\",{\"1\":{\"70\":5}}],[\"sub=订阅器\",{\"1\":{\"57\":1}}],[\"sub\",{\"1\":{\"53\":3,\"58\":1,\"60\":1,\"70\":7,\"71\":6,\"346\":1}}],[\"sql类型枚举\",{\"1\":{\"204\":1}}],[\"sql=\",{\"1\":{\"199\":1}}],[\"sql中的对象\",{\"1\":{\"198\":1}}],[\"sql中尽量带sharding\",{\"1\":{\"135\":1}}],[\"sqlexception等\",{\"1\":{\"531\":1}}],[\"sqlexception\",{\"1\":{\"198\":3,\"201\":7,\"202\":1,\"203\":1}}],[\"sqltype=\",{\"1\":{\"199\":1}}],[\"sqltype\",{\"1\":{\"197\":1,\"199\":9,\"204\":7}}],[\"sqlid=\",{\"1\":{\"199\":1}}],[\"sqlid\",{\"1\":{\"197\":1,\"199\":6,\"204\":3}}],[\"sqlsession类通常持有配置类对象configuration和执行器对象executor\",{\"1\":{\"197\":1}}],[\"sqlsession的crud方法会调用executor执行后续sql操作\",{\"1\":{\"194\":1}}],[\"sqlsession调getmapper方法创建mapper对象\",{\"1\":{\"193\":1}}],[\"sqlsession\",{\"0\":{\"197\":1},\"1\":{\"193\":3,\"194\":5,\"196\":2,\"197\":2,\"200\":18}}],[\"sqlsessionfactorybuilder\",{\"0\":{\"195\":1},\"1\":{\"193\":2,\"194\":1,\"195\":1}}],[\"sqlsessionfactory\",{\"0\":{\"196\":1},\"1\":{\"193\":4,\"195\":3,\"196\":2}}],[\"sql变化导致解析代码变化\",{\"1\":{\"176\":1}}],[\"sql变动需要改变java代码\",{\"1\":{\"176\":1}}],[\"sql优化和移植性\",{\"1\":{\"175\":1}}],[\"sql写在xml里\",{\"1\":{\"173\":1}}],[\"sql语句\",{\"1\":{\"199\":1}}],[\"sql语句写在代码中造成代码不易维护\",{\"1\":{\"176\":1}}],[\"sql语句依赖于数据库\",{\"1\":{\"173\":1}}],[\"sql语句的编写工作量较大\",{\"1\":{\"173\":1}}],[\"sql语句+索引\",{\"1\":{\"135\":1}}],[\"sql语法是否写错了\",{\"1\":{\"88\":1}}],[\"sql执行线程\",{\"1\":{\"132\":1}}],[\"sql执行的性能\",{\"1\":{\"121\":1}}],[\"sql注入的原理主要有以下\",{\"1\":{\"45\":1}}],[\"sql注入是什么\",{\"0\":{\"45\":1}}],[\"sql\",{\"0\":{\"94\":1},\"1\":{\"45\":4,\"98\":4,\"99\":2,\"108\":1,\"121\":1,\"126\":1,\"132\":1,\"141\":5,\"157\":2,\"175\":2,\"178\":4,\"179\":4,\"180\":3,\"199\":6,\"201\":1,\"348\":1}}],[\"scott\",{\"1\":{\"277\":1}}],[\"scope\",{\"0\":{\"272\":1},\"1\":{\"272\":1}}],[\"score\",{\"1\":{\"152\":2}}],[\"scala\",{\"1\":{\"350\":1}}],[\"scale=1\",{\"1\":{\"70\":1}}],[\"scanandlockforput\",{\"1\":{\"547\":1}}],[\"scan\",{\"1\":{\"162\":1,\"547\":1}}],[\"scheduledthreadpool\",{\"1\":{\"673\":2}}],[\"scheme\",{\"1\":{\"70\":1}}],[\"school\",{\"1\":{\"153\":1}}],[\"script>\",{\"1\":{\"70\":1}}],[\"scripting\",{\"1\":{\"44\":1}}],[\"scrolling=\",{\"1\":{\"70\":1}}],[\"scv=true\",{\"1\":{\"70\":1,\"71\":2}}],[\"scss\",{\"1\":{\"5\":1}}],[\"ssl运行在tcp协议之上\",{\"1\":{\"35\":1}}],[\"shell\",{\"1\":{\"729\":1,\"731\":1}}],[\"shutdownnow的原理是遍历线程池中的工作线程\",{\"1\":{\"630\":1,\"698\":1}}],[\"shutdownnow\",{\"0\":{\"630\":1},\"1\":{\"630\":1,\"698\":1}}],[\"shutdown\",{\"0\":{\"630\":1,\"698\":1},\"1\":{\"630\":2,\"631\":2,\"698\":2,\"699\":2}}],[\"shutdowngracefully\",{\"1\":{\"237\":2}}],[\"show\",{\"1\":{\"108\":1,\"141\":1}}],[\"short\",{\"1\":{\"70\":2,\"244\":2,\"449\":2,\"450\":1,\"489\":1,\"493\":2}}],[\"shouldparkafterfailedacquire\",{\"1\":{\"612\":1}}],[\"should\",{\"1\":{\"69\":1,\"70\":1,\"554\":1,\"578\":1}}],[\"shopify\",{\"1\":{\"62\":2}}],[\"shared\",{\"1\":{\"603\":1,\"612\":1}}],[\"share\",{\"1\":{\"601\":1,\"680\":1}}],[\"sharding\",{\"0\":{\"126\":1},\"1\":{\"122\":1,\"127\":1}}],[\"sharing\",{\"1\":{\"70\":6}}],[\"sha\",{\"1\":{\"70\":1}}],[\"shadowrocket等客户端要去掉tls加密\",{\"1\":{\"61\":1}}],[\"shake\",{\"1\":{\"25\":1}}],[\"shtml\",{\"1\":{\"28\":1}}],[\"system\",{\"1\":{\"193\":2,\"195\":1,\"196\":4,\"198\":1,\"204\":3,\"216\":6,\"223\":9,\"230\":6,\"231\":1,\"237\":7,\"244\":3,\"251\":5,\"258\":1,\"316\":2,\"317\":3,\"399\":1,\"454\":1,\"488\":6,\"494\":1,\"496\":1,\"497\":2,\"498\":1,\"499\":2,\"505\":2,\"506\":2,\"516\":1,\"521\":2,\"522\":1,\"532\":3,\"536\":2,\"560\":2,\"638\":2,\"675\":1}}],[\"systemall\",{\"1\":{\"157\":1}}],[\"sysctl\",{\"1\":{\"20\":1}}],[\"synchronousqueue\",{\"1\":{\"673\":3}}],[\"synchronize\",{\"1\":{\"594\":1}}],[\"synchronized关键字解决的是多个线程之间访问资源的同步性\",{\"1\":{\"709\":1}}],[\"synchronized关键字两者都能保证\",{\"1\":{\"709\":1}}],[\"synchronized和reentrantlock\",{\"0\":{\"707\":1}}],[\"synchronized的作用有哪些\",{\"0\":{\"650\":1}}],[\"synchronized的用法有哪些\",{\"0\":{\"649\":1}}],[\"synchronized实现更加低粒度的锁\",{\"1\":{\"584\":1}}],[\"synchronized实现更加细粒度的锁\",{\"1\":{\"546\":1}}],[\"synchronized来实现线程安全的\",{\"1\":{\"549\":1}}],[\"synchronizedmap<k\",{\"1\":{\"594\":1}}],[\"synchronizedmap方法\",{\"1\":{\"549\":1,\"594\":1}}],[\"synchronizedmap\",{\"1\":{\"547\":1,\"586\":1,\"594\":2}}],[\"synchronized替换\",{\"1\":{\"546\":1}}],[\"synchronized\",{\"0\":{\"646\":1,\"647\":1,\"648\":1,\"651\":1,\"652\":1,\"709\":1},\"1\":{\"481\":1,\"546\":2,\"547\":1,\"585\":1,\"646\":7,\"647\":3,\"648\":7,\"649\":6,\"651\":5,\"652\":3,\"653\":1,\"681\":1,\"684\":1,\"707\":7,\"709\":1,\"732\":2}}],[\"sync的方法\",{\"1\":{\"617\":1}}],[\"sync\",{\"1\":{\"133\":1,\"237\":4,\"338\":2,\"420\":2,\"605\":1,\"616\":1,\"617\":1}}],[\"syn\",{\"1\":{\"14\":11}}],[\"syn洪泛攻击属于\",{\"1\":{\"14\":1}}],[\"syn洪泛攻击\",{\"0\":{\"14\":1}}],[\"syn=1\",{\"1\":{\"11\":2}}],[\"syntax\",{\"1\":{\"3\":1,\"493\":1}}],[\"source\",{\"1\":{\"685\":1}}],[\"source=toutiao\",{\"1\":{\"618\":1}}],[\"sortedset\",{\"1\":{\"382\":2}}],[\"sorted\",{\"1\":{\"378\":1,\"382\":1}}],[\"sort=false\",{\"1\":{\"70\":1,\"71\":2}}],[\"solve\",{\"1\":{\"343\":1}}],[\"solid\",{\"1\":{\"70\":1}}],[\"sos\",{\"1\":{\"71\":1}}],[\"software\",{\"1\":{\"70\":1}}],[\"sohu\",{\"1\":{\"70\":2}}],[\"social\",{\"1\":{\"70\":6}}],[\"socketchannel\",{\"1\":{\"237\":1,\"245\":1}}],[\"socket传输的客户端\",{\"1\":{\"237\":1}}],[\"socket发送至客户端\",{\"1\":{\"223\":1}}],[\"socket建立连接\",{\"1\":{\"223\":1,\"237\":1,\"251\":1}}],[\"socket编程入门\",{\"1\":{\"214\":1}}],[\"socket>\",{\"1\":{\"70\":1}}],[\"socket\",{\"0\":{\"730\":1},\"1\":{\"69\":15,\"70\":18,\"216\":9,\"223\":9,\"230\":10,\"237\":5,\"251\":5,\"403\":25,\"404\":5,\"730\":1,\"731\":3}}],[\"sockets\",{\"1\":{\"69\":1,\"70\":1}}],[\"sockets的快速回收\",{\"1\":{\"20\":1}}],[\"sockets重新用于新的tcp连接\",{\"1\":{\"20\":1}}],[\"so\",{\"1\":{\"20\":1,\"69\":1,\"70\":2,\"399\":1,\"554\":1,\"578\":1}}],[\"something\",{\"1\":{\"732\":1}}],[\"some\",{\"1\":{\"3\":1,\"69\":3,\"70\":3,\"71\":2}}],[\"segstop\",{\"1\":{\"729\":1,\"731\":1}}],[\"segment<k\",{\"1\":{\"587\":1}}],[\"segment\",{\"1\":{\"546\":7,\"547\":2,\"549\":4,\"584\":5,\"585\":3}}],[\"segmentfault\",{\"1\":{\"25\":1,\"37\":1,\"48\":1,\"343\":1,\"544\":1,\"685\":1}}],[\"selfinterrupt\",{\"1\":{\"605\":1,\"610\":2,\"612\":1,\"617\":1}}],[\"select>\",{\"1\":{\"205\":2}}],[\"select标签\",{\"1\":{\"199\":1}}],[\"selectlist\",{\"1\":{\"193\":1,\"197\":3,\"200\":1,\"205\":2}}],[\"selectone\",{\"1\":{\"193\":1,\"197\":2,\"200\":1,\"205\":2}}],[\"select关键字对应的那个查询的类型\",{\"1\":{\"157\":1}}],[\"select\",{\"1\":{\"102\":1,\"108\":1,\"117\":1,\"136\":3,\"155\":2,\"157\":5,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"200\":1,\"204\":8,\"205\":2,\"403\":1}}],[\"semaphore\",{\"1\":{\"601\":1,\"680\":1,\"681\":2}}],[\"semi\",{\"1\":{\"133\":1}}],[\"sex\",{\"1\":{\"216\":2,\"223\":1}}],[\"serialversionuid也被static修饰\",{\"1\":{\"528\":1}}],[\"serialversionuid\",{\"1\":{\"524\":1,\"594\":1,\"616\":1}}],[\"serialversionuid什么时候修改\",{\"0\":{\"526\":1},\"1\":{\"484\":1}}],[\"serializationpair\",{\"1\":{\"314\":1}}],[\"serializabledemo\",{\"1\":{\"521\":1}}],[\"serializable接口\",{\"1\":{\"484\":1}}],[\"serializable\",{\"1\":{\"76\":2,\"102\":2,\"119\":1,\"200\":1,\"216\":1,\"223\":2,\"230\":1,\"521\":3,\"587\":1,\"594\":1}}],[\"serializevalueswith\",{\"1\":{\"314\":1}}],[\"serialize\",{\"1\":{\"244\":7}}],[\"serializertype\",{\"1\":{\"244\":2}}],[\"serializer\",{\"1\":{\"244\":13}}],[\"serializeuid\",{\"1\":{\"200\":1}}],[\"serif\",{\"1\":{\"70\":1,\"71\":1}}],[\"servlet包的handlerinterceptor\",{\"1\":{\"298\":1}}],[\"servlet\",{\"1\":{\"269\":1,\"299\":1}}],[\"servicediscovery\",{\"1\":{\"251\":3}}],[\"serviceregister\",{\"1\":{\"251\":10}}],[\"servicename创建成永久节点\",{\"1\":{\"251\":1}}],[\"servicename\",{\"1\":{\"230\":1,\"251\":8,\"258\":1}}],[\"service对象的map\",{\"1\":{\"230\":1}}],[\"serviceprovider\",{\"1\":{\"230\":8,\"237\":9,\"251\":5}}],[\"serviceprovide\",{\"1\":{\"230\":22}}],[\"services\",{\"1\":{\"70\":2}}],[\"service\",{\"1\":{\"43\":1,\"70\":7,\"229\":1,\"230\":11,\"237\":3,\"251\":3,\"271\":2}}],[\"serveraddress\",{\"1\":{\"251\":6}}],[\"server具体的handler\",{\"1\":{\"237\":1}}],[\"server初始化类\",{\"1\":{\"237\":1}}],[\"serverbootstrap\",{\"1\":{\"237\":5}}],[\"server==\",{\"1\":{\"52\":3,\"65\":2}}],[\"serversocket\",{\"1\":{\"216\":4,\"223\":4,\"230\":8}}],[\"servers\",{\"1\":{\"33\":1}}],[\"server\",{\"1\":{\"32\":1,\"37\":1,\"69\":8,\"70\":5,\"71\":1,\"388\":4}}],[\"severless\",{\"1\":{\"70\":3}}],[\"senior\",{\"1\":{\"157\":1,\"737\":1}}],[\"sendrequest\",{\"1\":{\"223\":2,\"237\":3,\"251\":1}}],[\"sendmessage\",{\"1\":{\"71\":3}}],[\"sending\",{\"1\":{\"70\":1}}],[\"send\",{\"1\":{\"69\":6,\"70\":7}}],[\"sentinel节点会与其他sentinel节点进行\",{\"1\":{\"425\":1}}],[\"sentinel主要是针对redis数据节点中的主节点的高可用切换\",{\"1\":{\"416\":1}}],[\"sentinel的节点数量要满足2n+1\",{\"1\":{\"416\":1}}],[\"sentinel集群部署简单\",{\"1\":{\"416\":1}}],[\"sentinel集群是由若干sentinel节点组成的分布式集群\",{\"1\":{\"416\":1}}],[\"sentinel集群和redis数据集群\",{\"1\":{\"416\":1}}],[\"sentinel是社区版本推出的原生高可用解决方案\",{\"1\":{\"416\":1}}],[\"sentinel\",{\"0\":{\"416\":1},\"1\":{\"413\":1,\"419\":1,\"425\":9}}],[\"sent\",{\"1\":{\"69\":1}}],[\"sent状态\",{\"1\":{\"11\":1}}],[\"separated\",{\"1\":{\"70\":1}}],[\"separate\",{\"1\":{\"69\":1}}],[\"secretkeyfor\",{\"1\":{\"316\":1}}],[\"secret\",{\"1\":{\"316\":4}}],[\"second\",{\"1\":{\"399\":1,\"435\":1}}],[\"seconds\",{\"1\":{\"230\":1,\"435\":1}}],[\"secoo\",{\"1\":{\"70\":2}}],[\"security\",{\"1\":{\"70\":1}}],[\"security=\",{\"1\":{\"71\":1}}],[\"security=tls\",{\"1\":{\"69\":1,\"70\":2,\"71\":1}}],[\"security=none\",{\"1\":{\"69\":1,\"70\":1}}],[\"sec\",{\"1\":{\"69\":1,\"70\":1}}],[\"searchparams\",{\"1\":{\"70\":2,\"71\":9}}],[\"search\",{\"1\":{\"69\":3,\"70\":4,\"71\":1}}],[\"setmaximumpoolsize\",{\"1\":{\"721\":1}}],[\"setcorepoolsize具体流程如下\",{\"1\":{\"721\":1}}],[\"setconnectionfactory\",{\"1\":{\"314\":1}}],[\"setexclusiveownerthread\",{\"1\":{\"605\":1,\"616\":2,\"617\":3}}],[\"setencoding\",{\"1\":{\"204\":1}}],[\"set代表无序不可重复集合\",{\"1\":{\"569\":1}}],[\"setpricemethod\",{\"1\":{\"505\":4}}],[\"setprice\",{\"1\":{\"505\":5}}],[\"setparams\",{\"1\":{\"244\":1}}],[\"setparameters\",{\"1\":{\"198\":1,\"202\":2}}],[\"set这样的api\",{\"1\":{\"438\":1}}],[\"set操作完成时\",{\"1\":{\"435\":1}}],[\"setname\",{\"1\":{\"521\":2,\"522\":2}}],[\"setnamespace\",{\"1\":{\"199\":1,\"204\":1}}],[\"setnx\",{\"1\":{\"435\":1}}],[\"setnx不支持超时参数\",{\"1\":{\"434\":1}}],[\"setnx的key必须设置一个超时时间\",{\"1\":{\"434\":1}}],[\"setx\",{\"1\":{\"434\":1}}],[\"setredis\",{\"1\":{\"396\":1}}],[\"setresulttype\",{\"1\":{\"199\":1,\"204\":1}}],[\"set是一个无序的天然去重的集合\",{\"1\":{\"382\":1}}],[\"set一样高效\",{\"1\":{\"378\":1}}],[\"setheadandpropagate\",{\"1\":{\"612\":1}}],[\"setheader\",{\"1\":{\"317\":4}}],[\"sethashvalueserializer\",{\"1\":{\"314\":1}}],[\"sethashkeyserializer\",{\"1\":{\"314\":1}}],[\"setissuedat\",{\"1\":{\"316\":1}}],[\"setstate\",{\"1\":{\"604\":1,\"616\":1,\"617\":2}}],[\"setsigningkey\",{\"1\":{\"316\":2}}],[\"setsubject\",{\"1\":{\"316\":1}}],[\"setsqltype\",{\"1\":{\"199\":1,\"204\":3}}],[\"setsql\",{\"1\":{\"199\":1,\"204\":1}}],[\"setsqlid\",{\"1\":{\"199\":1,\"204\":1}}],[\"setvalueserializer\",{\"1\":{\"314\":1}}],[\"setkeyserializer\",{\"1\":{\"314\":1}}],[\"setdata\",{\"1\":{\"244\":1}}],[\"setting\",{\"1\":{\"554\":1,\"578\":1}}],[\"settimeout\",{\"1\":{\"71\":1}}],[\"setters\",{\"1\":{\"277\":2}}],[\"setter\",{\"0\":{\"267\":1},\"1\":{\"205\":1,\"265\":2,\"267\":3}}],[\"setaccessible\",{\"1\":{\"203\":1}}],[\"setobject\",{\"1\":{\"202\":2}}],[\"set\",{\"1\":{\"69\":4,\"70\":6,\"71\":3,\"112\":1,\"184\":1,\"203\":4,\"204\":1,\"205\":1,\"237\":1,\"313\":1,\"316\":1,\"376\":1,\"378\":2,\"382\":4,\"399\":1,\"402\":1,\"403\":1,\"409\":1,\"435\":1,\"438\":2,\"569\":2,\"597\":1,\"721\":1}}],[\"setup\",{\"1\":{\"68\":1}}],[\"session不再由容器管理\",{\"1\":{\"381\":1}}],[\"session中\",{\"1\":{\"269\":1}}],[\"sessiontimeoutms\",{\"1\":{\"251\":2}}],[\"session1\",{\"1\":{\"112\":1}}],[\"session2\",{\"1\":{\"112\":1}}],[\"session的方案\",{\"1\":{\"42\":1}}],[\"sessionid\",{\"1\":{\"40\":6}}],[\"session\",{\"0\":{\"39\":1,\"40\":1,\"42\":1},\"1\":{\"39\":5,\"40\":5,\"41\":7,\"42\":7,\"141\":2,\"269\":2,\"272\":9,\"291\":1,\"354\":1}}],[\"seo方面\",{\"1\":{\"36\":1}}],[\"seo中302好于301\",{\"1\":{\"28\":1}}],[\"seq\",{\"1\":{\"11\":3,\"16\":4}}],[\"seems\",{\"1\":{\"69\":6,\"70\":6}}],[\"see\",{\"1\":{\"2\":1,\"71\":1,\"204\":2,\"313\":1,\"553\":1}}],[\"step4\",{\"1\":{\"564\":1}}],[\"step3\",{\"1\":{\"564\":1}}],[\"step2\",{\"1\":{\"564\":1}}],[\"step1\",{\"1\":{\"564\":1}}],[\"steamdb\",{\"1\":{\"62\":2}}],[\"studentconfig\",{\"1\":{\"268\":1}}],[\"studentbean\",{\"1\":{\"268\":4,\"277\":1}}],[\"student\",{\"1\":{\"152\":1,\"277\":5}}],[\"stomp2\",{\"1\":{\"353\":1}}],[\"stop\",{\"1\":{\"69\":1,\"70\":1,\"230\":3,\"237\":1,\"630\":1,\"640\":2,\"698\":1}}],[\"stock\",{\"1\":{\"60\":1}}],[\"still\",{\"1\":{\"69\":2}}],[\"str=new\",{\"0\":{\"488\":1},\"1\":{\"484\":1}}],[\"str=\",{\"0\":{\"488\":1},\"1\":{\"484\":1}}],[\"str\",{\"1\":{\"481\":2,\"503\":2}}],[\"struts2\",{\"0\":{\"299\":1},\"1\":{\"299\":3}}],[\"street\",{\"1\":{\"156\":3}}],[\"streaming\",{\"1\":{\"70\":4}}],[\"streams\",{\"1\":{\"69\":1,\"70\":2}}],[\"stream\",{\"1\":{\"69\":8,\"70\":9,\"195\":7}}],[\"stringhash32\",{\"1\":{\"555\":1,\"579\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"534\":1}}],[\"stringified\",{\"1\":{\"69\":1,\"70\":1}}],[\"stringify\",{\"1\":{\"69\":4,\"70\":4}}],[\"stringlist\",{\"1\":{\"514\":2}}],[\"string有哪些特性\",{\"0\":{\"490\":1},\"1\":{\"484\":1}}],[\"string相关\",{\"0\":{\"485\":1},\"1\":{\"484\":1}}],[\"string不可变的原因要包括\",{\"1\":{\"482\":1}}],[\"string为什么要设计成不可变的\",{\"0\":{\"482\":1}}],[\"string中的对象是不可变的\",{\"1\":{\"481\":1}}],[\"string类利用了final修饰的char类型数组存储字符\",{\"1\":{\"481\":1}}],[\"string类中使用字符数组保存字符串\",{\"1\":{\"481\":1}}],[\"stringbuilder是非线程安全的\",{\"1\":{\"481\":1}}],[\"stringbuilder与stringbuffer都继承自abstractstringbuilder类\",{\"1\":{\"481\":1}}],[\"stringbuilder\",{\"0\":{\"481\":1}}],[\"stringbuffer每次都会对stringbuffer对象本身进行操作\",{\"1\":{\"481\":1}}],[\"stringbuffer对方法加了同步锁或者对调用的方法加了同步锁\",{\"1\":{\"481\":1}}],[\"stringbuffer\",{\"0\":{\"481\":1},\"1\":{\"443\":1,\"481\":1}}],[\"string是最常用的一种数据类型\",{\"1\":{\"382\":1}}],[\"string>\",{\"1\":{\"316\":1,\"511\":1}}],[\"stringredisserializer\",{\"1\":{\"314\":2}}],[\"strings\",{\"1\":{\"251\":2,\"258\":1}}],[\"string对象呢\",{\"1\":{\"219\":1}}],[\"stringtrim\",{\"1\":{\"204\":2,\"313\":1}}],[\"string\",{\"0\":{\"450\":1,\"481\":1,\"488\":3,\"489\":1,\"491\":1},\"1\":{\"69\":18,\"70\":34,\"193\":1,\"195\":3,\"196\":3,\"197\":8,\"198\":4,\"199\":13,\"200\":1,\"201\":3,\"203\":2,\"204\":21,\"205\":3,\"216\":3,\"223\":7,\"230\":6,\"237\":5,\"251\":16,\"258\":3,\"277\":2,\"313\":4,\"316\":8,\"317\":1,\"382\":4,\"391\":1,\"443\":1,\"449\":1,\"450\":1,\"472\":1,\"481\":1,\"482\":4,\"484\":6,\"488\":24,\"490\":4,\"494\":2,\"499\":2,\"503\":4,\"505\":1,\"506\":7,\"507\":3,\"510\":5,\"511\":7,\"516\":2,\"521\":5,\"522\":6,\"532\":4,\"555\":2,\"560\":2,\"579\":2,\"582\":2,\"649\":1}}],[\"star\",{\"1\":{\"70\":1}}],[\"starters包含了许多项目中需要用到的依赖\",{\"1\":{\"307\":1}}],[\"starters可以理解为启动器\",{\"1\":{\"307\":1}}],[\"starters\",{\"0\":{\"307\":1}}],[\"starter\",{\"0\":{\"308\":1},\"1\":{\"304\":1,\"307\":1,\"308\":2}}],[\"started\",{\"0\":{\"1\":1}}],[\"start\",{\"0\":{\"635\":1,\"703\":1},\"1\":{\"24\":1,\"69\":3,\"70\":3,\"157\":1,\"216\":1,\"223\":1,\"230\":6,\"237\":1,\"251\":1,\"623\":2,\"635\":2,\"638\":5,\"690\":2,\"703\":2}}],[\"stackoverflowerror\",{\"1\":{\"534\":1}}],[\"stack\",{\"1\":{\"69\":1,\"70\":1,\"570\":1}}],[\"static静态代码块\",{\"1\":{\"461\":1}}],[\"static静态方法里面能不能引用静态资源\",{\"0\":{\"459\":1}}],[\"static静态方法能不能引用非静态资源\",{\"0\":{\"458\":1}}],[\"static变量在java中是属于类的\",{\"1\":{\"457\":1}}],[\"static方法跟类的任何实例都不相关\",{\"1\":{\"456\":1}}],[\"static关键字\",{\"1\":{\"455\":1}}],[\"static\",{\"0\":{\"456\":1},\"1\":{\"193\":1,\"198\":3,\"200\":1,\"201\":2,\"204\":6,\"216\":2,\"223\":5,\"230\":2,\"237\":3,\"244\":1,\"251\":1,\"313\":5,\"316\":1,\"456\":1,\"469\":1,\"494\":2,\"499\":7,\"505\":1,\"506\":5,\"521\":1,\"522\":1,\"532\":3,\"536\":2,\"555\":4,\"556\":1,\"573\":1,\"579\":3,\"586\":1,\"587\":1,\"594\":2,\"605\":1,\"616\":2,\"649\":1,\"663\":1,\"684\":3,\"685\":1}}],[\"station\",{\"1\":{\"70\":1}}],[\"stateless\",{\"1\":{\"282\":1}}],[\"stateful\",{\"1\":{\"282\":1}}],[\"statements\",{\"1\":{\"204\":2}}],[\"statementhaldler\",{\"1\":{\"198\":1}}],[\"statementhandler\",{\"1\":{\"198\":4,\"201\":2}}],[\"statementid\",{\"1\":{\"197\":12,\"200\":5}}],[\"statement中sql的动态参数进行映射生成最终执行的sql语句\",{\"1\":{\"172\":1}}],[\"statement模式下\",{\"1\":{\"89\":1}}],[\"statement\",{\"0\":{\"201\":1},\"1\":{\"89\":1,\"108\":2,\"172\":1,\"197\":4,\"198\":6,\"200\":2,\"204\":10}}],[\"state\",{\"1\":{\"69\":6,\"70\":6,\"426\":1,\"604\":2,\"617\":5,\"677\":2,\"680\":1}}],[\"statustext\",{\"1\":{\"69\":1,\"70\":1,\"71\":5}}],[\"status\",{\"1\":{\"69\":7,\"70\":8,\"71\":10}}],[\"style>\",{\"1\":{\"70\":1,\"71\":1}}],[\"style=\",{\"1\":{\"70\":4}}],[\"stylesheet\",{\"1\":{\"70\":1}}],[\"styles\",{\"1\":{\"5\":1}}],[\"style\",{\"1\":{\"5\":1}}],[\"sigkill\",{\"1\":{\"729\":1,\"731\":1}}],[\"sigterm\",{\"1\":{\"729\":1}}],[\"sigtstp\",{\"1\":{\"729\":1}}],[\"sigint\",{\"1\":{\"729\":1}}],[\"signifies\",{\"1\":{\"559\":1}}],[\"signwith\",{\"1\":{\"316\":1}}],[\"signature\",{\"1\":{\"507\":1}}],[\"signaturealgorithm\",{\"1\":{\"316\":1}}],[\"signal\",{\"1\":{\"71\":2,\"603\":1}}],[\"simplesnippets\",{\"1\":{\"544\":1}}],[\"simplestatementhandler\",{\"1\":{\"198\":1,\"201\":2}}],[\"simplechannelinboundhandler<rpcresponse>\",{\"1\":{\"237\":1}}],[\"simplechannelinboundhandler<rpcrequest>\",{\"1\":{\"237\":1}}],[\"simplerpcclient实现这个接口\",{\"1\":{\"237\":1}}],[\"simplerpcclient\",{\"1\":{\"237\":6,\"251\":2}}],[\"simplerpcrpcserver\",{\"1\":{\"230\":4}}],[\"simpleexecutor\",{\"1\":{\"197\":2,\"198\":2}}],[\"simple\",{\"1\":{\"157\":1,\"237\":1}}],[\"size++\",{\"1\":{\"573\":1}}],[\"size>=threshold\",{\"1\":{\"564\":1}}],[\"size=3\",{\"1\":{\"564\":1}}],[\"size=500x500\",{\"1\":{\"70\":1}}],[\"size=large\",{\"1\":{\"70\":1}}],[\"size\",{\"1\":{\"70\":2,\"258\":2,\"499\":1,\"553\":2,\"554\":1,\"573\":2,\"578\":1,\"723\":1}}],[\"sina\",{\"1\":{\"70\":2}}],[\"singbox\",{\"1\":{\"71\":2}}],[\"sing\",{\"1\":{\"70\":1,\"71\":1}}],[\"singlethreadscheduledexecutor\",{\"1\":{\"673\":2}}],[\"singlethreadexector\",{\"1\":{\"673\":1}}],[\"singleton\",{\"1\":{\"269\":1,\"272\":1}}],[\"single\",{\"1\":{\"70\":3}}],[\"singapore\",{\"1\":{\"62\":1}}],[\"since\",{\"1\":{\"33\":1,\"426\":1}}],[\"silkbook\",{\"1\":{\"62\":2}}],[\"sidebar\",{\"1\":{\"5\":1}}],[\"side\",{\"1\":{\"4\":1,\"69\":1}}],[\"site\",{\"0\":{\"746\":1},\"1\":{\"2\":1,\"4\":2,\"44\":1,\"70\":1}}],[\"sfc\",{\"1\":{\"3\":1}}],[\"t2\",{\"1\":{\"596\":1}}],[\"t>可以接受任何t的父类构成的list\",{\"1\":{\"513\":1}}],[\"t>可以接受任何继承自t的类型的list\",{\"1\":{\"513\":1}}],[\"t>它通过确保类型必须是t的父类来设定类型的下界\",{\"1\":{\"512\":1}}],[\"t>它通过确保类型必须是t的子类来设定类型的上界\",{\"1\":{\"512\":1}}],[\"t>之间有什么区别\",{\"0\":{\"513\":1},\"1\":{\"484\":1}}],[\"t>和list\",{\"0\":{\"513\":1},\"1\":{\"484\":1}}],[\"tt\",{\"1\":{\"682\":1}}],[\"ttl减去第三步的时间差\",{\"1\":{\"437\":1}}],[\"ttl为5s\",{\"1\":{\"437\":1}}],[\"ttl\",{\"1\":{\"388\":1,\"437\":1}}],[\"ttpaihang\",{\"1\":{\"70\":2}}],[\"tcc\",{\"1\":{\"126\":1}}],[\"tcp粘包问题\",{\"1\":{\"242\":1}}],[\"tcpsocket\",{\"1\":{\"69\":10,\"70\":10}}],[\"tcp连接不会关闭\",{\"1\":{\"31\":1}}],[\"tcp连接一旦建立\",{\"1\":{\"11\":1}}],[\"tcp引入了窗口概念\",{\"1\":{\"23\":1}}],[\"tcp传输的过程中\",{\"1\":{\"22\":1}}],[\"tcp主要提供了检验和\",{\"1\":{\"22\":1}}],[\"tcp协议如何保证可靠性\",{\"0\":{\"22\":1}}],[\"tcp的超时重传机制\",{\"1\":{\"15\":1}}],[\"tcp和udp的区别\",{\"0\":{\"9\":1}}],[\"tcp\",{\"0\":{\"10\":1,\"11\":1,\"16\":1},\"1\":{\"8\":5,\"9\":4,\"10\":1,\"11\":1,\"12\":2,\"14\":5,\"16\":3,\"18\":1,\"19\":1,\"20\":4,\"21\":1,\"23\":2,\"24\":1,\"25\":1,\"38\":5,\"69\":5,\"70\":4,\"99\":1,\"731\":1}}],[\"tddl\",{\"0\":{\"124\":1},\"1\":{\"122\":1}}],[\"t1\",{\"1\":{\"112\":2,\"596\":1}}],[\"t\",{\"1\":{\"98\":3,\"193\":1,\"194\":2,\"197\":5,\"200\":5,\"223\":1,\"507\":2,\"511\":6,\"596\":4,\"623\":2,\"661\":1,\"690\":2}}],[\"tg\",{\"1\":{\"71\":2}}],[\"tgid\",{\"1\":{\"71\":1}}],[\"tgtoken\",{\"1\":{\"71\":1}}],[\"tmtpost\",{\"1\":{\"70\":2}}],[\"tmall\",{\"1\":{\"70\":2}}],[\"tudou\",{\"1\":{\"70\":2}}],[\"tv\",{\"1\":{\"70\":3}}],[\"ticketing\",{\"1\":{\"70\":1}}],[\"tiktok\",{\"1\":{\"70\":2}}],[\"titles\",{\"1\":{\"157\":2}}],[\"title\",{\"1\":{\"70\":2,\"230\":2}}],[\"title>\",{\"1\":{\"70\":1,\"71\":1}}],[\"title=\",{\"1\":{\"70\":1,\"157\":1}}],[\"time时间\",{\"1\":{\"417\":1}}],[\"timeunit\",{\"1\":{\"230\":2,\"316\":1,\"627\":1,\"669\":1,\"694\":1,\"697\":1}}],[\"timeout\",{\"1\":{\"71\":2,\"417\":1,\"633\":1,\"669\":1,\"697\":1,\"701\":1}}],[\"timeout时间\",{\"1\":{\"43\":1,\"427\":1}}],[\"timestamp\",{\"1\":{\"71\":5,\"161\":1}}],[\"timestamps\",{\"1\":{\"20\":1,\"70\":1}}],[\"time\",{\"0\":{\"18\":1,\"20\":1,\"21\":1},\"1\":{\"16\":1,\"20\":2,\"21\":3,\"62\":1,\"69\":1,\"161\":2,\"166\":1,\"338\":2,\"396\":1,\"554\":1,\"578\":1}}],[\"tfo=false\",{\"1\":{\"70\":1,\"71\":2}}],[\"ten\",{\"1\":{\"553\":1}}],[\"tencent\",{\"1\":{\"25\":1,\"70\":1,\"438\":1}}],[\"tech\",{\"1\":{\"483\":1,\"544\":1,\"618\":1,\"675\":1,\"723\":1}}],[\"technical\",{\"1\":{\"70\":1}}],[\"technology\",{\"1\":{\"70\":5}}],[\"tempfile\",{\"1\":{\"521\":2,\"522\":2}}],[\"template\",{\"1\":{\"286\":1}}],[\"temporary等\",{\"1\":{\"157\":1}}],[\"temporary\",{\"1\":{\"157\":2}}],[\"telegram\",{\"1\":{\"71\":2}}],[\"telegraph\",{\"1\":{\"70\":2}}],[\"television\",{\"1\":{\"70\":1}}],[\"ted\",{\"1\":{\"70\":2}}],[\"testserver\",{\"1\":{\"230\":2}}],[\"test\",{\"1\":{\"69\":1,\"70\":1,\"205\":1,\"305\":2,\"434\":1,\"488\":2,\"494\":2,\"506\":1}}],[\"testing\",{\"1\":{\"69\":1}}],[\"text=\",{\"1\":{\"71\":1}}],[\"textencoder\",{\"1\":{\"70\":1}}],[\"textdecoder\",{\"1\":{\"69\":1,\"70\":1}}],[\"text\",{\"1\":{\"69\":1,\"70\":5,\"71\":24,\"159\":1}}],[\"type获取mapper对象\",{\"1\":{\"197\":1}}],[\"type=star\",{\"1\":{\"70\":1}}],[\"type=ws\",{\"1\":{\"69\":2,\"70\":3,\"71\":2}}],[\"typeerror\",{\"1\":{\"69\":1,\"70\":1}}],[\"type\",{\"1\":{\"69\":10,\"70\":11,\"71\":14,\"157\":7,\"193\":1,\"194\":8,\"197\":2,\"200\":5,\"205\":1,\"291\":1,\"489\":1}}],[\"types\",{\"1\":{\"69\":12,\"70\":12,\"514\":1}}],[\"treemap\",{\"1\":{\"570\":1}}],[\"treemap等实现类\",{\"1\":{\"569\":1}}],[\"treeset\",{\"1\":{\"569\":1,\"570\":1}}],[\"treenode<k\",{\"1\":{\"556\":1,\"559\":1}}],[\"treenode\",{\"1\":{\"556\":1,\"559\":1}}],[\"treenodes\",{\"1\":{\"553\":1}}],[\"treeifybin\",{\"1\":{\"556\":2}}],[\"treeify\",{\"1\":{\"553\":1,\"556\":3}}],[\"tree的叶子节点存储了主键的值的是非主键索引\",{\"1\":{\"151\":1}}],[\"tree的叶子节点存储了整行数据的是主键索引\",{\"1\":{\"151\":1}}],[\"tree的改进版本\",{\"1\":{\"149\":1}}],[\"tree需要获取所有节点\",{\"1\":{\"149\":1}}],[\"tree来说\",{\"1\":{\"149\":1}}],[\"tree能加快数据的访问速度\",{\"1\":{\"149\":1}}],[\"tree\",{\"0\":{\"150\":1},\"1\":{\"80\":1,\"150\":1,\"553\":1}}],[\"tree索引\",{\"1\":{\"79\":1,\"148\":2,\"149\":1}}],[\"tree或b+tree索引\",{\"1\":{\"79\":1,\"148\":1}}],[\"tradeoff\",{\"1\":{\"554\":1,\"578\":1}}],[\"traders\",{\"1\":{\"70\":1}}],[\"travel\",{\"1\":{\"70\":2}}],[\"tracking\",{\"1\":{\"70\":1}}],[\"trace\",{\"1\":{\"29\":1}}],[\"transfer\",{\"1\":{\"558\":3,\"581\":3}}],[\"transforming\",{\"1\":{\"70\":1}}],[\"transform\",{\"1\":{\"69\":1,\"70\":2}}],[\"transformstream\",{\"1\":{\"69\":4,\"70\":4}}],[\"transient\",{\"1\":{\"527\":4,\"587\":1}}],[\"transportlayer\",{\"1\":{\"354\":1}}],[\"transportlayer是kafka传输层的接口\",{\"1\":{\"341\":1}}],[\"transparent\",{\"1\":{\"70\":1}}],[\"trans\",{\"1\":{\"110\":1}}],[\"traffic\",{\"1\":{\"70\":1}}],[\"trim\",{\"1\":{\"69\":1,\"70\":3,\"71\":6,\"184\":1,\"201\":1,\"204\":2,\"313\":2}}],[\"true\",{\"1\":{\"69\":11,\"70\":11,\"71\":8,\"203\":1,\"216\":1,\"223\":2,\"230\":2,\"316\":1,\"317\":2,\"319\":1,\"488\":2,\"497\":2,\"499\":1,\"502\":1,\"516\":1,\"548\":1,\"556\":1,\"573\":1,\"605\":1,\"611\":1,\"612\":2,\"613\":1,\"616\":2,\"617\":3,\"631\":2,\"699\":2}}],[\"tryrelease只在reentrantlock中的sync实现\",{\"1\":{\"615\":1}}],[\"tryrelease需要自定义同步器实现\",{\"1\":{\"615\":1}}],[\"tryreleaseshared\",{\"1\":{\"613\":1,\"678\":1}}],[\"tryrelease\",{\"1\":{\"611\":1,\"617\":1,\"678\":1}}],[\"tryacquire是获取锁逻辑\",{\"1\":{\"615\":1}}],[\"tryacquire由各个自定义同步器实现\",{\"1\":{\"614\":1}}],[\"tryacquiresharednanos\",{\"1\":{\"612\":1}}],[\"tryacquireshared\",{\"1\":{\"612\":3,\"678\":1}}],[\"tryacquire\",{\"1\":{\"605\":4,\"610\":2,\"616\":1,\"617\":4,\"678\":1}}],[\"try中的\",{\"1\":{\"536\":1}}],[\"try+catch适合处理运行时异常+普通异常\",{\"1\":{\"535\":1}}],[\"try只适合处理运行时异常\",{\"1\":{\"535\":1}}],[\"trycloudflare\",{\"1\":{\"71\":1}}],[\"try\",{\"0\":{\"535\":1,\"536\":1},\"1\":{\"69\":4,\"70\":3,\"71\":6,\"195\":1,\"198\":2,\"202\":1,\"203\":1,\"204\":1,\"216\":3,\"223\":3,\"230\":4,\"237\":4,\"244\":2,\"251\":3,\"454\":1,\"484\":2,\"506\":1,\"507\":1,\"521\":2,\"522\":2,\"532\":1,\"533\":1,\"536\":2,\"607\":1,\"612\":1,\"627\":1,\"648\":1,\"684\":1,\"694\":1,\"707\":1,\"714\":1}}],[\"tang\",{\"1\":{\"682\":1}}],[\"task\",{\"1\":{\"629\":2,\"696\":2,\"714\":2}}],[\"tasteatlas\",{\"1\":{\"62\":1}}],[\"tailoffset\",{\"1\":{\"607\":1}}],[\"tail\",{\"1\":{\"607\":1}}],[\"taken\",{\"1\":{\"554\":1,\"578\":1}}],[\"tab为空则创建\",{\"1\":{\"556\":1}}],[\"tab\",{\"1\":{\"117\":1,\"556\":11,\"565\":1}}],[\"table的状态应该是下图中的任意一个\",{\"1\":{\"565\":1}}],[\"table的初始化长度length\",{\"1\":{\"554\":1,\"578\":1}}],[\"tablesizefor\",{\"1\":{\"555\":3}}],[\"table允许在单个语句中更改多个表\",{\"1\":{\"159\":1}}],[\"table用来创建普通索引\",{\"1\":{\"159\":1}}],[\"table命令去增加索引\",{\"1\":{\"159\":1}}],[\"table时创建索引\",{\"1\":{\"159\":1}}],[\"table中有一个二级索引\",{\"1\":{\"156\":1}}],[\"table\",{\"1\":{\"89\":1,\"92\":1,\"108\":1,\"114\":1,\"136\":3,\"155\":3,\"157\":2,\"159\":4,\"555\":4,\"556\":1,\"558\":3,\"559\":3,\"581\":3,\"585\":1,\"587\":1}}],[\"tahoma\",{\"1\":{\"71\":1}}],[\"taobao\",{\"1\":{\"70\":2}}],[\"target\",{\"1\":{\"195\":1,\"507\":2}}],[\"target=singbox\",{\"1\":{\"71\":1}}],[\"target=\",{\"1\":{\"70\":9}}],[\"target=clash\",{\"1\":{\"70\":1,\"71\":1}}],[\"targetuuid\",{\"1\":{\"69\":3}}],[\"tag\",{\"1\":{\"68\":1}}],[\"tlsindex\",{\"1\":{\"71\":4}}],[\"tls订阅生成\",{\"1\":{\"71\":1}}],[\"tls\",{\"1\":{\"69\":3,\"70\":1,\"71\":4}}],[\"tl\",{\"1\":{\"64\":1}}],[\"txt\",{\"1\":{\"58\":1,\"65\":1,\"71\":3}}],[\"tk\",{\"1\":{\"58\":2}}],[\"twice\",{\"1\":{\"553\":1}}],[\"twitter\",{\"1\":{\"70\":5,\"71\":1}}],[\"two\",{\"1\":{\"69\":1,\"70\":1}}],[\"tweek\",{\"1\":{\"55\":1}}],[\"tw\",{\"1\":{\"20\":3,\"62\":5,\"71\":1}}],[\"ts\",{\"1\":{\"4\":2,\"69\":3,\"70\":1}}],[\"than\",{\"1\":{\"553\":1,\"554\":1,\"578\":1}}],[\"that\",{\"1\":{\"69\":3,\"70\":7,\"399\":1}}],[\"thinkwon\",{\"1\":{\"144\":2,\"544\":1}}],[\"thisiswhy\",{\"1\":{\"723\":1}}],[\"this\",{\"1\":{\"1\":1,\"69\":5,\"70\":8,\"71\":1,\"196\":1,\"197\":3,\"198\":1,\"199\":5,\"200\":6,\"201\":1,\"202\":1,\"203\":1,\"204\":2,\"223\":1,\"230\":4,\"237\":2,\"251\":7,\"277\":1,\"476\":1,\"481\":1,\"505\":1,\"507\":1,\"521\":1,\"522\":1,\"556\":1,\"559\":1,\"594\":4,\"607\":1}}],[\"threshold=1\",{\"1\":{\"564\":1}}],[\"threshold=负载因子\",{\"1\":{\"564\":1}}],[\"threshold是hashmap所能容纳键值对的最大值\",{\"1\":{\"554\":1,\"578\":1}}],[\"threshold\",{\"1\":{\"553\":2,\"554\":2,\"556\":2,\"558\":2,\"559\":6,\"578\":2,\"581\":2}}],[\"thread是在调用构造方法时通过threadfactory来创建的线程\",{\"1\":{\"714\":1}}],[\"threadfactory\",{\"1\":{\"670\":1}}],[\"thread对象中持有一个threadlocal\",{\"1\":{\"664\":1}}],[\"thread类有一个类型为threadlocal\",{\"1\":{\"664\":1}}],[\"thread类中的yield方法有什么作用\",{\"0\":{\"636\":1,\"705\":1}}],[\"threadlocal是一个本地线程副本变量工具类\",{\"1\":{\"704\":1}}],[\"threadlocal是什么\",{\"0\":{\"663\":1,\"704\":1}}],[\"threadlocal内存结构图\",{\"1\":{\"664\":1}}],[\"threadlocalmap\",{\"1\":{\"704\":1}}],[\"threadlocalmap中使用的\",{\"1\":{\"665\":1}}],[\"threadlocalmap内部维护了entry数组\",{\"1\":{\"664\":1}}],[\"threadlocalmap内部维护着entry数组\",{\"1\":{\"664\":1}}],[\"threadlocalmap的key没了\",{\"1\":{\"665\":1}}],[\"threadlocalmap的key\",{\"1\":{\"665\":1}}],[\"threadlocalmap的成员变量\",{\"1\":{\"664\":1}}],[\"threadlocalmap的实例变量threadlocals\",{\"1\":{\"664\":1}}],[\"threadlocal的实现原理\",{\"0\":{\"664\":1}}],[\"threadlocal的应用场景有\",{\"1\":{\"663\":1}}],[\"threadlocal<>\",{\"1\":{\"663\":1}}],[\"threadlocal<string>\",{\"1\":{\"663\":1}}],[\"threadlocal\",{\"1\":{\"663\":1,\"665\":1}}],[\"threadid\",{\"1\":{\"652\":4}}],[\"threadpool\",{\"1\":{\"230\":4,\"723\":1}}],[\"threadpoolexecutor的运行状态有5种\",{\"1\":{\"712\":1}}],[\"threadpoolexecutor是如何运行\",{\"1\":{\"711\":1}}],[\"threadpoolexecutor将会一方面维护自身的生命周期\",{\"1\":{\"711\":1}}],[\"threadpoolexecutor实现的顶层接口是executor\",{\"1\":{\"711\":1}}],[\"threadpoolexecutor类中一共有4种饱和策略\",{\"1\":{\"670\":1}}],[\"threadpoolexecutor\",{\"1\":{\"230\":3}}],[\"threadpoolrpcrpcserver\",{\"1\":{\"230\":3}}],[\"thread会读取中继日志\",{\"1\":{\"132\":1}}],[\"thread\",{\"0\":{\"757\":1},\"1\":{\"132\":1,\"216\":1,\"223\":1,\"230\":1,\"391\":1,\"506\":1,\"563\":1,\"603\":1,\"605\":1,\"607\":1,\"616\":3,\"617\":3,\"619\":1,\"623\":1,\"635\":2,\"638\":8,\"639\":2,\"686\":1,\"690\":1,\"703\":2,\"710\":1,\"714\":2,\"724\":1,\"732\":2,\"737\":1}}],[\"throwable\",{\"1\":{\"200\":1,\"223\":1,\"237\":2,\"507\":1,\"530\":2}}],[\"throws\",{\"0\":{\"532\":1},\"1\":{\"198\":1,\"200\":1,\"201\":6,\"223\":1,\"237\":6,\"244\":2,\"245\":1,\"317\":3,\"484\":1,\"499\":1,\"505\":1,\"506\":1,\"507\":1,\"522\":2,\"532\":7,\"533\":1}}],[\"throwing\",{\"1\":{\"70\":1}}],[\"throw\",{\"0\":{\"532\":1},\"1\":{\"69\":4,\"70\":4,\"71\":3,\"198\":2,\"201\":1,\"203\":4,\"244\":2,\"484\":1,\"507\":1,\"532\":5,\"605\":1,\"616\":1,\"617\":2,\"684\":1}}],[\"theory\",{\"1\":{\"618\":1}}],[\"they\",{\"1\":{\"553\":2}}],[\"them\",{\"1\":{\"70\":1,\"553\":1}}],[\"themeresolver\",{\"1\":{\"291\":1}}],[\"theme\",{\"1\":{\"5\":2}}],[\"there\",{\"1\":{\"70\":2}}],[\"the\",{\"1\":{\"69\":28,\"70\":63,\"71\":1,\"521\":1,\"553\":5,\"554\":11,\"578\":11,\"607\":1}}],[\"then\",{\"1\":{\"3\":1,\"70\":1,\"71\":1}}],[\"too\",{\"1\":{\"399\":1,\"553\":1}}],[\"tool\",{\"1\":{\"70\":1}}],[\"tojavaobject\",{\"1\":{\"244\":2}}],[\"tojsonbytes\",{\"1\":{\"244\":1}}],[\"tobytearray\",{\"1\":{\"244\":1}}],[\"touppercase\",{\"1\":{\"71\":1}}],[\"toutiao\",{\"1\":{\"70\":4}}],[\"total=$\",{\"1\":{\"71\":3}}],[\"total\",{\"1\":{\"71\":6}}],[\"torrent\",{\"1\":{\"70\":1}}],[\"tolowercase\",{\"1\":{\"69\":1,\"70\":1,\"71\":9}}],[\"todo\",{\"1\":{\"69\":2,\"70\":3,\"197\":1,\"198\":1,\"200\":1}}],[\"tostringcache\",{\"1\":{\"481\":1}}],[\"tostring方法\",{\"1\":{\"205\":1}}],[\"tostring\",{\"1\":{\"69\":4,\"70\":5,\"199\":1,\"216\":1,\"506\":1,\"521\":1,\"522\":1}}],[\"token\",{\"1\":{\"69\":1,\"70\":1,\"71\":5,\"316\":12,\"317\":5}}],[\"token=订阅入口\",{\"1\":{\"58\":1}}],[\"toy\",{\"1\":{\"62\":3}}],[\"topics\",{\"1\":{\"322\":1}}],[\"topic\",{\"1\":{\"322\":2,\"323\":3,\"334\":1,\"336\":2,\"337\":1,\"350\":6,\"362\":4}}],[\"top\",{\"1\":{\"53\":1,\"55\":1,\"58\":2,\"59\":1,\"63\":1,\"70\":1,\"71\":1,\"141\":1,\"737\":1}}],[\"tomcat是默认的\",{\"1\":{\"304\":1}}],[\"tomcat\",{\"1\":{\"32\":1}}],[\"to\",{\"1\":{\"2\":1,\"3\":2,\"4\":1,\"69\":19,\"70\":48,\"71\":3,\"385\":1,\"399\":1,\"424\":2,\"483\":1,\"493\":1,\"521\":1,\"522\":1,\"553\":3,\"554\":1,\"578\":1,\"594\":1,\"607\":1,\"723\":1}}],[\"b又变回a的情况\",{\"1\":{\"645\":1}}],[\"b两个线程\",{\"1\":{\"548\":1,\"588\":1}}],[\"b0\",{\"1\":{\"544\":1}}],[\"bd\",{\"1\":{\"349\":1}}],[\"bdb支持页级锁\",{\"1\":{\"114\":1}}],[\"bdb引擎\",{\"1\":{\"114\":1}}],[\"bcde\",{\"1\":{\"346\":1}}],[\"bcd\",{\"1\":{\"346\":1,\"347\":2,\"349\":1}}],[\"b拿到a对象后顺利完成了初始化阶段1\",{\"1\":{\"281\":1}}],[\"b在初始化第一步的时候发现自己依赖了对象a\",{\"1\":{\"281\":1}}],[\"b2b\",{\"1\":{\"123\":1}}],[\"b=666\",{\"1\":{\"112\":1}}],[\"b=2\",{\"1\":{\"84\":1}}],[\"b字段都可以使用索引\",{\"1\":{\"84\":1}}],[\"b值又是按顺序排列的\",{\"1\":{\"84\":1}}],[\"b是无序的\",{\"1\":{\"84\":1}}],[\"b的顺序\",{\"1\":{\"84\":1}}],[\"b+树中存的都是数据表中的字段值\",{\"1\":{\"161\":1}}],[\"b+树的内部节点并没有指向关键字具体信息的指针\",{\"1\":{\"150\":1}}],[\"b+树的磁盘读写代价更低\",{\"1\":{\"150\":1}}],[\"b+树有2个头指针\",{\"1\":{\"149\":1}}],[\"b+树而不是其它树形结构\",{\"0\":{\"80\":1}}],[\"b+\",{\"1\":{\"83\":3,\"149\":1}}],[\"b+tree性质\",{\"1\":{\"149\":1}}],[\"b+tree索引\",{\"1\":{\"149\":1}}],[\"b+tree\",{\"1\":{\"83\":1}}],[\"b+tree叶节点的data域存放的是数据记录的地址\",{\"1\":{\"82\":1}}],[\"broker端如何保证消息不丢失\",{\"1\":{\"369\":1}}],[\"broker端\",{\"1\":{\"369\":1}}],[\"broker端属性\",{\"1\":{\"365\":1}}],[\"broker中是否有符合条件的消息\",{\"1\":{\"367\":1}}],[\"broker如何处理拉取请求的\",{\"0\":{\"367\":1}}],[\"broker可以看做rabbitmq的服务节点\",{\"1\":{\"355\":1}}],[\"broker问题等\",{\"1\":{\"339\":1}}],[\"broker\",{\"1\":{\"322\":1,\"323\":8,\"327\":1,\"334\":1,\"362\":1,\"363\":1}}],[\"br\",{\"1\":{\"71\":1}}],[\"british\",{\"1\":{\"70\":1}}],[\"break\",{\"0\":{\"452\":1},\"1\":{\"69\":3,\"70\":4,\"71\":2,\"200\":3,\"244\":2,\"452\":1,\"506\":1,\"556\":2}}],[\"bio一般适用于连接数目小且固定的架构\",{\"1\":{\"542\":1}}],[\"bio\",{\"0\":{\"542\":1},\"1\":{\"484\":1,\"542\":1}}],[\"bio的方式\",{\"1\":{\"237\":1}}],[\"bio的方式监听socket\",{\"1\":{\"216\":1,\"223\":1,\"230\":1}}],[\"biancheng\",{\"1\":{\"483\":1}}],[\"bit\",{\"1\":{\"382\":1,\"559\":1}}],[\"bitmap想象成一个以位为单位数组\",{\"1\":{\"382\":1}}],[\"bitmap的底层都是\",{\"1\":{\"382\":1}}],[\"bitmap\",{\"1\":{\"382\":3}}],[\"bis\",{\"1\":{\"244\":3}}],[\"bincount\",{\"1\":{\"556\":2}}],[\"bins\",{\"1\":{\"553\":4}}],[\"bin\",{\"1\":{\"251\":1}}],[\"bind\",{\"1\":{\"184\":1,\"237\":1}}],[\"binary\",{\"1\":{\"132\":1}}],[\"binlog线程\",{\"1\":{\"132\":1}}],[\"binlog\",{\"0\":{\"108\":1},\"1\":{\"99\":1,\"108\":7,\"132\":1,\"133\":1,\"144\":1,\"393\":2}}],[\"bilibili\",{\"1\":{\"70\":2}}],[\"big\",{\"1\":{\"69\":1,\"70\":1}}],[\"btree索引\",{\"1\":{\"79\":1,\"148\":1}}],[\"btn\",{\"1\":{\"70\":1}}],[\"btoa\",{\"1\":{\"70\":1,\"71\":1}}],[\"blank\",{\"1\":{\"70\":9}}],[\"blockingqueue\",{\"1\":{\"713\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"230\":1}}],[\"blocked\",{\"1\":{\"623\":1,\"690\":1}}],[\"bloch\",{\"1\":{\"515\":1}}],[\"blob\",{\"1\":{\"60\":1,\"69\":4,\"70\":4}}],[\"blogspot\",{\"1\":{\"567\":1}}],[\"blogserviceimpl\",{\"1\":{\"229\":1,\"230\":3}}],[\"blogservice\",{\"1\":{\"229\":4,\"230\":11,\"231\":4}}],[\"blogbyid\",{\"1\":{\"231\":2}}],[\"blog\",{\"1\":{\"25\":1,\"70\":1,\"144\":2,\"230\":7,\"231\":1,\"465\":1,\"483\":1,\"544\":3,\"599\":1,\"618\":1,\"685\":2,\"723\":1}}],[\"b>\",{\"1\":{\"70\":2}}],[\"bound\",{\"1\":{\"399\":1}}],[\"bos\",{\"1\":{\"244\":4}}],[\"bossgroup\",{\"1\":{\"237\":3}}],[\"boot支持不同环境的属性配置文件切换\",{\"1\":{\"305\":1}}],[\"boot中如何实现对不同环境的属性配置文件的支持\",{\"0\":{\"305\":1}}],[\"boot将为你管理依赖关系\",{\"1\":{\"304\":1}}],[\"boot\",{\"0\":{\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"310\":1},\"1\":{\"304\":1,\"306\":1,\"307\":1,\"308\":5,\"310\":7}}],[\"boot致力于弱化这些不必要的操作\",{\"1\":{\"304\":1}}],[\"bootstrap\",{\"1\":{\"237\":6}}],[\"books\",{\"1\":{\"193\":2}}],[\"book\",{\"1\":{\"193\":3,\"205\":8}}],[\"bookmapper\",{\"1\":{\"193\":5,\"194\":1,\"205\":4}}],[\"boolean\",{\"1\":{\"70\":3,\"204\":4,\"216\":1,\"313\":4,\"316\":1,\"317\":1,\"449\":3,\"476\":1,\"489\":1,\"493\":2,\"556\":2,\"573\":1,\"595\":1,\"604\":1,\"605\":1,\"607\":1,\"611\":1,\"612\":2,\"613\":1,\"616\":2,\"617\":3,\"648\":1,\"707\":1}}],[\"bottleneck\",{\"1\":{\"399\":1}}],[\"bottoken\",{\"1\":{\"71\":5}}],[\"bottom\",{\"1\":{\"70\":1}}],[\"bot\",{\"1\":{\"71\":1}}],[\"border\",{\"1\":{\"70\":3}}],[\"boxing\",{\"1\":{\"493\":1}}],[\"box\",{\"1\":{\"70\":1,\"71\":1}}],[\"body\",{\"1\":{\"69\":3,\"70\":5,\"71\":1}}],[\"body>\",{\"1\":{\"32\":1,\"70\":1,\"71\":1}}],[\"bytype\",{\"1\":{\"278\":2}}],[\"bytecode\",{\"1\":{\"483\":1}}],[\"bytearrayinputstream\",{\"1\":{\"244\":2}}],[\"bytearrayoutputstream\",{\"1\":{\"244\":2}}],[\"bytetomessagedecoder\",{\"1\":{\"244\":1}}],[\"bytetohex\",{\"1\":{\"69\":18,\"70\":18}}],[\"bytebuf\",{\"1\":{\"244\":2}}],[\"bytes\",{\"1\":{\"244\":14}}],[\"byte\",{\"0\":{\"450\":1},\"1\":{\"69\":2,\"70\":4,\"244\":11,\"449\":2,\"450\":1,\"489\":1,\"493\":2,\"541\":1}}],[\"bytelength\",{\"1\":{\"69\":3,\"70\":4}}],[\"byname\",{\"1\":{\"278\":1}}],[\"by不支持前缀索引\",{\"1\":{\"155\":1}}],[\"by只有一个表中的列\",{\"1\":{\"139\":1}}],[\"by和order\",{\"1\":{\"139\":1}}],[\"by\",{\"1\":{\"70\":5,\"499\":1,\"554\":1,\"578\":1}}],[\"bus\",{\"1\":{\"321\":1}}],[\"businesses\",{\"1\":{\"70\":1}}],[\"builder\",{\"1\":{\"216\":2,\"223\":6,\"230\":2,\"251\":1,\"316\":1}}],[\"build方法重载\",{\"1\":{\"195\":1}}],[\"build方法创建sqlsessionfactory对象\",{\"1\":{\"193\":1}}],[\"build\",{\"1\":{\"193\":1,\"194\":1,\"195\":5,\"216\":1,\"223\":4,\"230\":1,\"251\":1,\"316\":1}}],[\"bulianglin\",{\"1\":{\"71\":1}}],[\"buying\",{\"1\":{\"70\":1}}],[\"bufferedinputstream\",{\"1\":{\"543\":1}}],[\"bufferedreader\",{\"1\":{\"539\":1}}],[\"buffer\",{\"1\":{\"69\":1,\"70\":4}}],[\"button>\",{\"1\":{\"70\":2}}],[\"but\",{\"1\":{\"69\":2,\"554\":1,\"578\":1}}],[\"bug\",{\"1\":{\"69\":3,\"70\":3}}],[\"b100\",{\"1\":{\"61\":1}}],[\"b6gac\",{\"1\":{\"61\":3,\"62\":2,\"70\":3}}],[\"barrier\",{\"1\":{\"681\":1}}],[\"batching\",{\"1\":{\"329\":1}}],[\"bangalore\",{\"1\":{\"277\":1}}],[\"balance\",{\"1\":{\"258\":3}}],[\"bafybeigd6i5aavwpr6wvnwuyayklq3omonggta4x2q7kpmgafj357nkcky\",{\"1\":{\"70\":2}}],[\"backing\",{\"1\":{\"594\":1}}],[\"back\",{\"1\":{\"553\":1}}],[\"background\",{\"1\":{\"70\":5}}],[\"backup\",{\"1\":{\"69\":1,\"70\":1,\"607\":1}}],[\"backpressure\",{\"1\":{\"69\":2,\"70\":2}}],[\"base64response\",{\"1\":{\"71\":2}}],[\"base64text\",{\"1\":{\"71\":2}}],[\"base64toarraybuffer\",{\"1\":{\"69\":2,\"70\":2}}],[\"base64\",{\"1\":{\"69\":1,\"70\":3,\"71\":2}}],[\"base64str\",{\"1\":{\"69\":6,\"70\":6}}],[\"base\",{\"0\":{\"754\":1},\"1\":{\"69\":1}}],[\"basicack机制\",{\"1\":{\"356\":1}}],[\"basic\",{\"0\":{\"755\":1},\"1\":{\"3\":1}}],[\"basics\",{\"1\":{\"1\":1}}],[\"baidu\",{\"0\":{\"38\":1},\"1\":{\"38\":1,\"70\":2}}],[\"bad\",{\"1\":{\"33\":1}}],[\"b\",{\"0\":{\"80\":1},\"1\":{\"12\":2,\"42\":2,\"74\":2,\"75\":1,\"79\":1,\"80\":1,\"84\":8,\"103\":4,\"112\":2,\"136\":1,\"148\":1,\"149\":2,\"150\":2,\"154\":6,\"161\":7,\"281\":1,\"390\":1,\"391\":2,\"435\":6,\"467\":2,\"482\":1,\"488\":1,\"497\":2,\"498\":2,\"516\":2,\"559\":1,\"565\":1,\"644\":2,\"726\":3,\"727\":1,\"732\":2}}],[\"before\",{\"1\":{\"646\":1,\"650\":1}}],[\"become\",{\"1\":{\"553\":1}}],[\"becomes\",{\"1\":{\"399\":1}}],[\"because\",{\"1\":{\"553\":2}}],[\"beautiful\",{\"1\":{\"567\":1}}],[\"beaninfo\",{\"1\":{\"506\":1}}],[\"beans\",{\"1\":{\"506\":3}}],[\"beans>\",{\"1\":{\"268\":1}}],[\"bean工厂的初始化\",{\"1\":{\"506\":1}}],[\"beanmap\",{\"1\":{\"506\":2}}],[\"bean的会生效\",{\"1\":{\"280\":1}}],[\"bean的生命周期是由容器来管理的\",{\"1\":{\"273\":1}}],[\"bean出现同名bean\",{\"1\":{\"280\":1}}],[\"bean初始化完成\",{\"1\":{\"276\":1}}],[\"bean>\",{\"1\":{\"268\":1,\"277\":2}}],[\"bean\",{\"0\":{\"269\":1,\"271\":1,\"272\":1,\"273\":1,\"277\":1,\"282\":1},\"1\":{\"268\":11,\"269\":3,\"271\":2,\"272\":6,\"277\":8,\"278\":11,\"282\":2,\"286\":2,\"304\":1,\"308\":2,\"314\":2,\"315\":1,\"319\":1,\"506\":5}}],[\"beanfactoryaware\",{\"1\":{\"276\":1}}],[\"beanfactory的优缺点\",{\"1\":{\"266\":1}}],[\"beanfactory和applicationcontext的优缺点分析\",{\"1\":{\"266\":1}}],[\"beanfactory\",{\"0\":{\"266\":1},\"1\":{\"266\":1,\"278\":1,\"286\":1,\"506\":1}}],[\"beacsue\",{\"1\":{\"69\":1,\"70\":1}}],[\"between\",{\"1\":{\"84\":1,\"154\":1,\"161\":1,\"554\":1,\"578\":1}}],[\"bestnote\",{\"1\":{\"685\":1}}],[\"bestsubconfig\",{\"1\":{\"70\":2}}],[\"bestcf\",{\"1\":{\"58\":1}}],[\"bestip\",{\"1\":{\"53\":1,\"70\":3}}],[\"be\",{\"1\":{\"2\":1,\"3\":1,\"69\":4,\"70\":4,\"499\":1,\"554\":1,\"578\":1}}],[\"wkfvawl\",{\"1\":{\"483\":1}}],[\"wto\",{\"1\":{\"71\":1}}],[\"world\",{\"1\":{\"482\":2,\"560\":1}}],[\"worth\",{\"1\":{\"70\":1}}],[\"word的结构也就变为偏向锁结构\",{\"1\":{\"656\":1}}],[\"word\",{\"1\":{\"70\":2,\"656\":2}}],[\"workgroup\",{\"1\":{\"237\":3}}],[\"work负责具体的请求\",{\"1\":{\"237\":1}}],[\"workqueue\",{\"1\":{\"230\":2,\"670\":1,\"714\":1,\"720\":1}}],[\"workthread\",{\"1\":{\"230\":3}}],[\"working\",{\"1\":{\"71\":1}}],[\"worker会主动消除自身在线程池内的引用\",{\"1\":{\"714\":1}}],[\"worker被创建出来后\",{\"1\":{\"714\":1}}],[\"worker是通过继承aqs\",{\"1\":{\"714\":1}}],[\"worker执行任务\",{\"1\":{\"714\":1}}],[\"worker执行任务的模型如下图所示\",{\"1\":{\"714\":1}}],[\"worker这个工作线程\",{\"1\":{\"714\":1}}],[\"worker持有的线程\",{\"1\":{\"714\":1}}],[\"worker线程执行任务\",{\"1\":{\"714\":1}}],[\"worker线程回收\",{\"1\":{\"714\":1}}],[\"worker线程增加\",{\"1\":{\"714\":1}}],[\"worker线程\",{\"1\":{\"714\":1}}],[\"worker线程管理\",{\"0\":{\"714\":1}}],[\"worker线程数量和参数有关\",{\"1\":{\"674\":1}}],[\"workercount\",{\"1\":{\"712\":2,\"713\":1}}],[\"workervless2sub\",{\"1\":{\"71\":9}}],[\"worker\",{\"1\":{\"57\":1,\"60\":1,\"70\":3,\"71\":1,\"406\":2,\"714\":1}}],[\"workers\",{\"0\":{\"747\":1},\"1\":{\"57\":1,\"58\":1,\"60\":1,\"69\":22,\"70\":14,\"71\":5}}],[\"work\",{\"1\":{\"48\":1,\"69\":1}}],[\"wrapper\",{\"1\":{\"493\":1}}],[\"wrap\",{\"1\":{\"70\":3}}],[\"writing\",{\"1\":{\"70\":1}}],[\"writable\",{\"1\":{\"69\":3,\"70\":3,\"403\":5}}],[\"writablestream\",{\"1\":{\"69\":4,\"70\":3}}],[\"writeexternal\",{\"1\":{\"522\":2}}],[\"write默认情况下是0\",{\"1\":{\"424\":1}}],[\"writebytes\",{\"1\":{\"244\":1}}],[\"writeandflush\",{\"1\":{\"237\":2}}],[\"writeobject\",{\"1\":{\"216\":1,\"223\":2,\"230\":1,\"237\":1,\"244\":1,\"251\":1,\"521\":1,\"522\":2}}],[\"writeint\",{\"1\":{\"216\":1,\"244\":1}}],[\"writetext\",{\"1\":{\"70\":1}}],[\"writeshort\",{\"1\":{\"244\":3}}],[\"writes\",{\"1\":{\"70\":1}}],[\"writer\",{\"1\":{\"69\":8,\"70\":8,\"539\":1}}],[\"write\",{\"1\":{\"69\":11,\"70\":14,\"391\":1,\"424\":1,\"442\":1,\"521\":1,\"522\":1}}],[\"wvlessws\",{\"1\":{\"69\":3}}],[\"well\",{\"1\":{\"553\":1}}],[\"weakly\",{\"1\":{\"548\":1,\"590\":1}}],[\"weight\",{\"1\":{\"620\":2,\"687\":2}}],[\"weixin\",{\"1\":{\"544\":1,\"685\":1}}],[\"weibo\",{\"1\":{\"70\":2}}],[\"wechat\",{\"1\":{\"70\":2}}],[\"we\",{\"1\":{\"69\":2,\"70\":1,\"553\":1}}],[\"webmvcconfigurer\",{\"1\":{\"318\":1,\"319\":2}}],[\"web配置类\",{\"0\":{\"318\":1}}],[\"webconfiguration\",{\"0\":{\"316\":1}}],[\"web插件\",{\"1\":{\"269\":1}}],[\"website\",{\"1\":{\"69\":1,\"70\":23}}],[\"websocketserver\",{\"1\":{\"69\":8,\"70\":8}}],[\"websocketpair\",{\"1\":{\"69\":3,\"70\":3}}],[\"websocket\",{\"1\":{\"69\":44,\"70\":50}}],[\"web\",{\"1\":{\"33\":1,\"38\":2,\"39\":2,\"60\":1,\"70\":3,\"71\":1,\"272\":5,\"292\":1,\"298\":1}}],[\"web页中包含有其他的web资源\",{\"1\":{\"31\":1}}],[\"wsc\",{\"1\":{\"685\":1}}],[\"ws\",{\"1\":{\"69\":18,\"70\":10}}],[\"where子句中使用最频繁的一列放在最左边\",{\"1\":{\"154\":1}}],[\"where\",{\"1\":{\"112\":1,\"117\":1,\"136\":5,\"152\":1,\"156\":1,\"157\":4,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"184\":1,\"205\":2,\"442\":1}}],[\"when\",{\"1\":{\"69\":3,\"70\":4,\"184\":1,\"553\":2,\"554\":1,\"578\":1}}],[\"who\",{\"1\":{\"71\":1}}],[\"whoer\",{\"1\":{\"62\":1}}],[\"while循环不断地通过gettask\",{\"1\":{\"714\":1}}],[\"while\",{\"1\":{\"203\":1,\"216\":1,\"223\":1,\"230\":2,\"558\":1,\"559\":1,\"581\":1,\"714\":1,\"732\":2}}],[\"white\",{\"1\":{\"70\":1}}],[\"which\",{\"1\":{\"1\":1,\"69\":3,\"70\":2,\"594\":1}}],[\"whatwg\",{\"1\":{\"69\":1,\"70\":1}}],[\"whatismyip\",{\"1\":{\"62\":1}}],[\"whatismyipaddress\",{\"1\":{\"60\":1}}],[\"warrant\",{\"1\":{\"553\":1}}],[\"watch\",{\"1\":{\"408\":2,\"409\":1}}],[\"want\",{\"1\":{\"70\":1}}],[\"was\",{\"1\":{\"69\":1,\"70\":3,\"559\":1}}],[\"wave\",{\"1\":{\"25\":1}}],[\"waitting\",{\"1\":{\"639\":1}}],[\"wait方法\",{\"1\":{\"633\":1,\"701\":1}}],[\"waitstatus有下面几个枚举值\",{\"1\":{\"603\":1}}],[\"waitstatus\",{\"1\":{\"603\":1,\"611\":1}}],[\"wait会太多\",{\"1\":{\"21\":1}}],[\"wait状态\",{\"1\":{\"20\":3}}],[\"wait过多\",{\"1\":{\"20\":1}}],[\"wait连接\",{\"1\":{\"20\":1}}],[\"wait\",{\"0\":{\"18\":1,\"20\":1,\"21\":1,\"632\":1,\"700\":1},\"1\":{\"16\":1,\"20\":2,\"21\":2,\"633\":3,\"639\":2,\"701\":3,\"732\":3}}],[\"www\",{\"1\":{\"25\":2,\"38\":1,\"48\":2,\"55\":1,\"60\":4,\"62\":18,\"65\":1,\"66\":1,\"68\":1,\"69\":1,\"70\":74,\"71\":3,\"144\":2,\"149\":1,\"158\":1,\"311\":2,\"469\":1,\"474\":1,\"483\":3,\"510\":1,\"537\":1,\"544\":3,\"551\":2,\"562\":1,\"599\":2,\"637\":1,\"685\":1,\"708\":1,\"723\":1}}],[\"w\",{\"1\":{\"16\":2,\"714\":1}}],[\"wiki\",{\"1\":{\"553\":1}}],[\"wikipedia\",{\"1\":{\"553\":1}}],[\"widely\",{\"1\":{\"70\":1}}],[\"width\",{\"1\":{\"70\":3,\"71\":1}}],[\"width=device\",{\"1\":{\"70\":1}}],[\"width=\",{\"1\":{\"70\":1}}],[\"win版本\",{\"1\":{\"68\":1}}],[\"win64位\",{\"1\":{\"64\":1}}],[\"win\",{\"1\":{\"64\":1,\"69\":1,\"70\":1}}],[\"win专用ip优选\",{\"1\":{\"60\":1}}],[\"windows启动命令\",{\"1\":{\"251\":1}}],[\"windows\",{\"1\":{\"69\":1,\"70\":2}}],[\"window\",{\"1\":{\"24\":1,\"32\":1}}],[\"withmode\",{\"1\":{\"251\":2}}],[\"without\",{\"1\":{\"69\":1,\"70\":2}}],[\"with\",{\"1\":{\"4\":1,\"5\":1,\"69\":1,\"70\":7,\"117\":1,\"343\":1,\"399\":1,\"553\":3}}],[\"will\",{\"1\":{\"2\":1,\"3\":1,\"69\":8,\"70\":6,\"554\":1,\"578\":1}}],[\"ignoring\",{\"1\":{\"553\":1}}],[\"ignore\",{\"1\":{\"69\":3,\"70\":1}}],[\"illegalmonitorstateexception\",{\"1\":{\"617\":1}}],[\"illegalaccesserror\",{\"1\":{\"534\":1}}],[\"illegalaccessexception\",{\"1\":{\"203\":1,\"223\":1,\"230\":1,\"237\":1}}],[\"ilosz14mra9e\",{\"1\":{\"68\":1}}],[\"i>\",{\"1\":{\"70\":2}}],[\"i++\",{\"1\":{\"69\":1,\"70\":1,\"71\":1,\"202\":1,\"244\":1}}],[\"i\",{\"1\":{\"69\":7,\"70\":7,\"71\":3,\"112\":1,\"132\":1,\"202\":6,\"244\":9,\"388\":4,\"399\":3,\"400\":1,\"401\":7,\"496\":2,\"499\":13,\"506\":3,\"556\":3,\"558\":4,\"564\":3,\"565\":3,\"571\":5,\"581\":4,\"639\":2,\"717\":1}}],[\"ideally\",{\"1\":{\"553\":1}}],[\"ideas\",{\"1\":{\"70\":1}}],[\"id比较小的那个slave\",{\"1\":{\"426\":1}}],[\"id重复会导致数据互相覆盖\",{\"1\":{\"191\":1}}],[\"id是否可以重复\",{\"0\":{\"191\":1}}],[\"idx\",{\"1\":{\"155\":1}}],[\"id=b\",{\"1\":{\"136\":1}}],[\"id=\",{\"1\":{\"71\":1,\"205\":3,\"268\":1,\"277\":1}}],[\"id\",{\"1\":{\"69\":1,\"70\":2,\"112\":8,\"117\":3,\"121\":1,\"126\":1,\"136\":4,\"157\":4,\"159\":3,\"193\":1,\"204\":3,\"205\":7,\"215\":1,\"216\":7,\"223\":2,\"230\":5,\"336\":2,\"420\":1,\"422\":1,\"426\":1,\"506\":3,\"652\":2}}],[\"id将request再归属到各自不同的服务端请求里面\",{\"1\":{\"34\":1}}],[\"ifeve\",{\"1\":{\"548\":1,\"590\":1,\"723\":1}}],[\"ifeng\",{\"1\":{\"70\":2}}],[\"iframe>\",{\"1\":{\"70\":1}}],[\"if\",{\"1\":{\"69\":42,\"70\":41,\"71\":59,\"184\":1,\"196\":4,\"198\":1,\"200\":2,\"201\":1,\"202\":2,\"203\":3,\"204\":3,\"244\":6,\"251\":1,\"316\":1,\"317\":1,\"399\":1,\"499\":2,\"506\":1,\"532\":1,\"554\":1,\"555\":1,\"556\":11,\"558\":2,\"559\":14,\"573\":4,\"578\":1,\"579\":1,\"581\":2,\"605\":2,\"607\":2,\"610\":1,\"611\":2,\"612\":6,\"613\":1,\"616\":5,\"617\":7}}],[\"iyjdv14ueruh\",{\"1\":{\"68\":1}}],[\"iwdrn14wmola\",{\"1\":{\"64\":1}}],[\"icook\",{\"1\":{\"62\":3,\"71\":1}}],[\"io密集型的话\",{\"1\":{\"718\":1}}],[\"io密集型\",{\"1\":{\"675\":2}}],[\"io都有哪些设计模式\",{\"0\":{\"543\":1},\"1\":{\"484\":1}}],[\"io多路复用是\",{\"1\":{\"403\":1}}],[\"ioc容器支持勤性单例及延迟加载服务\",{\"1\":{\"270\":1}}],[\"ioc或依赖注入减少了应用程序的代码量\",{\"1\":{\"270\":1}}],[\"ioc就是控制反转\",{\"1\":{\"270\":1}}],[\"ioc\",{\"0\":{\"264\":1},\"1\":{\"265\":1,\"272\":1,\"310\":2}}],[\"ioclient\",{\"1\":{\"223\":2}}],[\"ioexception\",{\"1\":{\"195\":1,\"216\":3,\"223\":3,\"230\":3,\"237\":1,\"244\":2,\"251\":1,\"521\":2,\"522\":4}}],[\"io线程\",{\"1\":{\"132\":1}}],[\"io代价高\",{\"1\":{\"80\":1,\"150\":1}}],[\"io复杂度高\",{\"1\":{\"80\":1,\"150\":1}}],[\"io\",{\"0\":{\"538\":1},\"1\":{\"57\":10,\"69\":1,\"70\":2,\"71\":4,\"242\":1,\"244\":1,\"343\":2,\"378\":1,\"401\":1,\"402\":2,\"403\":8,\"404\":5,\"435\":1,\"484\":1,\"521\":2,\"531\":1,\"618\":3,\"622\":4,\"675\":1,\"689\":4,\"716\":1,\"718\":1}}],[\"immutable\",{\"1\":{\"490\":1}}],[\"imgotv\",{\"1\":{\"70\":1}}],[\"imgo\",{\"1\":{\"70\":1}}],[\"img\",{\"1\":{\"70\":1}}],[\"implements\",{\"1\":{\"196\":1,\"197\":1,\"198\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"216\":2,\"223\":3,\"230\":5,\"237\":3,\"244\":2,\"251\":2,\"258\":2,\"317\":1,\"318\":1,\"521\":1,\"522\":1,\"586\":1,\"587\":1,\"594\":1,\"638\":1,\"714\":1}}],[\"implement\",{\"1\":{\"69\":1,\"70\":3}}],[\"import\",{\"1\":{\"69\":13,\"70\":13,\"443\":1,\"521\":1}}],[\"image\",{\"1\":{\"32\":2,\"70\":5}}],[\"imageslr\",{\"1\":{\"25\":1}}],[\"im\",{\"1\":{\"16\":1}}],[\"ipaddress\",{\"1\":{\"71\":2}}],[\"ipaddressindex\",{\"1\":{\"71\":2}}],[\"ip地址在\",{\"1\":{\"71\":1}}],[\"ipinfo\",{\"1\":{\"71\":5}}],[\"iptest测速结果文件\",{\"1\":{\"71\":1}}],[\"ipfs\",{\"1\":{\"70\":4}}],[\"ipv6优选内容格式\",{\"1\":{\"71\":1}}],[\"ipv6\",{\"1\":{\"69\":5,\"70\":7}}],[\"ipv4\",{\"1\":{\"20\":3,\"69\":1,\"70\":1}}],[\"ip跳动问题\",{\"1\":{\"63\":1}}],[\"ipget\",{\"1\":{\"62\":1}}],[\"ip优选\",{\"1\":{\"60\":1,\"63\":1}}],[\"ip查看\",{\"1\":{\"60\":1}}],[\"ipdb\",{\"1\":{\"58\":1}}],[\"ip落地区域\",{\"1\":{\"57\":7}}],[\"ip\",{\"1\":{\"14\":3,\"38\":2,\"42\":3,\"61\":1,\"62\":1,\"64\":1,\"69\":3,\"70\":3,\"71\":6}}],[\"ip电话\",{\"1\":{\"9\":1}}],[\"ip参考模型没有真正描述这一层的实现\",{\"1\":{\"8\":1}}],[\"ip只有最上面三层\",{\"1\":{\"8\":1}}],[\"ip四层模型\",{\"1\":{\"8\":1}}],[\"ip四层模型和五层模型\",{\"1\":{\"8\":1}}],[\"its\",{\"1\":{\"554\":2,\"578\":2}}],[\"itwanger\",{\"1\":{\"474\":1}}],[\"ite1\",{\"1\":{\"506\":3}}],[\"ite\",{\"1\":{\"506\":3}}],[\"iterator无法获取集合中元素的索引\",{\"1\":{\"597\":1}}],[\"iterator无法修改集合中的元素\",{\"1\":{\"597\":1}}],[\"iterator无法向集合中添加元素\",{\"1\":{\"597\":1}}],[\"iterator\",{\"0\":{\"597\":1},\"1\":{\"204\":4,\"506\":3,\"574\":1}}],[\"item\",{\"1\":{\"71\":6}}],[\"ityouknow\",{\"1\":{\"48\":1,\"311\":1}}],[\"it\",{\"1\":{\"3\":1,\"4\":1,\"69\":2,\"70\":6,\"399\":2}}],[\"inner\",{\"1\":{\"277\":1}}],[\"innodb的聚簇索引其实就是在同一个结构中保存了b\",{\"1\":{\"148\":1}}],[\"innodb数据表上的索引是表空间的一个组成部分\",{\"1\":{\"146\":1}}],[\"innodb是基于索引来完成行锁\",{\"1\":{\"117\":1}}],[\"innodb实现了行级锁\",{\"1\":{\"115\":1}}],[\"innodb引擎的行锁是怎么实现的\",{\"0\":{\"117\":1}}],[\"innodb引擎\",{\"1\":{\"114\":1}}],[\"innodb\",{\"0\":{\"83\":1},\"1\":{\"83\":1,\"92\":10,\"102\":1,\"105\":1,\"107\":1,\"112\":3,\"151\":1}}],[\"innodb不支持全文索引\",{\"1\":{\"73\":1}}],[\"innodb支持外键\",{\"1\":{\"73\":1}}],[\"innodb支持mvcc\",{\"1\":{\"73\":1}}],[\"innodb支持行级锁\",{\"1\":{\"73\":1,\"114\":1}}],[\"innodb支持事物\",{\"1\":{\"73\":1}}],[\"injection\",{\"1\":{\"270\":1}}],[\"inetsocketaddress\",{\"1\":{\"251\":9}}],[\"in要快\",{\"1\":{\"96\":1}}],[\"init\",{\"1\":{\"506\":1}}],[\"initchannel\",{\"1\":{\"237\":1,\"245\":1}}],[\"initconnection中\",{\"1\":{\"198\":1}}],[\"initconnection\",{\"1\":{\"198\":2}}],[\"initializes\",{\"1\":{\"521\":1}}],[\"initializebean\",{\"1\":{\"281\":1}}],[\"initial\",{\"1\":{\"70\":1,\"554\":2,\"559\":5,\"578\":2}}],[\"ini\",{\"1\":{\"71\":1}}],[\"invocation\",{\"1\":{\"519\":1}}],[\"invocationtargetexception\",{\"1\":{\"223\":1,\"230\":1,\"237\":1,\"507\":1}}],[\"invocationhandler\",{\"1\":{\"200\":1,\"223\":1,\"284\":1}}],[\"invoke之后\",{\"1\":{\"507\":1}}],[\"invoke\",{\"1\":{\"200\":2,\"223\":4,\"230\":3,\"237\":3,\"505\":4,\"506\":1,\"507\":3}}],[\"investors\",{\"1\":{\"70\":1}}],[\"invalid\",{\"1\":{\"69\":3,\"70\":4}}],[\"inf\",{\"1\":{\"308\":1}}],[\"infile\",{\"1\":{\"108\":1}}],[\"infrastructure\",{\"1\":{\"70\":1}}],[\"infoq\",{\"1\":{\"618\":1}}],[\"information\",{\"1\":{\"70\":7,\"159\":2}}],[\"info\",{\"1\":{\"62\":2,\"65\":1,\"69\":3,\"70\":4,\"425\":2,\"435\":1,\"506\":2}}],[\"ins\",{\"1\":{\"506\":2}}],[\"insync\",{\"1\":{\"334\":1}}],[\"insertuserid\",{\"1\":{\"223\":3}}],[\"insert标签\",{\"1\":{\"199\":1}}],[\"insert\",{\"1\":{\"104\":1,\"108\":1,\"112\":1,\"197\":2,\"200\":1,\"204\":3,\"493\":1}}],[\"insert=false\",{\"1\":{\"70\":1,\"71\":2}}],[\"inside\",{\"1\":{\"70\":1}}],[\"instance\",{\"1\":{\"399\":1,\"425\":1}}],[\"instanceof\",{\"1\":{\"244\":2,\"555\":1,\"556\":1,\"559\":1,\"579\":1}}],[\"instantiationerror\",{\"1\":{\"534\":1}}],[\"instantiationexception\",{\"1\":{\"203\":1,\"534\":1}}],[\"instant\",{\"1\":{\"70\":1}}],[\"installed\",{\"1\":{\"71\":1}}],[\"install\",{\"1\":{\"70\":3}}],[\"instead\",{\"1\":{\"70\":1}}],[\"including\",{\"1\":{\"554\":1,\"578\":1}}],[\"includes\",{\"1\":{\"69\":4,\"70\":5,\"71\":32}}],[\"increase\",{\"1\":{\"554\":1,\"578\":1}}],[\"increments\",{\"1\":{\"573\":1}}],[\"increment\",{\"1\":{\"159\":1}}],[\"incompatible\",{\"1\":{\"514\":1}}],[\"incoming\",{\"1\":{\"69\":2,\"70\":3}}],[\"introspector\",{\"1\":{\"506\":1}}],[\"int的默认值是0\",{\"1\":{\"495\":1}}],[\"int是直接存储数据值\",{\"1\":{\"495\":1}}],[\"int是基本数据类型\",{\"1\":{\"495\":1}}],[\"int变量不需要\",{\"1\":{\"495\":1}}],[\"integer等等\",{\"1\":{\"514\":1}}],[\"integercachehighpropvalue\",{\"1\":{\"499\":3}}],[\"integercache是integer的内部类\",{\"1\":{\"499\":1}}],[\"integercache\",{\"1\":{\"499\":9}}],[\"integer对象\",{\"1\":{\"499\":1}}],[\"integer的默认值是null\",{\"1\":{\"495\":1}}],[\"integer实际是对象的引用\",{\"1\":{\"495\":1}}],[\"integer变量和int变量比较时\",{\"1\":{\"497\":1}}],[\"integer变量和int变量的对比\",{\"0\":{\"497\":1},\"1\":{\"484\":1}}],[\"integer变量必须实例化后才能使用\",{\"1\":{\"495\":1}}],[\"integer是int的包装类\",{\"1\":{\"495\":1}}],[\"integer及其它包装类\",{\"1\":{\"472\":1}}],[\"integer\",{\"0\":{\"495\":1,\"498\":1},\"1\":{\"203\":2,\"205\":3,\"215\":1,\"216\":4,\"223\":5,\"230\":4,\"237\":1,\"251\":1,\"484\":2,\"493\":3,\"494\":4,\"496\":4,\"497\":3,\"498\":5,\"499\":16,\"510\":1,\"516\":1,\"558\":1,\"559\":2,\"581\":1,\"673\":2}}],[\"intellectual\",{\"1\":{\"70\":1}}],[\"interruptidleworkers方法会使用trylock方法来判断线程池中的线程是否是空闲状态\",{\"1\":{\"714\":1}}],[\"interrupted\",{\"1\":{\"612\":3}}],[\"interruptedexception\",{\"1\":{\"237\":2}}],[\"intern的处理是\",{\"1\":{\"488\":2}}],[\"intern函数的作用是将对应的符号常量进入特殊处理\",{\"1\":{\"488\":1}}],[\"intern\",{\"1\":{\"488\":6}}],[\"internet\",{\"1\":{\"70\":3}}],[\"interceptorregistry\",{\"1\":{\"318\":1}}],[\"interceptor\",{\"1\":{\"315\":3}}],[\"interceptors\",{\"1\":{\"291\":1}}],[\"interfaces\",{\"1\":{\"230\":2,\"251\":2}}],[\"interfaceprovider\",{\"1\":{\"230\":4,\"251\":4}}],[\"interfacename\",{\"1\":{\"223\":2,\"230\":4,\"237\":2,\"251\":2}}],[\"interface\",{\"1\":{\"196\":1,\"197\":1,\"198\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"216\":1,\"223\":1,\"230\":2,\"237\":1,\"244\":1,\"251\":1,\"258\":1}}],[\"interval\",{\"1\":{\"71\":3}}],[\"interview\",{\"1\":{\"48\":1,\"90\":1,\"110\":2,\"144\":2,\"146\":1,\"311\":1,\"685\":1}}],[\"interactive\",{\"1\":{\"70\":1}}],[\"into\",{\"1\":{\"69\":1,\"70\":3,\"554\":1,\"578\":1}}],[\"int\",{\"0\":{\"495\":1},\"1\":{\"69\":1,\"70\":1,\"71\":1,\"159\":1,\"202\":1,\"205\":1,\"223\":3,\"230\":5,\"237\":4,\"244\":9,\"251\":3,\"258\":2,\"449\":2,\"450\":1,\"467\":5,\"484\":1,\"489\":1,\"493\":3,\"497\":1,\"499\":8,\"505\":5,\"506\":1,\"521\":1,\"522\":1,\"527\":1,\"536\":4,\"554\":3,\"555\":13,\"556\":6,\"558\":6,\"559\":6,\"571\":2,\"573\":7,\"578\":3,\"579\":8,\"581\":6,\"586\":1,\"604\":5,\"605\":3,\"610\":2,\"611\":3,\"612\":10,\"613\":2,\"616\":4,\"617\":6,\"678\":4,\"681\":1,\"684\":1}}],[\"inputstreamreader\",{\"1\":{\"540\":1,\"543\":1}}],[\"inputstream\",{\"1\":{\"195\":3,\"506\":1,\"539\":2,\"540\":1,\"543\":2}}],[\"input\",{\"1\":{\"69\":1,\"70\":1}}],[\"indexfor\",{\"1\":{\"555\":1,\"558\":1,\"579\":1,\"581\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"531\":1,\"534\":1}}],[\"indexof\",{\"1\":{\"71\":1}}],[\"index命令创建\",{\"1\":{\"159\":1}}],[\"index2\",{\"1\":{\"159\":1}}],[\"index全文索引\",{\"1\":{\"79\":1,\"148\":1}}],[\"index\",{\"1\":{\"5\":1,\"59\":1,\"63\":1,\"69\":8,\"70\":8,\"117\":1,\"141\":1,\"155\":1,\"156\":1,\"157\":4,\"159\":4,\"162\":1,\"343\":1,\"556\":1,\"571\":2}}],[\"in\",{\"0\":{\"96\":1,\"170\":1},\"1\":{\"2\":2,\"3\":1,\"69\":6,\"70\":10,\"96\":2,\"136\":1,\"150\":1,\"244\":5,\"338\":1,\"377\":1,\"426\":1,\"522\":2,\"544\":1,\"553\":3,\"554\":2,\"559\":1,\"578\":2,\"675\":1,\"723\":1}}],[\"isheldexclusively\",{\"1\":{\"678\":1}}],[\"isshutdown\",{\"0\":{\"631\":1,\"699\":1},\"1\":{\"631\":1,\"699\":1}}],[\"issue\",{\"1\":{\"69\":1,\"70\":1}}],[\"isterminated\",{\"0\":{\"631\":1,\"699\":1},\"1\":{\"631\":1,\"699\":1}}],[\"isr是由leader维护\",{\"1\":{\"338\":1}}],[\"isr\",{\"1\":{\"338\":1}}],[\"isr的伸缩指什么\",{\"0\":{\"338\":1}}],[\"isempty\",{\"1\":{\"204\":2,\"313\":2}}],[\"isarray\",{\"1\":{\"202\":3}}],[\"isassignablefrom\",{\"1\":{\"200\":1,\"244\":2}}],[\"isnotempty\",{\"1\":{\"196\":1,\"197\":1,\"201\":1,\"204\":4,\"313\":4}}],[\"isdir\",{\"1\":{\"196\":1}}],[\"isdirectory\",{\"1\":{\"196\":2}}],[\"isdns\",{\"1\":{\"69\":4,\"70\":4}}],[\"isวเลสheadersent\",{\"1\":{\"70\":3}}],[\"isvlessheadersent\",{\"1\":{\"69\":3}}],[\"isvaliduser\",{\"1\":{\"69\":3,\"70\":4}}],[\"isvaliduuid\",{\"1\":{\"69\":3,\"70\":3}}],[\"isuuidinresponse\",{\"1\":{\"69\":2}}],[\"isudp\",{\"1\":{\"69\":6,\"70\":9}}],[\"is\",{\"1\":{\"1\":1,\"62\":1,\"69\":29,\"70\":27,\"71\":3,\"201\":1,\"204\":2,\"277\":1,\"313\":3,\"399\":1,\"426\":1,\"499\":1,\"554\":1,\"578\":1,\"720\":1}}],[\"cyclic\",{\"1\":{\"681\":1}}],[\"cyclicbarrier默认的构造方法是\",{\"1\":{\"681\":1}}],[\"cyclicbarrier\",{\"1\":{\"680\":1,\"681\":5,\"736\":1}}],[\"cyou\",{\"1\":{\"69\":1,\"70\":1}}],[\"c2\",{\"1\":{\"516\":2}}],[\"c2c\",{\"1\":{\"70\":1}}],[\"c1\",{\"1\":{\"516\":2}}],[\"c=10000\",{\"1\":{\"497\":1,\"498\":1}}],[\"c++中的指针类型\",{\"1\":{\"449\":1}}],[\"c++\",{\"1\":{\"442\":1,\"443\":11}}],[\"cglib\",{\"1\":{\"284\":4}}],[\"cglib动态代理\",{\"1\":{\"284\":1}}],[\"cj\",{\"1\":{\"205\":1}}],[\"city\",{\"1\":{\"71\":1}}],[\"city==\",{\"1\":{\"52\":1}}],[\"ctrl+z\",{\"1\":{\"729\":1}}],[\"ctrl+c\",{\"1\":{\"729\":1}}],[\"ctrip\",{\"1\":{\"70\":2}}],[\"ctl这个atomicinteger类型\",{\"1\":{\"712\":1}}],[\"ctlof\",{\"1\":{\"712\":1}}],[\"ctl\",{\"1\":{\"712\":1}}],[\"ctx\",{\"1\":{\"69\":2,\"70\":2,\"237\":10,\"244\":2}}],[\"cctv\",{\"1\":{\"70\":1}}],[\"cc\",{\"1\":{\"70\":2,\"71\":1}}],[\"central\",{\"1\":{\"70\":1}}],[\"center\",{\"1\":{\"70\":1}}],[\"celebrity\",{\"1\":{\"70\":1}}],[\"certification\",{\"1\":{\"37\":1}}],[\"curatorframeworkfactory\",{\"1\":{\"251\":1}}],[\"curatorframework\",{\"1\":{\"251\":1}}],[\"curator\",{\"1\":{\"251\":1}}],[\"curator<\",{\"1\":{\"251\":1}}],[\"current\",{\"1\":{\"616\":3,\"617\":4}}],[\"currentthread\",{\"1\":{\"506\":1,\"605\":1,\"607\":1,\"616\":2,\"617\":2,\"621\":2,\"688\":2}}],[\"currentfile\",{\"1\":{\"196\":1}}],[\"currentdate\",{\"1\":{\"70\":6}}],[\"custom\",{\"1\":{\"61\":1}}],[\"customization\",{\"0\":{\"5\":1}}],[\"c55a\",{\"1\":{\"70\":1}}],[\"chenssy\",{\"1\":{\"562\":1}}],[\"chenshuyi\",{\"1\":{\"505\":1}}],[\"chenliguan\",{\"1\":{\"544\":1}}],[\"checkcast\",{\"1\":{\"511\":1}}],[\"checkexists\",{\"1\":{\"251\":1}}],[\"checkuuidinapi\",{\"1\":{\"69\":2}}],[\"checkuuidinapiresponse\",{\"1\":{\"69\":3}}],[\"checks\",{\"1\":{\"69\":1,\"70\":1}}],[\"check\",{\"1\":{\"5\":1,\"69\":3,\"70\":4,\"87\":1,\"94\":1,\"407\":1,\"409\":1}}],[\"ch\",{\"1\":{\"237\":2,\"245\":2}}],[\"childhandler\",{\"1\":{\"237\":1}}],[\"chinese\",{\"1\":{\"70\":52}}],[\"china\",{\"1\":{\"70\":9}}],[\"choose++\",{\"1\":{\"258\":1}}],[\"choose\",{\"1\":{\"184\":1,\"258\":7}}],[\"chrome\",{\"1\":{\"71\":1}}],[\"changemap\",{\"1\":{\"560\":4}}],[\"channelhandlercontext\",{\"1\":{\"237\":4,\"244\":2}}],[\"channelread0\",{\"1\":{\"237\":2}}],[\"channelpipeline\",{\"1\":{\"237\":1,\"245\":1}}],[\"channelinitializer<socketchannel>\",{\"1\":{\"237\":1,\"245\":1}}],[\"channelfuture\",{\"1\":{\"237\":6}}],[\"channel\",{\"1\":{\"237\":11,\"357\":1,\"358\":1}}],[\"chat\",{\"1\":{\"71\":1}}],[\"chatid\",{\"1\":{\"71\":5}}],[\"character\",{\"1\":{\"493\":1}}],[\"characterencoding=utf8\",{\"1\":{\"205\":1}}],[\"charat\",{\"1\":{\"71\":2}}],[\"charset\",{\"1\":{\"204\":2}}],[\"charset=utf\",{\"1\":{\"69\":2,\"70\":3,\"71\":8}}],[\"char\",{\"0\":{\"95\":1},\"1\":{\"95\":4,\"449\":4,\"450\":1,\"481\":2,\"486\":1,\"489\":1,\"493\":1}}],[\"charitable\",{\"1\":{\"70\":1}}],[\"charcodeat\",{\"1\":{\"69\":1,\"70\":1}}],[\"chunks\",{\"1\":{\"69\":1,\"70\":1}}],[\"chunk\",{\"1\":{\"69\":19,\"70\":23}}],[\"c\",{\"1\":{\"58\":1,\"69\":2,\"70\":2,\"84\":2,\"154\":5,\"161\":5,\"346\":1,\"349\":1,\"352\":1,\"443\":4,\"483\":1,\"497\":1,\"498\":1,\"616\":3,\"617\":6}}],[\"cmsblogs\",{\"1\":{\"618\":1}}],[\"cmproxyips\",{\"1\":{\"71\":3}}],[\"cmliu\",{\"1\":{\"71\":13}}],[\"cmd\",{\"1\":{\"69\":1,\"70\":1,\"251\":1}}],[\"cm大佬\",{\"1\":{\"57\":2}}],[\"cm\",{\"1\":{\"57\":1}}],[\"cdnjs\",{\"1\":{\"70\":1}}],[\"cdn\",{\"0\":{\"56\":1},\"1\":{\"58\":1,\"61\":4,\"62\":2,\"70\":3}}],[\"cfg中的ticktime\",{\"1\":{\"251\":1}}],[\"cfg\",{\"1\":{\"251\":1}}],[\"cfgo\",{\"1\":{\"71\":1}}],[\"cfcdnvmess2sub\",{\"1\":{\"71\":2}}],[\"cf`\",{\"1\":{\"70\":1}}],[\"cfip\",{\"1\":{\"58\":1}}],[\"cf\",{\"0\":{\"56\":1},\"1\":{\"57\":1,\"58\":2,\"60\":1,\"69\":15,\"70\":8,\"71\":3}}],[\"craig\",{\"1\":{\"602\":1}}],[\"credentials\",{\"1\":{\"317\":1}}],[\"creatingparentsifneeded\",{\"1\":{\"251\":2}}],[\"creating\",{\"1\":{\"70\":1}}],[\"createbeaninstance实例化\",{\"1\":{\"281\":1}}],[\"createbeaninstance\",{\"1\":{\"281\":1}}],[\"createmode\",{\"1\":{\"251\":2}}],[\"creates\",{\"1\":{\"70\":1}}],[\"create\",{\"1\":{\"4\":1,\"70\":2,\"108\":1,\"155\":1,\"159\":2,\"161\":1,\"166\":1,\"251\":2}}],[\"crud方法\",{\"1\":{\"197\":1}}],[\"crud比较慢\",{\"1\":{\"142\":1}}],[\"crud\",{\"1\":{\"124\":1}}],[\"crypto\",{\"1\":{\"70\":1}}],[\"crossoverjie\",{\"1\":{\"737\":1}}],[\"cross\",{\"1\":{\"44\":1}}],[\"calculate\",{\"1\":{\"723\":1}}],[\"calculatecapacity\",{\"1\":{\"573\":2}}],[\"callerrunspolicy\",{\"1\":{\"670\":1}}],[\"called\",{\"1\":{\"69\":1}}],[\"call方法可以抛出异常\",{\"1\":{\"621\":1,\"688\":1}}],[\"callable仅在\",{\"1\":{\"629\":1,\"696\":1}}],[\"callable\",{\"0\":{\"629\":1,\"696\":1},\"1\":{\"629\":4,\"696\":4}}],[\"callable的任务执行后可返回值\",{\"1\":{\"621\":1,\"688\":1}}],[\"callable规定\",{\"1\":{\"621\":1,\"688\":1}}],[\"callable接口的方式创建多线程\",{\"1\":{\"621\":1,\"688\":1}}],[\"call\",{\"1\":{\"69\":1,\"640\":1}}],[\"cap\",{\"1\":{\"555\":3}}],[\"capacity\",{\"1\":{\"554\":2,\"555\":2,\"556\":2,\"558\":1,\"559\":8,\"573\":1,\"578\":2,\"581\":1,\"721\":2}}],[\"caculate<t\",{\"1\":{\"511\":1}}],[\"caculate<t>\",{\"1\":{\"511\":1}}],[\"caculate\",{\"1\":{\"511\":5}}],[\"cachedthreadpool\",{\"1\":{\"673\":5}}],[\"cache命中率会下降\",{\"1\":{\"548\":1}}],[\"cache数组里面的元素却不是static\",{\"1\":{\"499\":1}}],[\"cache数组对象会被存储于静态常量池中\",{\"1\":{\"499\":1}}],[\"cache\",{\"1\":{\"329\":2,\"499\":5}}],[\"caching\",{\"1\":{\"69\":1,\"70\":1}}],[\"cause\",{\"1\":{\"237\":4}}],[\"card\",{\"1\":{\"70\":1,\"159\":2}}],[\"cas和\",{\"1\":{\"684\":1}}],[\"cas思想体现\",{\"1\":{\"645\":1}}],[\"cas有什么缺陷\",{\"0\":{\"645\":1}}],[\"cas是一种系统原语\",{\"1\":{\"644\":1}}],[\"cas了解吗\",{\"0\":{\"644\":1}}],[\"cas操作\",{\"1\":{\"616\":1}}],[\"cas失败\",{\"1\":{\"616\":1}}],[\"cas\",{\"1\":{\"409\":1,\"546\":1,\"547\":1,\"617\":1,\"644\":8,\"645\":2,\"683\":1}}],[\"casue\",{\"1\":{\"69\":1,\"70\":1}}],[\"case\",{\"1\":{\"69\":6,\"70\":8,\"200\":2,\"244\":4}}],[\"catch\",{\"0\":{\"535\":1,\"536\":2},\"1\":{\"69\":8,\"70\":8,\"71\":6,\"195\":1,\"198\":3,\"202\":1,\"203\":4,\"204\":1,\"216\":3,\"223\":3,\"230\":4,\"237\":4,\"244\":2,\"251\":3,\"454\":1,\"484\":3,\"506\":1,\"507\":1,\"521\":2,\"522\":2,\"530\":2,\"532\":1,\"533\":1,\"535\":1,\"536\":2,\"684\":1}}],[\"ca\",{\"1\":{\"37\":1}}],[\"cancelacquire\",{\"1\":{\"612\":1}}],[\"cancelled\",{\"1\":{\"603\":1}}],[\"canceled\",{\"1\":{\"69\":1,\"70\":1}}],[\"cancel\",{\"1\":{\"69\":5,\"70\":1}}],[\"can\",{\"1\":{\"2\":1,\"3\":1,\"4\":3,\"5\":1,\"69\":3,\"70\":4,\"399\":1}}],[\"csv文件缺少必需的字段\",{\"1\":{\"71\":1}}],[\"csvurl\",{\"1\":{\"71\":2}}],[\"csv\",{\"1\":{\"71\":3}}],[\"css\",{\"1\":{\"70\":3,\"318\":1}}],[\"css文件等\",{\"1\":{\"31\":1}}],[\"csgo\",{\"1\":{\"62\":1}}],[\"csdn\",{\"1\":{\"25\":1,\"70\":2,\"144\":2,\"483\":1,\"544\":3,\"599\":1,\"618\":1,\"685\":2,\"723\":1}}],[\"cpu要读\",{\"1\":{\"717\":1}}],[\"cpu核数\",{\"1\":{\"675\":2,\"717\":1}}],[\"cpu一直全速运行\",{\"1\":{\"675\":1}}],[\"cpu密集任务只有在真正的多核cpu上才能得到加速\",{\"1\":{\"675\":1}}],[\"cpu密集的意思是该任务需要最大的运算\",{\"1\":{\"675\":1}}],[\"cpu密集型也叫计算密集型\",{\"1\":{\"717\":1}}],[\"cpu密集型\",{\"1\":{\"675\":1,\"717\":1}}],[\"cpu为主要瓶颈\",{\"1\":{\"414\":1}}],[\"cpu友好\",{\"1\":{\"386\":1}}],[\"cpu\",{\"1\":{\"14\":1,\"141\":3,\"386\":2,\"399\":4,\"401\":3,\"548\":1,\"564\":1,\"622\":10,\"639\":3,\"644\":2,\"646\":1,\"689\":10,\"716\":1,\"717\":4,\"718\":1}}],[\"cltr+c\",{\"1\":{\"731\":1}}],[\"clh\",{\"1\":{\"602\":1}}],[\"cls\",{\"1\":{\"506\":2}}],[\"clsss\",{\"1\":{\"193\":1}}],[\"clz\",{\"1\":{\"503\":3,\"505\":7}}],[\"cluster模式\",{\"1\":{\"439\":1}}],[\"cluster节点间采取gossip协议进行通信\",{\"1\":{\"430\":1}}],[\"cluster节点间通信是什么机制\",{\"0\":{\"430\":1}}],[\"cluster移动hash\",{\"1\":{\"429\":1}}],[\"cluster中每个master都会持有部分slot\",{\"1\":{\"429\":1}}],[\"cluster中是如何实现数据分布的\",{\"0\":{\"429\":1}}],[\"cluster有固定的16384个hash\",{\"1\":{\"429\":1}}],[\"cluster不建议使用pipeline和multi\",{\"1\":{\"417\":1}}],[\"cluster采用虚拟槽分区\",{\"1\":{\"417\":1}}],[\"cluster集群节点最小配置6个节点以上\",{\"1\":{\"417\":1}}],[\"cluster集群部署能力\",{\"1\":{\"378\":1}}],[\"cluster能起到很好的负载均衡的目的\",{\"1\":{\"417\":1}}],[\"cluster是社区版推出的redis分布式集群解决方案\",{\"1\":{\"417\":1}}],[\"cluster可缓存的数据容量\",{\"1\":{\"413\":1}}],[\"cluster\",{\"0\":{\"417\":1},\"1\":{\"413\":3,\"417\":1,\"439\":1}}],[\"claims\",{\"1\":{\"316\":3}}],[\"clazz\",{\"1\":{\"223\":3,\"230\":2,\"251\":3,\"507\":1}}],[\"classcastexception\",{\"1\":{\"510\":2,\"531\":1,\"534\":1}}],[\"classloader\",{\"1\":{\"506\":3,\"507\":3,\"533\":3}}],[\"class文件常量池\",{\"1\":{\"487\":1}}],[\"class文件\",{\"1\":{\"445\":1}}],[\"classname\",{\"1\":{\"237\":2}}],[\"classnotfoundexception\",{\"0\":{\"533\":1},\"1\":{\"198\":1,\"203\":1,\"216\":1,\"223\":2,\"230\":1,\"237\":2,\"244\":1,\"251\":1,\"484\":1,\"521\":1,\"522\":2,\"531\":1,\"533\":1,\"534\":1}}],[\"classresolver\",{\"1\":{\"237\":1}}],[\"class作为key\",{\"1\":{\"200\":1}}],[\"class调用就是类路径\",{\"1\":{\"195\":1}}],[\"classes\",{\"1\":{\"195\":1}}],[\"class<t>\",{\"1\":{\"194\":2,\"197\":2,\"200\":6,\"223\":1}}],[\"class<\",{\"1\":{\"194\":1,\"200\":1,\"203\":3,\"223\":1,\"230\":1,\"237\":1,\"244\":2,\"251\":1}}],[\"class\",{\"1\":{\"193\":3,\"194\":4,\"195\":3,\"196\":2,\"197\":1,\"198\":2,\"199\":1,\"200\":11,\"201\":1,\"202\":1,\"203\":5,\"204\":3,\"205\":1,\"216\":4,\"223\":8,\"230\":9,\"231\":1,\"237\":10,\"244\":6,\"245\":1,\"251\":4,\"258\":2,\"268\":1,\"277\":2,\"283\":1,\"306\":1,\"313\":1,\"314\":2,\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"493\":1,\"494\":2,\"499\":1,\"502\":1,\"503\":9,\"504\":1,\"505\":10,\"506\":6,\"507\":3,\"511\":4,\"516\":4,\"521\":2,\"522\":2,\"533\":1,\"554\":1,\"578\":1,\"586\":1,\"587\":1,\"594\":1,\"605\":1,\"616\":1,\"638\":2,\"649\":2,\"684\":1,\"714\":1}}],[\"classified\",{\"1\":{\"70\":1}}],[\"class=\",{\"1\":{\"70\":2,\"268\":1,\"277\":2}}],[\"clash\",{\"1\":{\"68\":7,\"70\":4,\"71\":3}}],[\"cleartimeout\",{\"1\":{\"71\":1}}],[\"clipboard\",{\"1\":{\"70\":5}}],[\"client通过获取所有能获取的锁后的时间减去第一步的时间\",{\"1\":{\"437\":1}}],[\"client尝试按照顺序使用相同的key\",{\"1\":{\"437\":1}}],[\"client实现复杂\",{\"1\":{\"417\":1}}],[\"client得到消息并做完业务逻辑\",{\"1\":{\"360\":1}}],[\"client收到ack消息后\",{\"1\":{\"359\":1}}],[\"client发送ack消息给mq\",{\"1\":{\"360\":1}}],[\"client发送消息给mq\",{\"1\":{\"359\":1}}],[\"client发送应该是需要调用的service接口名\",{\"1\":{\"223\":1}}],[\"client不需要传入host与name\",{\"1\":{\"251\":1}}],[\"clienthandler设计\",{\"1\":{\"237\":1}}],[\"clientproxy\",{\"1\":{\"223\":5}}],[\"client\",{\"1\":{\"4\":2,\"69\":9,\"70\":6,\"124\":1,\"126\":1,\"210\":1,\"251\":7,\"258\":1,\"417\":1,\"436\":2}}],[\"closing\",{\"1\":{\"69\":2,\"70\":2}}],[\"closefuture\",{\"1\":{\"237\":2}}],[\"closes\",{\"1\":{\"70\":1}}],[\"close`\",{\"1\":{\"69\":1,\"70\":1}}],[\"close\",{\"1\":{\"69\":22,\"70\":12,\"177\":1,\"237\":4,\"244\":4,\"506\":1}}],[\"closed\",{\"1\":{\"12\":1,\"16\":2,\"69\":4,\"70\":3}}],[\"cloudflarest\",{\"1\":{\"64\":2}}],[\"cloudflare颁发证书网站\",{\"1\":{\"61\":1}}],[\"cloudflareyes\",{\"1\":{\"60\":1}}],[\"cloudflare网站链接>>\",{\"1\":{\"60\":1}}],[\"cloudflare\",{\"0\":{\"744\":1},\"1\":{\"52\":3,\"54\":1,\"65\":2,\"69\":17,\"70\":23,\"71\":1}}],[\"cloud\",{\"0\":{\"310\":1},\"1\":{\"25\":1,\"70\":2,\"310\":5,\"438\":1}}],[\"cn`\",{\"1\":{\"71\":1}}],[\"cntv\",{\"1\":{\"70\":1}}],[\"cnzz\",{\"1\":{\"70\":2}}],[\"cnki\",{\"1\":{\"70\":2}}],[\"cnblogs\",{\"1\":{\"25\":1,\"48\":1,\"70\":2,\"311\":1,\"469\":1,\"483\":1,\"510\":1,\"537\":1,\"544\":2,\"551\":1,\"562\":1,\"599\":1,\"685\":1,\"723\":1}}],[\"cn\",{\"1\":{\"11\":1,\"25\":1,\"32\":1,\"48\":3,\"69\":3,\"70\":14,\"311\":1,\"374\":1,\"461\":1,\"526\":1,\"544\":5,\"567\":3,\"599\":1,\"618\":1,\"685\":1}}],[\"cost\",{\"1\":{\"554\":1,\"578\":1}}],[\"costs\",{\"1\":{\"554\":1,\"578\":1}}],[\"cosen\",{\"1\":{\"521\":3,\"522\":2}}],[\"corsregistry\",{\"1\":{\"319\":1}}],[\"corsconfigurer\",{\"1\":{\"319\":1}}],[\"core参数为true表示在新增线程时会判断当前活动线程数是否少于corepoolsize\",{\"1\":{\"714\":1}}],[\"core\",{\"1\":{\"304\":1,\"714\":1,\"729\":3}}],[\"corepoolsize\",{\"1\":{\"230\":2,\"670\":2,\"713\":3,\"717\":1,\"720\":1}}],[\"cobar\",{\"0\":{\"123\":1},\"1\":{\"122\":1,\"127\":1}}],[\"counstraint\",{\"1\":{\"87\":4}}],[\"countdownlatch是一个同步工具类\",{\"1\":{\"681\":1}}],[\"countdownlatch\",{\"1\":{\"601\":1,\"680\":2,\"681\":4,\"736\":1}}],[\"count\",{\"1\":{\"155\":4,\"161\":1,\"616\":1,\"617\":1}}],[\"country\",{\"1\":{\"71\":1}}],[\"country==\",{\"1\":{\"52\":2,\"65\":2}}],[\"count=true\",{\"1\":{\"70\":1}}],[\"coustraint\",{\"1\":{\"87\":1}}],[\"collection框架中实现比较要怎么做\",{\"0\":{\"596\":1}}],[\"collection是一个接口\",{\"1\":{\"569\":1}}],[\"collection派生出了三个子接口\",{\"1\":{\"569\":1}}],[\"collections是一个工具类\",{\"1\":{\"569\":1}}],[\"collections\",{\"1\":{\"547\":1,\"586\":1}}],[\"collection<\",{\"1\":{\"204\":1,\"313\":1}}],[\"collection\",{\"0\":{\"568\":1},\"1\":{\"200\":2,\"204\":4,\"313\":4,\"551\":1,\"568\":1}}],[\"column\",{\"1\":{\"159\":3}}],[\"columns\",{\"1\":{\"71\":6}}],[\"col\",{\"1\":{\"155\":3,\"161\":1}}],[\"color\",{\"1\":{\"70\":11}}],[\"copied\",{\"1\":{\"70\":1}}],[\"copyof\",{\"1\":{\"573\":1}}],[\"copyof方法将elementdata数组指向新的内存空间\",{\"1\":{\"573\":1}}],[\"copy特性了\",{\"1\":{\"341\":1}}],[\"copy特性\",{\"1\":{\"341\":1}}],[\"copy带来的性能优势\",{\"1\":{\"341\":1}}],[\"copy使用场景的地方有两处\",{\"1\":{\"341\":1}}],[\"copy\",{\"0\":{\"341\":1},\"1\":{\"70\":3,\"329\":1,\"341\":1,\"507\":1}}],[\"copytoclipboard\",{\"1\":{\"70\":3}}],[\"codes\",{\"1\":{\"506\":1}}],[\"code\",{\"0\":{\"69\":1,\"70\":1,\"71\":1},\"1\":{\"70\":1,\"149\":1,\"223\":3,\"244\":2,\"284\":1}}],[\"co\",{\"1\":{\"62\":1,\"70\":1}}],[\"com408\",{\"0\":{\"740\":1}}],[\"combinedcontent\",{\"1\":{\"71\":4}}],[\"com<\",{\"1\":{\"71\":1}}],[\"compilation\",{\"1\":{\"514\":1}}],[\"compile\",{\"1\":{\"201\":1}}],[\"componentscan\",{\"1\":{\"306\":1}}],[\"componentscan扫描进来的优先级是最低的\",{\"1\":{\"280\":1}}],[\"componentscan扫描进来不会生效\",{\"1\":{\"280\":1}}],[\"component\",{\"1\":{\"271\":2,\"316\":1,\"317\":1}}],[\"computing\",{\"1\":{\"70\":1}}],[\"compareandswapobject\",{\"1\":{\"607\":1}}],[\"compareandsettail\",{\"1\":{\"607\":2}}],[\"compareandsetstate\",{\"1\":{\"604\":1,\"605\":1,\"616\":2,\"617\":1}}],[\"compare\",{\"1\":{\"596\":1,\"644\":1}}],[\"compareto\",{\"1\":{\"596\":1}}],[\"compact\",{\"1\":{\"316\":1}}],[\"company\",{\"1\":{\"70\":4}}],[\"compatible\",{\"1\":{\"32\":1}}],[\"completedabruptly\",{\"1\":{\"714\":1}}],[\"complete\",{\"1\":{\"70\":2,\"493\":1}}],[\"coming\",{\"1\":{\"69\":1,\"70\":1}}],[\"comicabc\",{\"1\":{\"62\":1}}],[\"communication\",{\"1\":{\"737\":1}}],[\"community\",{\"1\":{\"70\":4}}],[\"commercial\",{\"1\":{\"71\":1}}],[\"commerce\",{\"1\":{\"70\":2}}],[\"commentary\",{\"1\":{\"70\":1}}],[\"comment\",{\"1\":{\"70\":3}}],[\"comma\",{\"1\":{\"70\":1}}],[\"commands\",{\"1\":{\"399\":1}}],[\"command\",{\"1\":{\"69\":6,\"70\":6}}],[\"committed级别下\",{\"1\":{\"119\":1}}],[\"committed隔离级别\",{\"1\":{\"102\":1}}],[\"committed\",{\"1\":{\"76\":3,\"102\":2}}],[\"commit\",{\"1\":{\"69\":1,\"99\":1,\"102\":1,\"177\":1}}],[\"commonutis\",{\"1\":{\"313\":1}}],[\"commonutil\",{\"1\":{\"204\":1}}],[\"commonutils\",{\"0\":{\"313\":1},\"1\":{\"196\":1,\"197\":1,\"201\":1,\"204\":2}}],[\"commonurlpart\",{\"1\":{\"70\":4}}],[\"common\",{\"1\":{\"5\":1}}],[\"com后执行的全部过程\",{\"0\":{\"38\":1}}],[\"com\",{\"1\":{\"25\":5,\"37\":1,\"38\":1,\"48\":3,\"57\":1,\"58\":2,\"60\":6,\"62\":27,\"64\":1,\"65\":1,\"66\":1,\"68\":6,\"69\":4,\"70\":76,\"71\":11,\"144\":1,\"149\":1,\"158\":1,\"205\":3,\"230\":4,\"277\":2,\"311\":2,\"343\":1,\"438\":1,\"469\":1,\"474\":1,\"483\":4,\"502\":1,\"505\":2,\"506\":1,\"510\":1,\"537\":1,\"544\":4,\"548\":1,\"551\":2,\"562\":1,\"567\":1,\"590\":1,\"599\":2,\"618\":3,\"637\":1,\"675\":1,\"682\":1,\"685\":3,\"708\":1,\"723\":3}}],[\"coolshell\",{\"1\":{\"567\":1}}],[\"coolsen666\",{\"1\":{\"7\":1}}],[\"cookie是存储在客户端上的一小段数据\",{\"1\":{\"42\":1}}],[\"cookie和session的区别\",{\"0\":{\"41\":1}}],[\"cookie或浏览器\",{\"1\":{\"39\":1}}],[\"cookie\",{\"0\":{\"39\":1,\"40\":1},\"1\":{\"39\":5,\"40\":6,\"41\":8}}],[\"cookies\",{\"1\":{\"14\":1}}],[\"cookies技术\",{\"1\":{\"14\":1}}],[\"concurrent\",{\"1\":{\"604\":1,\"605\":3,\"607\":1,\"682\":2}}],[\"concurrent包下的容器都是安全失败\",{\"1\":{\"598\":1}}],[\"concurrenthashmap\",{\"0\":{\"545\":1,\"584\":1,\"585\":1,\"586\":1,\"588\":1,\"589\":1,\"590\":1,\"592\":1},\"1\":{\"545\":3,\"546\":5,\"547\":3,\"548\":12,\"549\":2,\"550\":1,\"570\":1,\"584\":1,\"585\":1,\"589\":1,\"590\":3,\"592\":1,\"598\":1}}],[\"conccurenthashmap且不产生锁竞争的最大线程数\",{\"1\":{\"548\":1}}],[\"concretecomponent\",{\"1\":{\"543\":2}}],[\"concat\",{\"1\":{\"71\":6}}],[\"con\",{\"1\":{\"506\":4}}],[\"conditional\",{\"1\":{\"308\":1}}],[\"condition\",{\"1\":{\"156\":1,\"567\":1,\"603\":1}}],[\"conversion\",{\"1\":{\"70\":1}}],[\"convert\",{\"1\":{\"70\":1}}],[\"converts\",{\"1\":{\"70\":1}}],[\"converted\",{\"1\":{\"2\":1,\"3\":1,\"553\":1}}],[\"consistent\",{\"1\":{\"548\":1,\"590\":1}}],[\"consumer太少了导致的还是说其他情况\",{\"1\":{\"370\":1}}],[\"consumer端如何保证消息不丢失\",{\"1\":{\"369\":1}}],[\"consumer端\",{\"1\":{\"369\":1}}],[\"consumer首次请求broker\",{\"1\":{\"367\":1}}],[\"consumer\",{\"1\":{\"322\":1,\"326\":1,\"337\":3,\"362\":5,\"363\":1,\"364\":4}}],[\"console\",{\"1\":{\"69\":8,\"70\":11,\"71\":14}}],[\"constant\",{\"1\":{\"196\":3,\"198\":4,\"199\":3,\"204\":12}}],[\"constructor的cache\",{\"1\":{\"507\":1}}],[\"constructor\",{\"0\":{\"468\":1},\"1\":{\"504\":1,\"505\":4}}],[\"construct\",{\"1\":{\"70\":1}}],[\"const\",{\"1\":{\"69\":60,\"70\":103,\"71\":69,\"157\":5}}],[\"congestion\",{\"1\":{\"24\":2}}],[\"conf对应的配置项是maxmemory\",{\"1\":{\"388\":1}}],[\"confirm\",{\"1\":{\"356\":1}}],[\"confi\",{\"1\":{\"194\":1}}],[\"configured\",{\"1\":{\"499\":1}}],[\"configurations\",{\"1\":{\"70\":1}}],[\"configuration<\",{\"1\":{\"70\":1}}],[\"configuration\",{\"0\":{\"4\":1},\"1\":{\"4\":3,\"5\":1,\"70\":4,\"71\":1,\"194\":5,\"195\":4,\"196\":11,\"197\":15,\"198\":12,\"204\":5,\"268\":3,\"306\":1,\"314\":1,\"315\":1,\"318\":1,\"319\":1}}],[\"config=$\",{\"1\":{\"71\":2}}],[\"config\",{\"1\":{\"4\":2,\"70\":3,\"71\":1,\"268\":1}}],[\"conf\",{\"1\":{\"193\":1,\"194\":1,\"198\":3,\"204\":3,\"205\":1}}],[\"conflict\",{\"1\":{\"33\":1}}],[\"conf文件\",{\"1\":{\"20\":1}}],[\"connected\",{\"1\":{\"70\":1}}],[\"connectstring\",{\"1\":{\"251\":1}}],[\"connects\",{\"1\":{\"70\":1}}],[\"connectandwrite\",{\"1\":{\"69\":3,\"70\":3}}],[\"connecting\",{\"1\":{\"69\":1,\"70\":2,\"71\":1}}],[\"connectionjdbc\",{\"1\":{\"506\":1}}],[\"connection对象的preparestatement方法创建preparedstatement对象执行sql语句\",{\"1\":{\"201\":1}}],[\"connection为空\",{\"1\":{\"198\":1}}],[\"connections\",{\"1\":{\"69\":1,\"70\":1}}],[\"connection\",{\"1\":{\"31\":1,\"32\":1,\"33\":1,\"70\":7,\"198\":10,\"201\":2,\"506\":1}}],[\"connect\",{\"1\":{\"14\":1,\"29\":1,\"69\":6,\"70\":8,\"237\":1}}],[\"control\",{\"1\":{\"317\":4}}],[\"controlledshutdownpartition\",{\"1\":{\"340\":1}}],[\"controller选举\",{\"1\":{\"327\":1}}],[\"controller\",{\"0\":{\"292\":1,\"294\":1},\"1\":{\"69\":22,\"70\":18,\"71\":3,\"271\":1,\"290\":1,\"291\":1,\"292\":4,\"294\":1,\"327\":2}}],[\"controlling\",{\"1\":{\"5\":1}}],[\"context\",{\"1\":{\"308\":1}}],[\"context等\",{\"1\":{\"304\":1}}],[\"content=\",{\"1\":{\"70\":16}}],[\"content\",{\"0\":{\"3\":1},\"1\":{\"32\":1,\"33\":1,\"65\":1,\"69\":4,\"70\":6,\"71\":13,\"291\":1}}],[\"continue\",{\"0\":{\"452\":1},\"1\":{\"71\":3,\"452\":1}}],[\"contain\",{\"1\":{\"553\":1}}],[\"containing\",{\"1\":{\"70\":2}}],[\"containskey方法之前\",{\"1\":{\"548\":1,\"588\":1}}],[\"containskey\",{\"1\":{\"548\":1,\"588\":1}}],[\"contains\",{\"1\":{\"1\":1,\"70\":2}}],[\"aqs已经在顶层实现好了\",{\"1\":{\"680\":1}}],[\"aqs定义两种资源共享方式\",{\"1\":{\"680\":1}}],[\"aqs同步器的设计是基于模板方法模式的\",{\"1\":{\"678\":1}}],[\"aqs同步队列中的节点会发生变化\",{\"1\":{\"607\":1}}],[\"aqs使用了模板方法模式\",{\"1\":{\"678\":1}}],[\"aqs使用了哪些设计模式\",{\"0\":{\"678\":1}}],[\"aqs使用一个volatile的int类型的成员变量来表示同步状态\",{\"1\":{\"602\":1}}],[\"aqs又是如何实现非公平锁和共享锁的呢\",{\"1\":{\"614\":1}}],[\"aqs的acquire方法通过调用tryacquire再给当前线程一次机会\",{\"1\":{\"616\":1}}],[\"aqs的acquire方法会执行tryacquire方法\",{\"1\":{\"615\":1}}],[\"aqs的acquire会调用tryacquire方法\",{\"1\":{\"614\":1}}],[\"aqs的设计模式采用的模板方法模式\",{\"1\":{\"609\":1}}],[\"aqs也提供了响应中断\",{\"1\":{\"612\":1}}],[\"aqs提供acquireshared\",{\"1\":{\"612\":1}}],[\"aqs提供了release\",{\"1\":{\"611\":1}}],[\"aqs提供了大量的模板方法来实现同步\",{\"1\":{\"609\":1}}],[\"aqs中维护了一个名为state的字段\",{\"1\":{\"604\":1}}],[\"aqs中最基本的数据结构\",{\"1\":{\"603\":1}}],[\"aqs中的队列是clh变体的虚拟双向队列\",{\"1\":{\"602\":1}}],[\"aqs数据结构\",{\"0\":{\"603\":1}}],[\"aqs是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配\",{\"1\":{\"602\":1}}],[\"aqs是一种提供了原子式管理同步状态\",{\"1\":{\"601\":1}}],[\"aqs核心思想是\",{\"1\":{\"602\":1}}],[\"aqs\",{\"0\":{\"600\":1,\"681\":1},\"1\":{\"546\":1,\"600\":1,\"617\":3,\"618\":1,\"677\":6}}],[\"a=40\",{\"1\":{\"536\":1}}],[\"a=1\",{\"1\":{\"112\":3}}],[\"a不是b的父类或子类\",{\"1\":{\"534\":1}}],[\"aio一般适用于连接数目多且连接比较长\",{\"1\":{\"542\":1}}],[\"aio\",{\"1\":{\"542\":1}}],[\"aio的区别\",{\"0\":{\"542\":1},\"1\":{\"484\":1}}],[\"aipai\",{\"1\":{\"70\":2}}],[\"aaa\",{\"0\":{\"488\":2},\"1\":{\"484\":3,\"488\":7}}],[\"ae\",{\"1\":{\"403\":13}}],[\"aof工具\",{\"1\":{\"407\":1}}],[\"aof可以保证数据的不丢失\",{\"1\":{\"384\":1}}],[\"aof运行效率要慢于rdb\",{\"1\":{\"383\":1}}],[\"aof采用文件追加方式\",{\"1\":{\"383\":1}}],[\"aof\",{\"1\":{\"383\":1,\"384\":1,\"399\":1}}],[\"aop\",{\"0\":{\"283\":1,\"284\":1,\"285\":2},\"1\":{\"263\":1,\"283\":2,\"284\":5,\"285\":3,\"286\":2,\"310\":2}}],[\"amqp的3层协议\",{\"0\":{\"354\":1}}],[\"amqp是什么\",{\"0\":{\"353\":1}}],[\"amqp\",{\"1\":{\"351\":1,\"353\":4}}],[\"amaige8kmabvddmkohtakg=\",{\"1\":{\"70\":1}}],[\"a服务是不需要做更改的\",{\"1\":{\"345\":1}}],[\"a可能就需要在原来的代码上做扩展\",{\"1\":{\"345\":1}}],[\"afternodeinsertion\",{\"1\":{\"556\":1}}],[\"afternodeaccess\",{\"1\":{\"556\":1}}],[\"after\",{\"1\":{\"425\":1,\"426\":2}}],[\"aftercompletion\",{\"1\":{\"298\":1,\"317\":2}}],[\"afterpropertiesset方法做一些属性被设定后的自定义的事情\",{\"1\":{\"276\":1}}],[\"a此时能拿到b的对象顺利完成自己的初始化阶段2\",{\"1\":{\"281\":1}}],[\"a首先完成了\",{\"1\":{\"281\":1}}],[\"a的某个field或者setter依赖了b的实例对象\",{\"1\":{\"281\":1}}],[\"aba\",{\"1\":{\"645\":1,\"683\":1}}],[\"about\",{\"1\":{\"553\":2}}],[\"abortpolicy\",{\"1\":{\"670\":1}}],[\"abortcontroller\",{\"1\":{\"71\":1}}],[\"abort`\",{\"1\":{\"69\":2,\"70\":2}}],[\"abort\",{\"1\":{\"69\":2,\"70\":2,\"71\":1}}],[\"abc\",{\"1\":{\"532\":3}}],[\"abcde\",{\"1\":{\"103\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"604\":1,\"605\":2,\"607\":1,\"617\":1,\"666\":1,\"714\":1}}],[\"abstract\",{\"1\":{\"469\":1}}],[\"a字段可以匹配上索引\",{\"1\":{\"84\":1}}],[\"average\",{\"1\":{\"399\":1,\"553\":1}}],[\"availableprocessors\",{\"1\":{\"230\":1,\"675\":1}}],[\"available\",{\"1\":{\"71\":1}}],[\"avoidance\",{\"1\":{\"24\":1}}],[\"adapter类\",{\"1\":{\"543\":2}}],[\"advice\",{\"1\":{\"286\":1}}],[\"advertising\",{\"1\":{\"70\":1}}],[\"addworker方法有两个参数\",{\"1\":{\"714\":1}}],[\"addwaiter\",{\"1\":{\"605\":2,\"607\":1,\"610\":2,\"612\":1,\"617\":3}}],[\"addl指令\",{\"1\":{\"637\":1,\"708\":1}}],[\"addlast\",{\"1\":{\"237\":5,\"245\":3}}],[\"addall\",{\"1\":{\"574\":1}}],[\"addapi\",{\"1\":{\"71\":2}}],[\"addmapping\",{\"1\":{\"319\":1}}],[\"addmapperstatement\",{\"1\":{\"204\":1}}],[\"addmapper\",{\"1\":{\"194\":3,\"196\":1,\"200\":1,\"204\":1}}],[\"addmapper实际上是向mapperregister类中添加mapperproxyfactory\",{\"1\":{\"194\":1}}],[\"addmapper步骤解析\",{\"1\":{\"194\":1}}],[\"addcorsmappings\",{\"1\":{\"319\":1}}],[\"addcsv\",{\"1\":{\"71\":2}}],[\"addpathpatterns\",{\"1\":{\"318\":1}}],[\"addinterceptor\",{\"1\":{\"318\":1}}],[\"addinterceptors\",{\"1\":{\"318\":1}}],[\"addinnerinterceptor\",{\"1\":{\"315\":1}}],[\"addnotlsapi\",{\"1\":{\"71\":2}}],[\"addnotls\",{\"1\":{\"71\":2}}],[\"addtext\",{\"1\":{\"71\":11}}],[\"addeventlistener\",{\"1\":{\"69\":3,\"70\":3}}],[\"addresslist\",{\"1\":{\"258\":7}}],[\"addresslength=addressbuffer\",{\"1\":{\"69\":1,\"70\":1}}],[\"addresslength\",{\"1\":{\"69\":10,\"70\":10}}],[\"addressid\",{\"1\":{\"71\":22}}],[\"addressindex\",{\"1\":{\"69\":4,\"70\":4}}],[\"addressescsv\",{\"1\":{\"71\":8}}],[\"addressesnotlsapi\",{\"1\":{\"71\":5}}],[\"addressesnotls\",{\"1\":{\"71\":9}}],[\"addressesipv6api\",{\"1\":{\"71\":1}}],[\"addressesapi\",{\"1\":{\"71\":7}}],[\"addresses\",{\"1\":{\"71\":9}}],[\"addressvalue\",{\"1\":{\"69\":6,\"70\":6}}],[\"addressvalueindex\",{\"1\":{\"69\":11,\"70\":11}}],[\"addresstype\",{\"1\":{\"69\":7,\"70\":8}}],[\"addressbuffer\",{\"1\":{\"69\":2,\"70\":2}}],[\"addressremote\",{\"1\":{\"69\":8,\"70\":9}}],[\"address\",{\"1\":{\"69\":11,\"70\":11,\"71\":32,\"156\":4,\"251\":5,\"277\":2}}],[\"add\",{\"1\":{\"2\":1,\"4\":1,\"5\":1,\"69\":1,\"70\":3,\"71\":20,\"159\":1,\"203\":1,\"204\":1,\"244\":1,\"510\":2,\"560\":2,\"571\":1,\"573\":1,\"595\":1}}],[\"audio\",{\"0\":{\"739\":1},\"1\":{\"70\":1}}],[\"auth\",{\"1\":{\"317\":1}}],[\"authority\",{\"1\":{\"37\":1}}],[\"automicinteger\",{\"1\":{\"684\":1}}],[\"automobile\",{\"1\":{\"70\":1}}],[\"autoboxcachemax\",{\"1\":{\"499\":1}}],[\"autoconfigure\",{\"1\":{\"308\":1}}],[\"autowire\",{\"1\":{\"278\":1}}],[\"autowired\",{\"1\":{\"271\":2,\"316\":1,\"318\":1}}],[\"autodetect\",{\"1\":{\"278\":1}}],[\"autohome\",{\"1\":{\"70\":2}}],[\"auto\",{\"1\":{\"53\":2,\"70\":2,\"71\":4,\"159\":1}}],[\"aware接口是为了感知到自身的一些属性\",{\"1\":{\"274\":1}}],[\"await\",{\"1\":{\"69\":18,\"70\":17,\"71\":32}}],[\"awesome\",{\"1\":{\"70\":2}}],[\"ajax\",{\"1\":{\"70\":1}}],[\"a><\",{\"1\":{\"70\":1}}],[\"a>\",{\"1\":{\"70\":8,\"71\":2}}],[\"age\",{\"1\":{\"136\":2,\"153\":1,\"167\":1,\"521\":1,\"522\":1}}],[\"agency\",{\"1\":{\"70\":2}}],[\"agent\",{\"1\":{\"32\":1,\"71\":3}}],[\"aggregator\",{\"1\":{\"70\":1}}],[\"against\",{\"1\":{\"70\":1}}],[\"atomicmarkablereference\",{\"1\":{\"683\":2}}],[\"atomicstampedreference\",{\"1\":{\"683\":1}}],[\"atomicreference\",{\"1\":{\"683\":1}}],[\"atomicreferencearray\",{\"1\":{\"683\":1}}],[\"atomicboolean\",{\"1\":{\"683\":1}}],[\"atomiclongfieldupdater\",{\"1\":{\"683\":1}}],[\"atomiclongarray\",{\"1\":{\"683\":1}}],[\"atomiclong\",{\"1\":{\"683\":1}}],[\"atomicintegerfieldupdater\",{\"1\":{\"683\":1}}],[\"atomicintegerarray\",{\"1\":{\"683\":1}}],[\"atomicinteger\",{\"0\":{\"684\":1},\"1\":{\"683\":1,\"684\":2,\"712\":2}}],[\"atomic1\",{\"1\":{\"682\":1}}],[\"atomic\",{\"0\":{\"682\":1},\"1\":{\"682\":3}}],[\"atob\",{\"1\":{\"69\":2,\"70\":16,\"71\":1}}],[\"attr\",{\"1\":{\"237\":2}}],[\"attribute\",{\"1\":{\"506\":6}}],[\"attributekey\",{\"1\":{\"237\":2}}],[\"attributekey<rpcresponse>\",{\"1\":{\"237\":2}}],[\"attributekey是\",{\"1\":{\"237\":1}}],[\"attributevalue\",{\"1\":{\"204\":3}}],[\"atlas\",{\"0\":{\"125\":1},\"1\":{\"122\":1}}],[\"at\",{\"1\":{\"70\":9,\"71\":1}}],[\"antirez\",{\"1\":{\"402\":1}}],[\"annotationdefault\",{\"1\":{\"507\":1}}],[\"annotations\",{\"1\":{\"507\":1}}],[\"annotation\",{\"1\":{\"268\":1}}],[\"analytics\",{\"1\":{\"70\":1}}],[\"answer\",{\"1\":{\"70\":1}}],[\"an\",{\"1\":{\"69\":1,\"70\":11,\"399\":1}}],[\"anyway\",{\"1\":{\"69\":1,\"70\":1}}],[\"any\",{\"1\":{\"69\":4,\"70\":4,\"442\":1}}],[\"anycast\",{\"1\":{\"61\":2,\"62\":1}}],[\"and\",{\"0\":{\"5\":1,\"285\":1},\"1\":{\"3\":1,\"69\":4,\"70\":35,\"71\":3,\"84\":5,\"154\":5,\"156\":4,\"157\":2,\"161\":5,\"277\":2,\"300\":1,\"409\":1,\"483\":1,\"553\":1,\"554\":3,\"578\":3,\"602\":1,\"618\":1,\"644\":1}}],[\"apach\",{\"1\":{\"321\":1}}],[\"apache\",{\"0\":{\"321\":1},\"1\":{\"32\":1,\"251\":2}}],[\"apiurl\",{\"1\":{\"71\":3}}],[\"apiresponse\",{\"1\":{\"69\":3}}],[\"api\",{\"0\":{\"302\":1},\"1\":{\"69\":4,\"70\":4,\"71\":6,\"268\":1,\"294\":1,\"300\":1,\"302\":3,\"380\":1,\"504\":1,\"505\":3,\"506\":1,\"648\":2,\"707\":2}}],[\"apply\",{\"1\":{\"618\":1}}],[\"appleobj\",{\"1\":{\"505\":5}}],[\"appleconstructor\",{\"1\":{\"505\":4}}],[\"apple\",{\"1\":{\"505\":12}}],[\"applicationcontextaware\",{\"1\":{\"276\":1}}],[\"applicationcontext情形下有效\",{\"1\":{\"269\":1}}],[\"applicationcontext的优缺点\",{\"1\":{\"266\":1}}],[\"applicationcontext\",{\"0\":{\"266\":1},\"1\":{\"266\":1,\"272\":1,\"286\":1}}],[\"application\",{\"1\":{\"69\":2,\"70\":2,\"71\":4,\"305\":3,\"399\":1}}],[\"append\",{\"1\":{\"481\":2}}],[\"appendfsync\",{\"1\":{\"383\":3}}],[\"app\",{\"1\":{\"57\":1,\"60\":1,\"70\":3}}],[\"acquires\",{\"1\":{\"616\":5,\"617\":3}}],[\"acquiresharedinterruptibly\",{\"1\":{\"612\":1}}],[\"acquireshared\",{\"1\":{\"612\":2}}],[\"acquirequeued\",{\"1\":{\"605\":1,\"610\":2,\"617\":1}}],[\"acquire\",{\"1\":{\"605\":2,\"610\":2,\"616\":1,\"617\":3}}],[\"acc\",{\"1\":{\"651\":2}}],[\"account\",{\"1\":{\"554\":1,\"578\":1}}],[\"access\",{\"1\":{\"317\":4}}],[\"accepts\",{\"1\":{\"70\":1}}],[\"accepting\",{\"1\":{\"70\":1}}],[\"accept\",{\"1\":{\"32\":3,\"69\":1,\"70\":1,\"71\":3,\"216\":1,\"223\":1,\"230\":2,\"294\":1}}],[\"action\",{\"1\":{\"507\":1}}],[\"actionclass\",{\"1\":{\"507\":1}}],[\"actionclass=class\",{\"1\":{\"507\":1}}],[\"action=actionclass\",{\"1\":{\"507\":1}}],[\"activemq\",{\"0\":{\"350\":1},\"1\":{\"350\":3}}],[\"active=test\",{\"1\":{\"305\":1}}],[\"active=dev\",{\"1\":{\"305\":1}}],[\"acid\",{\"1\":{\"112\":1}}],[\"acl4ssr\",{\"1\":{\"71\":2}}],[\"acks=all\",{\"1\":{\"333\":1,\"334\":1}}],[\"ack为0\",{\"0\":{\"330\":1}}],[\"ack\",{\"1\":{\"11\":2,\"14\":4,\"16\":4,\"17\":1,\"18\":8,\"133\":2,\"323\":3,\"358\":1}}],[\"ack=1\",{\"1\":{\"11\":2,\"16\":4}}],[\"alex\",{\"1\":{\"685\":1}}],[\"alert\",{\"1\":{\"70\":1}}],[\"alan\",{\"1\":{\"682\":1}}],[\"always\",{\"1\":{\"383\":1}}],[\"although\",{\"1\":{\"553\":1}}],[\"alter\",{\"1\":{\"108\":1,\"159\":3}}],[\"alt=\",{\"1\":{\"70\":1}}],[\"allkeys\",{\"1\":{\"388\":3}}],[\"all<\",{\"1\":{\"237\":1}}],[\"allargsconstructor\",{\"1\":{\"216\":1,\"223\":1,\"230\":2,\"237\":4,\"244\":2}}],[\"allsettled\",{\"1\":{\"71\":1}}],[\"allsettled等待所有api请求完成\",{\"1\":{\"71\":1}}],[\"allowcorethreadtimeout\",{\"1\":{\"722\":1}}],[\"allowcredentials\",{\"1\":{\"319\":1}}],[\"allow\",{\"1\":{\"317\":4}}],[\"allowing\",{\"1\":{\"70\":1}}],[\"allowlnsecure\",{\"1\":{\"69\":2}}],[\"allowedorigins\",{\"1\":{\"319\":1}}],[\"allowedmethods\",{\"1\":{\"319\":1}}],[\"allowedheaders\",{\"1\":{\"319\":1}}],[\"allowed\",{\"1\":{\"69\":1,\"70\":1}}],[\"all\",{\"1\":{\"61\":1,\"62\":1,\"69\":1,\"70\":1,\"157\":2}}],[\"ali\",{\"1\":{\"71\":1}}],[\"alibaba\",{\"1\":{\"70\":3}}],[\"align=\",{\"1\":{\"70\":1}}],[\"aliyun\",{\"1\":{\"57\":1,\"70\":1,\"71\":1}}],[\"alive不会永久保持连接\",{\"1\":{\"31\":1}}],[\"alive\",{\"1\":{\"31\":1,\"32\":1,\"33\":1}}],[\"also\",{\"1\":{\"3\":1,\"4\":1}}],[\"arithmeticexception\",{\"1\":{\"534\":1,\"536\":2}}],[\"arial\",{\"1\":{\"70\":1,\"71\":1}}],[\"ar=isr+osr\",{\"1\":{\"338\":1}}],[\"ar\",{\"1\":{\"338\":1}}],[\"ar代表什么\",{\"0\":{\"338\":1}}],[\"arg\",{\"1\":{\"605\":7,\"610\":4,\"611\":4,\"612\":12,\"613\":3,\"616\":1,\"617\":5}}],[\"arg0\",{\"1\":{\"507\":2}}],[\"arg>\",{\"1\":{\"277\":1,\"279\":1}}],[\"args\",{\"1\":{\"193\":1,\"200\":8,\"216\":2,\"223\":4,\"230\":2,\"494\":2,\"505\":1,\"506\":2,\"507\":2,\"521\":1,\"522\":1,\"532\":2}}],[\"artifactid>\",{\"1\":{\"237\":1,\"251\":1}}],[\"articles\",{\"1\":{\"567\":1}}],[\"article\",{\"1\":{\"25\":2,\"144\":2,\"343\":1,\"438\":1,\"483\":1,\"544\":3,\"599\":1,\"618\":2,\"685\":2,\"723\":1}}],[\"archive\",{\"1\":{\"92\":1}}],[\"archives\",{\"1\":{\"55\":1}}],[\"arrays\",{\"1\":{\"573\":1}}],[\"arraystoreexception\",{\"1\":{\"531\":1}}],[\"arrayqueue\",{\"1\":{\"569\":1}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"534\":1}}],[\"arraylist都需要对这个list的容量进行一个判断\",{\"1\":{\"573\":1}}],[\"arraylist扩容的本质就是计算出新的扩容数组的size后实例化\",{\"1\":{\"573\":1}}],[\"arraylist在底层数组不够用时在原来的基础上扩展0\",{\"1\":{\"572\":1}}],[\"arraylist不是线程安全的\",{\"1\":{\"572\":1}}],[\"arraylist的空\",{\"1\":{\"571\":1}}],[\"arraylist与\",{\"0\":{\"571\":1}}],[\"arraylist<integer>\",{\"1\":{\"516\":2}}],[\"arraylist<string>\",{\"1\":{\"516\":2}}],[\"arraylist<>\",{\"1\":{\"203\":1,\"204\":1,\"493\":2,\"560\":1}}],[\"arraylist\",{\"0\":{\"572\":1,\"574\":2},\"1\":{\"510\":1,\"516\":3,\"570\":1,\"571\":4,\"574\":3,\"598\":1}}],[\"array中可以用泛型吗\",{\"0\":{\"515\":1},\"1\":{\"484\":1}}],[\"arrayblockingqueue\",{\"1\":{\"670\":1}}],[\"arrayblockingqueue<>\",{\"1\":{\"230\":1}}],[\"arraybuffer|null\",{\"1\":{\"70\":1}}],[\"arraybuffer\",{\"1\":{\"69\":8,\"70\":10}}],[\"array\",{\"0\":{\"574\":2},\"1\":{\"70\":4,\"499\":1,\"515\":2,\"573\":1,\"574\":2}}],[\"arr\",{\"1\":{\"69\":19,\"70\":19,\"204\":4,\"313\":4}}],[\"arrybuffer\",{\"1\":{\"69\":2,\"70\":2}}],[\"are\",{\"1\":{\"5\":1,\"69\":2,\"70\":1,\"553\":5}}],[\"assert\",{\"1\":{\"499\":1}}],[\"assigned\",{\"1\":{\"338\":1}}],[\"aspectj\",{\"0\":{\"285\":1},\"1\":{\"285\":1}}],[\"aspect\",{\"1\":{\"283\":2}}],[\"async\",{\"1\":{\"69\":12,\"70\":12,\"71\":6,\"400\":2}}],[\"asn==\",{\"1\":{\"52\":1}}],[\"asn\",{\"1\":{\"52\":7,\"65\":4}}],[\"ascii\",{\"1\":{\"41\":1,\"486\":1}}],[\"as\",{\"1\":{\"4\":1,\"70\":1,\"71\":1,\"399\":1,\"554\":2,\"578\":2}}],[\"a\",{\"1\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"12\":3,\"16\":1,\"25\":1,\"37\":1,\"42\":2,\"48\":1,\"69\":3,\"70\":91,\"74\":2,\"75\":2,\"84\":5,\"103\":7,\"112\":1,\"136\":3,\"154\":4,\"161\":5,\"281\":1,\"342\":3,\"343\":1,\"346\":9,\"347\":3,\"348\":6,\"349\":1,\"390\":1,\"391\":2,\"393\":1,\"435\":9,\"449\":2,\"467\":2,\"482\":1,\"488\":1,\"497\":3,\"516\":2,\"536\":16,\"544\":1,\"553\":3,\"554\":2,\"559\":1,\"565\":1,\"578\":2,\"614\":5,\"644\":2,\"685\":1,\"726\":3,\"727\":1,\"732\":3}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
